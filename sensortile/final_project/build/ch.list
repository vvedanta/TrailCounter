
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000200:	b672      	cpsid	i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000202:	4826      	ldr	r0, [pc, #152]	; (800029c <endfiniloop+0x4>)
                msr     PSP, r0
 8000204:	f380 8809 	msr	PSP, r0

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 8000208:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800020a:	f380 8814 	msr	CONTROL, r0
                isb
 800020e:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000212:	f000 f87d 	bl	8000310 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000216:	f00b fc6b 	bl	800baf0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800021a:	4821      	ldr	r0, [pc, #132]	; (80002a0 <endfiniloop+0x8>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800021c:	4921      	ldr	r1, [pc, #132]	; (80002a4 <endfiniloop+0xc>)
                ldr     r2, =__main_stack_end__
 800021e:	4a22      	ldr	r2, [pc, #136]	; (80002a8 <endfiniloop+0x10>)

08000220 <msloop>:
msloop:
                cmp     r1, r2
 8000220:	4291      	cmp	r1, r2
                itt     lo
 8000222:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000228:	f7ff bffa 	bcc.w	8000220 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800022c:	491f      	ldr	r1, [pc, #124]	; (80002ac <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 800022e:	4a1b      	ldr	r2, [pc, #108]	; (800029c <endfiniloop+0x4>)

08000230 <psloop>:
psloop:
                cmp     r1, r2
 8000230:	4291      	cmp	r1, r2
                itt     lo
 8000232:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000234:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000238:	f7ff bffa 	bcc.w	8000230 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 800023c:	491c      	ldr	r1, [pc, #112]	; (80002b0 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 800023e:	4a1d      	ldr	r2, [pc, #116]	; (80002b4 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 8000240:	4b1d      	ldr	r3, [pc, #116]	; (80002b8 <endfiniloop+0x20>)

08000242 <dloop>:
dloop:
                cmp     r2, r3
 8000242:	429a      	cmp	r2, r3
                ittt    lo
 8000244:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000246:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800024a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800024e:	f7ff bff8 	bcc.w	8000242 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000252:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000254:	4919      	ldr	r1, [pc, #100]	; (80002bc <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000256:	4a1a      	ldr	r2, [pc, #104]	; (80002c0 <endfiniloop+0x28>)

08000258 <bloop>:
bloop:
                cmp     r1, r2
 8000258:	4291      	cmp	r1, r2
                itt     lo
 800025a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000260:	f7ff bffa 	bcc.w	8000258 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000264:	f000 f874 	bl	8000350 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000268:	f000 f862 	bl	8000330 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800026c:	4c15      	ldr	r4, [pc, #84]	; (80002c4 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800026e:	4d16      	ldr	r5, [pc, #88]	; (80002c8 <endfiniloop+0x30>)

08000270 <initloop>:
initloop:
                cmp     r4, r5
 8000270:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000272:	f280 8005 	bge.w	8000280 <endinitloop>
                ldr     r1, [r4], #4
 8000276:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800027a:	4788      	blx	r1
                b       initloop
 800027c:	f7ff bff8 	b.w	8000270 <initloop>

08000280 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000280:	f012 fb46 	bl	8012910 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000284:	4c11      	ldr	r4, [pc, #68]	; (80002cc <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 8000286:	4d12      	ldr	r5, [pc, #72]	; (80002d0 <endfiniloop+0x38>)

08000288 <finiloop>:
finiloop:
                cmp     r4, r5
 8000288:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800028a:	f280 8005 	bge.w	8000298 <endfiniloop>
                ldr     r1, [r4], #4
 800028e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000292:	4788      	blx	r1
                b       finiloop
 8000294:	f7ff bff8 	b.w	8000288 <finiloop>

08000298 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000298:	f000 b852 	b.w	8000340 <__default_exit>
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 800029c:	20000800 	.word	0x20000800

                /* Early initialization.*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80002a0:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80002a4:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 80002a8:	20000400 	.word	0x20000400
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80002ac:	20000400 	.word	0x20000400
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 80002b0:	0801c658 	.word	0x0801c658
                ldr     r2, =_data_start
 80002b4:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002b8:	2000121c 	.word	0x2000121c

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 80002bc:	20001220 	.word	0x20001220
                ldr     r2, =_bss_end
 80002c0:	20006d20 	.word	0x20006d20
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 80002c4:	08000200 	.word	0x08000200
                ldr     r5, =__init_array_end
 80002c8:	08000200 	.word	0x08000200
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 80002cc:	08000200 	.word	0x08000200
                ldr     r5, =__fini_array_end
 80002d0:	08000200 	.word	0x08000200
	...

080002e0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002e8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ea:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002f6:	4628      	mov	r0, r5
                blx     r4
 80002f8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002fa:	2000      	movs	r0, #0
                bl      chThdExit
 80002fc:	f001 f838 	bl	8001370 <chThdExit>

08000300 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 8000300:	f000 fdce 	bl	8000ea0 <chSchDoReschedule>

08000304 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000304:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000306:	e7fe      	b.n	8000306 <_port_exit_from_isr+0x2>
	...

08000310 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000310:	4770      	bx	lr
 8000312:	bf00      	nop
 8000314:	f3af 8000 	nop.w
 8000318:	f3af 8000 	nop.w
 800031c:	f3af 8000 	nop.w
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __early_init(void) {}
 8000320:	4770      	bx	lr
 8000322:	bf00      	nop
 8000324:	f3af 8000 	nop.w
 8000328:	f3af 8000 	nop.w
 800032c:	f3af 8000 	nop.w

08000330 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000330:	4770      	bx	lr
 8000332:	bf00      	nop
 8000334:	f3af 8000 	nop.w
 8000338:	f3af 8000 	nop.w
 800033c:	f3af 8000 	nop.w

08000340 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 8000340:	e7fe      	b.n	8000340 <__default_exit>
 8000342:	bf00      	nop
 8000344:	f3af 8000 	nop.w
 8000348:	f3af 8000 	nop.w
 800034c:	f3af 8000 	nop.w

08000350 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000350:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000352:	4b16      	ldr	r3, [pc, #88]	; (80003ac <__init_ram_areas+0x5c>)
 8000354:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000356:	9b03      	ldr	r3, [sp, #12]
 8000358:	681b      	ldr	r3, [r3, #0]
 800035a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800035c:	9b03      	ldr	r3, [sp, #12]
 800035e:	685b      	ldr	r3, [r3, #4]
 8000360:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000362:	e009      	b.n	8000378 <__init_ram_areas+0x28>
      *p = *tp;
 8000364:	9b02      	ldr	r3, [sp, #8]
 8000366:	681a      	ldr	r2, [r3, #0]
 8000368:	9b01      	ldr	r3, [sp, #4]
 800036a:	601a      	str	r2, [r3, #0]
      p++;
 800036c:	9b01      	ldr	r3, [sp, #4]
 800036e:	3304      	adds	r3, #4
 8000370:	9301      	str	r3, [sp, #4]
      tp++;
 8000372:	9b02      	ldr	r3, [sp, #8]
 8000374:	3304      	adds	r3, #4
 8000376:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000378:	9b03      	ldr	r3, [sp, #12]
 800037a:	689a      	ldr	r2, [r3, #8]
 800037c:	9b01      	ldr	r3, [sp, #4]
 800037e:	429a      	cmp	r2, r3
 8000380:	d8f0      	bhi.n	8000364 <__init_ram_areas+0x14>
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000382:	e005      	b.n	8000390 <__init_ram_areas+0x40>
      *p = 0;
 8000384:	9b01      	ldr	r3, [sp, #4]
 8000386:	2200      	movs	r2, #0
 8000388:	601a      	str	r2, [r3, #0]
      p++;
 800038a:	9b01      	ldr	r3, [sp, #4]
 800038c:	3304      	adds	r3, #4
 800038e:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000390:	9b03      	ldr	r3, [sp, #12]
 8000392:	68da      	ldr	r2, [r3, #12]
 8000394:	9b01      	ldr	r3, [sp, #4]
 8000396:	429a      	cmp	r2, r3
 8000398:	d8f4      	bhi.n	8000384 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800039a:	9b03      	ldr	r3, [sp, #12]
 800039c:	3310      	adds	r3, #16
 800039e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80003a0:	9a03      	ldr	r2, [sp, #12]
 80003a2:	4b03      	ldr	r3, [pc, #12]	; (80003b0 <__init_ram_areas+0x60>)
 80003a4:	429a      	cmp	r2, r3
 80003a6:	d3d6      	bcc.n	8000356 <__init_ram_areas+0x6>
#endif
}
 80003a8:	b004      	add	sp, #16
 80003aa:	4770      	bx	lr
 80003ac:	0801a9b0 	.word	0x0801a9b0
 80003b0:	0801aa30 	.word	0x0801aa30
 80003b4:	f3af 8000 	nop.w
 80003b8:	f3af 8000 	nop.w
 80003bc:	f3af 8000 	nop.w

080003c0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 80003c0:	e7fe      	b.n	80003c0 <_unhandled_exception>
 80003c2:	bf00      	nop
 80003c4:	f3af 8000 	nop.w
 80003c8:	f3af 8000 	nop.w
 80003cc:	f3af 8000 	nop.w

080003d0 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80003d0:	b084      	sub	sp, #16
 80003d2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80003d4:	9b01      	ldr	r3, [sp, #4]
 80003d6:	f003 0307 	and.w	r3, r3, #7
 80003da:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80003dc:	4b0a      	ldr	r3, [pc, #40]	; (8000408 <NVIC_SetPriorityGrouping+0x38>)
 80003de:	68db      	ldr	r3, [r3, #12]
 80003e0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80003e2:	9a02      	ldr	r2, [sp, #8]
 80003e4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80003e8:	4013      	ands	r3, r2
 80003ea:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 80003ec:	9b03      	ldr	r3, [sp, #12]
 80003ee:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80003f0:	9b02      	ldr	r3, [sp, #8]
 80003f2:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80003f4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80003f8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80003fc:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80003fe:	4b02      	ldr	r3, [pc, #8]	; (8000408 <NVIC_SetPriorityGrouping+0x38>)
 8000400:	9a02      	ldr	r2, [sp, #8]
 8000402:	60da      	str	r2, [r3, #12]
}
 8000404:	b004      	add	sp, #16
 8000406:	4770      	bx	lr
 8000408:	e000ed00 	.word	0xe000ed00
 800040c:	f3af 8000 	nop.w

08000410 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000410:	b082      	sub	sp, #8
 8000412:	4603      	mov	r3, r0
 8000414:	9100      	str	r1, [sp, #0]
 8000416:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 800041a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800041e:	2b00      	cmp	r3, #0
 8000420:	da0c      	bge.n	800043c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000422:	490c      	ldr	r1, [pc, #48]	; (8000454 <NVIC_SetPriority+0x44>)
 8000424:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000428:	f003 030f 	and.w	r3, r3, #15
 800042c:	3b04      	subs	r3, #4
 800042e:	9a00      	ldr	r2, [sp, #0]
 8000430:	b2d2      	uxtb	r2, r2
 8000432:	0112      	lsls	r2, r2, #4
 8000434:	b2d2      	uxtb	r2, r2
 8000436:	440b      	add	r3, r1
 8000438:	761a      	strb	r2, [r3, #24]
 800043a:	e009      	b.n	8000450 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800043c:	4906      	ldr	r1, [pc, #24]	; (8000458 <NVIC_SetPriority+0x48>)
 800043e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8000442:	9a00      	ldr	r2, [sp, #0]
 8000444:	b2d2      	uxtb	r2, r2
 8000446:	0112      	lsls	r2, r2, #4
 8000448:	b2d2      	uxtb	r2, r2
 800044a:	440b      	add	r3, r1
 800044c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8000450:	b002      	add	sp, #8
 8000452:	4770      	bx	lr
 8000454:	e000ed00 	.word	0xe000ed00
 8000458:	e000e100 	.word	0xe000e100
 800045c:	f3af 8000 	nop.w

08000460 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8000460:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000462:	4b0e      	ldr	r3, [pc, #56]	; (800049c <port_init+0x3c>)
 8000464:	2200      	movs	r2, #0
 8000466:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8000468:	2003      	movs	r0, #3
 800046a:	f7ff ffb1 	bl	80003d0 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800046e:	4b0c      	ldr	r3, [pc, #48]	; (80004a0 <port_init+0x40>)
 8000470:	4a0b      	ldr	r2, [pc, #44]	; (80004a0 <port_init+0x40>)
 8000472:	68d2      	ldr	r2, [r2, #12]
 8000474:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000478:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800047a:	4b0a      	ldr	r3, [pc, #40]	; (80004a4 <port_init+0x44>)
 800047c:	4a09      	ldr	r2, [pc, #36]	; (80004a4 <port_init+0x44>)
 800047e:	6812      	ldr	r2, [r2, #0]
 8000480:	f042 0201 	orr.w	r2, r2, #1
 8000484:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8000486:	f06f 0004 	mvn.w	r0, #4
 800048a:	2101      	movs	r1, #1
 800048c:	f7ff ffc0 	bl	8000410 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8000490:	f06f 0001 	mvn.w	r0, #1
 8000494:	2102      	movs	r1, #2
 8000496:	f7ff ffbb 	bl	8000410 <NVIC_SetPriority>
}
 800049a:	bd08      	pop	{r3, pc}
 800049c:	e000ed00 	.word	0xe000ed00
 80004a0:	e000edf0 	.word	0xe000edf0
 80004a4:	e0001000 	.word	0xe0001000
 80004a8:	f3af 8000 	nop.w
 80004ac:	f3af 8000 	nop.w

080004b0 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 80004b0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80004b2:	f3ef 8311 	mrs	r3, BASEPRI
 80004b6:	9300      	str	r3, [sp, #0]
  return(result);
 80004b8:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 80004ba:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 80004bc:	9b01      	ldr	r3, [sp, #4]
}
 80004be:	4618      	mov	r0, r3
 80004c0:	b002      	add	sp, #8
 80004c2:	4770      	bx	lr
 80004c4:	f3af 8000 	nop.w
 80004c8:	f3af 8000 	nop.w
 80004cc:	f3af 8000 	nop.w

080004d0 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 80004d0:	b082      	sub	sp, #8
 80004d2:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 80004d4:	9b01      	ldr	r3, [sp, #4]
 80004d6:	2b00      	cmp	r3, #0
 80004d8:	bf14      	ite	ne
 80004da:	2300      	movne	r3, #0
 80004dc:	2301      	moveq	r3, #1
 80004de:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004e0:	4618      	mov	r0, r3
 80004e2:	b002      	add	sp, #8
 80004e4:	4770      	bx	lr
 80004e6:	bf00      	nop
 80004e8:	f3af 8000 	nop.w
 80004ec:	f3af 8000 	nop.w

080004f0 <port_is_isr_context>:
 *
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
 80004f0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80004f2:	f3ef 8305 	mrs	r3, IPSR
 80004f6:	9301      	str	r3, [sp, #4]
  return(result);
 80004f8:	9b01      	ldr	r3, [sp, #4]

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80004fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80004fe:	2b00      	cmp	r3, #0
 8000500:	bf0c      	ite	eq
 8000502:	2300      	moveq	r3, #0
 8000504:	2301      	movne	r3, #1
 8000506:	b2db      	uxtb	r3, r3
}
 8000508:	4618      	mov	r0, r3
 800050a:	b002      	add	sp, #8
 800050c:	4770      	bx	lr
 800050e:	bf00      	nop

08000510 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000510:	b082      	sub	sp, #8
 8000512:	2320      	movs	r3, #32
 8000514:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000516:	9b01      	ldr	r3, [sp, #4]
 8000518:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800051c:	b002      	add	sp, #8
 800051e:	4770      	bx	lr

08000520 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000520:	b082      	sub	sp, #8
 8000522:	2300      	movs	r3, #0
 8000524:	9301      	str	r3, [sp, #4]
 8000526:	9b01      	ldr	r3, [sp, #4]
 8000528:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800052c:	b002      	add	sp, #8
 800052e:	4770      	bx	lr

08000530 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000530:	b508      	push	{r3, lr}

  port_lock();
 8000532:	f7ff ffed 	bl	8000510 <port_lock>
}
 8000536:	bd08      	pop	{r3, pc}
 8000538:	f3af 8000 	nop.w
 800053c:	f3af 8000 	nop.w

08000540 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000540:	b508      	push	{r3, lr}

  port_unlock();
 8000542:	f7ff ffed 	bl	8000520 <port_unlock>
}
 8000546:	bd08      	pop	{r3, pc}
 8000548:	f3af 8000 	nop.w
 800054c:	f3af 8000 	nop.w

08000550 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000550:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8000552:	4770      	bx	lr
 8000554:	f3af 8000 	nop.w
 8000558:	f3af 8000 	nop.w
 800055c:	f3af 8000 	nop.w

08000560 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8000560:	b082      	sub	sp, #8
 8000562:	2300      	movs	r3, #0
 8000564:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000566:	9b01      	ldr	r3, [sp, #4]
 8000568:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800056c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800056e:	b002      	add	sp, #8
 8000570:	4770      	bx	lr
 8000572:	bf00      	nop
 8000574:	f3af 8000 	nop.w
 8000578:	f3af 8000 	nop.w
 800057c:	f3af 8000 	nop.w

08000580 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8000580:	4770      	bx	lr
 8000582:	bf00      	nop
 8000584:	f3af 8000 	nop.w
 8000588:	f3af 8000 	nop.w
 800058c:	f3af 8000 	nop.w

08000590 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000590:	4b01      	ldr	r3, [pc, #4]	; (8000598 <port_rt_get_counter_value+0x8>)
 8000592:	685b      	ldr	r3, [r3, #4]
}
 8000594:	4618      	mov	r0, r3
 8000596:	4770      	bx	lr
 8000598:	e0001000 	.word	0xe0001000
 800059c:	f3af 8000 	nop.w

080005a0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 80005a0:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 80005a2:	f7ff ffdd 	bl	8000560 <port_enable>
}
 80005a6:	bd08      	pop	{r3, pc}
 80005a8:	f3af 8000 	nop.w
 80005ac:	f3af 8000 	nop.w

080005b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80005b0:	b508      	push	{r3, lr}

  port_lock();
 80005b2:	f7ff ffad 	bl	8000510 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80005b6:	bd08      	pop	{r3, pc}
 80005b8:	f3af 8000 	nop.w
 80005bc:	f3af 8000 	nop.w

080005c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80005c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80005c2:	f7ff ffad 	bl	8000520 <port_unlock>
}
 80005c6:	bd08      	pop	{r3, pc}
 80005c8:	f3af 8000 	nop.w
 80005cc:	f3af 8000 	nop.w

080005d0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80005d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80005d2:	f7ff ffad 	bl	8000530 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80005d6:	bd08      	pop	{r3, pc}
 80005d8:	f3af 8000 	nop.w
 80005dc:	f3af 8000 	nop.w

080005e0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80005e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80005e2:	f7ff ffad 	bl	8000540 <port_unlock_from_isr>
}
 80005e6:	bd08      	pop	{r3, pc}
 80005e8:	f3af 8000 	nop.w
 80005ec:	f3af 8000 	nop.w

080005f0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 80005f0:	b500      	push	{lr}
 80005f2:	b083      	sub	sp, #12

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80005f4:	4b18      	ldr	r3, [pc, #96]	; (8000658 <chVTDoTickI+0x68>)
 80005f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80005f8:	1c5a      	adds	r2, r3, #1
 80005fa:	4b17      	ldr	r3, [pc, #92]	; (8000658 <chVTDoTickI+0x68>)
 80005fc:	629a      	str	r2, [r3, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80005fe:	4b16      	ldr	r3, [pc, #88]	; (8000658 <chVTDoTickI+0x68>)
 8000600:	69da      	ldr	r2, [r3, #28]
 8000602:	4b16      	ldr	r3, [pc, #88]	; (800065c <chVTDoTickI+0x6c>)
 8000604:	429a      	cmp	r2, r3
 8000606:	d024      	beq.n	8000652 <chVTDoTickI+0x62>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 8000608:	4b13      	ldr	r3, [pc, #76]	; (8000658 <chVTDoTickI+0x68>)
 800060a:	69db      	ldr	r3, [r3, #28]
 800060c:	689a      	ldr	r2, [r3, #8]
 800060e:	3a01      	subs	r2, #1
 8000610:	609a      	str	r2, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8000612:	e019      	b.n	8000648 <chVTDoTickI+0x58>
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
 8000614:	4b10      	ldr	r3, [pc, #64]	; (8000658 <chVTDoTickI+0x68>)
 8000616:	69db      	ldr	r3, [r3, #28]
 8000618:	9301      	str	r3, [sp, #4]
      fn = vtp->vt_func;
 800061a:	9b01      	ldr	r3, [sp, #4]
 800061c:	68db      	ldr	r3, [r3, #12]
 800061e:	9300      	str	r3, [sp, #0]
      vtp->vt_func = NULL;
 8000620:	9b01      	ldr	r3, [sp, #4]
 8000622:	2200      	movs	r2, #0
 8000624:	60da      	str	r2, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000626:	9b01      	ldr	r3, [sp, #4]
 8000628:	681b      	ldr	r3, [r3, #0]
 800062a:	4a0c      	ldr	r2, [pc, #48]	; (800065c <chVTDoTickI+0x6c>)
 800062c:	605a      	str	r2, [r3, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 800062e:	9b01      	ldr	r3, [sp, #4]
 8000630:	681a      	ldr	r2, [r3, #0]
 8000632:	4b09      	ldr	r3, [pc, #36]	; (8000658 <chVTDoTickI+0x68>)
 8000634:	61da      	str	r2, [r3, #28]
      chSysUnlockFromISR();
 8000636:	f7ff ffd3 	bl	80005e0 <chSysUnlockFromISR>
      fn(vtp->vt_par);
 800063a:	9b01      	ldr	r3, [sp, #4]
 800063c:	691a      	ldr	r2, [r3, #16]
 800063e:	9b00      	ldr	r3, [sp, #0]
 8000640:	4610      	mov	r0, r2
 8000642:	4798      	blx	r3
      chSysLockFromISR();
 8000644:	f7ff ffc4 	bl	80005d0 <chSysLockFromISR>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8000648:	4b03      	ldr	r3, [pc, #12]	; (8000658 <chVTDoTickI+0x68>)
 800064a:	69db      	ldr	r3, [r3, #28]
 800064c:	689b      	ldr	r3, [r3, #8]
 800064e:	2b00      	cmp	r3, #0
 8000650:	d0e0      	beq.n	8000614 <chVTDoTickI+0x24>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000652:	b003      	add	sp, #12
 8000654:	f85d fb04 	ldr.w	pc, [sp], #4
 8000658:	200039a8 	.word	0x200039a8
 800065c:	200039c4 	.word	0x200039c4

08000660 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000660:	b082      	sub	sp, #8
 8000662:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8000664:	4b02      	ldr	r3, [pc, #8]	; (8000670 <chRegSetThreadName+0x10>)
 8000666:	699b      	ldr	r3, [r3, #24]
 8000668:	9a01      	ldr	r2, [sp, #4]
 800066a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800066c:	b002      	add	sp, #8
 800066e:	4770      	bx	lr
 8000670:	200039a8 	.word	0x200039a8
 8000674:	f3af 8000 	nop.w
 8000678:	f3af 8000 	nop.w
 800067c:	f3af 8000 	nop.w

08000680 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8000680:	b082      	sub	sp, #8
 8000682:	9001      	str	r0, [sp, #4]
 8000684:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8000686:	9b01      	ldr	r3, [sp, #4]
 8000688:	9a00      	ldr	r2, [sp, #0]
 800068a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800068c:	b002      	add	sp, #8
 800068e:	4770      	bx	lr

08000690 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000690:	b500      	push	{lr}
 8000692:	b083      	sub	sp, #12
 8000694:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8000696:	f7ff ff73 	bl	8000580 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
 800069a:	e7fc      	b.n	8000696 <_idle_thread+0x6>
 800069c:	f3af 8000 	nop.w

080006a0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80006a0:	b500      	push	{lr}
 80006a2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 80006a4:	f7ff fedc 	bl	8000460 <port_init>
  _scheduler_init();
 80006a8:	f000 fa6a 	bl	8000b80 <_scheduler_init>
  _vt_init();
 80006ac:	f000 f958 	bl	8000960 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80006b0:	f000 ffd6 	bl	8001660 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80006b4:	f002 ffbc 	bl	8003630 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80006b8:	f003 f81a 	bl	80036f0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80006bc:	480f      	ldr	r0, [pc, #60]	; (80006fc <chSysInit+0x5c>)
 80006be:	2140      	movs	r1, #64	; 0x40
 80006c0:	f000 fd26 	bl	8001110 <_thread_init>
 80006c4:	4602      	mov	r2, r0
 80006c6:	4b0e      	ldr	r3, [pc, #56]	; (8000700 <chSysInit+0x60>)
 80006c8:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80006ca:	4b0d      	ldr	r3, [pc, #52]	; (8000700 <chSysInit+0x60>)
 80006cc:	699b      	ldr	r3, [r3, #24]
 80006ce:	2201      	movs	r2, #1
 80006d0:	771a      	strb	r2, [r3, #28]
#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
#endif

  chSysEnable();
 80006d2:	f7ff ff65 	bl	80005a0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 80006d6:	480b      	ldr	r0, [pc, #44]	; (8000704 <chSysInit+0x64>)
 80006d8:	f7ff ffc2 	bl	8000660 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80006dc:	2300      	movs	r3, #0
 80006de:	9300      	str	r3, [sp, #0]
 80006e0:	4809      	ldr	r0, [pc, #36]	; (8000708 <chSysInit+0x68>)
 80006e2:	21d8      	movs	r1, #216	; 0xd8
 80006e4:	2201      	movs	r2, #1
 80006e6:	4b09      	ldr	r3, [pc, #36]	; (800070c <chSysInit+0x6c>)
 80006e8:	f000 fd7a 	bl	80011e0 <chThdCreateStatic>
 80006ec:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 80006ee:	9803      	ldr	r0, [sp, #12]
 80006f0:	4907      	ldr	r1, [pc, #28]	; (8000710 <chSysInit+0x70>)
 80006f2:	f7ff ffc5 	bl	8000680 <chRegSetThreadNameX>
  }
#endif
}
 80006f6:	b005      	add	sp, #20
 80006f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80006fc:	200039d8 	.word	0x200039d8
 8000700:	200039a8 	.word	0x200039a8
 8000704:	0801aa40 	.word	0x0801aa40
 8000708:	20003a20 	.word	0x20003a20
 800070c:	08000691 	.word	0x08000691
 8000710:	0801aa30 	.word	0x0801aa30
 8000714:	f3af 8000 	nop.w
 8000718:	f3af 8000 	nop.w
 800071c:	f3af 8000 	nop.w

08000720 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8000720:	b500      	push	{lr}
 8000722:	b083      	sub	sp, #12
 8000724:	9001      	str	r0, [sp, #4]

  port_disable();
 8000726:	f7ff ff13 	bl	8000550 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800072a:	4b02      	ldr	r3, [pc, #8]	; (8000734 <chSysHalt+0x14>)
 800072c:	9a01      	ldr	r2, [sp, #4]
 800072e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
 8000730:	e7fe      	b.n	8000730 <chSysHalt+0x10>
 8000732:	bf00      	nop
 8000734:	200039a8 	.word	0x200039a8
 8000738:	f3af 8000 	nop.w
 800073c:	f3af 8000 	nop.w

08000740 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8000740:	b086      	sub	sp, #24
 8000742:	9001      	str	r0, [sp, #4]
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000744:	9b01      	ldr	r3, [sp, #4]
 8000746:	f003 0301 	and.w	r3, r3, #1
 800074a:	2b00      	cmp	r3, #0
 800074c:	d022      	beq.n	8000794 <chSysIntegrityCheckI+0x54>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800074e:	2300      	movs	r3, #0
 8000750:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_queue.p_next;
 8000752:	4b3a      	ldr	r3, [pc, #232]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000754:	681b      	ldr	r3, [r3, #0]
 8000756:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000758:	e005      	b.n	8000766 <chSysIntegrityCheckI+0x26>
      n++;
 800075a:	9b05      	ldr	r3, [sp, #20]
 800075c:	3301      	adds	r3, #1
 800075e:	9305      	str	r3, [sp, #20]
      tp = tp->p_next;
 8000760:	9b04      	ldr	r3, [sp, #16]
 8000762:	681b      	ldr	r3, [r3, #0]
 8000764:	9304      	str	r3, [sp, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000766:	9a04      	ldr	r2, [sp, #16]
 8000768:	4b34      	ldr	r3, [pc, #208]	; (800083c <chSysIntegrityCheckI+0xfc>)
 800076a:	429a      	cmp	r2, r3
 800076c:	d1f5      	bne.n	800075a <chSysIntegrityCheckI+0x1a>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 800076e:	4b33      	ldr	r3, [pc, #204]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000770:	685b      	ldr	r3, [r3, #4]
 8000772:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000774:	e005      	b.n	8000782 <chSysIntegrityCheckI+0x42>
      n--;
 8000776:	9b05      	ldr	r3, [sp, #20]
 8000778:	3b01      	subs	r3, #1
 800077a:	9305      	str	r3, [sp, #20]
      tp = tp->p_prev;
 800077c:	9b04      	ldr	r3, [sp, #16]
 800077e:	685b      	ldr	r3, [r3, #4]
 8000780:	9304      	str	r3, [sp, #16]
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000782:	9a04      	ldr	r2, [sp, #16]
 8000784:	4b2d      	ldr	r3, [pc, #180]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000786:	429a      	cmp	r2, r3
 8000788:	d1f5      	bne.n	8000776 <chSysIntegrityCheckI+0x36>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800078a:	9b05      	ldr	r3, [sp, #20]
 800078c:	2b00      	cmp	r3, #0
 800078e:	d001      	beq.n	8000794 <chSysIntegrityCheckI+0x54>
      return true;
 8000790:	2301      	movs	r3, #1
 8000792:	e050      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 8000794:	9b01      	ldr	r3, [sp, #4]
 8000796:	f003 0302 	and.w	r3, r3, #2
 800079a:	2b00      	cmp	r3, #0
 800079c:	d022      	beq.n	80007e4 <chSysIntegrityCheckI+0xa4>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 800079e:	2300      	movs	r3, #0
 80007a0:	9305      	str	r3, [sp, #20]
    vtp = ch.vtlist.vt_next;
 80007a2:	4b26      	ldr	r3, [pc, #152]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007a4:	69db      	ldr	r3, [r3, #28]
 80007a6:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007a8:	e005      	b.n	80007b6 <chSysIntegrityCheckI+0x76>
      n++;
 80007aa:	9b05      	ldr	r3, [sp, #20]
 80007ac:	3301      	adds	r3, #1
 80007ae:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_next;
 80007b0:	9b03      	ldr	r3, [sp, #12]
 80007b2:	681b      	ldr	r3, [r3, #0]
 80007b4:	9303      	str	r3, [sp, #12]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007b6:	9a03      	ldr	r2, [sp, #12]
 80007b8:	4b21      	ldr	r3, [pc, #132]	; (8000840 <chSysIntegrityCheckI+0x100>)
 80007ba:	429a      	cmp	r2, r3
 80007bc:	d1f5      	bne.n	80007aa <chSysIntegrityCheckI+0x6a>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 80007be:	4b1f      	ldr	r3, [pc, #124]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007c0:	6a1b      	ldr	r3, [r3, #32]
 80007c2:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007c4:	e005      	b.n	80007d2 <chSysIntegrityCheckI+0x92>
      n--;
 80007c6:	9b05      	ldr	r3, [sp, #20]
 80007c8:	3b01      	subs	r3, #1
 80007ca:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_prev;
 80007cc:	9b03      	ldr	r3, [sp, #12]
 80007ce:	685b      	ldr	r3, [r3, #4]
 80007d0:	9303      	str	r3, [sp, #12]
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007d2:	9a03      	ldr	r2, [sp, #12]
 80007d4:	4b1a      	ldr	r3, [pc, #104]	; (8000840 <chSysIntegrityCheckI+0x100>)
 80007d6:	429a      	cmp	r2, r3
 80007d8:	d1f5      	bne.n	80007c6 <chSysIntegrityCheckI+0x86>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80007da:	9b05      	ldr	r3, [sp, #20]
 80007dc:	2b00      	cmp	r3, #0
 80007de:	d001      	beq.n	80007e4 <chSysIntegrityCheckI+0xa4>
      return true;
 80007e0:	2301      	movs	r3, #1
 80007e2:	e028      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 80007e4:	9b01      	ldr	r3, [sp, #4]
 80007e6:	f003 0304 	and.w	r3, r3, #4
 80007ea:	2b00      	cmp	r3, #0
 80007ec:	d022      	beq.n	8000834 <chSysIntegrityCheckI+0xf4>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80007ee:	2300      	movs	r3, #0
 80007f0:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_newer;
 80007f2:	4b12      	ldr	r3, [pc, #72]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007f4:	691b      	ldr	r3, [r3, #16]
 80007f6:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 80007f8:	e005      	b.n	8000806 <chSysIntegrityCheckI+0xc6>
      n++;
 80007fa:	9b05      	ldr	r3, [sp, #20]
 80007fc:	3301      	adds	r3, #1
 80007fe:	9305      	str	r3, [sp, #20]
      tp = tp->p_newer;
 8000800:	9b02      	ldr	r3, [sp, #8]
 8000802:	691b      	ldr	r3, [r3, #16]
 8000804:	9302      	str	r3, [sp, #8]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 8000806:	9a02      	ldr	r2, [sp, #8]
 8000808:	4b0c      	ldr	r3, [pc, #48]	; (800083c <chSysIntegrityCheckI+0xfc>)
 800080a:	429a      	cmp	r2, r3
 800080c:	d1f5      	bne.n	80007fa <chSysIntegrityCheckI+0xba>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 800080e:	4b0b      	ldr	r3, [pc, #44]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000810:	695b      	ldr	r3, [r3, #20]
 8000812:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 8000814:	e005      	b.n	8000822 <chSysIntegrityCheckI+0xe2>
      n--;
 8000816:	9b05      	ldr	r3, [sp, #20]
 8000818:	3b01      	subs	r3, #1
 800081a:	9305      	str	r3, [sp, #20]
      tp = tp->p_older;
 800081c:	9b02      	ldr	r3, [sp, #8]
 800081e:	695b      	ldr	r3, [r3, #20]
 8000820:	9302      	str	r3, [sp, #8]
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 8000822:	9a02      	ldr	r2, [sp, #8]
 8000824:	4b05      	ldr	r3, [pc, #20]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000826:	429a      	cmp	r2, r3
 8000828:	d1f5      	bne.n	8000816 <chSysIntegrityCheckI+0xd6>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800082a:	9b05      	ldr	r3, [sp, #20]
 800082c:	2b00      	cmp	r3, #0
 800082e:	d001      	beq.n	8000834 <chSysIntegrityCheckI+0xf4>
      return true;
 8000830:	2301      	movs	r3, #1
 8000832:	e000      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 8000834:	2300      	movs	r3, #0
}
 8000836:	4618      	mov	r0, r3
 8000838:	b006      	add	sp, #24
 800083a:	4770      	bx	lr
 800083c:	200039a8 	.word	0x200039a8
 8000840:	200039c4 	.word	0x200039c4
 8000844:	f3af 8000 	nop.w
 8000848:	f3af 8000 	nop.w
 800084c:	f3af 8000 	nop.w

08000850 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000850:	b508      	push	{r3, lr}

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > (tslices_t)0) {
 8000852:	4b07      	ldr	r3, [pc, #28]	; (8000870 <chSysTimerHandlerI+0x20>)
 8000854:	699b      	ldr	r3, [r3, #24]
 8000856:	7fdb      	ldrb	r3, [r3, #31]
 8000858:	2b00      	cmp	r3, #0
 800085a:	d005      	beq.n	8000868 <chSysTimerHandlerI+0x18>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800085c:	4b04      	ldr	r3, [pc, #16]	; (8000870 <chSysTimerHandlerI+0x20>)
 800085e:	699b      	ldr	r3, [r3, #24]
 8000860:	7fda      	ldrb	r2, [r3, #31]
 8000862:	3a01      	subs	r2, #1
 8000864:	b2d2      	uxtb	r2, r2
 8000866:	77da      	strb	r2, [r3, #31]
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8000868:	f7ff fec2 	bl	80005f0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800086c:	bd08      	pop	{r3, pc}
 800086e:	bf00      	nop
 8000870:	200039a8 	.word	0x200039a8
 8000874:	f3af 8000 	nop.w
 8000878:	f3af 8000 	nop.w
 800087c:	f3af 8000 	nop.w

08000880 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 8000880:	b500      	push	{lr}
 8000882:	b083      	sub	sp, #12

  syssts_t sts = port_get_irq_status();
 8000884:	f7ff fe14 	bl	80004b0 <port_get_irq_status>
 8000888:	9001      	str	r0, [sp, #4]
  if (port_irq_enabled(sts)) {
 800088a:	9801      	ldr	r0, [sp, #4]
 800088c:	f7ff fe20 	bl	80004d0 <port_irq_enabled>
 8000890:	4603      	mov	r3, r0
 8000892:	2b00      	cmp	r3, #0
 8000894:	d009      	beq.n	80008aa <chSysGetStatusAndLockX+0x2a>
    if (port_is_isr_context()) {
 8000896:	f7ff fe2b 	bl	80004f0 <port_is_isr_context>
 800089a:	4603      	mov	r3, r0
 800089c:	2b00      	cmp	r3, #0
 800089e:	d002      	beq.n	80008a6 <chSysGetStatusAndLockX+0x26>
      chSysLockFromISR();
 80008a0:	f7ff fe96 	bl	80005d0 <chSysLockFromISR>
 80008a4:	e001      	b.n	80008aa <chSysGetStatusAndLockX+0x2a>
    }
    else {
      chSysLock();
 80008a6:	f7ff fe83 	bl	80005b0 <chSysLock>
    }
  }
  return sts;
 80008aa:	9b01      	ldr	r3, [sp, #4]
}
 80008ac:	4618      	mov	r0, r3
 80008ae:	b003      	add	sp, #12
 80008b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80008b4:	f3af 8000 	nop.w
 80008b8:	f3af 8000 	nop.w
 80008bc:	f3af 8000 	nop.w

080008c0 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80008c0:	b500      	push	{lr}
 80008c2:	b083      	sub	sp, #12
 80008c4:	9001      	str	r0, [sp, #4]

  if (port_irq_enabled(sts)) {
 80008c6:	9801      	ldr	r0, [sp, #4]
 80008c8:	f7ff fe02 	bl	80004d0 <port_irq_enabled>
 80008cc:	4603      	mov	r3, r0
 80008ce:	2b00      	cmp	r3, #0
 80008d0:	d00b      	beq.n	80008ea <chSysRestoreStatusX+0x2a>
    if (port_is_isr_context()) {
 80008d2:	f7ff fe0d 	bl	80004f0 <port_is_isr_context>
 80008d6:	4603      	mov	r3, r0
 80008d8:	2b00      	cmp	r3, #0
 80008da:	d002      	beq.n	80008e2 <chSysRestoreStatusX+0x22>
      chSysUnlockFromISR();
 80008dc:	f7ff fe80 	bl	80005e0 <chSysUnlockFromISR>
 80008e0:	e003      	b.n	80008ea <chSysRestoreStatusX+0x2a>
    }
    else {
      chSchRescheduleS();
 80008e2:	f000 fa4d 	bl	8000d80 <chSchRescheduleS>
      chSysUnlock();
 80008e6:	f7ff fe6b 	bl	80005c0 <chSysUnlock>
    }
  }
}
 80008ea:	b003      	add	sp, #12
 80008ec:	f85d fb04 	ldr.w	pc, [sp], #4

080008f0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 80008f0:	b084      	sub	sp, #16
 80008f2:	9003      	str	r0, [sp, #12]
 80008f4:	9102      	str	r1, [sp, #8]
 80008f6:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 80008f8:	9a03      	ldr	r2, [sp, #12]
 80008fa:	9b02      	ldr	r3, [sp, #8]
 80008fc:	1ad2      	subs	r2, r2, r3
 80008fe:	9901      	ldr	r1, [sp, #4]
 8000900:	9b02      	ldr	r3, [sp, #8]
 8000902:	1acb      	subs	r3, r1, r3
 8000904:	429a      	cmp	r2, r3
 8000906:	bf2c      	ite	cs
 8000908:	2300      	movcs	r3, #0
 800090a:	2301      	movcc	r3, #1
 800090c:	b2db      	uxtb	r3, r3
}
 800090e:	4618      	mov	r0, r3
 8000910:	b004      	add	sp, #16
 8000912:	4770      	bx	lr
 8000914:	f3af 8000 	nop.w
 8000918:	f3af 8000 	nop.w
 800091c:	f3af 8000 	nop.w

08000920 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8000920:	b500      	push	{lr}
 8000922:	b085      	sub	sp, #20
 8000924:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8000926:	f7ff fe33 	bl	8000590 <port_rt_get_counter_value>
 800092a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800092c:	9a03      	ldr	r2, [sp, #12]
 800092e:	9b01      	ldr	r3, [sp, #4]
 8000930:	4413      	add	r3, r2
 8000932:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8000934:	bf00      	nop
 8000936:	f7ff fe2b 	bl	8000590 <port_rt_get_counter_value>
 800093a:	4603      	mov	r3, r0
 800093c:	4618      	mov	r0, r3
 800093e:	9903      	ldr	r1, [sp, #12]
 8000940:	9a02      	ldr	r2, [sp, #8]
 8000942:	f7ff ffd5 	bl	80008f0 <chSysIsCounterWithinX>
 8000946:	4603      	mov	r3, r0
 8000948:	2b00      	cmp	r3, #0
 800094a:	d1f4      	bne.n	8000936 <chSysPolledDelayX+0x16>
  }
}
 800094c:	b005      	add	sp, #20
 800094e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000952:	bf00      	nop
 8000954:	f3af 8000 	nop.w
 8000958:	f3af 8000 	nop.w
 800095c:	f3af 8000 	nop.w

08000960 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8000960:	4b06      	ldr	r3, [pc, #24]	; (800097c <_vt_init+0x1c>)
 8000962:	4a07      	ldr	r2, [pc, #28]	; (8000980 <_vt_init+0x20>)
 8000964:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000966:	4b05      	ldr	r3, [pc, #20]	; (800097c <_vt_init+0x1c>)
 8000968:	4a05      	ldr	r2, [pc, #20]	; (8000980 <_vt_init+0x20>)
 800096a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800096c:	4b03      	ldr	r3, [pc, #12]	; (800097c <_vt_init+0x1c>)
 800096e:	f04f 32ff 	mov.w	r2, #4294967295
 8000972:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 8000974:	4b01      	ldr	r3, [pc, #4]	; (800097c <_vt_init+0x1c>)
 8000976:	2200      	movs	r2, #0
 8000978:	629a      	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800097a:	4770      	bx	lr
 800097c:	200039a8 	.word	0x200039a8
 8000980:	200039c4 	.word	0x200039c4
 8000984:	f3af 8000 	nop.w
 8000988:	f3af 8000 	nop.w
 800098c:	f3af 8000 	nop.w

08000990 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000990:	b086      	sub	sp, #24
 8000992:	9003      	str	r0, [sp, #12]
 8000994:	9102      	str	r1, [sp, #8]
 8000996:	9201      	str	r2, [sp, #4]
 8000998:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800099a:	9b03      	ldr	r3, [sp, #12]
 800099c:	9a00      	ldr	r2, [sp, #0]
 800099e:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 80009a0:	9b03      	ldr	r3, [sp, #12]
 80009a2:	9a01      	ldr	r2, [sp, #4]
 80009a4:	60da      	str	r2, [r3, #12]
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
    }
  }
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
 80009a6:	9b02      	ldr	r3, [sp, #8]
 80009a8:	9304      	str	r3, [sp, #16]

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.vt_next;
 80009aa:	4b17      	ldr	r3, [pc, #92]	; (8000a08 <chVTDoSetI+0x78>)
 80009ac:	69db      	ldr	r3, [r3, #28]
 80009ae:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80009b0:	e007      	b.n	80009c2 <chVTDoSetI+0x32>
    delta -= p->vt_delta;
 80009b2:	9b05      	ldr	r3, [sp, #20]
 80009b4:	689b      	ldr	r3, [r3, #8]
 80009b6:	9a04      	ldr	r2, [sp, #16]
 80009b8:	1ad3      	subs	r3, r2, r3
 80009ba:	9304      	str	r3, [sp, #16]
    p = p->vt_next;
 80009bc:	9b05      	ldr	r3, [sp, #20]
 80009be:	681b      	ldr	r3, [r3, #0]
 80009c0:	9305      	str	r3, [sp, #20]
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80009c2:	9b05      	ldr	r3, [sp, #20]
 80009c4:	689a      	ldr	r2, [r3, #8]
 80009c6:	9b04      	ldr	r3, [sp, #16]
 80009c8:	429a      	cmp	r2, r3
 80009ca:	d3f2      	bcc.n	80009b2 <chVTDoSetI+0x22>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80009cc:	9b03      	ldr	r3, [sp, #12]
 80009ce:	9a05      	ldr	r2, [sp, #20]
 80009d0:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80009d2:	9b03      	ldr	r3, [sp, #12]
 80009d4:	681b      	ldr	r3, [r3, #0]
 80009d6:	685a      	ldr	r2, [r3, #4]
 80009d8:	9b03      	ldr	r3, [sp, #12]
 80009da:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 80009dc:	9b03      	ldr	r3, [sp, #12]
 80009de:	685b      	ldr	r3, [r3, #4]
 80009e0:	9a03      	ldr	r2, [sp, #12]
 80009e2:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 80009e4:	9b05      	ldr	r3, [sp, #20]
 80009e6:	9a03      	ldr	r2, [sp, #12]
 80009e8:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 80009ea:	9b03      	ldr	r3, [sp, #12]
 80009ec:	9a04      	ldr	r2, [sp, #16]
 80009ee:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80009f0:	9b05      	ldr	r3, [sp, #20]
 80009f2:	689a      	ldr	r2, [r3, #8]
 80009f4:	9b04      	ldr	r3, [sp, #16]
 80009f6:	1ad2      	subs	r2, r2, r3
 80009f8:	9b05      	ldr	r3, [sp, #20]
 80009fa:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80009fc:	4b02      	ldr	r3, [pc, #8]	; (8000a08 <chVTDoSetI+0x78>)
 80009fe:	f04f 32ff 	mov.w	r2, #4294967295
 8000a02:	625a      	str	r2, [r3, #36]	; 0x24
}
 8000a04:	b006      	add	sp, #24
 8000a06:	4770      	bx	lr
 8000a08:	200039a8 	.word	0x200039a8
 8000a0c:	f3af 8000 	nop.w

08000a10 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000a10:	b082      	sub	sp, #8
 8000a12:	9001      	str	r0, [sp, #4]
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000a14:	9b01      	ldr	r3, [sp, #4]
 8000a16:	681b      	ldr	r3, [r3, #0]
 8000a18:	9a01      	ldr	r2, [sp, #4]
 8000a1a:	6812      	ldr	r2, [r2, #0]
 8000a1c:	6891      	ldr	r1, [r2, #8]
 8000a1e:	9a01      	ldr	r2, [sp, #4]
 8000a20:	6892      	ldr	r2, [r2, #8]
 8000a22:	440a      	add	r2, r1
 8000a24:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000a26:	9b01      	ldr	r3, [sp, #4]
 8000a28:	685b      	ldr	r3, [r3, #4]
 8000a2a:	9a01      	ldr	r2, [sp, #4]
 8000a2c:	6812      	ldr	r2, [r2, #0]
 8000a2e:	601a      	str	r2, [r3, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000a30:	9b01      	ldr	r3, [sp, #4]
 8000a32:	681b      	ldr	r3, [r3, #0]
 8000a34:	9a01      	ldr	r2, [sp, #4]
 8000a36:	6852      	ldr	r2, [r2, #4]
 8000a38:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8000a3a:	9b01      	ldr	r3, [sp, #4]
 8000a3c:	2200      	movs	r2, #0
 8000a3e:	60da      	str	r2, [r3, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000a40:	4b02      	ldr	r3, [pc, #8]	; (8000a4c <chVTDoResetI+0x3c>)
 8000a42:	f04f 32ff 	mov.w	r2, #4294967295
 8000a46:	625a      	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000a48:	b002      	add	sp, #8
 8000a4a:	4770      	bx	lr
 8000a4c:	200039a8 	.word	0x200039a8

08000a50 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000a50:	b082      	sub	sp, #8
 8000a52:	2320      	movs	r3, #32
 8000a54:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000a56:	9b01      	ldr	r3, [sp, #4]
 8000a58:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a5c:	b002      	add	sp, #8
 8000a5e:	4770      	bx	lr

08000a60 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000a60:	b082      	sub	sp, #8
 8000a62:	2300      	movs	r3, #0
 8000a64:	9301      	str	r3, [sp, #4]
 8000a66:	9b01      	ldr	r3, [sp, #4]
 8000a68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a6c:	b002      	add	sp, #8
 8000a6e:	4770      	bx	lr

08000a70 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000a70:	b508      	push	{r3, lr}

  port_lock();
 8000a72:	f7ff ffed 	bl	8000a50 <port_lock>
}
 8000a76:	bd08      	pop	{r3, pc}
 8000a78:	f3af 8000 	nop.w
 8000a7c:	f3af 8000 	nop.w

08000a80 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000a80:	b508      	push	{r3, lr}

  port_unlock();
 8000a82:	f7ff ffed 	bl	8000a60 <port_unlock>
}
 8000a86:	bd08      	pop	{r3, pc}
 8000a88:	f3af 8000 	nop.w
 8000a8c:	f3af 8000 	nop.w

08000a90 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000a90:	b082      	sub	sp, #8
 8000a92:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000a94:	9b01      	ldr	r3, [sp, #4]
 8000a96:	9a01      	ldr	r2, [sp, #4]
 8000a98:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000a9a:	9b01      	ldr	r3, [sp, #4]
 8000a9c:	9a01      	ldr	r2, [sp, #4]
 8000a9e:	605a      	str	r2, [r3, #4]
}
 8000aa0:	b002      	add	sp, #8
 8000aa2:	4770      	bx	lr
 8000aa4:	f3af 8000 	nop.w
 8000aa8:	f3af 8000 	nop.w
 8000aac:	f3af 8000 	nop.w

08000ab0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000ab0:	b084      	sub	sp, #16
 8000ab2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000ab4:	9b01      	ldr	r3, [sp, #4]
 8000ab6:	681b      	ldr	r3, [r3, #0]
 8000ab8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000aba:	9b03      	ldr	r3, [sp, #12]
 8000abc:	681a      	ldr	r2, [r3, #0]
 8000abe:	9b01      	ldr	r3, [sp, #4]
 8000ac0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000ac2:	9b01      	ldr	r3, [sp, #4]
 8000ac4:	681b      	ldr	r3, [r3, #0]
 8000ac6:	9a01      	ldr	r2, [sp, #4]
 8000ac8:	605a      	str	r2, [r3, #4]

  return tp;
 8000aca:	9b03      	ldr	r3, [sp, #12]
}
 8000acc:	4618      	mov	r0, r3
 8000ace:	b004      	add	sp, #16
 8000ad0:	4770      	bx	lr
 8000ad2:	bf00      	nop
 8000ad4:	f3af 8000 	nop.w
 8000ad8:	f3af 8000 	nop.w
 8000adc:	f3af 8000 	nop.w

08000ae0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8000ae0:	b082      	sub	sp, #8
 8000ae2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8000ae4:	9b01      	ldr	r3, [sp, #4]
 8000ae6:	685b      	ldr	r3, [r3, #4]
 8000ae8:	9a01      	ldr	r2, [sp, #4]
 8000aea:	6812      	ldr	r2, [r2, #0]
 8000aec:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000aee:	9b01      	ldr	r3, [sp, #4]
 8000af0:	681b      	ldr	r3, [r3, #0]
 8000af2:	9a01      	ldr	r2, [sp, #4]
 8000af4:	6852      	ldr	r2, [r2, #4]
 8000af6:	605a      	str	r2, [r3, #4]

  return tp;
 8000af8:	9b01      	ldr	r3, [sp, #4]
}
 8000afa:	4618      	mov	r0, r3
 8000afc:	b002      	add	sp, #8
 8000afe:	4770      	bx	lr

08000b00 <chSchIsRescRequiredI>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000b00:	4b06      	ldr	r3, [pc, #24]	; (8000b1c <chSchIsRescRequiredI+0x1c>)
 8000b02:	681b      	ldr	r3, [r3, #0]
 8000b04:	689a      	ldr	r2, [r3, #8]
 8000b06:	4b05      	ldr	r3, [pc, #20]	; (8000b1c <chSchIsRescRequiredI+0x1c>)
 8000b08:	699b      	ldr	r3, [r3, #24]
 8000b0a:	689b      	ldr	r3, [r3, #8]
 8000b0c:	429a      	cmp	r2, r3
 8000b0e:	bf94      	ite	ls
 8000b10:	2300      	movls	r3, #0
 8000b12:	2301      	movhi	r3, #1
 8000b14:	b2db      	uxtb	r3, r3
}
 8000b16:	4618      	mov	r0, r3
 8000b18:	4770      	bx	lr
 8000b1a:	bf00      	nop
 8000b1c:	200039a8 	.word	0x200039a8

08000b20 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000b20:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000b22:	f7ff ffa5 	bl	8000a70 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000b26:	bd08      	pop	{r3, pc}
 8000b28:	f3af 8000 	nop.w
 8000b2c:	f3af 8000 	nop.w

08000b30 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000b30:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000b32:	f7ff ffa5 	bl	8000a80 <port_unlock_from_isr>
}
 8000b36:	bd08      	pop	{r3, pc}
 8000b38:	f3af 8000 	nop.w
 8000b3c:	f3af 8000 	nop.w

08000b40 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8000b40:	b082      	sub	sp, #8
 8000b42:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8000b44:	9b01      	ldr	r3, [sp, #4]
 8000b46:	68db      	ldr	r3, [r3, #12]
 8000b48:	2b00      	cmp	r3, #0
 8000b4a:	bf0c      	ite	eq
 8000b4c:	2300      	moveq	r3, #0
 8000b4e:	2301      	movne	r3, #1
 8000b50:	b2db      	uxtb	r3, r3
}
 8000b52:	4618      	mov	r0, r3
 8000b54:	b002      	add	sp, #8
 8000b56:	4770      	bx	lr
 8000b58:	f3af 8000 	nop.w
 8000b5c:	f3af 8000 	nop.w

08000b60 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8000b60:	b082      	sub	sp, #8
 8000b62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8000b64:	9b01      	ldr	r3, [sp, #4]
 8000b66:	689b      	ldr	r3, [r3, #8]
 8000b68:	1c5a      	adds	r2, r3, #1
 8000b6a:	9b01      	ldr	r3, [sp, #4]
 8000b6c:	609a      	str	r2, [r3, #8]
}
 8000b6e:	b002      	add	sp, #8
 8000b70:	4770      	bx	lr
 8000b72:	bf00      	nop
 8000b74:	f3af 8000 	nop.w
 8000b78:	f3af 8000 	nop.w
 8000b7c:	f3af 8000 	nop.w

08000b80 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8000b80:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 8000b82:	4806      	ldr	r0, [pc, #24]	; (8000b9c <_scheduler_init+0x1c>)
 8000b84:	f7ff ff84 	bl	8000a90 <queue_init>
  ch.rlist.r_prio = NOPRIO;
 8000b88:	4b04      	ldr	r3, [pc, #16]	; (8000b9c <_scheduler_init+0x1c>)
 8000b8a:	2200      	movs	r2, #0
 8000b8c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8000b8e:	4b03      	ldr	r3, [pc, #12]	; (8000b9c <_scheduler_init+0x1c>)
 8000b90:	4a02      	ldr	r2, [pc, #8]	; (8000b9c <_scheduler_init+0x1c>)
 8000b92:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8000b94:	4b01      	ldr	r3, [pc, #4]	; (8000b9c <_scheduler_init+0x1c>)
 8000b96:	4a01      	ldr	r2, [pc, #4]	; (8000b9c <_scheduler_init+0x1c>)
 8000b98:	615a      	str	r2, [r3, #20]
#endif
}
 8000b9a:	bd08      	pop	{r3, pc}
 8000b9c:	200039a8 	.word	0x200039a8

08000ba0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000ba0:	b084      	sub	sp, #16
 8000ba2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000ba4:	9b01      	ldr	r3, [sp, #4]
 8000ba6:	2200      	movs	r2, #0
 8000ba8:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000baa:	4b0e      	ldr	r3, [pc, #56]	; (8000be4 <chSchReadyI+0x44>)
 8000bac:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8000bae:	9b03      	ldr	r3, [sp, #12]
 8000bb0:	681b      	ldr	r3, [r3, #0]
 8000bb2:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8000bb4:	9b03      	ldr	r3, [sp, #12]
 8000bb6:	689a      	ldr	r2, [r3, #8]
 8000bb8:	9b01      	ldr	r3, [sp, #4]
 8000bba:	689b      	ldr	r3, [r3, #8]
 8000bbc:	429a      	cmp	r2, r3
 8000bbe:	d2f6      	bcs.n	8000bae <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000bc0:	9b01      	ldr	r3, [sp, #4]
 8000bc2:	9a03      	ldr	r2, [sp, #12]
 8000bc4:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8000bc6:	9b03      	ldr	r3, [sp, #12]
 8000bc8:	685a      	ldr	r2, [r3, #4]
 8000bca:	9b01      	ldr	r3, [sp, #4]
 8000bcc:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000bce:	9b01      	ldr	r3, [sp, #4]
 8000bd0:	685b      	ldr	r3, [r3, #4]
 8000bd2:	9a01      	ldr	r2, [sp, #4]
 8000bd4:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8000bd6:	9b03      	ldr	r3, [sp, #12]
 8000bd8:	9a01      	ldr	r2, [sp, #4]
 8000bda:	605a      	str	r2, [r3, #4]

  return tp;
 8000bdc:	9b01      	ldr	r3, [sp, #4]
}
 8000bde:	4618      	mov	r0, r3
 8000be0:	b004      	add	sp, #16
 8000be2:	4770      	bx	lr
 8000be4:	200039a8 	.word	0x200039a8
 8000be8:	f3af 8000 	nop.w
 8000bec:	f3af 8000 	nop.w

08000bf0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000bf0:	b500      	push	{lr}
 8000bf2:	b085      	sub	sp, #20
 8000bf4:	4603      	mov	r3, r0
 8000bf6:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000bfa:	4b0e      	ldr	r3, [pc, #56]	; (8000c34 <chSchGoSleepS+0x44>)
 8000bfc:	699b      	ldr	r3, [r3, #24]
 8000bfe:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8000c00:	9b03      	ldr	r3, [sp, #12]
 8000c02:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8000c06:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8000c08:	9b03      	ldr	r3, [sp, #12]
 8000c0a:	220a      	movs	r2, #10
 8000c0c:	77da      	strb	r2, [r3, #31]
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000c0e:	4809      	ldr	r0, [pc, #36]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c10:	f7ff ff4e 	bl	8000ab0 <queue_fifo_remove>
 8000c14:	4602      	mov	r2, r0
 8000c16:	4b07      	ldr	r3, [pc, #28]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c18:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000c1a:	4b06      	ldr	r3, [pc, #24]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c1c:	699b      	ldr	r3, [r3, #24]
 8000c1e:	2201      	movs	r2, #1
 8000c20:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 8000c22:	4b04      	ldr	r3, [pc, #16]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c24:	699b      	ldr	r3, [r3, #24]
 8000c26:	4618      	mov	r0, r3
 8000c28:	9903      	ldr	r1, [sp, #12]
 8000c2a:	f7ff fb59 	bl	80002e0 <_port_switch>
}
 8000c2e:	b005      	add	sp, #20
 8000c30:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c34:	200039a8 	.word	0x200039a8
 8000c38:	f3af 8000 	nop.w
 8000c3c:	f3af 8000 	nop.w

08000c40 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000c40:	b500      	push	{lr}
 8000c42:	b085      	sub	sp, #20
 8000c44:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8000c46:	9b01      	ldr	r3, [sp, #4]
 8000c48:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8000c4a:	f7ff ff69 	bl	8000b20 <chSysLockFromISR>
  switch (tp->p_state) {
 8000c4e:	9b03      	ldr	r3, [sp, #12]
 8000c50:	7f1b      	ldrb	r3, [r3, #28]
 8000c52:	2b07      	cmp	r3, #7
 8000c54:	d823      	bhi.n	8000c9e <wakeup+0x5e>
 8000c56:	a201      	add	r2, pc, #4	; (adr r2, 8000c5c <wakeup+0x1c>)
 8000c58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000c5c:	08000c7d 	.word	0x08000c7d
 8000c60:	08000c9f 	.word	0x08000c9f
 8000c64:	08000c9f 	.word	0x08000c9f
 8000c68:	08000c83 	.word	0x08000c83
 8000c6c:	08000c97 	.word	0x08000c97
 8000c70:	08000c8d 	.word	0x08000c8d
 8000c74:	08000c9f 	.word	0x08000c9f
 8000c78:	08000c97 	.word	0x08000c97
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8000c7c:	f7ff ff58 	bl	8000b30 <chSysUnlockFromISR>
    return;
 8000c80:	e017      	b.n	8000cb2 <wakeup+0x72>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000c82:	9b03      	ldr	r3, [sp, #12]
 8000c84:	6a1b      	ldr	r3, [r3, #32]
 8000c86:	2200      	movs	r2, #0
 8000c88:	601a      	str	r2, [r3, #0]
    break;
 8000c8a:	e009      	b.n	8000ca0 <wakeup+0x60>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8000c8c:	9b03      	ldr	r3, [sp, #12]
 8000c8e:	6a1b      	ldr	r3, [r3, #32]
 8000c90:	4618      	mov	r0, r3
 8000c92:	f7ff ff65 	bl	8000b60 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8000c96:	9803      	ldr	r0, [sp, #12]
 8000c98:	f7ff ff22 	bl	8000ae0 <queue_dequeue>
    break;
 8000c9c:	e000      	b.n	8000ca0 <wakeup+0x60>
  default:
    /* Any other state, nothing to do.*/
    break;
 8000c9e:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000ca0:	9b03      	ldr	r3, [sp, #12]
 8000ca2:	f04f 32ff 	mov.w	r2, #4294967295
 8000ca6:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8000ca8:	9803      	ldr	r0, [sp, #12]
 8000caa:	f7ff ff79 	bl	8000ba0 <chSchReadyI>
  chSysUnlockFromISR();
 8000cae:	f7ff ff3f 	bl	8000b30 <chSysUnlockFromISR>
}
 8000cb2:	b005      	add	sp, #20
 8000cb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8000cb8:	f3af 8000 	nop.w
 8000cbc:	f3af 8000 	nop.w

08000cc0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000cc0:	b500      	push	{lr}
 8000cc2:	b089      	sub	sp, #36	; 0x24
 8000cc4:	4603      	mov	r3, r0
 8000cc6:	9100      	str	r1, [sp, #0]
 8000cc8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000ccc:	9b00      	ldr	r3, [sp, #0]
 8000cce:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000cd2:	d019      	beq.n	8000d08 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000cd4:	4b12      	ldr	r3, [pc, #72]	; (8000d20 <chSchGoSleepTimeoutS+0x60>)
 8000cd6:	699b      	ldr	r3, [r3, #24]
 8000cd8:	aa03      	add	r2, sp, #12
 8000cda:	4610      	mov	r0, r2
 8000cdc:	9900      	ldr	r1, [sp, #0]
 8000cde:	4a11      	ldr	r2, [pc, #68]	; (8000d24 <chSchGoSleepTimeoutS+0x64>)
 8000ce0:	f7ff fe56 	bl	8000990 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000ce4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000ce8:	4618      	mov	r0, r3
 8000cea:	f7ff ff81 	bl	8000bf0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000cee:	ab03      	add	r3, sp, #12
 8000cf0:	4618      	mov	r0, r3
 8000cf2:	f7ff ff25 	bl	8000b40 <chVTIsArmedI>
 8000cf6:	4603      	mov	r3, r0
 8000cf8:	2b00      	cmp	r3, #0
 8000cfa:	d004      	beq.n	8000d06 <chSchGoSleepTimeoutS+0x46>
      chVTDoResetI(&vt);
 8000cfc:	ab03      	add	r3, sp, #12
 8000cfe:	4618      	mov	r0, r3
 8000d00:	f7ff fe86 	bl	8000a10 <chVTDoResetI>
 8000d04:	e005      	b.n	8000d12 <chSchGoSleepTimeoutS+0x52>
 8000d06:	e004      	b.n	8000d12 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000d08:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000d0c:	4618      	mov	r0, r3
 8000d0e:	f7ff ff6f 	bl	8000bf0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000d12:	4b03      	ldr	r3, [pc, #12]	; (8000d20 <chSchGoSleepTimeoutS+0x60>)
 8000d14:	699b      	ldr	r3, [r3, #24]
 8000d16:	6a1b      	ldr	r3, [r3, #32]
}
 8000d18:	4618      	mov	r0, r3
 8000d1a:	b009      	add	sp, #36	; 0x24
 8000d1c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d20:	200039a8 	.word	0x200039a8
 8000d24:	08000c41 	.word	0x08000c41
 8000d28:	f3af 8000 	nop.w
 8000d2c:	f3af 8000 	nop.w

08000d30 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000d30:	b500      	push	{lr}
 8000d32:	b085      	sub	sp, #20
 8000d34:	9001      	str	r0, [sp, #4]
 8000d36:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000d38:	9b01      	ldr	r3, [sp, #4]
 8000d3a:	9a00      	ldr	r2, [sp, #0]
 8000d3c:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000d3e:	9b01      	ldr	r3, [sp, #4]
 8000d40:	689a      	ldr	r2, [r3, #8]
 8000d42:	4b0e      	ldr	r3, [pc, #56]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d44:	699b      	ldr	r3, [r3, #24]
 8000d46:	689b      	ldr	r3, [r3, #8]
 8000d48:	429a      	cmp	r2, r3
 8000d4a:	d803      	bhi.n	8000d54 <chSchWakeupS+0x24>
    (void) chSchReadyI(ntp);
 8000d4c:	9801      	ldr	r0, [sp, #4]
 8000d4e:	f7ff ff27 	bl	8000ba0 <chSchReadyI>
 8000d52:	e00f      	b.n	8000d74 <chSchWakeupS+0x44>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000d54:	4b09      	ldr	r3, [pc, #36]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d56:	699b      	ldr	r3, [r3, #24]
 8000d58:	4618      	mov	r0, r3
 8000d5a:	f7ff ff21 	bl	8000ba0 <chSchReadyI>
 8000d5e:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8000d60:	4b06      	ldr	r3, [pc, #24]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d62:	9a01      	ldr	r2, [sp, #4]
 8000d64:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000d66:	9b01      	ldr	r3, [sp, #4]
 8000d68:	2201      	movs	r2, #1
 8000d6a:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8000d6c:	9801      	ldr	r0, [sp, #4]
 8000d6e:	9903      	ldr	r1, [sp, #12]
 8000d70:	f7ff fab6 	bl	80002e0 <_port_switch>
  }
}
 8000d74:	b005      	add	sp, #20
 8000d76:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d7a:	bf00      	nop
 8000d7c:	200039a8 	.word	0x200039a8

08000d80 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000d80:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000d82:	f7ff febd 	bl	8000b00 <chSchIsRescRequiredI>
 8000d86:	4603      	mov	r3, r0
 8000d88:	2b00      	cmp	r3, #0
 8000d8a:	d001      	beq.n	8000d90 <chSchRescheduleS+0x10>
    chSchDoRescheduleAhead();
 8000d8c:	f000 f850 	bl	8000e30 <chSchDoRescheduleAhead>
  }
}
 8000d90:	bd08      	pop	{r3, pc}
 8000d92:	bf00      	nop
 8000d94:	f3af 8000 	nop.w
 8000d98:	f3af 8000 	nop.w
 8000d9c:	f3af 8000 	nop.w

08000da0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8000da0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000da2:	4b0f      	ldr	r3, [pc, #60]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000da4:	681b      	ldr	r3, [r3, #0]
 8000da6:	689b      	ldr	r3, [r3, #8]
 8000da8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8000daa:	4b0d      	ldr	r3, [pc, #52]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000dac:	699b      	ldr	r3, [r3, #24]
 8000dae:	689b      	ldr	r3, [r3, #8]
 8000db0:	9300      	str	r3, [sp, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 8000db2:	4b0b      	ldr	r3, [pc, #44]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000db4:	699b      	ldr	r3, [r3, #24]
 8000db6:	7fdb      	ldrb	r3, [r3, #31]
 8000db8:	2b00      	cmp	r3, #0
 8000dba:	d007      	beq.n	8000dcc <chSchIsPreemptionRequired+0x2c>
 8000dbc:	9a01      	ldr	r2, [sp, #4]
 8000dbe:	9b00      	ldr	r3, [sp, #0]
 8000dc0:	429a      	cmp	r2, r3
 8000dc2:	bf94      	ite	ls
 8000dc4:	2300      	movls	r3, #0
 8000dc6:	2301      	movhi	r3, #1
 8000dc8:	b2db      	uxtb	r3, r3
 8000dca:	e006      	b.n	8000dda <chSchIsPreemptionRequired+0x3a>
 8000dcc:	9a01      	ldr	r2, [sp, #4]
 8000dce:	9b00      	ldr	r3, [sp, #0]
 8000dd0:	429a      	cmp	r2, r3
 8000dd2:	bf34      	ite	cc
 8000dd4:	2300      	movcc	r3, #0
 8000dd6:	2301      	movcs	r3, #1
 8000dd8:	b2db      	uxtb	r3, r3
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
 8000dda:	4618      	mov	r0, r3
 8000ddc:	b002      	add	sp, #8
 8000dde:	4770      	bx	lr
 8000de0:	200039a8 	.word	0x200039a8
 8000de4:	f3af 8000 	nop.w
 8000de8:	f3af 8000 	nop.w
 8000dec:	f3af 8000 	nop.w

08000df0 <chSchDoRescheduleBehind>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 8000df0:	b500      	push	{lr}
 8000df2:	b083      	sub	sp, #12
  thread_t *otp;

  otp = currp;
 8000df4:	4b0d      	ldr	r3, [pc, #52]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000df6:	699b      	ldr	r3, [r3, #24]
 8000df8:	9301      	str	r3, [sp, #4]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000dfa:	480c      	ldr	r0, [pc, #48]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000dfc:	f7ff fe58 	bl	8000ab0 <queue_fifo_remove>
 8000e00:	4602      	mov	r2, r0
 8000e02:	4b0a      	ldr	r3, [pc, #40]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e04:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e06:	4b09      	ldr	r3, [pc, #36]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e08:	699b      	ldr	r3, [r3, #24]
 8000e0a:	2201      	movs	r2, #1
 8000e0c:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8000e0e:	9b01      	ldr	r3, [sp, #4]
 8000e10:	220a      	movs	r2, #10
 8000e12:	77da      	strb	r2, [r3, #31]
#endif
  (void) chSchReadyI(otp);
 8000e14:	9801      	ldr	r0, [sp, #4]
 8000e16:	f7ff fec3 	bl	8000ba0 <chSchReadyI>
  chSysSwitch(currp, otp);
 8000e1a:	4b04      	ldr	r3, [pc, #16]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e1c:	699b      	ldr	r3, [r3, #24]
 8000e1e:	4618      	mov	r0, r3
 8000e20:	9901      	ldr	r1, [sp, #4]
 8000e22:	f7ff fa5d 	bl	80002e0 <_port_switch>
}
 8000e26:	b003      	add	sp, #12
 8000e28:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e2c:	200039a8 	.word	0x200039a8

08000e30 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000e30:	b500      	push	{lr}
 8000e32:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8000e34:	4b18      	ldr	r3, [pc, #96]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e36:	699b      	ldr	r3, [r3, #24]
 8000e38:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000e3a:	4817      	ldr	r0, [pc, #92]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e3c:	f7ff fe38 	bl	8000ab0 <queue_fifo_remove>
 8000e40:	4602      	mov	r2, r0
 8000e42:	4b15      	ldr	r3, [pc, #84]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e44:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e46:	4b14      	ldr	r3, [pc, #80]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e48:	699b      	ldr	r3, [r3, #24]
 8000e4a:	2201      	movs	r2, #1
 8000e4c:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 8000e4e:	9b00      	ldr	r3, [sp, #0]
 8000e50:	2200      	movs	r2, #0
 8000e52:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000e54:	4b10      	ldr	r3, [pc, #64]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e56:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 8000e58:	9b01      	ldr	r3, [sp, #4]
 8000e5a:	681b      	ldr	r3, [r3, #0]
 8000e5c:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 8000e5e:	9b01      	ldr	r3, [sp, #4]
 8000e60:	689a      	ldr	r2, [r3, #8]
 8000e62:	9b00      	ldr	r3, [sp, #0]
 8000e64:	689b      	ldr	r3, [r3, #8]
 8000e66:	429a      	cmp	r2, r3
 8000e68:	d8f6      	bhi.n	8000e58 <chSchDoRescheduleAhead+0x28>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000e6a:	9b00      	ldr	r3, [sp, #0]
 8000e6c:	9a01      	ldr	r2, [sp, #4]
 8000e6e:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8000e70:	9b01      	ldr	r3, [sp, #4]
 8000e72:	685a      	ldr	r2, [r3, #4]
 8000e74:	9b00      	ldr	r3, [sp, #0]
 8000e76:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8000e78:	9b00      	ldr	r3, [sp, #0]
 8000e7a:	685b      	ldr	r3, [r3, #4]
 8000e7c:	9a00      	ldr	r2, [sp, #0]
 8000e7e:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8000e80:	9b01      	ldr	r3, [sp, #4]
 8000e82:	9a00      	ldr	r2, [sp, #0]
 8000e84:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8000e86:	4b04      	ldr	r3, [pc, #16]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e88:	699b      	ldr	r3, [r3, #24]
 8000e8a:	4618      	mov	r0, r3
 8000e8c:	9900      	ldr	r1, [sp, #0]
 8000e8e:	f7ff fa27 	bl	80002e0 <_port_switch>
}
 8000e92:	b003      	add	sp, #12
 8000e94:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e98:	200039a8 	.word	0x200039a8
 8000e9c:	f3af 8000 	nop.w

08000ea0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8000ea0:	b508      	push	{r3, lr}

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
 8000ea2:	4b05      	ldr	r3, [pc, #20]	; (8000eb8 <chSchDoReschedule+0x18>)
 8000ea4:	699b      	ldr	r3, [r3, #24]
 8000ea6:	7fdb      	ldrb	r3, [r3, #31]
 8000ea8:	2b00      	cmp	r3, #0
 8000eaa:	d102      	bne.n	8000eb2 <chSchDoReschedule+0x12>
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 8000eac:	f7ff ffa0 	bl	8000df0 <chSchDoRescheduleBehind>
 8000eb0:	e001      	b.n	8000eb6 <chSchDoReschedule+0x16>
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 8000eb2:	f7ff ffbd 	bl	8000e30 <chSchDoRescheduleAhead>
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8000eb6:	bd08      	pop	{r3, pc}
 8000eb8:	200039a8 	.word	0x200039a8
 8000ebc:	f3af 8000 	nop.w

08000ec0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000ec0:	b082      	sub	sp, #8
 8000ec2:	2320      	movs	r3, #32
 8000ec4:	9301      	str	r3, [sp, #4]
 8000ec6:	9b01      	ldr	r3, [sp, #4]
 8000ec8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000ecc:	b002      	add	sp, #8
 8000ece:	4770      	bx	lr

08000ed0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000ed0:	b082      	sub	sp, #8
 8000ed2:	2300      	movs	r3, #0
 8000ed4:	9301      	str	r3, [sp, #4]
 8000ed6:	9b01      	ldr	r3, [sp, #4]
 8000ed8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000edc:	b002      	add	sp, #8
 8000ede:	4770      	bx	lr

08000ee0 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8000ee0:	b082      	sub	sp, #8
 8000ee2:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8000ee4:	9b01      	ldr	r3, [sp, #4]
 8000ee6:	9a01      	ldr	r2, [sp, #4]
 8000ee8:	601a      	str	r2, [r3, #0]
}
 8000eea:	b002      	add	sp, #8
 8000eec:	4770      	bx	lr
 8000eee:	bf00      	nop

08000ef0 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8000ef0:	b082      	sub	sp, #8
 8000ef2:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000ef4:	9b01      	ldr	r3, [sp, #4]
 8000ef6:	681a      	ldr	r2, [r3, #0]
 8000ef8:	9b01      	ldr	r3, [sp, #4]
 8000efa:	429a      	cmp	r2, r3
 8000efc:	bf0c      	ite	eq
 8000efe:	2300      	moveq	r3, #0
 8000f00:	2301      	movne	r3, #1
 8000f02:	b2db      	uxtb	r3, r3
}
 8000f04:	4618      	mov	r0, r3
 8000f06:	b002      	add	sp, #8
 8000f08:	4770      	bx	lr
 8000f0a:	bf00      	nop
 8000f0c:	f3af 8000 	nop.w

08000f10 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000f10:	b082      	sub	sp, #8
 8000f12:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000f14:	9b01      	ldr	r3, [sp, #4]
 8000f16:	9a01      	ldr	r2, [sp, #4]
 8000f18:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000f1a:	9b01      	ldr	r3, [sp, #4]
 8000f1c:	9a01      	ldr	r2, [sp, #4]
 8000f1e:	605a      	str	r2, [r3, #4]
}
 8000f20:	b002      	add	sp, #8
 8000f22:	4770      	bx	lr
 8000f24:	f3af 8000 	nop.w
 8000f28:	f3af 8000 	nop.w
 8000f2c:	f3af 8000 	nop.w

08000f30 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8000f30:	b082      	sub	sp, #8
 8000f32:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000f34:	9b01      	ldr	r3, [sp, #4]
 8000f36:	681a      	ldr	r2, [r3, #0]
 8000f38:	9b01      	ldr	r3, [sp, #4]
 8000f3a:	429a      	cmp	r2, r3
 8000f3c:	bf0c      	ite	eq
 8000f3e:	2300      	moveq	r3, #0
 8000f40:	2301      	movne	r3, #1
 8000f42:	b2db      	uxtb	r3, r3
}
 8000f44:	4618      	mov	r0, r3
 8000f46:	b002      	add	sp, #8
 8000f48:	4770      	bx	lr
 8000f4a:	bf00      	nop
 8000f4c:	f3af 8000 	nop.w

08000f50 <list_insert>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
 8000f50:	b082      	sub	sp, #8
 8000f52:	9001      	str	r0, [sp, #4]
 8000f54:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
 8000f56:	9b00      	ldr	r3, [sp, #0]
 8000f58:	681a      	ldr	r2, [r3, #0]
 8000f5a:	9b01      	ldr	r3, [sp, #4]
 8000f5c:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 8000f5e:	9b00      	ldr	r3, [sp, #0]
 8000f60:	9a01      	ldr	r2, [sp, #4]
 8000f62:	601a      	str	r2, [r3, #0]
}
 8000f64:	b002      	add	sp, #8
 8000f66:	4770      	bx	lr
 8000f68:	f3af 8000 	nop.w
 8000f6c:	f3af 8000 	nop.w

08000f70 <list_remove>:

static inline thread_t *list_remove(threads_list_t *tlp) {
 8000f70:	b084      	sub	sp, #16
 8000f72:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8000f74:	9b01      	ldr	r3, [sp, #4]
 8000f76:	681b      	ldr	r3, [r3, #0]
 8000f78:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8000f7a:	9b03      	ldr	r3, [sp, #12]
 8000f7c:	681a      	ldr	r2, [r3, #0]
 8000f7e:	9b01      	ldr	r3, [sp, #4]
 8000f80:	601a      	str	r2, [r3, #0]

  return tp;
 8000f82:	9b03      	ldr	r3, [sp, #12]
}
 8000f84:	4618      	mov	r0, r3
 8000f86:	b004      	add	sp, #16
 8000f88:	4770      	bx	lr
 8000f8a:	bf00      	nop
 8000f8c:	f3af 8000 	nop.w

08000f90 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8000f90:	b082      	sub	sp, #8
 8000f92:	9001      	str	r0, [sp, #4]
 8000f94:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8000f96:	9b01      	ldr	r3, [sp, #4]
 8000f98:	9a00      	ldr	r2, [sp, #0]
 8000f9a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8000f9c:	9b00      	ldr	r3, [sp, #0]
 8000f9e:	685a      	ldr	r2, [r3, #4]
 8000fa0:	9b01      	ldr	r3, [sp, #4]
 8000fa2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000fa4:	9b01      	ldr	r3, [sp, #4]
 8000fa6:	685b      	ldr	r3, [r3, #4]
 8000fa8:	9a01      	ldr	r2, [sp, #4]
 8000faa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8000fac:	9b00      	ldr	r3, [sp, #0]
 8000fae:	9a01      	ldr	r2, [sp, #4]
 8000fb0:	605a      	str	r2, [r3, #4]
}
 8000fb2:	b002      	add	sp, #8
 8000fb4:	4770      	bx	lr
 8000fb6:	bf00      	nop
 8000fb8:	f3af 8000 	nop.w
 8000fbc:	f3af 8000 	nop.w

08000fc0 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000fc0:	b084      	sub	sp, #16
 8000fc2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000fc4:	9b01      	ldr	r3, [sp, #4]
 8000fc6:	681b      	ldr	r3, [r3, #0]
 8000fc8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000fca:	9b03      	ldr	r3, [sp, #12]
 8000fcc:	681a      	ldr	r2, [r3, #0]
 8000fce:	9b01      	ldr	r3, [sp, #4]
 8000fd0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000fd2:	9b01      	ldr	r3, [sp, #4]
 8000fd4:	681b      	ldr	r3, [r3, #0]
 8000fd6:	9a01      	ldr	r2, [sp, #4]
 8000fd8:	605a      	str	r2, [r3, #4]

  return tp;
 8000fda:	9b03      	ldr	r3, [sp, #12]
}
 8000fdc:	4618      	mov	r0, r3
 8000fde:	b004      	add	sp, #16
 8000fe0:	4770      	bx	lr
 8000fe2:	bf00      	nop
 8000fe4:	f3af 8000 	nop.w
 8000fe8:	f3af 8000 	nop.w
 8000fec:	f3af 8000 	nop.w

08000ff0 <chSchCanYieldS>:
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8000ff0:	4b06      	ldr	r3, [pc, #24]	; (800100c <chSchCanYieldS+0x1c>)
 8000ff2:	681b      	ldr	r3, [r3, #0]
 8000ff4:	689a      	ldr	r2, [r3, #8]
 8000ff6:	4b05      	ldr	r3, [pc, #20]	; (800100c <chSchCanYieldS+0x1c>)
 8000ff8:	699b      	ldr	r3, [r3, #24]
 8000ffa:	689b      	ldr	r3, [r3, #8]
 8000ffc:	429a      	cmp	r2, r3
 8000ffe:	bf34      	ite	cc
 8001000:	2300      	movcc	r3, #0
 8001002:	2301      	movcs	r3, #1
 8001004:	b2db      	uxtb	r3, r3
}
 8001006:	4618      	mov	r0, r3
 8001008:	4770      	bx	lr
 800100a:	bf00      	nop
 800100c:	200039a8 	.word	0x200039a8

08001010 <chSchDoYieldS>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {
 8001010:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8001012:	f7ff ffed 	bl	8000ff0 <chSchCanYieldS>
 8001016:	4603      	mov	r3, r0
 8001018:	2b00      	cmp	r3, #0
 800101a:	d001      	beq.n	8001020 <chSchDoYieldS+0x10>
    chSchDoRescheduleBehind();
 800101c:	f7ff fee8 	bl	8000df0 <chSchDoRescheduleBehind>
  }
}
 8001020:	bd08      	pop	{r3, pc}
 8001022:	bf00      	nop
 8001024:	f3af 8000 	nop.w
 8001028:	f3af 8000 	nop.w
 800102c:	f3af 8000 	nop.w

08001030 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001030:	b508      	push	{r3, lr}

  port_lock();
 8001032:	f7ff ff45 	bl	8000ec0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001036:	bd08      	pop	{r3, pc}
 8001038:	f3af 8000 	nop.w
 800103c:	f3af 8000 	nop.w

08001040 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001040:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001042:	f7ff ff45 	bl	8000ed0 <port_unlock>
}
 8001046:	bd08      	pop	{r3, pc}
 8001048:	f3af 8000 	nop.w
 800104c:	f3af 8000 	nop.w

08001050 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8001050:	4b01      	ldr	r3, [pc, #4]	; (8001058 <chVTGetSystemTimeX+0x8>)
 8001052:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001054:	4618      	mov	r0, r3
 8001056:	4770      	bx	lr
 8001058:	200039a8 	.word	0x200039a8
 800105c:	f3af 8000 	nop.w

08001060 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8001060:	b084      	sub	sp, #16
 8001062:	9003      	str	r0, [sp, #12]
 8001064:	9102      	str	r1, [sp, #8]
 8001066:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8001068:	9a03      	ldr	r2, [sp, #12]
 800106a:	9b02      	ldr	r3, [sp, #8]
 800106c:	1ad2      	subs	r2, r2, r3
 800106e:	9901      	ldr	r1, [sp, #4]
 8001070:	9b02      	ldr	r3, [sp, #8]
 8001072:	1acb      	subs	r3, r1, r3
 8001074:	429a      	cmp	r2, r3
 8001076:	bf2c      	ite	cs
 8001078:	2300      	movcs	r3, #0
 800107a:	2301      	movcc	r3, #1
 800107c:	b2db      	uxtb	r3, r3
}
 800107e:	4618      	mov	r0, r3
 8001080:	b004      	add	sp, #16
 8001082:	4770      	bx	lr
 8001084:	f3af 8000 	nop.w
 8001088:	f3af 8000 	nop.w
 800108c:	f3af 8000 	nop.w

08001090 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001090:	4b01      	ldr	r3, [pc, #4]	; (8001098 <chThdGetSelfX+0x8>)
 8001092:	699b      	ldr	r3, [r3, #24]
}
 8001094:	4618      	mov	r0, r3
 8001096:	4770      	bx	lr
 8001098:	200039a8 	.word	0x200039a8
 800109c:	f3af 8000 	nop.w

080010a0 <chThdStartI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 80010a0:	b500      	push	{lr}
 80010a2:	b083      	sub	sp, #12
 80010a4:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 80010a6:	9801      	ldr	r0, [sp, #4]
 80010a8:	f7ff fd7a 	bl	8000ba0 <chSchReadyI>
 80010ac:	4603      	mov	r3, r0
}
 80010ae:	4618      	mov	r0, r3
 80010b0:	b003      	add	sp, #12
 80010b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80010b6:	bf00      	nop
 80010b8:	f3af 8000 	nop.w
 80010bc:	f3af 8000 	nop.w

080010c0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 80010c0:	b500      	push	{lr}
 80010c2:	b083      	sub	sp, #12
 80010c4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80010c6:	2008      	movs	r0, #8
 80010c8:	9901      	ldr	r1, [sp, #4]
 80010ca:	f7ff fdf9 	bl	8000cc0 <chSchGoSleepTimeoutS>
}
 80010ce:	b003      	add	sp, #12
 80010d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80010d4:	f3af 8000 	nop.w
 80010d8:	f3af 8000 	nop.w
 80010dc:	f3af 8000 	nop.w

080010e0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80010e0:	b500      	push	{lr}
 80010e2:	b085      	sub	sp, #20
 80010e4:	9001      	str	r0, [sp, #4]
 80010e6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 80010e8:	9801      	ldr	r0, [sp, #4]
 80010ea:	f7ff ff69 	bl	8000fc0 <queue_fifo_remove>
 80010ee:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80010f0:	9b03      	ldr	r3, [sp, #12]
 80010f2:	9a00      	ldr	r2, [sp, #0]
 80010f4:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 80010f6:	9803      	ldr	r0, [sp, #12]
 80010f8:	f7ff fd52 	bl	8000ba0 <chSchReadyI>
}
 80010fc:	b005      	add	sp, #20
 80010fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001102:	bf00      	nop
 8001104:	f3af 8000 	nop.w
 8001108:	f3af 8000 	nop.w
 800110c:	f3af 8000 	nop.w

08001110 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8001110:	b500      	push	{lr}
 8001112:	b083      	sub	sp, #12
 8001114:	9001      	str	r0, [sp, #4]
 8001116:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8001118:	9b01      	ldr	r3, [sp, #4]
 800111a:	9a00      	ldr	r2, [sp, #0]
 800111c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 800111e:	9b01      	ldr	r3, [sp, #4]
 8001120:	2202      	movs	r2, #2
 8001122:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001124:	9b01      	ldr	r3, [sp, #4]
 8001126:	2200      	movs	r2, #0
 8001128:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800112a:	9b01      	ldr	r3, [sp, #4]
 800112c:	220a      	movs	r2, #10
 800112e:	77da      	strb	r2, [r3, #31]
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001130:	9b01      	ldr	r3, [sp, #4]
 8001132:	9a00      	ldr	r2, [sp, #0]
 8001134:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8001136:	9b01      	ldr	r3, [sp, #4]
 8001138:	2200      	movs	r2, #0
 800113a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800113c:	9b01      	ldr	r3, [sp, #4]
 800113e:	2200      	movs	r2, #0
 8001140:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001142:	9b01      	ldr	r3, [sp, #4]
 8001144:	2201      	movs	r2, #1
 8001146:	779a      	strb	r2, [r3, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8001148:	9b01      	ldr	r3, [sp, #4]
 800114a:	2200      	movs	r2, #0
 800114c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800114e:	9b01      	ldr	r3, [sp, #4]
 8001150:	4a0d      	ldr	r2, [pc, #52]	; (8001188 <_thread_init+0x78>)
 8001152:	611a      	str	r2, [r3, #16]
 8001154:	4b0c      	ldr	r3, [pc, #48]	; (8001188 <_thread_init+0x78>)
 8001156:	695a      	ldr	r2, [r3, #20]
 8001158:	9b01      	ldr	r3, [sp, #4]
 800115a:	615a      	str	r2, [r3, #20]
 800115c:	9b01      	ldr	r3, [sp, #4]
 800115e:	695b      	ldr	r3, [r3, #20]
 8001160:	9a01      	ldr	r2, [sp, #4]
 8001162:	611a      	str	r2, [r3, #16]
 8001164:	4b08      	ldr	r3, [pc, #32]	; (8001188 <_thread_init+0x78>)
 8001166:	9a01      	ldr	r2, [sp, #4]
 8001168:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800116a:	9b01      	ldr	r3, [sp, #4]
 800116c:	3324      	adds	r3, #36	; 0x24
 800116e:	4618      	mov	r0, r3
 8001170:	f7ff feb6 	bl	8000ee0 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001174:	9b01      	ldr	r3, [sp, #4]
 8001176:	3328      	adds	r3, #40	; 0x28
 8001178:	4618      	mov	r0, r3
 800117a:	f7ff fec9 	bl	8000f10 <queue_init>
  chTMObjectInit(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 800117e:	9b01      	ldr	r3, [sp, #4]
}
 8001180:	4618      	mov	r0, r3
 8001182:	b003      	add	sp, #12
 8001184:	f85d fb04 	ldr.w	pc, [sp], #4
 8001188:	200039a8 	.word	0x200039a8
 800118c:	f3af 8000 	nop.w

08001190 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8001190:	b500      	push	{lr}
 8001192:	b087      	sub	sp, #28
 8001194:	9003      	str	r0, [sp, #12]
 8001196:	9102      	str	r1, [sp, #8]
 8001198:	9201      	str	r2, [sp, #4]
 800119a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 800119c:	9b03      	ldr	r3, [sp, #12]
 800119e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80011a0:	9b02      	ldr	r3, [sp, #8]
 80011a2:	3b24      	subs	r3, #36	; 0x24
 80011a4:	9a03      	ldr	r2, [sp, #12]
 80011a6:	441a      	add	r2, r3
 80011a8:	9b05      	ldr	r3, [sp, #20]
 80011aa:	60da      	str	r2, [r3, #12]
 80011ac:	9b05      	ldr	r3, [sp, #20]
 80011ae:	68db      	ldr	r3, [r3, #12]
 80011b0:	9a00      	ldr	r2, [sp, #0]
 80011b2:	601a      	str	r2, [r3, #0]
 80011b4:	9b05      	ldr	r3, [sp, #20]
 80011b6:	68db      	ldr	r3, [r3, #12]
 80011b8:	9a08      	ldr	r2, [sp, #32]
 80011ba:	605a      	str	r2, [r3, #4]
 80011bc:	9b05      	ldr	r3, [sp, #20]
 80011be:	68db      	ldr	r3, [r3, #12]
 80011c0:	4a05      	ldr	r2, [pc, #20]	; (80011d8 <chThdCreateI+0x48>)
 80011c2:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 80011c4:	9805      	ldr	r0, [sp, #20]
 80011c6:	9901      	ldr	r1, [sp, #4]
 80011c8:	f7ff ffa2 	bl	8001110 <_thread_init>
 80011cc:	4603      	mov	r3, r0
}
 80011ce:	4618      	mov	r0, r3
 80011d0:	b007      	add	sp, #28
 80011d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80011d6:	bf00      	nop
 80011d8:	080002f1 	.word	0x080002f1
 80011dc:	f3af 8000 	nop.w

080011e0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80011e0:	b500      	push	{lr}
 80011e2:	b089      	sub	sp, #36	; 0x24
 80011e4:	9005      	str	r0, [sp, #20]
 80011e6:	9104      	str	r1, [sp, #16]
 80011e8:	9203      	str	r2, [sp, #12]
 80011ea:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80011ec:	f7ff ff20 	bl	8001030 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80011f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80011f2:	9300      	str	r3, [sp, #0]
 80011f4:	9805      	ldr	r0, [sp, #20]
 80011f6:	9904      	ldr	r1, [sp, #16]
 80011f8:	9a03      	ldr	r2, [sp, #12]
 80011fa:	9b02      	ldr	r3, [sp, #8]
 80011fc:	f7ff ffc8 	bl	8001190 <chThdCreateI>
 8001200:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8001202:	9807      	ldr	r0, [sp, #28]
 8001204:	2100      	movs	r1, #0
 8001206:	f7ff fd93 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 800120a:	f7ff ff19 	bl	8001040 <chSysUnlock>

  return tp;
 800120e:	9b07      	ldr	r3, [sp, #28]
}
 8001210:	4618      	mov	r0, r3
 8001212:	b009      	add	sp, #36	; 0x24
 8001214:	f85d fb04 	ldr.w	pc, [sp], #4
 8001218:	f3af 8000 	nop.w
 800121c:	f3af 8000 	nop.w

08001220 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 8001220:	b500      	push	{lr}
 8001222:	b083      	sub	sp, #12
 8001224:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001226:	f7ff ff03 	bl	8001030 <chSysLock>
  tp = chThdStartI(tp);
 800122a:	9801      	ldr	r0, [sp, #4]
 800122c:	f7ff ff38 	bl	80010a0 <chThdStartI>
 8001230:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8001232:	f7ff ff05 	bl	8001040 <chSysUnlock>

  return tp;
 8001236:	9b01      	ldr	r3, [sp, #4]
}
 8001238:	4618      	mov	r0, r3
 800123a:	b003      	add	sp, #12
 800123c:	f85d fb04 	ldr.w	pc, [sp], #4

08001240 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001240:	b500      	push	{lr}
 8001242:	b085      	sub	sp, #20
 8001244:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
 8001246:	f7ff fef3 	bl	8001030 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 800124a:	4b11      	ldr	r3, [pc, #68]	; (8001290 <chThdSetPriority+0x50>)
 800124c:	699b      	ldr	r3, [r3, #24]
 800124e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001250:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 8001252:	4b0f      	ldr	r3, [pc, #60]	; (8001290 <chThdSetPriority+0x50>)
 8001254:	699b      	ldr	r3, [r3, #24]
 8001256:	689a      	ldr	r2, [r3, #8]
 8001258:	4b0d      	ldr	r3, [pc, #52]	; (8001290 <chThdSetPriority+0x50>)
 800125a:	699b      	ldr	r3, [r3, #24]
 800125c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800125e:	429a      	cmp	r2, r3
 8001260:	d005      	beq.n	800126e <chThdSetPriority+0x2e>
 8001262:	4b0b      	ldr	r3, [pc, #44]	; (8001290 <chThdSetPriority+0x50>)
 8001264:	699b      	ldr	r3, [r3, #24]
 8001266:	689a      	ldr	r2, [r3, #8]
 8001268:	9b01      	ldr	r3, [sp, #4]
 800126a:	429a      	cmp	r2, r3
 800126c:	d203      	bcs.n	8001276 <chThdSetPriority+0x36>
    currp->p_prio = newprio;
 800126e:	4b08      	ldr	r3, [pc, #32]	; (8001290 <chThdSetPriority+0x50>)
 8001270:	699b      	ldr	r3, [r3, #24]
 8001272:	9a01      	ldr	r2, [sp, #4]
 8001274:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
 8001276:	4b06      	ldr	r3, [pc, #24]	; (8001290 <chThdSetPriority+0x50>)
 8001278:	699b      	ldr	r3, [r3, #24]
 800127a:	9a01      	ldr	r2, [sp, #4]
 800127c:	63da      	str	r2, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 800127e:	f7ff fd7f 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8001282:	f7ff fedd 	bl	8001040 <chSysUnlock>

  return oldprio;
 8001286:	9b03      	ldr	r3, [sp, #12]
}
 8001288:	4618      	mov	r0, r3
 800128a:	b005      	add	sp, #20
 800128c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001290:	200039a8 	.word	0x200039a8
 8001294:	f3af 8000 	nop.w
 8001298:	f3af 8000 	nop.w
 800129c:	f3af 8000 	nop.w

080012a0 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(thread_t *tp) {
 80012a0:	b500      	push	{lr}
 80012a2:	b083      	sub	sp, #12
 80012a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012a6:	f7ff fec3 	bl	8001030 <chSysLock>
  tp->p_flags |= CH_FLAG_TERMINATE;
 80012aa:	9b01      	ldr	r3, [sp, #4]
 80012ac:	7f5b      	ldrb	r3, [r3, #29]
 80012ae:	f043 0304 	orr.w	r3, r3, #4
 80012b2:	b2da      	uxtb	r2, r3
 80012b4:	9b01      	ldr	r3, [sp, #4]
 80012b6:	775a      	strb	r2, [r3, #29]
  chSysUnlock();
 80012b8:	f7ff fec2 	bl	8001040 <chSysUnlock>
}
 80012bc:	b003      	add	sp, #12
 80012be:	f85d fb04 	ldr.w	pc, [sp], #4
 80012c2:	bf00      	nop
 80012c4:	f3af 8000 	nop.w
 80012c8:	f3af 8000 	nop.w
 80012cc:	f3af 8000 	nop.w

080012d0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80012d0:	b500      	push	{lr}
 80012d2:	b083      	sub	sp, #12
 80012d4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012d6:	f7ff feab 	bl	8001030 <chSysLock>
  chThdSleepS(time);
 80012da:	9801      	ldr	r0, [sp, #4]
 80012dc:	f7ff fef0 	bl	80010c0 <chThdSleepS>
  chSysUnlock();
 80012e0:	f7ff feae 	bl	8001040 <chSysUnlock>
}
 80012e4:	b003      	add	sp, #12
 80012e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80012ea:	bf00      	nop
 80012ec:	f3af 8000 	nop.w

080012f0 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 80012f0:	b500      	push	{lr}
 80012f2:	b083      	sub	sp, #12
 80012f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012f6:	f7ff fe9b 	bl	8001030 <chSysLock>
  time -= chVTGetSystemTimeX();
 80012fa:	f7ff fea9 	bl	8001050 <chVTGetSystemTimeX>
 80012fe:	4603      	mov	r3, r0
 8001300:	9a01      	ldr	r2, [sp, #4]
 8001302:	1ad3      	subs	r3, r2, r3
 8001304:	9301      	str	r3, [sp, #4]
  if (time > (systime_t)0) {
 8001306:	9b01      	ldr	r3, [sp, #4]
 8001308:	2b00      	cmp	r3, #0
 800130a:	d002      	beq.n	8001312 <chThdSleepUntil+0x22>
    chThdSleepS(time);
 800130c:	9801      	ldr	r0, [sp, #4]
 800130e:	f7ff fed7 	bl	80010c0 <chThdSleepS>
  }
  chSysUnlock();
 8001312:	f7ff fe95 	bl	8001040 <chSysUnlock>
}
 8001316:	b003      	add	sp, #12
 8001318:	f85d fb04 	ldr.w	pc, [sp], #4
 800131c:	f3af 8000 	nop.w

08001320 <chThdSleepUntilWindowed>:
 * @param[in] next      absolute system time of the next deadline
 * @return				the @p next parameter
 *
 * @api
 */
systime_t chThdSleepUntilWindowed(systime_t prev, systime_t next) {
 8001320:	b500      	push	{lr}
 8001322:	b085      	sub	sp, #20
 8001324:	9001      	str	r0, [sp, #4]
 8001326:	9100      	str	r1, [sp, #0]
  systime_t time;

  chSysLock();
 8001328:	f7ff fe82 	bl	8001030 <chSysLock>
  time = chVTGetSystemTimeX();
 800132c:	f7ff fe90 	bl	8001050 <chVTGetSystemTimeX>
 8001330:	9003      	str	r0, [sp, #12]
  if (chVTIsTimeWithinX(time, prev, next)) {
 8001332:	9803      	ldr	r0, [sp, #12]
 8001334:	9901      	ldr	r1, [sp, #4]
 8001336:	9a00      	ldr	r2, [sp, #0]
 8001338:	f7ff fe92 	bl	8001060 <chVTIsTimeWithinX>
 800133c:	4603      	mov	r3, r0
 800133e:	2b00      	cmp	r3, #0
 8001340:	d005      	beq.n	800134e <chThdSleepUntilWindowed+0x2e>
	chThdSleepS(next - time);
 8001342:	9a00      	ldr	r2, [sp, #0]
 8001344:	9b03      	ldr	r3, [sp, #12]
 8001346:	1ad3      	subs	r3, r2, r3
 8001348:	4618      	mov	r0, r3
 800134a:	f7ff feb9 	bl	80010c0 <chThdSleepS>
  }
  chSysUnlock();
 800134e:	f7ff fe77 	bl	8001040 <chSysUnlock>

  return next;
 8001352:	9b00      	ldr	r3, [sp, #0]
}
 8001354:	4618      	mov	r0, r3
 8001356:	b005      	add	sp, #20
 8001358:	f85d fb04 	ldr.w	pc, [sp], #4
 800135c:	f3af 8000 	nop.w

08001360 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8001360:	b508      	push	{r3, lr}

  chSysLock();
 8001362:	f7ff fe65 	bl	8001030 <chSysLock>
  chSchDoYieldS();
 8001366:	f7ff fe53 	bl	8001010 <chSchDoYieldS>
  chSysUnlock();
 800136a:	f7ff fe69 	bl	8001040 <chSysUnlock>
}
 800136e:	bd08      	pop	{r3, pc}

08001370 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001370:	b500      	push	{lr}
 8001372:	b083      	sub	sp, #12
 8001374:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001376:	f7ff fe5b 	bl	8001030 <chSysLock>
  chThdExitS(msg);
 800137a:	9801      	ldr	r0, [sp, #4]
 800137c:	f000 f808 	bl	8001390 <chThdExitS>
  /* The thread never returns here.*/
}
 8001380:	b003      	add	sp, #12
 8001382:	f85d fb04 	ldr.w	pc, [sp], #4
 8001386:	bf00      	nop
 8001388:	f3af 8000 	nop.w
 800138c:	f3af 8000 	nop.w

08001390 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001390:	b500      	push	{lr}
 8001392:	b085      	sub	sp, #20
 8001394:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8001396:	4b17      	ldr	r3, [pc, #92]	; (80013f4 <chThdExitS+0x64>)
 8001398:	699b      	ldr	r3, [r3, #24]
 800139a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 800139c:	9b03      	ldr	r3, [sp, #12]
 800139e:	9a01      	ldr	r2, [sp, #4]
 80013a0:	621a      	str	r2, [r3, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80013a2:	e008      	b.n	80013b6 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80013a4:	9b03      	ldr	r3, [sp, #12]
 80013a6:	3324      	adds	r3, #36	; 0x24
 80013a8:	4618      	mov	r0, r3
 80013aa:	f7ff fde1 	bl	8000f70 <list_remove>
 80013ae:	4603      	mov	r3, r0
 80013b0:	4618      	mov	r0, r3
 80013b2:	f7ff fbf5 	bl	8000ba0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80013b6:	9b03      	ldr	r3, [sp, #12]
 80013b8:	3324      	adds	r3, #36	; 0x24
 80013ba:	4618      	mov	r0, r3
 80013bc:	f7ff fd98 	bl	8000ef0 <list_notempty>
 80013c0:	4603      	mov	r3, r0
 80013c2:	2b00      	cmp	r3, #0
 80013c4:	d1ee      	bne.n	80013a4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80013c6:	9b03      	ldr	r3, [sp, #12]
 80013c8:	7f5b      	ldrb	r3, [r3, #29]
 80013ca:	f003 0303 	and.w	r3, r3, #3
 80013ce:	2b00      	cmp	r3, #0
 80013d0:	d109      	bne.n	80013e6 <chThdExitS+0x56>
    REG_REMOVE(tp);
 80013d2:	9b03      	ldr	r3, [sp, #12]
 80013d4:	695b      	ldr	r3, [r3, #20]
 80013d6:	9a03      	ldr	r2, [sp, #12]
 80013d8:	6912      	ldr	r2, [r2, #16]
 80013da:	611a      	str	r2, [r3, #16]
 80013dc:	9b03      	ldr	r3, [sp, #12]
 80013de:	691b      	ldr	r3, [r3, #16]
 80013e0:	9a03      	ldr	r2, [sp, #12]
 80013e2:	6952      	ldr	r2, [r2, #20]
 80013e4:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80013e6:	200f      	movs	r0, #15
 80013e8:	f7ff fc02 	bl	8000bf0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 80013ec:	b005      	add	sp, #20
 80013ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80013f2:	bf00      	nop
 80013f4:	200039a8 	.word	0x200039a8
 80013f8:	f3af 8000 	nop.w
 80013fc:	f3af 8000 	nop.w

08001400 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001400:	b500      	push	{lr}
 8001402:	b085      	sub	sp, #20
 8001404:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);

  chSysLock();
 8001406:	f7ff fe13 	bl	8001030 <chSysLock>
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 800140a:	9b01      	ldr	r3, [sp, #4]
 800140c:	7f1b      	ldrb	r3, [r3, #28]
 800140e:	2b0f      	cmp	r3, #15
 8001410:	d00a      	beq.n	8001428 <chThdWait+0x28>
    list_insert(currp, &tp->p_waiting);
 8001412:	4b0c      	ldr	r3, [pc, #48]	; (8001444 <chThdWait+0x44>)
 8001414:	699a      	ldr	r2, [r3, #24]
 8001416:	9b01      	ldr	r3, [sp, #4]
 8001418:	3324      	adds	r3, #36	; 0x24
 800141a:	4610      	mov	r0, r2
 800141c:	4619      	mov	r1, r3
 800141e:	f7ff fd97 	bl	8000f50 <list_insert>
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001422:	2009      	movs	r0, #9
 8001424:	f7ff fbe4 	bl	8000bf0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 8001428:	9b01      	ldr	r3, [sp, #4]
 800142a:	6a1b      	ldr	r3, [r3, #32]
 800142c:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 800142e:	f7ff fe07 	bl	8001040 <chSysUnlock>

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 8001432:	9801      	ldr	r0, [sp, #4]
 8001434:	f000 f9c4 	bl	80017c0 <chThdRelease>
#endif

  return msg;
 8001438:	9b03      	ldr	r3, [sp, #12]
}
 800143a:	4618      	mov	r0, r3
 800143c:	b005      	add	sp, #20
 800143e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001442:	bf00      	nop
 8001444:	200039a8 	.word	0x200039a8
 8001448:	f3af 8000 	nop.w
 800144c:	f3af 8000 	nop.w

08001450 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 8001450:	b500      	push	{lr}
 8001452:	b085      	sub	sp, #20
 8001454:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 8001456:	f7ff fe1b 	bl	8001090 <chThdGetSelfX>
 800145a:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 800145c:	9b01      	ldr	r3, [sp, #4]
 800145e:	9a03      	ldr	r2, [sp, #12]
 8001460:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 8001462:	9b03      	ldr	r3, [sp, #12]
 8001464:	9a01      	ldr	r2, [sp, #4]
 8001466:	621a      	str	r2, [r3, #32]
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001468:	2003      	movs	r0, #3
 800146a:	f7ff fbc1 	bl	8000bf0 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 800146e:	f7ff fe0f 	bl	8001090 <chThdGetSelfX>
 8001472:	4603      	mov	r3, r0
 8001474:	6a1b      	ldr	r3, [r3, #32]
}
 8001476:	4618      	mov	r0, r3
 8001478:	b005      	add	sp, #20
 800147a:	f85d fb04 	ldr.w	pc, [sp], #4
 800147e:	bf00      	nop

08001480 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 8001480:	b500      	push	{lr}
 8001482:	b085      	sub	sp, #20
 8001484:	9001      	str	r0, [sp, #4]
 8001486:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8001488:	f7ff fe02 	bl	8001090 <chThdGetSelfX>
 800148c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  if (TIME_IMMEDIATE == timeout) {
 800148e:	9b00      	ldr	r3, [sp, #0]
 8001490:	2b00      	cmp	r3, #0
 8001492:	d102      	bne.n	800149a <chThdSuspendTimeoutS+0x1a>
    return MSG_TIMEOUT;
 8001494:	f04f 33ff 	mov.w	r3, #4294967295
 8001498:	e00a      	b.n	80014b0 <chThdSuspendTimeoutS+0x30>
  }

  *trp = tp;
 800149a:	9b01      	ldr	r3, [sp, #4]
 800149c:	9a03      	ldr	r2, [sp, #12]
 800149e:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 80014a0:	9b03      	ldr	r3, [sp, #12]
 80014a2:	9a01      	ldr	r2, [sp, #4]
 80014a4:	621a      	str	r2, [r3, #32]

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80014a6:	2003      	movs	r0, #3
 80014a8:	9900      	ldr	r1, [sp, #0]
 80014aa:	f7ff fc09 	bl	8000cc0 <chSchGoSleepTimeoutS>
 80014ae:	4603      	mov	r3, r0
}
 80014b0:	4618      	mov	r0, r3
 80014b2:	b005      	add	sp, #20
 80014b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80014b8:	f3af 8000 	nop.w
 80014bc:	f3af 8000 	nop.w

080014c0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 80014c0:	b500      	push	{lr}
 80014c2:	b085      	sub	sp, #20
 80014c4:	9001      	str	r0, [sp, #4]
 80014c6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80014c8:	9b01      	ldr	r3, [sp, #4]
 80014ca:	681b      	ldr	r3, [r3, #0]
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d00b      	beq.n	80014e8 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 80014d0:	9b01      	ldr	r3, [sp, #4]
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 80014d6:	9b01      	ldr	r3, [sp, #4]
 80014d8:	2200      	movs	r2, #0
 80014da:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 80014dc:	9b03      	ldr	r3, [sp, #12]
 80014de:	9a00      	ldr	r2, [sp, #0]
 80014e0:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80014e2:	9803      	ldr	r0, [sp, #12]
 80014e4:	f7ff fb5c 	bl	8000ba0 <chSchReadyI>
  }
}
 80014e8:	b005      	add	sp, #20
 80014ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80014ee:	bf00      	nop

080014f0 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 80014f0:	b500      	push	{lr}
 80014f2:	b085      	sub	sp, #20
 80014f4:	9001      	str	r0, [sp, #4]
 80014f6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80014f8:	9b01      	ldr	r3, [sp, #4]
 80014fa:	681b      	ldr	r3, [r3, #0]
 80014fc:	2b00      	cmp	r3, #0
 80014fe:	d009      	beq.n	8001514 <chThdResumeS+0x24>
    thread_t *tp = *trp;
 8001500:	9b01      	ldr	r3, [sp, #4]
 8001502:	681b      	ldr	r3, [r3, #0]
 8001504:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001506:	9b01      	ldr	r3, [sp, #4]
 8001508:	2200      	movs	r2, #0
 800150a:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 800150c:	9803      	ldr	r0, [sp, #12]
 800150e:	9900      	ldr	r1, [sp, #0]
 8001510:	f7ff fc0e 	bl	8000d30 <chSchWakeupS>
  }
}
 8001514:	b005      	add	sp, #20
 8001516:	f85d fb04 	ldr.w	pc, [sp], #4
 800151a:	bf00      	nop
 800151c:	f3af 8000 	nop.w

08001520 <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
 8001520:	b500      	push	{lr}
 8001522:	b083      	sub	sp, #12
 8001524:	9001      	str	r0, [sp, #4]
 8001526:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001528:	f7ff fd82 	bl	8001030 <chSysLock>
  chThdResumeS(trp, msg);
 800152c:	9801      	ldr	r0, [sp, #4]
 800152e:	9900      	ldr	r1, [sp, #0]
 8001530:	f7ff ffde 	bl	80014f0 <chThdResumeS>
  chSysUnlock();
 8001534:	f7ff fd84 	bl	8001040 <chSysUnlock>
}
 8001538:	b003      	add	sp, #12
 800153a:	f85d fb04 	ldr.w	pc, [sp], #4
 800153e:	bf00      	nop

08001540 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001540:	b500      	push	{lr}
 8001542:	b083      	sub	sp, #12
 8001544:	9001      	str	r0, [sp, #4]
 8001546:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8001548:	9b00      	ldr	r3, [sp, #0]
 800154a:	2b00      	cmp	r3, #0
 800154c:	d102      	bne.n	8001554 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 800154e:	f04f 33ff 	mov.w	r3, #4294967295
 8001552:	e00a      	b.n	800156a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 8001554:	4b07      	ldr	r3, [pc, #28]	; (8001574 <chThdEnqueueTimeoutS+0x34>)
 8001556:	699b      	ldr	r3, [r3, #24]
 8001558:	4618      	mov	r0, r3
 800155a:	9901      	ldr	r1, [sp, #4]
 800155c:	f7ff fd18 	bl	8000f90 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001560:	2004      	movs	r0, #4
 8001562:	9900      	ldr	r1, [sp, #0]
 8001564:	f7ff fbac 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8001568:	4603      	mov	r3, r0
}
 800156a:	4618      	mov	r0, r3
 800156c:	b003      	add	sp, #12
 800156e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001572:	bf00      	nop
 8001574:	200039a8 	.word	0x200039a8
 8001578:	f3af 8000 	nop.w
 800157c:	f3af 8000 	nop.w

08001580 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001580:	b500      	push	{lr}
 8001582:	b083      	sub	sp, #12
 8001584:	9001      	str	r0, [sp, #4]
 8001586:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8001588:	9801      	ldr	r0, [sp, #4]
 800158a:	f7ff fcd1 	bl	8000f30 <queue_notempty>
 800158e:	4603      	mov	r3, r0
 8001590:	2b00      	cmp	r3, #0
 8001592:	d003      	beq.n	800159c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8001594:	9801      	ldr	r0, [sp, #4]
 8001596:	9900      	ldr	r1, [sp, #0]
 8001598:	f7ff fda2 	bl	80010e0 <chThdDoDequeueNextI>
  }
}
 800159c:	b003      	add	sp, #12
 800159e:	f85d fb04 	ldr.w	pc, [sp], #4
 80015a2:	bf00      	nop
 80015a4:	f3af 8000 	nop.w
 80015a8:	f3af 8000 	nop.w
 80015ac:	f3af 8000 	nop.w

080015b0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80015b0:	b500      	push	{lr}
 80015b2:	b083      	sub	sp, #12
 80015b4:	9001      	str	r0, [sp, #4]
 80015b6:	9100      	str	r1, [sp, #0]

  while (queue_notempty(tqp)) {
 80015b8:	e003      	b.n	80015c2 <chThdDequeueAllI+0x12>
    chThdDoDequeueNextI(tqp, msg);
 80015ba:	9801      	ldr	r0, [sp, #4]
 80015bc:	9900      	ldr	r1, [sp, #0]
 80015be:	f7ff fd8f 	bl	80010e0 <chThdDoDequeueNextI>
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 80015c2:	9801      	ldr	r0, [sp, #4]
 80015c4:	f7ff fcb4 	bl	8000f30 <queue_notempty>
 80015c8:	4603      	mov	r3, r0
 80015ca:	2b00      	cmp	r3, #0
 80015cc:	d1f5      	bne.n	80015ba <chThdDequeueAllI+0xa>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80015ce:	b003      	add	sp, #12
 80015d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80015d4:	f3af 8000 	nop.w
 80015d8:	f3af 8000 	nop.w
 80015dc:	f3af 8000 	nop.w

080015e0 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80015e0:	4b01      	ldr	r3, [pc, #4]	; (80015e8 <port_rt_get_counter_value+0x8>)
 80015e2:	685b      	ldr	r3, [r3, #4]
}
 80015e4:	4618      	mov	r0, r3
 80015e6:	4770      	bx	lr
 80015e8:	e0001000 	.word	0xe0001000
 80015ec:	f3af 8000 	nop.w

080015f0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 80015f0:	b084      	sub	sp, #16
 80015f2:	9003      	str	r0, [sp, #12]
 80015f4:	9102      	str	r1, [sp, #8]
 80015f6:	9201      	str	r2, [sp, #4]

  tmp->n++;
 80015f8:	9b03      	ldr	r3, [sp, #12]
 80015fa:	68db      	ldr	r3, [r3, #12]
 80015fc:	1c5a      	adds	r2, r3, #1
 80015fe:	9b03      	ldr	r3, [sp, #12]
 8001600:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8001602:	9b03      	ldr	r3, [sp, #12]
 8001604:	689b      	ldr	r3, [r3, #8]
 8001606:	9a02      	ldr	r2, [sp, #8]
 8001608:	1ad2      	subs	r2, r2, r3
 800160a:	9b01      	ldr	r3, [sp, #4]
 800160c:	1ad2      	subs	r2, r2, r3
 800160e:	9b03      	ldr	r3, [sp, #12]
 8001610:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001612:	9b03      	ldr	r3, [sp, #12]
 8001614:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8001618:	9b03      	ldr	r3, [sp, #12]
 800161a:	689b      	ldr	r3, [r3, #8]
 800161c:	461a      	mov	r2, r3
 800161e:	f04f 0300 	mov.w	r3, #0
 8001622:	1812      	adds	r2, r2, r0
 8001624:	eb43 0301 	adc.w	r3, r3, r1
 8001628:	9903      	ldr	r1, [sp, #12]
 800162a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 800162e:	9b03      	ldr	r3, [sp, #12]
 8001630:	689a      	ldr	r2, [r3, #8]
 8001632:	9b03      	ldr	r3, [sp, #12]
 8001634:	685b      	ldr	r3, [r3, #4]
 8001636:	429a      	cmp	r2, r3
 8001638:	d903      	bls.n	8001642 <tm_stop+0x52>
    tmp->worst = tmp->last;
 800163a:	9b03      	ldr	r3, [sp, #12]
 800163c:	689a      	ldr	r2, [r3, #8]
 800163e:	9b03      	ldr	r3, [sp, #12]
 8001640:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8001642:	9b03      	ldr	r3, [sp, #12]
 8001644:	689a      	ldr	r2, [r3, #8]
 8001646:	9b03      	ldr	r3, [sp, #12]
 8001648:	681b      	ldr	r3, [r3, #0]
 800164a:	429a      	cmp	r2, r3
 800164c:	d203      	bcs.n	8001656 <tm_stop+0x66>
    tmp->best = tmp->last;
 800164e:	9b03      	ldr	r3, [sp, #12]
 8001650:	689a      	ldr	r2, [r3, #8]
 8001652:	9b03      	ldr	r3, [sp, #12]
 8001654:	601a      	str	r2, [r3, #0]
  }
}
 8001656:	b004      	add	sp, #16
 8001658:	4770      	bx	lr
 800165a:	bf00      	nop
 800165c:	f3af 8000 	nop.w

08001660 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001660:	b500      	push	{lr}
 8001662:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001664:	4b0a      	ldr	r3, [pc, #40]	; (8001690 <_tm_init+0x30>)
 8001666:	2200      	movs	r2, #0
 8001668:	675a      	str	r2, [r3, #116]	; 0x74
  chTMObjectInit(&tm);
 800166a:	466b      	mov	r3, sp
 800166c:	4618      	mov	r0, r3
 800166e:	f000 f817 	bl	80016a0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8001672:	466b      	mov	r3, sp
 8001674:	4618      	mov	r0, r3
 8001676:	f000 f82b 	bl	80016d0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800167a:	466b      	mov	r3, sp
 800167c:	4618      	mov	r0, r3
 800167e:	f000 f837 	bl	80016f0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8001682:	9a02      	ldr	r2, [sp, #8]
 8001684:	4b02      	ldr	r3, [pc, #8]	; (8001690 <_tm_init+0x30>)
 8001686:	675a      	str	r2, [r3, #116]	; 0x74
}
 8001688:	b007      	add	sp, #28
 800168a:	f85d fb04 	ldr.w	pc, [sp], #4
 800168e:	bf00      	nop
 8001690:	200039a8 	.word	0x200039a8
 8001694:	f3af 8000 	nop.w
 8001698:	f3af 8000 	nop.w
 800169c:	f3af 8000 	nop.w

080016a0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80016a0:	b082      	sub	sp, #8
 80016a2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80016a4:	9b01      	ldr	r3, [sp, #4]
 80016a6:	f04f 32ff 	mov.w	r2, #4294967295
 80016aa:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80016ac:	9b01      	ldr	r3, [sp, #4]
 80016ae:	2200      	movs	r2, #0
 80016b0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80016b2:	9b01      	ldr	r3, [sp, #4]
 80016b4:	2200      	movs	r2, #0
 80016b6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80016b8:	9b01      	ldr	r3, [sp, #4]
 80016ba:	2200      	movs	r2, #0
 80016bc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80016be:	9901      	ldr	r1, [sp, #4]
 80016c0:	f04f 0200 	mov.w	r2, #0
 80016c4:	f04f 0300 	mov.w	r3, #0
 80016c8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 80016cc:	b002      	add	sp, #8
 80016ce:	4770      	bx	lr

080016d0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 80016d0:	b500      	push	{lr}
 80016d2:	b083      	sub	sp, #12
 80016d4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 80016d6:	f7ff ff83 	bl	80015e0 <port_rt_get_counter_value>
 80016da:	4602      	mov	r2, r0
 80016dc:	9b01      	ldr	r3, [sp, #4]
 80016de:	609a      	str	r2, [r3, #8]
}
 80016e0:	b003      	add	sp, #12
 80016e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80016e6:	bf00      	nop
 80016e8:	f3af 8000 	nop.w
 80016ec:	f3af 8000 	nop.w

080016f0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80016f0:	b500      	push	{lr}
 80016f2:	b083      	sub	sp, #12
 80016f4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80016f6:	f7ff ff73 	bl	80015e0 <port_rt_get_counter_value>
 80016fa:	4602      	mov	r2, r0
 80016fc:	4b04      	ldr	r3, [pc, #16]	; (8001710 <chTMStopMeasurementX+0x20>)
 80016fe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001700:	9801      	ldr	r0, [sp, #4]
 8001702:	4611      	mov	r1, r2
 8001704:	461a      	mov	r2, r3
 8001706:	f7ff ff73 	bl	80015f0 <tm_stop>
}
 800170a:	b003      	add	sp, #12
 800170c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001710:	200039a8 	.word	0x200039a8
 8001714:	f3af 8000 	nop.w
 8001718:	f3af 8000 	nop.w
 800171c:	f3af 8000 	nop.w

08001720 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 8001720:	b500      	push	{lr}
 8001722:	b083      	sub	sp, #12
 8001724:	9001      	str	r0, [sp, #4]
 8001726:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 8001728:	f7ff ff5a 	bl	80015e0 <port_rt_get_counter_value>
 800172c:	4602      	mov	r2, r0
 800172e:	9b00      	ldr	r3, [sp, #0]
 8001730:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 8001732:	9b00      	ldr	r3, [sp, #0]
 8001734:	689b      	ldr	r3, [r3, #8]
 8001736:	9801      	ldr	r0, [sp, #4]
 8001738:	4619      	mov	r1, r3
 800173a:	2200      	movs	r2, #0
 800173c:	f7ff ff58 	bl	80015f0 <tm_stop>
}
 8001740:	b003      	add	sp, #12
 8001742:	f85d fb04 	ldr.w	pc, [sp], #4
 8001746:	bf00      	nop
 8001748:	f3af 8000 	nop.w
 800174c:	f3af 8000 	nop.w

08001750 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001750:	b082      	sub	sp, #8
 8001752:	2320      	movs	r3, #32
 8001754:	9301      	str	r3, [sp, #4]
 8001756:	9b01      	ldr	r3, [sp, #4]
 8001758:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800175c:	b002      	add	sp, #8
 800175e:	4770      	bx	lr

08001760 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001760:	b082      	sub	sp, #8
 8001762:	2300      	movs	r3, #0
 8001764:	9301      	str	r3, [sp, #4]
 8001766:	9b01      	ldr	r3, [sp, #4]
 8001768:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800176c:	b002      	add	sp, #8
 800176e:	4770      	bx	lr

08001770 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001770:	b508      	push	{r3, lr}

  port_lock();
 8001772:	f7ff ffed 	bl	8001750 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001776:	bd08      	pop	{r3, pc}
 8001778:	f3af 8000 	nop.w
 800177c:	f3af 8000 	nop.w

08001780 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001780:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001782:	f7ff ffed 	bl	8001760 <port_unlock>
}
 8001786:	bd08      	pop	{r3, pc}
 8001788:	f3af 8000 	nop.w
 800178c:	f3af 8000 	nop.w

08001790 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
thread_t *chThdAddRef(thread_t *tp) {
 8001790:	b500      	push	{lr}
 8001792:	b083      	sub	sp, #12
 8001794:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001796:	f7ff ffeb 	bl	8001770 <chSysLock>
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
  tp->p_refs++;
 800179a:	9b01      	ldr	r3, [sp, #4]
 800179c:	7f9b      	ldrb	r3, [r3, #30]
 800179e:	3301      	adds	r3, #1
 80017a0:	b2da      	uxtb	r2, r3
 80017a2:	9b01      	ldr	r3, [sp, #4]
 80017a4:	779a      	strb	r2, [r3, #30]
  chSysUnlock();
 80017a6:	f7ff ffeb 	bl	8001780 <chSysUnlock>

  return tp;
 80017aa:	9b01      	ldr	r3, [sp, #4]
}
 80017ac:	4618      	mov	r0, r3
 80017ae:	b003      	add	sp, #12
 80017b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80017b4:	f3af 8000 	nop.w
 80017b8:	f3af 8000 	nop.w
 80017bc:	f3af 8000 	nop.w

080017c0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80017c0:	b500      	push	{lr}
 80017c2:	b085      	sub	sp, #20
 80017c4:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
 80017c6:	f7ff ffd3 	bl	8001770 <chSysLock>
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 80017ca:	9b01      	ldr	r3, [sp, #4]
 80017cc:	7f9b      	ldrb	r3, [r3, #30]
 80017ce:	3b01      	subs	r3, #1
 80017d0:	b2da      	uxtb	r2, r3
 80017d2:	9b01      	ldr	r3, [sp, #4]
 80017d4:	779a      	strb	r2, [r3, #30]
  refs = tp->p_refs;
 80017d6:	9b01      	ldr	r3, [sp, #4]
 80017d8:	7f9b      	ldrb	r3, [r3, #30]
 80017da:	f88d 300f 	strb.w	r3, [sp, #15]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 80017de:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80017e2:	2b00      	cmp	r3, #0
 80017e4:	d12f      	bne.n	8001846 <chThdRelease+0x86>
 80017e6:	9b01      	ldr	r3, [sp, #4]
 80017e8:	7f1b      	ldrb	r3, [r3, #28]
 80017ea:	2b0f      	cmp	r3, #15
 80017ec:	d12b      	bne.n	8001846 <chThdRelease+0x86>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 80017ee:	9b01      	ldr	r3, [sp, #4]
 80017f0:	7f5b      	ldrb	r3, [r3, #29]
 80017f2:	f003 0303 	and.w	r3, r3, #3
 80017f6:	2b01      	cmp	r3, #1
 80017f8:	d002      	beq.n	8001800 <chThdRelease+0x40>
 80017fa:	2b02      	cmp	r3, #2
 80017fc:	d010      	beq.n	8001820 <chThdRelease+0x60>
      return;
#endif
    default:
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
 80017fe:	e022      	b.n	8001846 <chThdRelease+0x86>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001800:	9b01      	ldr	r3, [sp, #4]
 8001802:	695b      	ldr	r3, [r3, #20]
 8001804:	9a01      	ldr	r2, [sp, #4]
 8001806:	6912      	ldr	r2, [r2, #16]
 8001808:	611a      	str	r2, [r3, #16]
 800180a:	9b01      	ldr	r3, [sp, #4]
 800180c:	691b      	ldr	r3, [r3, #16]
 800180e:	9a01      	ldr	r2, [sp, #4]
 8001810:	6952      	ldr	r2, [r2, #20]
 8001812:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 8001814:	f7ff ffb4 	bl	8001780 <chSysUnlock>
      chHeapFree(tp);
 8001818:	9801      	ldr	r0, [sp, #4]
 800181a:	f002 f819 	bl	8003850 <chHeapFree>
      return;
 800181e:	e014      	b.n	800184a <chThdRelease+0x8a>
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001820:	9b01      	ldr	r3, [sp, #4]
 8001822:	695b      	ldr	r3, [r3, #20]
 8001824:	9a01      	ldr	r2, [sp, #4]
 8001826:	6912      	ldr	r2, [r2, #16]
 8001828:	611a      	str	r2, [r3, #16]
 800182a:	9b01      	ldr	r3, [sp, #4]
 800182c:	691b      	ldr	r3, [r3, #16]
 800182e:	9a01      	ldr	r2, [sp, #4]
 8001830:	6952      	ldr	r2, [r2, #20]
 8001832:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 8001834:	f7ff ffa4 	bl	8001780 <chSysUnlock>
      chPoolFree(tp->p_mpool, tp);
 8001838:	9b01      	ldr	r3, [sp, #4]
 800183a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800183c:	4618      	mov	r0, r3
 800183e:	9901      	ldr	r1, [sp, #4]
 8001840:	f002 f93e 	bl	8003ac0 <chPoolFree>
      return;
 8001844:	e001      	b.n	800184a <chThdRelease+0x8a>
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
  chSysUnlock();
 8001846:	f7ff ff9b 	bl	8001780 <chSysUnlock>
}
 800184a:	b005      	add	sp, #20
 800184c:	f85d fb04 	ldr.w	pc, [sp], #4

08001850 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 8001850:	b500      	push	{lr}
 8001852:	b089      	sub	sp, #36	; 0x24
 8001854:	9005      	str	r0, [sp, #20]
 8001856:	9104      	str	r1, [sp, #16]
 8001858:	9203      	str	r2, [sp, #12]
 800185a:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 800185c:	9805      	ldr	r0, [sp, #20]
 800185e:	9904      	ldr	r1, [sp, #16]
 8001860:	f001 ff7e 	bl	8003760 <chHeapAlloc>
 8001864:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 8001866:	9b07      	ldr	r3, [sp, #28]
 8001868:	2b00      	cmp	r3, #0
 800186a:	d101      	bne.n	8001870 <chThdCreateFromHeap+0x20>
    return NULL;
 800186c:	2300      	movs	r3, #0
 800186e:	e014      	b.n	800189a <chThdCreateFromHeap+0x4a>
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8001870:	f7ff ff7e 	bl	8001770 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8001874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001876:	9300      	str	r3, [sp, #0]
 8001878:	9807      	ldr	r0, [sp, #28]
 800187a:	9904      	ldr	r1, [sp, #16]
 800187c:	9a03      	ldr	r2, [sp, #12]
 800187e:	9b02      	ldr	r3, [sp, #8]
 8001880:	f7ff fc86 	bl	8001190 <chThdCreateI>
 8001884:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8001886:	9b06      	ldr	r3, [sp, #24]
 8001888:	2201      	movs	r2, #1
 800188a:	775a      	strb	r2, [r3, #29]
  chSchWakeupS(tp, MSG_OK);
 800188c:	9806      	ldr	r0, [sp, #24]
 800188e:	2100      	movs	r1, #0
 8001890:	f7ff fa4e 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 8001894:	f7ff ff74 	bl	8001780 <chSysUnlock>

  return tp;
 8001898:	9b06      	ldr	r3, [sp, #24]
}
 800189a:	4618      	mov	r0, r3
 800189c:	b009      	add	sp, #36	; 0x24
 800189e:	f85d fb04 	ldr.w	pc, [sp], #4
 80018a2:	bf00      	nop
 80018a4:	f3af 8000 	nop.w
 80018a8:	f3af 8000 	nop.w
 80018ac:	f3af 8000 	nop.w

080018b0 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
                                    tfunc_t pf, void *arg) {
 80018b0:	b500      	push	{lr}
 80018b2:	b089      	sub	sp, #36	; 0x24
 80018b4:	9005      	str	r0, [sp, #20]
 80018b6:	9104      	str	r1, [sp, #16]
 80018b8:	9203      	str	r2, [sp, #12]
 80018ba:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80018bc:	9805      	ldr	r0, [sp, #20]
 80018be:	f002 f8df 	bl	8003a80 <chPoolAlloc>
 80018c2:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 80018c4:	9b07      	ldr	r3, [sp, #28]
 80018c6:	2b00      	cmp	r3, #0
 80018c8:	d101      	bne.n	80018ce <chThdCreateFromMemoryPool+0x1e>
    return NULL;
 80018ca:	2300      	movs	r3, #0
 80018cc:	e019      	b.n	8001902 <chThdCreateFromMemoryPool+0x52>
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80018ce:	f7ff ff4f 	bl	8001770 <chSysLock>
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 80018d2:	9b05      	ldr	r3, [sp, #20]
 80018d4:	685b      	ldr	r3, [r3, #4]
 80018d6:	9a02      	ldr	r2, [sp, #8]
 80018d8:	9200      	str	r2, [sp, #0]
 80018da:	9807      	ldr	r0, [sp, #28]
 80018dc:	4619      	mov	r1, r3
 80018de:	9a04      	ldr	r2, [sp, #16]
 80018e0:	9b03      	ldr	r3, [sp, #12]
 80018e2:	f7ff fc55 	bl	8001190 <chThdCreateI>
 80018e6:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 80018e8:	9b06      	ldr	r3, [sp, #24]
 80018ea:	2202      	movs	r2, #2
 80018ec:	775a      	strb	r2, [r3, #29]
  tp->p_mpool = mp;
 80018ee:	9b06      	ldr	r3, [sp, #24]
 80018f0:	9a05      	ldr	r2, [sp, #20]
 80018f2:	641a      	str	r2, [r3, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 80018f4:	9806      	ldr	r0, [sp, #24]
 80018f6:	2100      	movs	r1, #0
 80018f8:	f7ff fa1a 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 80018fc:	f7ff ff40 	bl	8001780 <chSysUnlock>

  return tp;
 8001900:	9b06      	ldr	r3, [sp, #24]
}
 8001902:	4618      	mov	r0, r3
 8001904:	b009      	add	sp, #36	; 0x24
 8001906:	f85d fb04 	ldr.w	pc, [sp], #4
 800190a:	bf00      	nop
 800190c:	f3af 8000 	nop.w

08001910 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001910:	b082      	sub	sp, #8
 8001912:	2320      	movs	r3, #32
 8001914:	9301      	str	r3, [sp, #4]
 8001916:	9b01      	ldr	r3, [sp, #4]
 8001918:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800191c:	b002      	add	sp, #8
 800191e:	4770      	bx	lr

08001920 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001920:	b082      	sub	sp, #8
 8001922:	2300      	movs	r3, #0
 8001924:	9301      	str	r3, [sp, #4]
 8001926:	9b01      	ldr	r3, [sp, #4]
 8001928:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800192c:	b002      	add	sp, #8
 800192e:	4770      	bx	lr

08001930 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001930:	b508      	push	{r3, lr}

  port_lock();
 8001932:	f7ff ffed 	bl	8001910 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001936:	bd08      	pop	{r3, pc}
 8001938:	f3af 8000 	nop.w
 800193c:	f3af 8000 	nop.w

08001940 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001940:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001942:	f7ff ffed 	bl	8001920 <port_unlock>
}
 8001946:	bd08      	pop	{r3, pc}
 8001948:	f3af 8000 	nop.w
 800194c:	f3af 8000 	nop.w

08001950 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8001950:	b500      	push	{lr}
 8001952:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8001954:	f7ff ffec 	bl	8001930 <chSysLock>
  tp = ch.rlist.r_newer;
 8001958:	4b07      	ldr	r3, [pc, #28]	; (8001978 <chRegFirstThread+0x28>)
 800195a:	691b      	ldr	r3, [r3, #16]
 800195c:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 800195e:	9b01      	ldr	r3, [sp, #4]
 8001960:	7f9b      	ldrb	r3, [r3, #30]
 8001962:	3301      	adds	r3, #1
 8001964:	b2da      	uxtb	r2, r3
 8001966:	9b01      	ldr	r3, [sp, #4]
 8001968:	779a      	strb	r2, [r3, #30]
#endif
  chSysUnlock();
 800196a:	f7ff ffe9 	bl	8001940 <chSysUnlock>

  return tp;
 800196e:	9b01      	ldr	r3, [sp, #4]
}
 8001970:	4618      	mov	r0, r3
 8001972:	b003      	add	sp, #12
 8001974:	f85d fb04 	ldr.w	pc, [sp], #4
 8001978:	200039a8 	.word	0x200039a8
 800197c:	f3af 8000 	nop.w

08001980 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8001980:	b500      	push	{lr}
 8001982:	b085      	sub	sp, #20
 8001984:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 8001986:	f7ff ffd3 	bl	8001930 <chSysLock>
  ntp = tp->p_newer;
 800198a:	9b01      	ldr	r3, [sp, #4]
 800198c:	691b      	ldr	r3, [r3, #16]
 800198e:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001990:	9a03      	ldr	r2, [sp, #12]
 8001992:	4b0b      	ldr	r3, [pc, #44]	; (80019c0 <chRegNextThread+0x40>)
 8001994:	429a      	cmp	r2, r3
 8001996:	d102      	bne.n	800199e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8001998:	2300      	movs	r3, #0
 800199a:	9303      	str	r3, [sp, #12]
 800199c:	e005      	b.n	80019aa <chRegNextThread+0x2a>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 800199e:	9b03      	ldr	r3, [sp, #12]
 80019a0:	7f9b      	ldrb	r3, [r3, #30]
 80019a2:	3301      	adds	r3, #1
 80019a4:	b2da      	uxtb	r2, r3
 80019a6:	9b03      	ldr	r3, [sp, #12]
 80019a8:	779a      	strb	r2, [r3, #30]
  }
#endif
  chSysUnlock();
 80019aa:	f7ff ffc9 	bl	8001940 <chSysUnlock>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80019ae:	9801      	ldr	r0, [sp, #4]
 80019b0:	f7ff ff06 	bl	80017c0 <chThdRelease>
#endif

  return ntp;
 80019b4:	9b03      	ldr	r3, [sp, #12]
}
 80019b6:	4618      	mov	r0, r3
 80019b8:	b005      	add	sp, #20
 80019ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80019be:	bf00      	nop
 80019c0:	200039a8 	.word	0x200039a8
 80019c4:	f3af 8000 	nop.w
 80019c8:	f3af 8000 	nop.w
 80019cc:	f3af 8000 	nop.w

080019d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80019d0:	b082      	sub	sp, #8
 80019d2:	2320      	movs	r3, #32
 80019d4:	9301      	str	r3, [sp, #4]
 80019d6:	9b01      	ldr	r3, [sp, #4]
 80019d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80019dc:	b002      	add	sp, #8
 80019de:	4770      	bx	lr

080019e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80019e0:	b082      	sub	sp, #8
 80019e2:	2300      	movs	r3, #0
 80019e4:	9301      	str	r3, [sp, #4]
 80019e6:	9b01      	ldr	r3, [sp, #4]
 80019e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80019ec:	b002      	add	sp, #8
 80019ee:	4770      	bx	lr

080019f0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80019f0:	b082      	sub	sp, #8
 80019f2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80019f4:	9b01      	ldr	r3, [sp, #4]
 80019f6:	9a01      	ldr	r2, [sp, #4]
 80019f8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80019fa:	9b01      	ldr	r3, [sp, #4]
 80019fc:	9a01      	ldr	r2, [sp, #4]
 80019fe:	605a      	str	r2, [r3, #4]
}
 8001a00:	b002      	add	sp, #8
 8001a02:	4770      	bx	lr
 8001a04:	f3af 8000 	nop.w
 8001a08:	f3af 8000 	nop.w
 8001a0c:	f3af 8000 	nop.w

08001a10 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8001a10:	b082      	sub	sp, #8
 8001a12:	9001      	str	r0, [sp, #4]
 8001a14:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8001a16:	9b01      	ldr	r3, [sp, #4]
 8001a18:	9a00      	ldr	r2, [sp, #0]
 8001a1a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8001a1c:	9b00      	ldr	r3, [sp, #0]
 8001a1e:	685a      	ldr	r2, [r3, #4]
 8001a20:	9b01      	ldr	r3, [sp, #4]
 8001a22:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001a24:	9b01      	ldr	r3, [sp, #4]
 8001a26:	685b      	ldr	r3, [r3, #4]
 8001a28:	9a01      	ldr	r2, [sp, #4]
 8001a2a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8001a2c:	9b00      	ldr	r3, [sp, #0]
 8001a2e:	9a01      	ldr	r2, [sp, #4]
 8001a30:	605a      	str	r2, [r3, #4]
}
 8001a32:	b002      	add	sp, #8
 8001a34:	4770      	bx	lr
 8001a36:	bf00      	nop
 8001a38:	f3af 8000 	nop.w
 8001a3c:	f3af 8000 	nop.w

08001a40 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001a40:	b084      	sub	sp, #16
 8001a42:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001a44:	9b01      	ldr	r3, [sp, #4]
 8001a46:	681b      	ldr	r3, [r3, #0]
 8001a48:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001a4a:	9b03      	ldr	r3, [sp, #12]
 8001a4c:	681a      	ldr	r2, [r3, #0]
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001a52:	9b01      	ldr	r3, [sp, #4]
 8001a54:	681b      	ldr	r3, [r3, #0]
 8001a56:	9a01      	ldr	r2, [sp, #4]
 8001a58:	605a      	str	r2, [r3, #4]

  return tp;
 8001a5a:	9b03      	ldr	r3, [sp, #12]
}
 8001a5c:	4618      	mov	r0, r3
 8001a5e:	b004      	add	sp, #16
 8001a60:	4770      	bx	lr
 8001a62:	bf00      	nop
 8001a64:	f3af 8000 	nop.w
 8001a68:	f3af 8000 	nop.w
 8001a6c:	f3af 8000 	nop.w

08001a70 <queue_lifo_remove>:

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
 8001a70:	b084      	sub	sp, #16
 8001a72:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_prev;
 8001a74:	9b01      	ldr	r3, [sp, #4]
 8001a76:	685b      	ldr	r3, [r3, #4]
 8001a78:	9303      	str	r3, [sp, #12]

  tqp->p_prev = tp->p_prev;
 8001a7a:	9b03      	ldr	r3, [sp, #12]
 8001a7c:	685a      	ldr	r2, [r3, #4]
 8001a7e:	9b01      	ldr	r3, [sp, #4]
 8001a80:	605a      	str	r2, [r3, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 8001a82:	9b01      	ldr	r3, [sp, #4]
 8001a84:	685b      	ldr	r3, [r3, #4]
 8001a86:	9a01      	ldr	r2, [sp, #4]
 8001a88:	601a      	str	r2, [r3, #0]

  return tp;
 8001a8a:	9b03      	ldr	r3, [sp, #12]
}
 8001a8c:	4618      	mov	r0, r3
 8001a8e:	b004      	add	sp, #16
 8001a90:	4770      	bx	lr
 8001a92:	bf00      	nop
 8001a94:	f3af 8000 	nop.w
 8001a98:	f3af 8000 	nop.w
 8001a9c:	f3af 8000 	nop.w

08001aa0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001aa0:	b508      	push	{r3, lr}

  port_lock();
 8001aa2:	f7ff ff95 	bl	80019d0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001aa6:	bd08      	pop	{r3, pc}
 8001aa8:	f3af 8000 	nop.w
 8001aac:	f3af 8000 	nop.w

08001ab0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001ab0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001ab2:	f7ff ff95 	bl	80019e0 <port_unlock>
}
 8001ab6:	bd08      	pop	{r3, pc}
 8001ab8:	f3af 8000 	nop.w
 8001abc:	f3af 8000 	nop.w

08001ac0 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
 8001ac0:	b500      	push	{lr}
 8001ac2:	b083      	sub	sp, #12
 8001ac4:	9001      	str	r0, [sp, #4]
 8001ac6:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
 8001ac8:	9b01      	ldr	r3, [sp, #4]
 8001aca:	4618      	mov	r0, r3
 8001acc:	f7ff ff90 	bl	80019f0 <queue_init>
  sp->s_cnt = n;
 8001ad0:	9b01      	ldr	r3, [sp, #4]
 8001ad2:	9a00      	ldr	r2, [sp, #0]
 8001ad4:	609a      	str	r2, [r3, #8]
}
 8001ad6:	b003      	add	sp, #12
 8001ad8:	f85d fb04 	ldr.w	pc, [sp], #4
 8001adc:	f3af 8000 	nop.w

08001ae0 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001ae0:	b500      	push	{lr}
 8001ae2:	b083      	sub	sp, #12
 8001ae4:	9001      	str	r0, [sp, #4]
 8001ae6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001ae8:	f7ff ffda 	bl	8001aa0 <chSysLock>
  chSemResetI(sp, n);
 8001aec:	9801      	ldr	r0, [sp, #4]
 8001aee:	9900      	ldr	r1, [sp, #0]
 8001af0:	f000 f80e 	bl	8001b10 <chSemResetI>
  chSchRescheduleS();
 8001af4:	f7ff f944 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8001af8:	f7ff ffda 	bl	8001ab0 <chSysUnlock>
}
 8001afc:	b003      	add	sp, #12
 8001afe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b02:	bf00      	nop
 8001b04:	f3af 8000 	nop.w
 8001b08:	f3af 8000 	nop.w
 8001b0c:	f3af 8000 	nop.w

08001b10 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001b10:	b500      	push	{lr}
 8001b12:	b085      	sub	sp, #20
 8001b14:	9001      	str	r0, [sp, #4]
 8001b16:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 8001b18:	9b01      	ldr	r3, [sp, #4]
 8001b1a:	689b      	ldr	r3, [r3, #8]
 8001b1c:	9303      	str	r3, [sp, #12]
  sp->s_cnt = n;
 8001b1e:	9b01      	ldr	r3, [sp, #4]
 8001b20:	9a00      	ldr	r2, [sp, #0]
 8001b22:	609a      	str	r2, [r3, #8]
  while (++cnt <= (cnt_t)0) {
 8001b24:	e00b      	b.n	8001b3e <chSemResetI+0x2e>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8001b26:	9b01      	ldr	r3, [sp, #4]
 8001b28:	4618      	mov	r0, r3
 8001b2a:	f7ff ffa1 	bl	8001a70 <queue_lifo_remove>
 8001b2e:	4603      	mov	r3, r0
 8001b30:	4618      	mov	r0, r3
 8001b32:	f7ff f835 	bl	8000ba0 <chSchReadyI>
 8001b36:	4603      	mov	r3, r0
 8001b38:	f06f 0201 	mvn.w	r2, #1
 8001b3c:	621a      	str	r2, [r3, #32]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001b3e:	9b03      	ldr	r3, [sp, #12]
 8001b40:	3301      	adds	r3, #1
 8001b42:	9303      	str	r3, [sp, #12]
 8001b44:	9b03      	ldr	r3, [sp, #12]
 8001b46:	2b00      	cmp	r3, #0
 8001b48:	dded      	ble.n	8001b26 <chSemResetI+0x16>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 8001b4a:	b005      	add	sp, #20
 8001b4c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b50 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8001b50:	b500      	push	{lr}
 8001b52:	b085      	sub	sp, #20
 8001b54:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8001b56:	f7ff ffa3 	bl	8001aa0 <chSysLock>
  msg = chSemWaitS(sp);
 8001b5a:	9801      	ldr	r0, [sp, #4]
 8001b5c:	f000 f808 	bl	8001b70 <chSemWaitS>
 8001b60:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001b62:	f7ff ffa5 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001b66:	9b03      	ldr	r3, [sp, #12]
}
 8001b68:	4618      	mov	r0, r3
 8001b6a:	b005      	add	sp, #20
 8001b6c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b70 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {
 8001b70:	b500      	push	{lr}
 8001b72:	b083      	sub	sp, #12
 8001b74:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001b76:	9b01      	ldr	r3, [sp, #4]
 8001b78:	689b      	ldr	r3, [r3, #8]
 8001b7a:	1e5a      	subs	r2, r3, #1
 8001b7c:	9b01      	ldr	r3, [sp, #4]
 8001b7e:	609a      	str	r2, [r3, #8]
 8001b80:	9b01      	ldr	r3, [sp, #4]
 8001b82:	689b      	ldr	r3, [r3, #8]
 8001b84:	2b00      	cmp	r3, #0
 8001b86:	da11      	bge.n	8001bac <chSemWaitS+0x3c>
    currp->p_u.wtsemp = sp;
 8001b88:	4b0b      	ldr	r3, [pc, #44]	; (8001bb8 <chSemWaitS+0x48>)
 8001b8a:	699b      	ldr	r3, [r3, #24]
 8001b8c:	9a01      	ldr	r2, [sp, #4]
 8001b8e:	621a      	str	r2, [r3, #32]
    sem_insert(currp, &sp->s_queue);
 8001b90:	4b09      	ldr	r3, [pc, #36]	; (8001bb8 <chSemWaitS+0x48>)
 8001b92:	699a      	ldr	r2, [r3, #24]
 8001b94:	9b01      	ldr	r3, [sp, #4]
 8001b96:	4610      	mov	r0, r2
 8001b98:	4619      	mov	r1, r3
 8001b9a:	f7ff ff39 	bl	8001a10 <queue_insert>
    chSchGoSleepS(CH_STATE_WTSEM);
 8001b9e:	2005      	movs	r0, #5
 8001ba0:	f7ff f826 	bl	8000bf0 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 8001ba4:	4b04      	ldr	r3, [pc, #16]	; (8001bb8 <chSemWaitS+0x48>)
 8001ba6:	699b      	ldr	r3, [r3, #24]
 8001ba8:	6a1b      	ldr	r3, [r3, #32]
 8001baa:	e000      	b.n	8001bae <chSemWaitS+0x3e>
  }

  return MSG_OK;
 8001bac:	2300      	movs	r3, #0
}
 8001bae:	4618      	mov	r0, r3
 8001bb0:	b003      	add	sp, #12
 8001bb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bb6:	bf00      	nop
 8001bb8:	200039a8 	.word	0x200039a8
 8001bbc:	f3af 8000 	nop.w

08001bc0 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 8001bc0:	b500      	push	{lr}
 8001bc2:	b085      	sub	sp, #20
 8001bc4:	9001      	str	r0, [sp, #4]
 8001bc6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 8001bc8:	f7ff ff6a 	bl	8001aa0 <chSysLock>
  msg = chSemWaitTimeoutS(sp, time);
 8001bcc:	9801      	ldr	r0, [sp, #4]
 8001bce:	9900      	ldr	r1, [sp, #0]
 8001bd0:	f000 f80e 	bl	8001bf0 <chSemWaitTimeoutS>
 8001bd4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001bd6:	f7ff ff6b 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001bda:	9b03      	ldr	r3, [sp, #12]
}
 8001bdc:	4618      	mov	r0, r3
 8001bde:	b005      	add	sp, #20
 8001be0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001be4:	f3af 8000 	nop.w
 8001be8:	f3af 8000 	nop.w
 8001bec:	f3af 8000 	nop.w

08001bf0 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001bf0:	b500      	push	{lr}
 8001bf2:	b083      	sub	sp, #12
 8001bf4:	9001      	str	r0, [sp, #4]
 8001bf6:	9100      	str	r1, [sp, #0]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001bf8:	9b01      	ldr	r3, [sp, #4]
 8001bfa:	689b      	ldr	r3, [r3, #8]
 8001bfc:	1e5a      	subs	r2, r3, #1
 8001bfe:	9b01      	ldr	r3, [sp, #4]
 8001c00:	609a      	str	r2, [r3, #8]
 8001c02:	9b01      	ldr	r3, [sp, #4]
 8001c04:	689b      	ldr	r3, [r3, #8]
 8001c06:	2b00      	cmp	r3, #0
 8001c08:	da1b      	bge.n	8001c42 <chSemWaitTimeoutS+0x52>
    if (TIME_IMMEDIATE == time) {
 8001c0a:	9b00      	ldr	r3, [sp, #0]
 8001c0c:	2b00      	cmp	r3, #0
 8001c0e:	d107      	bne.n	8001c20 <chSemWaitTimeoutS+0x30>
      sp->s_cnt++;
 8001c10:	9b01      	ldr	r3, [sp, #4]
 8001c12:	689b      	ldr	r3, [r3, #8]
 8001c14:	1c5a      	adds	r2, r3, #1
 8001c16:	9b01      	ldr	r3, [sp, #4]
 8001c18:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
 8001c1a:	f04f 33ff 	mov.w	r3, #4294967295
 8001c1e:	e011      	b.n	8001c44 <chSemWaitTimeoutS+0x54>
    }
    currp->p_u.wtsemp = sp;
 8001c20:	4b0a      	ldr	r3, [pc, #40]	; (8001c4c <chSemWaitTimeoutS+0x5c>)
 8001c22:	699b      	ldr	r3, [r3, #24]
 8001c24:	9a01      	ldr	r2, [sp, #4]
 8001c26:	621a      	str	r2, [r3, #32]
    sem_insert(currp, &sp->s_queue);
 8001c28:	4b08      	ldr	r3, [pc, #32]	; (8001c4c <chSemWaitTimeoutS+0x5c>)
 8001c2a:	699a      	ldr	r2, [r3, #24]
 8001c2c:	9b01      	ldr	r3, [sp, #4]
 8001c2e:	4610      	mov	r0, r2
 8001c30:	4619      	mov	r1, r3
 8001c32:	f7ff feed 	bl	8001a10 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001c36:	2005      	movs	r0, #5
 8001c38:	9900      	ldr	r1, [sp, #0]
 8001c3a:	f7ff f841 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8001c3e:	4603      	mov	r3, r0
 8001c40:	e000      	b.n	8001c44 <chSemWaitTimeoutS+0x54>
  }

  return MSG_OK;
 8001c42:	2300      	movs	r3, #0
}
 8001c44:	4618      	mov	r0, r3
 8001c46:	b003      	add	sp, #12
 8001c48:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c4c:	200039a8 	.word	0x200039a8

08001c50 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8001c50:	b500      	push	{lr}
 8001c52:	b083      	sub	sp, #12
 8001c54:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 8001c56:	f7ff ff23 	bl	8001aa0 <chSysLock>
  if (++sp->s_cnt <= (cnt_t)0) {
 8001c5a:	9b01      	ldr	r3, [sp, #4]
 8001c5c:	689b      	ldr	r3, [r3, #8]
 8001c5e:	1c5a      	adds	r2, r3, #1
 8001c60:	9b01      	ldr	r3, [sp, #4]
 8001c62:	609a      	str	r2, [r3, #8]
 8001c64:	9b01      	ldr	r3, [sp, #4]
 8001c66:	689b      	ldr	r3, [r3, #8]
 8001c68:	2b00      	cmp	r3, #0
 8001c6a:	dc08      	bgt.n	8001c7e <chSemSignal+0x2e>
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 8001c6c:	9b01      	ldr	r3, [sp, #4]
 8001c6e:	4618      	mov	r0, r3
 8001c70:	f7ff fee6 	bl	8001a40 <queue_fifo_remove>
 8001c74:	4603      	mov	r3, r0
 8001c76:	4618      	mov	r0, r3
 8001c78:	2100      	movs	r1, #0
 8001c7a:	f7ff f859 	bl	8000d30 <chSchWakeupS>
  }
  chSysUnlock();
 8001c7e:	f7ff ff17 	bl	8001ab0 <chSysUnlock>
}
 8001c82:	b003      	add	sp, #12
 8001c84:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c88:	f3af 8000 	nop.w
 8001c8c:	f3af 8000 	nop.w

08001c90 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8001c90:	b500      	push	{lr}
 8001c92:	b085      	sub	sp, #20
 8001c94:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8001c96:	9b01      	ldr	r3, [sp, #4]
 8001c98:	689b      	ldr	r3, [r3, #8]
 8001c9a:	1c5a      	adds	r2, r3, #1
 8001c9c:	9b01      	ldr	r3, [sp, #4]
 8001c9e:	609a      	str	r2, [r3, #8]
 8001ca0:	9b01      	ldr	r3, [sp, #4]
 8001ca2:	689b      	ldr	r3, [r3, #8]
 8001ca4:	2b00      	cmp	r3, #0
 8001ca6:	dc0a      	bgt.n	8001cbe <chSemSignalI+0x2e>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
 8001ca8:	9b01      	ldr	r3, [sp, #4]
 8001caa:	4618      	mov	r0, r3
 8001cac:	f7ff fec8 	bl	8001a40 <queue_fifo_remove>
 8001cb0:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 8001cb2:	9b03      	ldr	r3, [sp, #12]
 8001cb4:	2200      	movs	r2, #0
 8001cb6:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8001cb8:	9803      	ldr	r0, [sp, #12]
 8001cba:	f7fe ff71 	bl	8000ba0 <chSchReadyI>
  }
}
 8001cbe:	b005      	add	sp, #20
 8001cc0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001cc4:	f3af 8000 	nop.w
 8001cc8:	f3af 8000 	nop.w
 8001ccc:	f3af 8000 	nop.w

08001cd0 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8001cd0:	b500      	push	{lr}
 8001cd2:	b083      	sub	sp, #12
 8001cd4:	9001      	str	r0, [sp, #4]
 8001cd6:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001cd8:	e016      	b.n	8001d08 <chSemAddCounterI+0x38>
    if (++sp->s_cnt <= (cnt_t)0) {
 8001cda:	9b01      	ldr	r3, [sp, #4]
 8001cdc:	689b      	ldr	r3, [r3, #8]
 8001cde:	1c5a      	adds	r2, r3, #1
 8001ce0:	9b01      	ldr	r3, [sp, #4]
 8001ce2:	609a      	str	r2, [r3, #8]
 8001ce4:	9b01      	ldr	r3, [sp, #4]
 8001ce6:	689b      	ldr	r3, [r3, #8]
 8001ce8:	2b00      	cmp	r3, #0
 8001cea:	dc0a      	bgt.n	8001d02 <chSemAddCounterI+0x32>
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001cec:	9b01      	ldr	r3, [sp, #4]
 8001cee:	4618      	mov	r0, r3
 8001cf0:	f7ff fea6 	bl	8001a40 <queue_fifo_remove>
 8001cf4:	4603      	mov	r3, r0
 8001cf6:	4618      	mov	r0, r3
 8001cf8:	f7fe ff52 	bl	8000ba0 <chSchReadyI>
 8001cfc:	4603      	mov	r3, r0
 8001cfe:	2200      	movs	r2, #0
 8001d00:	621a      	str	r2, [r3, #32]
    }
    n--;
 8001d02:	9b00      	ldr	r3, [sp, #0]
 8001d04:	3b01      	subs	r3, #1
 8001d06:	9300      	str	r3, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001d08:	9b00      	ldr	r3, [sp, #0]
 8001d0a:	2b00      	cmp	r3, #0
 8001d0c:	dce5      	bgt.n	8001cda <chSemAddCounterI+0xa>
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
    }
    n--;
  }
}
 8001d0e:	b003      	add	sp, #12
 8001d10:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d14:	f3af 8000 	nop.w
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8001d20:	b500      	push	{lr}
 8001d22:	b085      	sub	sp, #20
 8001d24:	9001      	str	r0, [sp, #4]
 8001d26:	9100      	str	r1, [sp, #0]
              "inconsistent semaphore");
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 8001d28:	f7ff feba 	bl	8001aa0 <chSysLock>
  if (++sps->s_cnt <= (cnt_t)0) {
 8001d2c:	9b01      	ldr	r3, [sp, #4]
 8001d2e:	689b      	ldr	r3, [r3, #8]
 8001d30:	1c5a      	adds	r2, r3, #1
 8001d32:	9b01      	ldr	r3, [sp, #4]
 8001d34:	609a      	str	r2, [r3, #8]
 8001d36:	9b01      	ldr	r3, [sp, #4]
 8001d38:	689b      	ldr	r3, [r3, #8]
 8001d3a:	2b00      	cmp	r3, #0
 8001d3c:	dc0a      	bgt.n	8001d54 <chSemSignalWait+0x34>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8001d3e:	9b01      	ldr	r3, [sp, #4]
 8001d40:	4618      	mov	r0, r3
 8001d42:	f7ff fe7d 	bl	8001a40 <queue_fifo_remove>
 8001d46:	4603      	mov	r3, r0
 8001d48:	4618      	mov	r0, r3
 8001d4a:	f7fe ff29 	bl	8000ba0 <chSchReadyI>
 8001d4e:	4603      	mov	r3, r0
 8001d50:	2200      	movs	r2, #0
 8001d52:	621a      	str	r2, [r3, #32]
  }
  if (--spw->s_cnt < (cnt_t)0) {
 8001d54:	9b00      	ldr	r3, [sp, #0]
 8001d56:	689b      	ldr	r3, [r3, #8]
 8001d58:	1e5a      	subs	r2, r3, #1
 8001d5a:	9b00      	ldr	r3, [sp, #0]
 8001d5c:	609a      	str	r2, [r3, #8]
 8001d5e:	9b00      	ldr	r3, [sp, #0]
 8001d60:	689b      	ldr	r3, [r3, #8]
 8001d62:	2b00      	cmp	r3, #0
 8001d64:	da11      	bge.n	8001d8a <chSemSignalWait+0x6a>
    thread_t *ctp = currp;
 8001d66:	4b0e      	ldr	r3, [pc, #56]	; (8001da0 <chSemSignalWait+0x80>)
 8001d68:	699b      	ldr	r3, [r3, #24]
 8001d6a:	9302      	str	r3, [sp, #8]
    sem_insert(ctp, &spw->s_queue);
 8001d6c:	9b00      	ldr	r3, [sp, #0]
 8001d6e:	9802      	ldr	r0, [sp, #8]
 8001d70:	4619      	mov	r1, r3
 8001d72:	f7ff fe4d 	bl	8001a10 <queue_insert>
    ctp->p_u.wtsemp = spw;
 8001d76:	9b02      	ldr	r3, [sp, #8]
 8001d78:	9a00      	ldr	r2, [sp, #0]
 8001d7a:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTSEM);
 8001d7c:	2005      	movs	r0, #5
 8001d7e:	f7fe ff37 	bl	8000bf0 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8001d82:	9b02      	ldr	r3, [sp, #8]
 8001d84:	6a1b      	ldr	r3, [r3, #32]
 8001d86:	9303      	str	r3, [sp, #12]
 8001d88:	e003      	b.n	8001d92 <chSemSignalWait+0x72>
  }
  else {
    chSchRescheduleS();
 8001d8a:	f7fe fff9 	bl	8000d80 <chSchRescheduleS>
    msg = MSG_OK;
 8001d8e:	2300      	movs	r3, #0
 8001d90:	9303      	str	r3, [sp, #12]
  }
  chSysUnlock();
 8001d92:	f7ff fe8d 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001d96:	9b03      	ldr	r3, [sp, #12]
}
 8001d98:	4618      	mov	r0, r3
 8001d9a:	b005      	add	sp, #20
 8001d9c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001da0:	200039a8 	.word	0x200039a8
 8001da4:	f3af 8000 	nop.w
 8001da8:	f3af 8000 	nop.w
 8001dac:	f3af 8000 	nop.w

08001db0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001db0:	b082      	sub	sp, #8
 8001db2:	2320      	movs	r3, #32
 8001db4:	9301      	str	r3, [sp, #4]
 8001db6:	9b01      	ldr	r3, [sp, #4]
 8001db8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001dbc:	b002      	add	sp, #8
 8001dbe:	4770      	bx	lr

08001dc0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001dc0:	b082      	sub	sp, #8
 8001dc2:	2300      	movs	r3, #0
 8001dc4:	9301      	str	r3, [sp, #4]
 8001dc6:	9b01      	ldr	r3, [sp, #4]
 8001dc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001dcc:	b002      	add	sp, #8
 8001dce:	4770      	bx	lr

08001dd0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001dd0:	b082      	sub	sp, #8
 8001dd2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001dd4:	9b01      	ldr	r3, [sp, #4]
 8001dd6:	9a01      	ldr	r2, [sp, #4]
 8001dd8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001dda:	9b01      	ldr	r3, [sp, #4]
 8001ddc:	9a01      	ldr	r2, [sp, #4]
 8001dde:	605a      	str	r2, [r3, #4]
}
 8001de0:	b002      	add	sp, #8
 8001de2:	4770      	bx	lr
 8001de4:	f3af 8000 	nop.w
 8001de8:	f3af 8000 	nop.w
 8001dec:	f3af 8000 	nop.w

08001df0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8001df0:	b082      	sub	sp, #8
 8001df2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001df4:	9b01      	ldr	r3, [sp, #4]
 8001df6:	681a      	ldr	r2, [r3, #0]
 8001df8:	9b01      	ldr	r3, [sp, #4]
 8001dfa:	429a      	cmp	r2, r3
 8001dfc:	bf0c      	ite	eq
 8001dfe:	2300      	moveq	r3, #0
 8001e00:	2301      	movne	r3, #1
 8001e02:	b2db      	uxtb	r3, r3
}
 8001e04:	4618      	mov	r0, r3
 8001e06:	b002      	add	sp, #8
 8001e08:	4770      	bx	lr
 8001e0a:	bf00      	nop
 8001e0c:	f3af 8000 	nop.w

08001e10 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8001e10:	b084      	sub	sp, #16
 8001e12:	9001      	str	r0, [sp, #4]
 8001e14:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8001e16:	9b00      	ldr	r3, [sp, #0]
 8001e18:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8001e1a:	9b03      	ldr	r3, [sp, #12]
 8001e1c:	681b      	ldr	r3, [r3, #0]
 8001e1e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001e20:	9a03      	ldr	r2, [sp, #12]
 8001e22:	9b00      	ldr	r3, [sp, #0]
 8001e24:	429a      	cmp	r2, r3
 8001e26:	d005      	beq.n	8001e34 <queue_prio_insert+0x24>
 8001e28:	9b03      	ldr	r3, [sp, #12]
 8001e2a:	689a      	ldr	r2, [r3, #8]
 8001e2c:	9b01      	ldr	r3, [sp, #4]
 8001e2e:	689b      	ldr	r3, [r3, #8]
 8001e30:	429a      	cmp	r2, r3
 8001e32:	d2f2      	bcs.n	8001e1a <queue_prio_insert+0xa>
  tp->p_next = cp;
 8001e34:	9b01      	ldr	r3, [sp, #4]
 8001e36:	9a03      	ldr	r2, [sp, #12]
 8001e38:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8001e3a:	9b03      	ldr	r3, [sp, #12]
 8001e3c:	685a      	ldr	r2, [r3, #4]
 8001e3e:	9b01      	ldr	r3, [sp, #4]
 8001e40:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001e42:	9b01      	ldr	r3, [sp, #4]
 8001e44:	685b      	ldr	r3, [r3, #4]
 8001e46:	9a01      	ldr	r2, [sp, #4]
 8001e48:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8001e4a:	9b03      	ldr	r3, [sp, #12]
 8001e4c:	9a01      	ldr	r2, [sp, #4]
 8001e4e:	605a      	str	r2, [r3, #4]
}
 8001e50:	b004      	add	sp, #16
 8001e52:	4770      	bx	lr
 8001e54:	f3af 8000 	nop.w
 8001e58:	f3af 8000 	nop.w
 8001e5c:	f3af 8000 	nop.w

08001e60 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001e60:	b084      	sub	sp, #16
 8001e62:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001e64:	9b01      	ldr	r3, [sp, #4]
 8001e66:	681b      	ldr	r3, [r3, #0]
 8001e68:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001e6a:	9b03      	ldr	r3, [sp, #12]
 8001e6c:	681a      	ldr	r2, [r3, #0]
 8001e6e:	9b01      	ldr	r3, [sp, #4]
 8001e70:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001e72:	9b01      	ldr	r3, [sp, #4]
 8001e74:	681b      	ldr	r3, [r3, #0]
 8001e76:	9a01      	ldr	r2, [sp, #4]
 8001e78:	605a      	str	r2, [r3, #4]

  return tp;
 8001e7a:	9b03      	ldr	r3, [sp, #12]
}
 8001e7c:	4618      	mov	r0, r3
 8001e7e:	b004      	add	sp, #16
 8001e80:	4770      	bx	lr
 8001e82:	bf00      	nop
 8001e84:	f3af 8000 	nop.w
 8001e88:	f3af 8000 	nop.w
 8001e8c:	f3af 8000 	nop.w

08001e90 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8001e90:	b082      	sub	sp, #8
 8001e92:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8001e94:	9b01      	ldr	r3, [sp, #4]
 8001e96:	685b      	ldr	r3, [r3, #4]
 8001e98:	9a01      	ldr	r2, [sp, #4]
 8001e9a:	6812      	ldr	r2, [r2, #0]
 8001e9c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001e9e:	9b01      	ldr	r3, [sp, #4]
 8001ea0:	681b      	ldr	r3, [r3, #0]
 8001ea2:	9a01      	ldr	r2, [sp, #4]
 8001ea4:	6852      	ldr	r2, [r2, #4]
 8001ea6:	605a      	str	r2, [r3, #4]

  return tp;
 8001ea8:	9b01      	ldr	r3, [sp, #4]
}
 8001eaa:	4618      	mov	r0, r3
 8001eac:	b002      	add	sp, #8
 8001eae:	4770      	bx	lr

08001eb0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001eb0:	b508      	push	{r3, lr}

  port_lock();
 8001eb2:	f7ff ff7d 	bl	8001db0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001eb6:	bd08      	pop	{r3, pc}
 8001eb8:	f3af 8000 	nop.w
 8001ebc:	f3af 8000 	nop.w

08001ec0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001ec0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001ec2:	f7ff ff7d 	bl	8001dc0 <port_unlock>
}
 8001ec6:	bd08      	pop	{r3, pc}
 8001ec8:	f3af 8000 	nop.w
 8001ecc:	f3af 8000 	nop.w

08001ed0 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8001ed0:	b500      	push	{lr}
 8001ed2:	b083      	sub	sp, #12
 8001ed4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();

  return queue_notempty(&mp->m_queue);
 8001ed6:	9b01      	ldr	r3, [sp, #4]
 8001ed8:	4618      	mov	r0, r3
 8001eda:	f7ff ff89 	bl	8001df0 <queue_notempty>
 8001ede:	4603      	mov	r3, r0
}
 8001ee0:	4618      	mov	r0, r3
 8001ee2:	b003      	add	sp, #12
 8001ee4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ee8:	f3af 8000 	nop.w
 8001eec:	f3af 8000 	nop.w

08001ef0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001ef0:	b500      	push	{lr}
 8001ef2:	b083      	sub	sp, #12
 8001ef4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 8001ef6:	9b01      	ldr	r3, [sp, #4]
 8001ef8:	4618      	mov	r0, r3
 8001efa:	f7ff ff69 	bl	8001dd0 <queue_init>
  mp->m_owner = NULL;
 8001efe:	9b01      	ldr	r3, [sp, #4]
 8001f00:	2200      	movs	r2, #0
 8001f02:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8001f04:	b003      	add	sp, #12
 8001f06:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f0a:	bf00      	nop
 8001f0c:	f3af 8000 	nop.w

08001f10 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001f10:	b500      	push	{lr}
 8001f12:	b083      	sub	sp, #12
 8001f14:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001f16:	f7ff ffcb 	bl	8001eb0 <chSysLock>
  chMtxLockS(mp);
 8001f1a:	9801      	ldr	r0, [sp, #4]
 8001f1c:	f000 f808 	bl	8001f30 <chMtxLockS>
  chSysUnlock();
 8001f20:	f7ff ffce 	bl	8001ec0 <chSysUnlock>
}
 8001f24:	b003      	add	sp, #12
 8001f26:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f2a:	bf00      	nop
 8001f2c:	f3af 8000 	nop.w

08001f30 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001f30:	b500      	push	{lr}
 8001f32:	b085      	sub	sp, #20
 8001f34:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001f36:	4b2d      	ldr	r3, [pc, #180]	; (8001fec <chMtxLockS+0xbc>)
 8001f38:	699b      	ldr	r3, [r3, #24]
 8001f3a:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001f3c:	9b01      	ldr	r3, [sp, #4]
 8001f3e:	689b      	ldr	r3, [r3, #8]
 8001f40:	2b00      	cmp	r3, #0
 8001f42:	d045      	beq.n	8001fd0 <chMtxLockS+0xa0>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
 8001f44:	9b01      	ldr	r3, [sp, #4]
 8001f46:	689b      	ldr	r3, [r3, #8]
 8001f48:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001f4a:	e02f      	b.n	8001fac <chMtxLockS+0x7c>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8001f4c:	9b02      	ldr	r3, [sp, #8]
 8001f4e:	689a      	ldr	r2, [r3, #8]
 8001f50:	9b03      	ldr	r3, [sp, #12]
 8001f52:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001f54:	9b03      	ldr	r3, [sp, #12]
 8001f56:	7f1b      	ldrb	r3, [r3, #28]
 8001f58:	2b06      	cmp	r3, #6
 8001f5a:	d004      	beq.n	8001f66 <chMtxLockS+0x36>
 8001f5c:	2b07      	cmp	r3, #7
 8001f5e:	d011      	beq.n	8001f84 <chMtxLockS+0x54>
 8001f60:	2b00      	cmp	r3, #0
 8001f62:	d01a      	beq.n	8001f9a <chMtxLockS+0x6a>
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
          /* Nothing to do for other states.*/
          break;
 8001f64:	e021      	b.n	8001faa <chMtxLockS+0x7a>

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f66:	9803      	ldr	r0, [sp, #12]
 8001f68:	f7ff ff92 	bl	8001e90 <queue_dequeue>
 8001f6c:	4602      	mov	r2, r0
 8001f6e:	9b03      	ldr	r3, [sp, #12]
 8001f70:	6a1b      	ldr	r3, [r3, #32]
 8001f72:	4610      	mov	r0, r2
 8001f74:	4619      	mov	r1, r3
 8001f76:	f7ff ff4b 	bl	8001e10 <queue_prio_insert>
          tp = tp->p_u.wtmtxp->m_owner;
 8001f7a:	9b03      	ldr	r3, [sp, #12]
 8001f7c:	6a1b      	ldr	r3, [r3, #32]
 8001f7e:	689b      	ldr	r3, [r3, #8]
 8001f80:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8001f82:	e013      	b.n	8001fac <chMtxLockS+0x7c>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f84:	9803      	ldr	r0, [sp, #12]
 8001f86:	f7ff ff83 	bl	8001e90 <queue_dequeue>
 8001f8a:	4602      	mov	r2, r0
 8001f8c:	9b03      	ldr	r3, [sp, #12]
 8001f8e:	6a1b      	ldr	r3, [r3, #32]
 8001f90:	4610      	mov	r0, r2
 8001f92:	4619      	mov	r1, r3
 8001f94:	f7ff ff3c 	bl	8001e10 <queue_prio_insert>
          break;
 8001f98:	e007      	b.n	8001faa <chMtxLockS+0x7a>
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001f9a:	9803      	ldr	r0, [sp, #12]
 8001f9c:	f7ff ff78 	bl	8001e90 <queue_dequeue>
 8001fa0:	4603      	mov	r3, r0
 8001fa2:	4618      	mov	r0, r3
 8001fa4:	f7fe fdfc 	bl	8000ba0 <chSchReadyI>
          break;
 8001fa8:	bf00      	nop
        default:
          /* Nothing to do for other states.*/
          break;
        }
        break;
 8001faa:	e005      	b.n	8001fb8 <chMtxLockS+0x88>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001fac:	9b03      	ldr	r3, [sp, #12]
 8001fae:	689a      	ldr	r2, [r3, #8]
 8001fb0:	9b02      	ldr	r3, [sp, #8]
 8001fb2:	689b      	ldr	r3, [r3, #8]
 8001fb4:	429a      	cmp	r2, r3
 8001fb6:	d3c9      	bcc.n	8001f4c <chMtxLockS+0x1c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 8001fb8:	9b01      	ldr	r3, [sp, #4]
 8001fba:	9802      	ldr	r0, [sp, #8]
 8001fbc:	4619      	mov	r1, r3
 8001fbe:	f7ff ff27 	bl	8001e10 <queue_prio_insert>
      ctp->p_u.wtmtxp = mp;
 8001fc2:	9b02      	ldr	r3, [sp, #8]
 8001fc4:	9a01      	ldr	r2, [sp, #4]
 8001fc6:	621a      	str	r2, [r3, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001fc8:	2006      	movs	r0, #6
 8001fca:	f7fe fe11 	bl	8000bf0 <chSchGoSleepS>
 8001fce:	e009      	b.n	8001fe4 <chMtxLockS+0xb4>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8001fd0:	9b01      	ldr	r3, [sp, #4]
 8001fd2:	9a02      	ldr	r2, [sp, #8]
 8001fd4:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
 8001fd6:	9b02      	ldr	r3, [sp, #8]
 8001fd8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001fda:	9b01      	ldr	r3, [sp, #4]
 8001fdc:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
 8001fde:	9b02      	ldr	r3, [sp, #8]
 8001fe0:	9a01      	ldr	r2, [sp, #4]
 8001fe2:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8001fe4:	b005      	add	sp, #20
 8001fe6:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fea:	bf00      	nop
 8001fec:	200039a8 	.word	0x200039a8

08001ff0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 8001ff0:	b500      	push	{lr}
 8001ff2:	b085      	sub	sp, #20
 8001ff4:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 8001ff6:	f7ff ff5b 	bl	8001eb0 <chSysLock>
  b = chMtxTryLockS(mp);
 8001ffa:	9801      	ldr	r0, [sp, #4]
 8001ffc:	f000 f810 	bl	8002020 <chMtxTryLockS>
 8002000:	4603      	mov	r3, r0
 8002002:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 8002006:	f7ff ff5b 	bl	8001ec0 <chSysUnlock>

  return b;
 800200a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800200e:	4618      	mov	r0, r3
 8002010:	b005      	add	sp, #20
 8002012:	f85d fb04 	ldr.w	pc, [sp], #4
 8002016:	bf00      	nop
 8002018:	f3af 8000 	nop.w
 800201c:	f3af 8000 	nop.w

08002020 <chMtxTryLockS>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {
 8002020:	b082      	sub	sp, #8
 8002022:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8002024:	9b01      	ldr	r3, [sp, #4]
 8002026:	689b      	ldr	r3, [r3, #8]
 8002028:	2b00      	cmp	r3, #0
 800202a:	d001      	beq.n	8002030 <chMtxTryLockS+0x10>
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 800202c:	2300      	movs	r3, #0
 800202e:	e00d      	b.n	800204c <chMtxTryLockS+0x2c>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8002030:	4b08      	ldr	r3, [pc, #32]	; (8002054 <chMtxTryLockS+0x34>)
 8002032:	699a      	ldr	r2, [r3, #24]
 8002034:	9b01      	ldr	r3, [sp, #4]
 8002036:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 8002038:	4b06      	ldr	r3, [pc, #24]	; (8002054 <chMtxTryLockS+0x34>)
 800203a:	699b      	ldr	r3, [r3, #24]
 800203c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800203e:	9b01      	ldr	r3, [sp, #4]
 8002040:	60da      	str	r2, [r3, #12]
  currp->p_mtxlist = mp;
 8002042:	4b04      	ldr	r3, [pc, #16]	; (8002054 <chMtxTryLockS+0x34>)
 8002044:	699b      	ldr	r3, [r3, #24]
 8002046:	9a01      	ldr	r2, [sp, #4]
 8002048:	639a      	str	r2, [r3, #56]	; 0x38
  return true;
 800204a:	2301      	movs	r3, #1
}
 800204c:	4618      	mov	r0, r3
 800204e:	b002      	add	sp, #8
 8002050:	4770      	bx	lr
 8002052:	bf00      	nop
 8002054:	200039a8 	.word	0x200039a8
 8002058:	f3af 8000 	nop.w
 800205c:	f3af 8000 	nop.w

08002060 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002060:	b500      	push	{lr}
 8002062:	b087      	sub	sp, #28
 8002064:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002066:	4b26      	ldr	r3, [pc, #152]	; (8002100 <chMtxUnlock+0xa0>)
 8002068:	699b      	ldr	r3, [r3, #24]
 800206a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);

  chSysLock();
 800206c:	f7ff ff20 	bl	8001eb0 <chSysLock>
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8002070:	9b01      	ldr	r3, [sp, #4]
 8002072:	68da      	ldr	r2, [r3, #12]
 8002074:	9b03      	ldr	r3, [sp, #12]
 8002076:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002078:	9801      	ldr	r0, [sp, #4]
 800207a:	f7ff ff29 	bl	8001ed0 <chMtxQueueNotEmptyS>
 800207e:	4603      	mov	r3, r0
 8002080:	2b00      	cmp	r3, #0
 8002082:	d034      	beq.n	80020ee <chMtxUnlock+0x8e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002084:	9b03      	ldr	r3, [sp, #12]
 8002086:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002088:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 800208a:	9b03      	ldr	r3, [sp, #12]
 800208c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800208e:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8002090:	e012      	b.n	80020b8 <chMtxUnlock+0x58>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002092:	9805      	ldr	r0, [sp, #20]
 8002094:	f7ff ff1c 	bl	8001ed0 <chMtxQueueNotEmptyS>
 8002098:	4603      	mov	r3, r0
 800209a:	2b00      	cmp	r3, #0
 800209c:	d009      	beq.n	80020b2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800209e:	9b05      	ldr	r3, [sp, #20]
 80020a0:	681b      	ldr	r3, [r3, #0]
 80020a2:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80020a4:	9b04      	ldr	r3, [sp, #16]
 80020a6:	429a      	cmp	r2, r3
 80020a8:	d903      	bls.n	80020b2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 80020aa:	9b05      	ldr	r3, [sp, #20]
 80020ac:	681b      	ldr	r3, [r3, #0]
 80020ae:	689b      	ldr	r3, [r3, #8]
 80020b0:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 80020b2:	9b05      	ldr	r3, [sp, #20]
 80020b4:	68db      	ldr	r3, [r3, #12]
 80020b6:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80020b8:	9b05      	ldr	r3, [sp, #20]
 80020ba:	2b00      	cmp	r3, #0
 80020bc:	d1e9      	bne.n	8002092 <chMtxUnlock+0x32>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80020be:	9b03      	ldr	r3, [sp, #12]
 80020c0:	9a04      	ldr	r2, [sp, #16]
 80020c2:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 80020c4:	9b01      	ldr	r3, [sp, #4]
 80020c6:	4618      	mov	r0, r3
 80020c8:	f7ff feca 	bl	8001e60 <queue_fifo_remove>
 80020cc:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 80020ce:	9b01      	ldr	r3, [sp, #4]
 80020d0:	9a02      	ldr	r2, [sp, #8]
 80020d2:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 80020d4:	9b02      	ldr	r3, [sp, #8]
 80020d6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80020d8:	9b01      	ldr	r3, [sp, #4]
 80020da:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 80020dc:	9b02      	ldr	r3, [sp, #8]
 80020de:	9a01      	ldr	r2, [sp, #4]
 80020e0:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80020e2:	9802      	ldr	r0, [sp, #8]
 80020e4:	f7fe fd5c 	bl	8000ba0 <chSchReadyI>
      chSchRescheduleS();
 80020e8:	f7fe fe4a 	bl	8000d80 <chSchRescheduleS>
 80020ec:	e002      	b.n	80020f4 <chMtxUnlock+0x94>
    }
    else {
      mp->m_owner = NULL;
 80020ee:	9b01      	ldr	r3, [sp, #4]
 80020f0:	2200      	movs	r2, #0
 80020f2:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 80020f4:	f7ff fee4 	bl	8001ec0 <chSysUnlock>
}
 80020f8:	b007      	add	sp, #28
 80020fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80020fe:	bf00      	nop
 8002100:	200039a8 	.word	0x200039a8
 8002104:	f3af 8000 	nop.w
 8002108:	f3af 8000 	nop.w
 800210c:	f3af 8000 	nop.w

08002110 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8002110:	b500      	push	{lr}
 8002112:	b087      	sub	sp, #28
 8002114:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002116:	4b23      	ldr	r3, [pc, #140]	; (80021a4 <chMtxUnlockS+0x94>)
 8002118:	699b      	ldr	r3, [r3, #24]
 800211a:	9303      	str	r3, [sp, #12]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800211c:	9b01      	ldr	r3, [sp, #4]
 800211e:	68da      	ldr	r2, [r3, #12]
 8002120:	9b03      	ldr	r3, [sp, #12]
 8002122:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002124:	9801      	ldr	r0, [sp, #4]
 8002126:	f7ff fed3 	bl	8001ed0 <chMtxQueueNotEmptyS>
 800212a:	4603      	mov	r3, r0
 800212c:	2b00      	cmp	r3, #0
 800212e:	d032      	beq.n	8002196 <chMtxUnlockS+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002130:	9b03      	ldr	r3, [sp, #12]
 8002132:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002134:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 8002136:	9b03      	ldr	r3, [sp, #12]
 8002138:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800213a:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 800213c:	e012      	b.n	8002164 <chMtxUnlockS+0x54>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800213e:	9805      	ldr	r0, [sp, #20]
 8002140:	f7ff fec6 	bl	8001ed0 <chMtxQueueNotEmptyS>
 8002144:	4603      	mov	r3, r0
 8002146:	2b00      	cmp	r3, #0
 8002148:	d009      	beq.n	800215e <chMtxUnlockS+0x4e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800214a:	9b05      	ldr	r3, [sp, #20]
 800214c:	681b      	ldr	r3, [r3, #0]
 800214e:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002150:	9b04      	ldr	r3, [sp, #16]
 8002152:	429a      	cmp	r2, r3
 8002154:	d903      	bls.n	800215e <chMtxUnlockS+0x4e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 8002156:	9b05      	ldr	r3, [sp, #20]
 8002158:	681b      	ldr	r3, [r3, #0]
 800215a:	689b      	ldr	r3, [r3, #8]
 800215c:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 800215e:	9b05      	ldr	r3, [sp, #20]
 8002160:	68db      	ldr	r3, [r3, #12]
 8002162:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002164:	9b05      	ldr	r3, [sp, #20]
 8002166:	2b00      	cmp	r3, #0
 8002168:	d1e9      	bne.n	800213e <chMtxUnlockS+0x2e>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800216a:	9b03      	ldr	r3, [sp, #12]
 800216c:	9a04      	ldr	r2, [sp, #16]
 800216e:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 8002170:	9b01      	ldr	r3, [sp, #4]
 8002172:	4618      	mov	r0, r3
 8002174:	f7ff fe74 	bl	8001e60 <queue_fifo_remove>
 8002178:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 800217a:	9b01      	ldr	r3, [sp, #4]
 800217c:	9a02      	ldr	r2, [sp, #8]
 800217e:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8002180:	9b02      	ldr	r3, [sp, #8]
 8002182:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002184:	9b01      	ldr	r3, [sp, #4]
 8002186:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 8002188:	9b02      	ldr	r3, [sp, #8]
 800218a:	9a01      	ldr	r2, [sp, #4]
 800218c:	639a      	str	r2, [r3, #56]	; 0x38
      (void) chSchReadyI(tp);
 800218e:	9802      	ldr	r0, [sp, #8]
 8002190:	f7fe fd06 	bl	8000ba0 <chSchReadyI>
 8002194:	e002      	b.n	800219c <chMtxUnlockS+0x8c>
    }
    else {
      mp->m_owner = NULL;
 8002196:	9b01      	ldr	r3, [sp, #4]
 8002198:	2200      	movs	r2, #0
 800219a:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800219c:	b007      	add	sp, #28
 800219e:	f85d fb04 	ldr.w	pc, [sp], #4
 80021a2:	bf00      	nop
 80021a4:	200039a8 	.word	0x200039a8
 80021a8:	f3af 8000 	nop.w
 80021ac:	f3af 8000 	nop.w

080021b0 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 80021b0:	b500      	push	{lr}
 80021b2:	b085      	sub	sp, #20
  thread_t *ctp = currp;
 80021b4:	4b1d      	ldr	r3, [pc, #116]	; (800222c <chMtxUnlockAll+0x7c>)
 80021b6:	699b      	ldr	r3, [r3, #24]
 80021b8:	9303      	str	r3, [sp, #12]

  chSysLock();
 80021ba:	f7ff fe79 	bl	8001eb0 <chSysLock>
  if (ctp->p_mtxlist != NULL) {
 80021be:	9b03      	ldr	r3, [sp, #12]
 80021c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80021c2:	2b00      	cmp	r3, #0
 80021c4:	d02c      	beq.n	8002220 <chMtxUnlockAll+0x70>
    do {
      mutex_t *mp = ctp->p_mtxlist;
 80021c6:	9b03      	ldr	r3, [sp, #12]
 80021c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80021ca:	9302      	str	r3, [sp, #8]
      ctp->p_mtxlist = mp->m_next;
 80021cc:	9b02      	ldr	r3, [sp, #8]
 80021ce:	68da      	ldr	r2, [r3, #12]
 80021d0:	9b03      	ldr	r3, [sp, #12]
 80021d2:	639a      	str	r2, [r3, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 80021d4:	9802      	ldr	r0, [sp, #8]
 80021d6:	f7ff fe7b 	bl	8001ed0 <chMtxQueueNotEmptyS>
 80021da:	4603      	mov	r3, r0
 80021dc:	2b00      	cmp	r3, #0
 80021de:	d012      	beq.n	8002206 <chMtxUnlockAll+0x56>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
 80021e0:	9b02      	ldr	r3, [sp, #8]
 80021e2:	4618      	mov	r0, r3
 80021e4:	f7ff fe3c 	bl	8001e60 <queue_fifo_remove>
 80021e8:	9001      	str	r0, [sp, #4]
        mp->m_owner = tp;
 80021ea:	9b02      	ldr	r3, [sp, #8]
 80021ec:	9a01      	ldr	r2, [sp, #4]
 80021ee:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 80021f0:	9b01      	ldr	r3, [sp, #4]
 80021f2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80021f4:	9b02      	ldr	r3, [sp, #8]
 80021f6:	60da      	str	r2, [r3, #12]
        tp->p_mtxlist = mp;
 80021f8:	9b01      	ldr	r3, [sp, #4]
 80021fa:	9a02      	ldr	r2, [sp, #8]
 80021fc:	639a      	str	r2, [r3, #56]	; 0x38
        (void) chSchReadyI(tp);
 80021fe:	9801      	ldr	r0, [sp, #4]
 8002200:	f7fe fcce 	bl	8000ba0 <chSchReadyI>
 8002204:	e002      	b.n	800220c <chMtxUnlockAll+0x5c>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8002206:	9b02      	ldr	r3, [sp, #8]
 8002208:	2200      	movs	r2, #0
 800220a:	609a      	str	r2, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 800220c:	9b03      	ldr	r3, [sp, #12]
 800220e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002210:	2b00      	cmp	r3, #0
 8002212:	d1d8      	bne.n	80021c6 <chMtxUnlockAll+0x16>
    ctp->p_prio = ctp->p_realprio;
 8002214:	9b03      	ldr	r3, [sp, #12]
 8002216:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002218:	9b03      	ldr	r3, [sp, #12]
 800221a:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
 800221c:	f7fe fdb0 	bl	8000d80 <chSchRescheduleS>
  }
  chSysUnlock();
 8002220:	f7ff fe4e 	bl	8001ec0 <chSysUnlock>
}
 8002224:	b005      	add	sp, #20
 8002226:	f85d fb04 	ldr.w	pc, [sp], #4
 800222a:	bf00      	nop
 800222c:	200039a8 	.word	0x200039a8

08002230 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002230:	b082      	sub	sp, #8
 8002232:	2320      	movs	r3, #32
 8002234:	9301      	str	r3, [sp, #4]
 8002236:	9b01      	ldr	r3, [sp, #4]
 8002238:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800223c:	b002      	add	sp, #8
 800223e:	4770      	bx	lr

08002240 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002240:	b082      	sub	sp, #8
 8002242:	2300      	movs	r3, #0
 8002244:	9301      	str	r3, [sp, #4]
 8002246:	9b01      	ldr	r3, [sp, #4]
 8002248:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800224c:	b002      	add	sp, #8
 800224e:	4770      	bx	lr

08002250 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002250:	b082      	sub	sp, #8
 8002252:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002254:	9b01      	ldr	r3, [sp, #4]
 8002256:	9a01      	ldr	r2, [sp, #4]
 8002258:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800225a:	9b01      	ldr	r3, [sp, #4]
 800225c:	9a01      	ldr	r2, [sp, #4]
 800225e:	605a      	str	r2, [r3, #4]
}
 8002260:	b002      	add	sp, #8
 8002262:	4770      	bx	lr
 8002264:	f3af 8000 	nop.w
 8002268:	f3af 8000 	nop.w
 800226c:	f3af 8000 	nop.w

08002270 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002270:	b082      	sub	sp, #8
 8002272:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002274:	9b01      	ldr	r3, [sp, #4]
 8002276:	681a      	ldr	r2, [r3, #0]
 8002278:	9b01      	ldr	r3, [sp, #4]
 800227a:	429a      	cmp	r2, r3
 800227c:	bf0c      	ite	eq
 800227e:	2300      	moveq	r3, #0
 8002280:	2301      	movne	r3, #1
 8002282:	b2db      	uxtb	r3, r3
}
 8002284:	4618      	mov	r0, r3
 8002286:	b002      	add	sp, #8
 8002288:	4770      	bx	lr
 800228a:	bf00      	nop
 800228c:	f3af 8000 	nop.w

08002290 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8002290:	b084      	sub	sp, #16
 8002292:	9001      	str	r0, [sp, #4]
 8002294:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8002296:	9b00      	ldr	r3, [sp, #0]
 8002298:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800229a:	9b03      	ldr	r3, [sp, #12]
 800229c:	681b      	ldr	r3, [r3, #0]
 800229e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80022a0:	9a03      	ldr	r2, [sp, #12]
 80022a2:	9b00      	ldr	r3, [sp, #0]
 80022a4:	429a      	cmp	r2, r3
 80022a6:	d005      	beq.n	80022b4 <queue_prio_insert+0x24>
 80022a8:	9b03      	ldr	r3, [sp, #12]
 80022aa:	689a      	ldr	r2, [r3, #8]
 80022ac:	9b01      	ldr	r3, [sp, #4]
 80022ae:	689b      	ldr	r3, [r3, #8]
 80022b0:	429a      	cmp	r2, r3
 80022b2:	d2f2      	bcs.n	800229a <queue_prio_insert+0xa>
  tp->p_next = cp;
 80022b4:	9b01      	ldr	r3, [sp, #4]
 80022b6:	9a03      	ldr	r2, [sp, #12]
 80022b8:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 80022ba:	9b03      	ldr	r3, [sp, #12]
 80022bc:	685a      	ldr	r2, [r3, #4]
 80022be:	9b01      	ldr	r3, [sp, #4]
 80022c0:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80022c2:	9b01      	ldr	r3, [sp, #4]
 80022c4:	685b      	ldr	r3, [r3, #4]
 80022c6:	9a01      	ldr	r2, [sp, #4]
 80022c8:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 80022ca:	9b03      	ldr	r3, [sp, #12]
 80022cc:	9a01      	ldr	r2, [sp, #4]
 80022ce:	605a      	str	r2, [r3, #4]
}
 80022d0:	b004      	add	sp, #16
 80022d2:	4770      	bx	lr
 80022d4:	f3af 8000 	nop.w
 80022d8:	f3af 8000 	nop.w
 80022dc:	f3af 8000 	nop.w

080022e0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80022e0:	b084      	sub	sp, #16
 80022e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 80022e4:	9b01      	ldr	r3, [sp, #4]
 80022e6:	681b      	ldr	r3, [r3, #0]
 80022e8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 80022ea:	9b03      	ldr	r3, [sp, #12]
 80022ec:	681a      	ldr	r2, [r3, #0]
 80022ee:	9b01      	ldr	r3, [sp, #4]
 80022f0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80022f2:	9b01      	ldr	r3, [sp, #4]
 80022f4:	681b      	ldr	r3, [r3, #0]
 80022f6:	9a01      	ldr	r2, [sp, #4]
 80022f8:	605a      	str	r2, [r3, #4]

  return tp;
 80022fa:	9b03      	ldr	r3, [sp, #12]
}
 80022fc:	4618      	mov	r0, r3
 80022fe:	b004      	add	sp, #16
 8002300:	4770      	bx	lr
 8002302:	bf00      	nop
 8002304:	f3af 8000 	nop.w
 8002308:	f3af 8000 	nop.w
 800230c:	f3af 8000 	nop.w

08002310 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002310:	b508      	push	{r3, lr}

  port_lock();
 8002312:	f7ff ff8d 	bl	8002230 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002316:	bd08      	pop	{r3, pc}
 8002318:	f3af 8000 	nop.w
 800231c:	f3af 8000 	nop.w

08002320 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002320:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002322:	f7ff ff8d 	bl	8002240 <port_unlock>
}
 8002326:	bd08      	pop	{r3, pc}
 8002328:	f3af 8000 	nop.w
 800232c:	f3af 8000 	nop.w

08002330 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002330:	4b01      	ldr	r3, [pc, #4]	; (8002338 <chThdGetSelfX+0x8>)
 8002332:	699b      	ldr	r3, [r3, #24]
}
 8002334:	4618      	mov	r0, r3
 8002336:	4770      	bx	lr
 8002338:	200039a8 	.word	0x200039a8
 800233c:	f3af 8000 	nop.w

08002340 <chMtxGetNextMutexS>:
 * @return              A pointer to the next mutex in the stack.
 * @retval NULL         if the stack is empty.
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {
 8002340:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_mtxlist;
 8002342:	f7ff fff5 	bl	8002330 <chThdGetSelfX>
 8002346:	4603      	mov	r3, r0
 8002348:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 800234a:	4618      	mov	r0, r3
 800234c:	bd08      	pop	{r3, pc}
 800234e:	bf00      	nop

08002350 <chCondObjectInit>:
 *
 * @param[out] cp       pointer to a @p condition_variable_t structure
 *
 * @init
 */
void chCondObjectInit(condition_variable_t *cp) {
 8002350:	b500      	push	{lr}
 8002352:	b083      	sub	sp, #12
 8002354:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  queue_init(&cp->c_queue);
 8002356:	9b01      	ldr	r3, [sp, #4]
 8002358:	4618      	mov	r0, r3
 800235a:	f7ff ff79 	bl	8002250 <queue_init>
}
 800235e:	b003      	add	sp, #12
 8002360:	f85d fb04 	ldr.w	pc, [sp], #4
 8002364:	f3af 8000 	nop.w
 8002368:	f3af 8000 	nop.w
 800236c:	f3af 8000 	nop.w

08002370 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8002370:	b500      	push	{lr}
 8002372:	b083      	sub	sp, #12
 8002374:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  chSysLock();
 8002376:	f7ff ffcb 	bl	8002310 <chSysLock>
  if (queue_notempty(&cp->c_queue)) {
 800237a:	9b01      	ldr	r3, [sp, #4]
 800237c:	4618      	mov	r0, r3
 800237e:	f7ff ff77 	bl	8002270 <queue_notempty>
 8002382:	4603      	mov	r3, r0
 8002384:	2b00      	cmp	r3, #0
 8002386:	d008      	beq.n	800239a <chCondSignal+0x2a>
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8002388:	9b01      	ldr	r3, [sp, #4]
 800238a:	4618      	mov	r0, r3
 800238c:	f7ff ffa8 	bl	80022e0 <queue_fifo_remove>
 8002390:	4603      	mov	r3, r0
 8002392:	4618      	mov	r0, r3
 8002394:	2100      	movs	r1, #0
 8002396:	f7fe fccb 	bl	8000d30 <chSchWakeupS>
  }
  chSysUnlock();
 800239a:	f7ff ffc1 	bl	8002320 <chSysUnlock>
}
 800239e:	b003      	add	sp, #12
 80023a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80023a4:	f3af 8000 	nop.w
 80023a8:	f3af 8000 	nop.w
 80023ac:	f3af 8000 	nop.w

080023b0 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 80023b0:	b500      	push	{lr}
 80023b2:	b085      	sub	sp, #20
 80023b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 80023b6:	9b01      	ldr	r3, [sp, #4]
 80023b8:	4618      	mov	r0, r3
 80023ba:	f7ff ff59 	bl	8002270 <queue_notempty>
 80023be:	4603      	mov	r3, r0
 80023c0:	2b00      	cmp	r3, #0
 80023c2:	d00a      	beq.n	80023da <chCondSignalI+0x2a>
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
 80023c4:	9b01      	ldr	r3, [sp, #4]
 80023c6:	4618      	mov	r0, r3
 80023c8:	f7ff ff8a 	bl	80022e0 <queue_fifo_remove>
 80023cc:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 80023ce:	9b03      	ldr	r3, [sp, #12]
 80023d0:	2200      	movs	r2, #0
 80023d2:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80023d4:	9803      	ldr	r0, [sp, #12]
 80023d6:	f7fe fbe3 	bl	8000ba0 <chSchReadyI>
  }
}
 80023da:	b005      	add	sp, #20
 80023dc:	f85d fb04 	ldr.w	pc, [sp], #4

080023e0 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 80023e0:	b500      	push	{lr}
 80023e2:	b083      	sub	sp, #12
 80023e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80023e6:	f7ff ff93 	bl	8002310 <chSysLock>
  chCondBroadcastI(cp);
 80023ea:	9801      	ldr	r0, [sp, #4]
 80023ec:	f000 f808 	bl	8002400 <chCondBroadcastI>
  chSchRescheduleS();
 80023f0:	f7fe fcc6 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 80023f4:	f7ff ff94 	bl	8002320 <chSysUnlock>
}
 80023f8:	b003      	add	sp, #12
 80023fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80023fe:	bf00      	nop

08002400 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 8002400:	b500      	push	{lr}
 8002402:	b083      	sub	sp, #12
 8002404:	9001      	str	r0, [sp, #4]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002406:	e00b      	b.n	8002420 <chCondBroadcastI+0x20>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8002408:	9b01      	ldr	r3, [sp, #4]
 800240a:	4618      	mov	r0, r3
 800240c:	f7ff ff68 	bl	80022e0 <queue_fifo_remove>
 8002410:	4603      	mov	r3, r0
 8002412:	4618      	mov	r0, r3
 8002414:	f7fe fbc4 	bl	8000ba0 <chSchReadyI>
 8002418:	4603      	mov	r3, r0
 800241a:	f06f 0201 	mvn.w	r2, #1
 800241e:	621a      	str	r2, [r3, #32]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002420:	9b01      	ldr	r3, [sp, #4]
 8002422:	4618      	mov	r0, r3
 8002424:	f7ff ff24 	bl	8002270 <queue_notempty>
 8002428:	4603      	mov	r3, r0
 800242a:	2b00      	cmp	r3, #0
 800242c:	d1ec      	bne.n	8002408 <chCondBroadcastI+0x8>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 800242e:	b003      	add	sp, #12
 8002430:	f85d fb04 	ldr.w	pc, [sp], #4
 8002434:	f3af 8000 	nop.w
 8002438:	f3af 8000 	nop.w
 800243c:	f3af 8000 	nop.w

08002440 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8002440:	b500      	push	{lr}
 8002442:	b085      	sub	sp, #20
 8002444:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8002446:	f7ff ff63 	bl	8002310 <chSysLock>
  msg = chCondWaitS(cp);
 800244a:	9801      	ldr	r0, [sp, #4]
 800244c:	f000 f808 	bl	8002460 <chCondWaitS>
 8002450:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8002452:	f7ff ff65 	bl	8002320 <chSysUnlock>
  return msg;
 8002456:	9b03      	ldr	r3, [sp, #12]
}
 8002458:	4618      	mov	r0, r3
 800245a:	b005      	add	sp, #20
 800245c:	f85d fb04 	ldr.w	pc, [sp], #4

08002460 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 8002460:	b500      	push	{lr}
 8002462:	b087      	sub	sp, #28
 8002464:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002466:	4b0f      	ldr	r3, [pc, #60]	; (80024a4 <chCondWaitS+0x44>)
 8002468:	699b      	ldr	r3, [r3, #24]
 800246a:	9305      	str	r3, [sp, #20]
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 800246c:	f7ff ff68 	bl	8002340 <chMtxGetNextMutexS>
 8002470:	9004      	str	r0, [sp, #16]
  chMtxUnlockS(mp);
 8002472:	9804      	ldr	r0, [sp, #16]
 8002474:	f7ff fe4c 	bl	8002110 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 8002478:	9b05      	ldr	r3, [sp, #20]
 800247a:	9a01      	ldr	r2, [sp, #4]
 800247c:	621a      	str	r2, [r3, #32]
  queue_prio_insert(ctp, &cp->c_queue);
 800247e:	9b01      	ldr	r3, [sp, #4]
 8002480:	9805      	ldr	r0, [sp, #20]
 8002482:	4619      	mov	r1, r3
 8002484:	f7ff ff04 	bl	8002290 <queue_prio_insert>
  chSchGoSleepS(CH_STATE_WTCOND);
 8002488:	2007      	movs	r0, #7
 800248a:	f7fe fbb1 	bl	8000bf0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 800248e:	9b05      	ldr	r3, [sp, #20]
 8002490:	6a1b      	ldr	r3, [r3, #32]
 8002492:	9303      	str	r3, [sp, #12]
  chMtxLockS(mp);
 8002494:	9804      	ldr	r0, [sp, #16]
 8002496:	f7ff fd4b 	bl	8001f30 <chMtxLockS>

  return msg;
 800249a:	9b03      	ldr	r3, [sp, #12]
}
 800249c:	4618      	mov	r0, r3
 800249e:	b007      	add	sp, #28
 80024a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80024a4:	200039a8 	.word	0x200039a8
 80024a8:	f3af 8000 	nop.w
 80024ac:	f3af 8000 	nop.w

080024b0 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 80024b0:	b500      	push	{lr}
 80024b2:	b085      	sub	sp, #20
 80024b4:	9001      	str	r0, [sp, #4]
 80024b6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 80024b8:	f7ff ff2a 	bl	8002310 <chSysLock>
  msg = chCondWaitTimeoutS(cp, time);
 80024bc:	9801      	ldr	r0, [sp, #4]
 80024be:	9900      	ldr	r1, [sp, #0]
 80024c0:	f000 f80e 	bl	80024e0 <chCondWaitTimeoutS>
 80024c4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 80024c6:	f7ff ff2b 	bl	8002320 <chSysUnlock>

  return msg;
 80024ca:	9b03      	ldr	r3, [sp, #12]
}
 80024cc:	4618      	mov	r0, r3
 80024ce:	b005      	add	sp, #20
 80024d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80024d4:	f3af 8000 	nop.w
 80024d8:	f3af 8000 	nop.w
 80024dc:	f3af 8000 	nop.w

080024e0 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 80024e0:	b500      	push	{lr}
 80024e2:	b085      	sub	sp, #20
 80024e4:	9001      	str	r0, [sp, #4]
 80024e6:	9100      	str	r1, [sp, #0]
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 80024e8:	f7ff ff2a 	bl	8002340 <chMtxGetNextMutexS>
 80024ec:	9003      	str	r0, [sp, #12]
  chMtxUnlockS(mp);
 80024ee:	9803      	ldr	r0, [sp, #12]
 80024f0:	f7ff fe0e 	bl	8002110 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 80024f4:	4b0d      	ldr	r3, [pc, #52]	; (800252c <chCondWaitTimeoutS+0x4c>)
 80024f6:	699b      	ldr	r3, [r3, #24]
 80024f8:	9a01      	ldr	r2, [sp, #4]
 80024fa:	621a      	str	r2, [r3, #32]
  queue_prio_insert(currp, &cp->c_queue);
 80024fc:	4b0b      	ldr	r3, [pc, #44]	; (800252c <chCondWaitTimeoutS+0x4c>)
 80024fe:	699a      	ldr	r2, [r3, #24]
 8002500:	9b01      	ldr	r3, [sp, #4]
 8002502:	4610      	mov	r0, r2
 8002504:	4619      	mov	r1, r3
 8002506:	f7ff fec3 	bl	8002290 <queue_prio_insert>
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800250a:	2007      	movs	r0, #7
 800250c:	9900      	ldr	r1, [sp, #0]
 800250e:	f7fe fbd7 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002512:	9002      	str	r0, [sp, #8]
  if (msg != MSG_TIMEOUT) {
 8002514:	9b02      	ldr	r3, [sp, #8]
 8002516:	f1b3 3fff 	cmp.w	r3, #4294967295
 800251a:	d002      	beq.n	8002522 <chCondWaitTimeoutS+0x42>
    chMtxLockS(mp);
 800251c:	9803      	ldr	r0, [sp, #12]
 800251e:	f7ff fd07 	bl	8001f30 <chMtxLockS>
  }

  return msg;
 8002522:	9b02      	ldr	r3, [sp, #8]
}
 8002524:	4618      	mov	r0, r3
 8002526:	b005      	add	sp, #20
 8002528:	f85d fb04 	ldr.w	pc, [sp], #4
 800252c:	200039a8 	.word	0x200039a8

08002530 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002530:	b082      	sub	sp, #8
 8002532:	2320      	movs	r3, #32
 8002534:	9301      	str	r3, [sp, #4]
 8002536:	9b01      	ldr	r3, [sp, #4]
 8002538:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800253c:	b002      	add	sp, #8
 800253e:	4770      	bx	lr

08002540 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002540:	b082      	sub	sp, #8
 8002542:	2300      	movs	r3, #0
 8002544:	9301      	str	r3, [sp, #4]
 8002546:	9b01      	ldr	r3, [sp, #4]
 8002548:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800254c:	b002      	add	sp, #8
 800254e:	4770      	bx	lr

08002550 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002550:	b508      	push	{r3, lr}

  port_lock();
 8002552:	f7ff ffed 	bl	8002530 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002556:	bd08      	pop	{r3, pc}
 8002558:	f3af 8000 	nop.w
 800255c:	f3af 8000 	nop.w

08002560 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002560:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002562:	f7ff ffed 	bl	8002540 <port_unlock>
}
 8002566:	bd08      	pop	{r3, pc}
 8002568:	f3af 8000 	nop.w
 800256c:	f3af 8000 	nop.w

08002570 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8002570:	b500      	push	{lr}
 8002572:	b085      	sub	sp, #20
 8002574:	9003      	str	r0, [sp, #12]
 8002576:	9102      	str	r1, [sp, #8]
 8002578:	9201      	str	r2, [sp, #4]
 800257a:	9300      	str	r3, [sp, #0]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
 800257c:	f7ff ffe8 	bl	8002550 <chSysLock>
  elp->el_next     = esp->es_next;
 8002580:	9b03      	ldr	r3, [sp, #12]
 8002582:	681a      	ldr	r2, [r3, #0]
 8002584:	9b02      	ldr	r3, [sp, #8]
 8002586:	601a      	str	r2, [r3, #0]
  esp->es_next     = elp;
 8002588:	9b03      	ldr	r3, [sp, #12]
 800258a:	9a02      	ldr	r2, [sp, #8]
 800258c:	601a      	str	r2, [r3, #0]
  elp->el_listener = currp;
 800258e:	4b09      	ldr	r3, [pc, #36]	; (80025b4 <chEvtRegisterMaskWithFlags+0x44>)
 8002590:	699a      	ldr	r2, [r3, #24]
 8002592:	9b02      	ldr	r3, [sp, #8]
 8002594:	605a      	str	r2, [r3, #4]
  elp->el_events   = events;
 8002596:	9b02      	ldr	r3, [sp, #8]
 8002598:	9a01      	ldr	r2, [sp, #4]
 800259a:	609a      	str	r2, [r3, #8]
  elp->el_flags    = (eventflags_t)0;
 800259c:	9b02      	ldr	r3, [sp, #8]
 800259e:	2200      	movs	r2, #0
 80025a0:	60da      	str	r2, [r3, #12]
  elp->el_wflags   = wflags;
 80025a2:	9b02      	ldr	r3, [sp, #8]
 80025a4:	9a00      	ldr	r2, [sp, #0]
 80025a6:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 80025a8:	f7ff ffda 	bl	8002560 <chSysUnlock>
}
 80025ac:	b005      	add	sp, #20
 80025ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80025b2:	bf00      	nop
 80025b4:	200039a8 	.word	0x200039a8
 80025b8:	f3af 8000 	nop.w
 80025bc:	f3af 8000 	nop.w

080025c0 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 80025c0:	b500      	push	{lr}
 80025c2:	b085      	sub	sp, #20
 80025c4:	9001      	str	r0, [sp, #4]
 80025c6:	9100      	str	r1, [sp, #0]
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80025c8:	9b01      	ldr	r3, [sp, #4]
 80025ca:	9303      	str	r3, [sp, #12]
  /*lint -restore*/
  chSysLock();
 80025cc:	f7ff ffc0 	bl	8002550 <chSysLock>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80025d0:	e00c      	b.n	80025ec <chEvtUnregister+0x2c>
  /*lint -restore*/
    if (p->el_next == elp) {
 80025d2:	9b03      	ldr	r3, [sp, #12]
 80025d4:	681a      	ldr	r2, [r3, #0]
 80025d6:	9b00      	ldr	r3, [sp, #0]
 80025d8:	429a      	cmp	r2, r3
 80025da:	d104      	bne.n	80025e6 <chEvtUnregister+0x26>
      p->el_next = elp->el_next;
 80025dc:	9b00      	ldr	r3, [sp, #0]
 80025de:	681a      	ldr	r2, [r3, #0]
 80025e0:	9b03      	ldr	r3, [sp, #12]
 80025e2:	601a      	str	r2, [r3, #0]
      break;
 80025e4:	e007      	b.n	80025f6 <chEvtUnregister+0x36>
    }
    p = p->el_next;
 80025e6:	9b03      	ldr	r3, [sp, #12]
 80025e8:	681b      	ldr	r3, [r3, #0]
 80025ea:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80025ec:	9b03      	ldr	r3, [sp, #12]
 80025ee:	681a      	ldr	r2, [r3, #0]
 80025f0:	9b01      	ldr	r3, [sp, #4]
 80025f2:	429a      	cmp	r2, r3
 80025f4:	d1ed      	bne.n	80025d2 <chEvtUnregister+0x12>
      p->el_next = elp->el_next;
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
 80025f6:	f7ff ffb3 	bl	8002560 <chSysUnlock>
}
 80025fa:	b005      	add	sp, #20
 80025fc:	f85d fb04 	ldr.w	pc, [sp], #4

08002600 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 8002600:	b500      	push	{lr}
 8002602:	b085      	sub	sp, #20
 8002604:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  chSysLock();
 8002606:	f7ff ffa3 	bl	8002550 <chSysLock>
  m = currp->p_epending & events;
 800260a:	4b0b      	ldr	r3, [pc, #44]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 800260c:	699b      	ldr	r3, [r3, #24]
 800260e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002610:	9b01      	ldr	r3, [sp, #4]
 8002612:	4013      	ands	r3, r2
 8002614:	9303      	str	r3, [sp, #12]
  currp->p_epending &= ~events;
 8002616:	4b08      	ldr	r3, [pc, #32]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 8002618:	699b      	ldr	r3, [r3, #24]
 800261a:	4a07      	ldr	r2, [pc, #28]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 800261c:	6992      	ldr	r2, [r2, #24]
 800261e:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002620:	9a01      	ldr	r2, [sp, #4]
 8002622:	43d2      	mvns	r2, r2
 8002624:	400a      	ands	r2, r1
 8002626:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002628:	f7ff ff9a 	bl	8002560 <chSysUnlock>

  return m;
 800262c:	9b03      	ldr	r3, [sp, #12]
}
 800262e:	4618      	mov	r0, r3
 8002630:	b005      	add	sp, #20
 8002632:	f85d fb04 	ldr.w	pc, [sp], #4
 8002636:	bf00      	nop
 8002638:	200039a8 	.word	0x200039a8
 800263c:	f3af 8000 	nop.w

08002640 <chEvtAddEvents>:
 * @param[in] events    the events to be added
 * @return              The current pending events.
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {
 8002640:	b500      	push	{lr}
 8002642:	b083      	sub	sp, #12
 8002644:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002646:	f7ff ff83 	bl	8002550 <chSysLock>
  currp->p_epending |= events;
 800264a:	4b09      	ldr	r3, [pc, #36]	; (8002670 <chEvtAddEvents+0x30>)
 800264c:	699b      	ldr	r3, [r3, #24]
 800264e:	4a08      	ldr	r2, [pc, #32]	; (8002670 <chEvtAddEvents+0x30>)
 8002650:	6992      	ldr	r2, [r2, #24]
 8002652:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002654:	9a01      	ldr	r2, [sp, #4]
 8002656:	430a      	orrs	r2, r1
 8002658:	635a      	str	r2, [r3, #52]	; 0x34
  events = currp->p_epending;
 800265a:	4b05      	ldr	r3, [pc, #20]	; (8002670 <chEvtAddEvents+0x30>)
 800265c:	699b      	ldr	r3, [r3, #24]
 800265e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002660:	9301      	str	r3, [sp, #4]
  chSysUnlock();
 8002662:	f7ff ff7d 	bl	8002560 <chSysUnlock>

  return events;
 8002666:	9b01      	ldr	r3, [sp, #4]
}
 8002668:	4618      	mov	r0, r3
 800266a:	b003      	add	sp, #12
 800266c:	f85d fb04 	ldr.w	pc, [sp], #4
 8002670:	200039a8 	.word	0x200039a8
 8002674:	f3af 8000 	nop.w
 8002678:	f3af 8000 	nop.w
 800267c:	f3af 8000 	nop.w

08002680 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002680:	b500      	push	{lr}
 8002682:	b085      	sub	sp, #20
 8002684:	9001      	str	r0, [sp, #4]
 8002686:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8002688:	9b01      	ldr	r3, [sp, #4]
 800268a:	681b      	ldr	r3, [r3, #0]
 800268c:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800268e:	e01a      	b.n	80026c6 <chEvtBroadcastFlagsI+0x46>
  /*lint -restore*/
    elp->el_flags |= flags;
 8002690:	9b03      	ldr	r3, [sp, #12]
 8002692:	68da      	ldr	r2, [r3, #12]
 8002694:	9b00      	ldr	r3, [sp, #0]
 8002696:	431a      	orrs	r2, r3
 8002698:	9b03      	ldr	r3, [sp, #12]
 800269a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800269c:	9b00      	ldr	r3, [sp, #0]
 800269e:	2b00      	cmp	r3, #0
 80026a0:	d006      	beq.n	80026b0 <chEvtBroadcastFlagsI+0x30>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 80026a2:	9b03      	ldr	r3, [sp, #12]
 80026a4:	68da      	ldr	r2, [r3, #12]
 80026a6:	9b03      	ldr	r3, [sp, #12]
 80026a8:	691b      	ldr	r3, [r3, #16]
 80026aa:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80026ac:	2b00      	cmp	r3, #0
 80026ae:	d007      	beq.n	80026c0 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 80026b0:	9b03      	ldr	r3, [sp, #12]
 80026b2:	685a      	ldr	r2, [r3, #4]
 80026b4:	9b03      	ldr	r3, [sp, #12]
 80026b6:	689b      	ldr	r3, [r3, #8]
 80026b8:	4610      	mov	r0, r2
 80026ba:	4619      	mov	r1, r3
 80026bc:	f000 f840 	bl	8002740 <chEvtSignalI>
    }
    elp = elp->el_next;
 80026c0:	9b03      	ldr	r3, [sp, #12]
 80026c2:	681b      	ldr	r3, [r3, #0]
 80026c4:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80026c6:	9a03      	ldr	r2, [sp, #12]
 80026c8:	9b01      	ldr	r3, [sp, #4]
 80026ca:	429a      	cmp	r2, r3
 80026cc:	d1e0      	bne.n	8002690 <chEvtBroadcastFlagsI+0x10>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 80026ce:	b005      	add	sp, #20
 80026d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80026d4:	f3af 8000 	nop.w
 80026d8:	f3af 8000 	nop.w
 80026dc:	f3af 8000 	nop.w

080026e0 <chEvtGetAndClearFlags>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @api
 */
eventflags_t chEvtGetAndClearFlags(event_listener_t *elp) {
 80026e0:	b500      	push	{lr}
 80026e2:	b085      	sub	sp, #20
 80026e4:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  chSysLock();
 80026e6:	f7ff ff33 	bl	8002550 <chSysLock>
  flags = elp->el_flags;
 80026ea:	9b01      	ldr	r3, [sp, #4]
 80026ec:	68db      	ldr	r3, [r3, #12]
 80026ee:	9303      	str	r3, [sp, #12]
  elp->el_flags = (eventflags_t)0;
 80026f0:	9b01      	ldr	r3, [sp, #4]
 80026f2:	2200      	movs	r2, #0
 80026f4:	60da      	str	r2, [r3, #12]
  chSysUnlock();
 80026f6:	f7ff ff33 	bl	8002560 <chSysUnlock>

  return flags;
 80026fa:	9b03      	ldr	r3, [sp, #12]
}
 80026fc:	4618      	mov	r0, r3
 80026fe:	b005      	add	sp, #20
 8002700:	f85d fb04 	ldr.w	pc, [sp], #4
 8002704:	f3af 8000 	nop.w
 8002708:	f3af 8000 	nop.w
 800270c:	f3af 8000 	nop.w

08002710 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 8002710:	b500      	push	{lr}
 8002712:	b083      	sub	sp, #12
 8002714:	9001      	str	r0, [sp, #4]
 8002716:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002718:	f7ff ff1a 	bl	8002550 <chSysLock>
  chEvtSignalI(tp, events);
 800271c:	9801      	ldr	r0, [sp, #4]
 800271e:	9900      	ldr	r1, [sp, #0]
 8002720:	f000 f80e 	bl	8002740 <chEvtSignalI>
  chSchRescheduleS();
 8002724:	f7fe fb2c 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8002728:	f7ff ff1a 	bl	8002560 <chSysUnlock>
}
 800272c:	b003      	add	sp, #12
 800272e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002732:	bf00      	nop
 8002734:	f3af 8000 	nop.w
 8002738:	f3af 8000 	nop.w
 800273c:	f3af 8000 	nop.w

08002740 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8002740:	b500      	push	{lr}
 8002742:	b083      	sub	sp, #12
 8002744:	9001      	str	r0, [sp, #4]
 8002746:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002748:	9b01      	ldr	r3, [sp, #4]
 800274a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800274c:	9b00      	ldr	r3, [sp, #0]
 800274e:	431a      	orrs	r2, r3
 8002750:	9b01      	ldr	r3, [sp, #4]
 8002752:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002754:	9b01      	ldr	r3, [sp, #4]
 8002756:	7f1b      	ldrb	r3, [r3, #28]
 8002758:	2b0a      	cmp	r3, #10
 800275a:	d106      	bne.n	800276a <chEvtSignalI+0x2a>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800275c:	9b01      	ldr	r3, [sp, #4]
 800275e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002760:	9b01      	ldr	r3, [sp, #4]
 8002762:	6a1b      	ldr	r3, [r3, #32]
 8002764:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002766:	2b00      	cmp	r3, #0
 8002768:	d10c      	bne.n	8002784 <chEvtSignalI+0x44>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800276a:	9b01      	ldr	r3, [sp, #4]
 800276c:	7f1b      	ldrb	r3, [r3, #28]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800276e:	2b0b      	cmp	r3, #11
 8002770:	d10e      	bne.n	8002790 <chEvtSignalI+0x50>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8002772:	9b01      	ldr	r3, [sp, #4]
 8002774:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002776:	9b01      	ldr	r3, [sp, #4]
 8002778:	6a1b      	ldr	r3, [r3, #32]
 800277a:	401a      	ands	r2, r3
 800277c:	9b01      	ldr	r3, [sp, #4]
 800277e:	6a1b      	ldr	r3, [r3, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8002780:	429a      	cmp	r2, r3
 8002782:	d105      	bne.n	8002790 <chEvtSignalI+0x50>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8002784:	9b01      	ldr	r3, [sp, #4]
 8002786:	2200      	movs	r2, #0
 8002788:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 800278a:	9801      	ldr	r0, [sp, #4]
 800278c:	f7fe fa08 	bl	8000ba0 <chSchReadyI>
  }
}
 8002790:	b003      	add	sp, #12
 8002792:	f85d fb04 	ldr.w	pc, [sp], #4
 8002796:	bf00      	nop
 8002798:	f3af 8000 	nop.w
 800279c:	f3af 8000 	nop.w

080027a0 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 80027a0:	b500      	push	{lr}
 80027a2:	b083      	sub	sp, #12
 80027a4:	9001      	str	r0, [sp, #4]
 80027a6:	9100      	str	r1, [sp, #0]

  chSysLock();
 80027a8:	f7ff fed2 	bl	8002550 <chSysLock>
  chEvtBroadcastFlagsI(esp, flags);
 80027ac:	9801      	ldr	r0, [sp, #4]
 80027ae:	9900      	ldr	r1, [sp, #0]
 80027b0:	f7ff ff66 	bl	8002680 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80027b4:	f7fe fae4 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 80027b8:	f7ff fed2 	bl	8002560 <chSysUnlock>
}
 80027bc:	b003      	add	sp, #12
 80027be:	f85d fb04 	ldr.w	pc, [sp], #4
 80027c2:	bf00      	nop
 80027c4:	f3af 8000 	nop.w
 80027c8:	f3af 8000 	nop.w
 80027cc:	f3af 8000 	nop.w

080027d0 <chEvtGetAndClearFlagsI>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
eventflags_t chEvtGetAndClearFlagsI(event_listener_t *elp) {
 80027d0:	b084      	sub	sp, #16
 80027d2:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  flags = elp->el_flags;
 80027d4:	9b01      	ldr	r3, [sp, #4]
 80027d6:	68db      	ldr	r3, [r3, #12]
 80027d8:	9303      	str	r3, [sp, #12]
  elp->el_flags = (eventflags_t)0;
 80027da:	9b01      	ldr	r3, [sp, #4]
 80027dc:	2200      	movs	r2, #0
 80027de:	60da      	str	r2, [r3, #12]

  return flags;
 80027e0:	9b03      	ldr	r3, [sp, #12]
}
 80027e2:	4618      	mov	r0, r3
 80027e4:	b004      	add	sp, #16
 80027e6:	4770      	bx	lr
 80027e8:	f3af 8000 	nop.w
 80027ec:	f3af 8000 	nop.w

080027f0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 80027f0:	b500      	push	{lr}
 80027f2:	b085      	sub	sp, #20
 80027f4:	9001      	str	r0, [sp, #4]
 80027f6:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 80027f8:	2300      	movs	r3, #0
 80027fa:	9303      	str	r3, [sp, #12]
  while (events != (eventmask_t)0) {
 80027fc:	e019      	b.n	8002832 <chEvtDispatch+0x42>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80027fe:	9a00      	ldr	r2, [sp, #0]
 8002800:	9b03      	ldr	r3, [sp, #12]
 8002802:	fa22 f303 	lsr.w	r3, r2, r3
 8002806:	f003 0301 	and.w	r3, r3, #1
 800280a:	2b00      	cmp	r3, #0
 800280c:	d00e      	beq.n	800282c <chEvtDispatch+0x3c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 800280e:	2201      	movs	r2, #1
 8002810:	9b03      	ldr	r3, [sp, #12]
 8002812:	fa02 f303 	lsl.w	r3, r2, r3
 8002816:	43db      	mvns	r3, r3
 8002818:	9a00      	ldr	r2, [sp, #0]
 800281a:	4013      	ands	r3, r2
 800281c:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
 800281e:	9b03      	ldr	r3, [sp, #12]
 8002820:	009b      	lsls	r3, r3, #2
 8002822:	9a01      	ldr	r2, [sp, #4]
 8002824:	4413      	add	r3, r2
 8002826:	681b      	ldr	r3, [r3, #0]
 8002828:	9803      	ldr	r0, [sp, #12]
 800282a:	4798      	blx	r3
    }
    eid++;
 800282c:	9b03      	ldr	r3, [sp, #12]
 800282e:	3301      	adds	r3, #1
 8002830:	9303      	str	r3, [sp, #12]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002832:	9b00      	ldr	r3, [sp, #0]
 8002834:	2b00      	cmp	r3, #0
 8002836:	d1e2      	bne.n	80027fe <chEvtDispatch+0xe>
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
 8002838:	b005      	add	sp, #20
 800283a:	f85d fb04 	ldr.w	pc, [sp], #4
 800283e:	bf00      	nop

08002840 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002840:	b500      	push	{lr}
 8002842:	b085      	sub	sp, #20
 8002844:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002846:	4b15      	ldr	r3, [pc, #84]	; (800289c <chEvtWaitOne+0x5c>)
 8002848:	699b      	ldr	r3, [r3, #24]
 800284a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800284c:	f7ff fe80 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 8002850:	9b02      	ldr	r3, [sp, #8]
 8002852:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002854:	9b01      	ldr	r3, [sp, #4]
 8002856:	4013      	ands	r3, r2
 8002858:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800285a:	9b03      	ldr	r3, [sp, #12]
 800285c:	2b00      	cmp	r3, #0
 800285e:	d10a      	bne.n	8002876 <chEvtWaitOne+0x36>
    ctp->p_u.ewmask = events;
 8002860:	9b02      	ldr	r3, [sp, #8]
 8002862:	9a01      	ldr	r2, [sp, #4]
 8002864:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002866:	200a      	movs	r0, #10
 8002868:	f7fe f9c2 	bl	8000bf0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800286c:	9b02      	ldr	r3, [sp, #8]
 800286e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002870:	9b01      	ldr	r3, [sp, #4]
 8002872:	4013      	ands	r3, r2
 8002874:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8002876:	9b03      	ldr	r3, [sp, #12]
 8002878:	425b      	negs	r3, r3
 800287a:	9a03      	ldr	r2, [sp, #12]
 800287c:	4013      	ands	r3, r2
 800287e:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 8002880:	9b02      	ldr	r3, [sp, #8]
 8002882:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002884:	9b03      	ldr	r3, [sp, #12]
 8002886:	43db      	mvns	r3, r3
 8002888:	401a      	ands	r2, r3
 800288a:	9b02      	ldr	r3, [sp, #8]
 800288c:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 800288e:	f7ff fe67 	bl	8002560 <chSysUnlock>

  return m;
 8002892:	9b03      	ldr	r3, [sp, #12]
}
 8002894:	4618      	mov	r0, r3
 8002896:	b005      	add	sp, #20
 8002898:	f85d fb04 	ldr.w	pc, [sp], #4
 800289c:	200039a8 	.word	0x200039a8

080028a0 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 80028a0:	b500      	push	{lr}
 80028a2:	b085      	sub	sp, #20
 80028a4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80028a6:	4b13      	ldr	r3, [pc, #76]	; (80028f4 <chEvtWaitAny+0x54>)
 80028a8:	699b      	ldr	r3, [r3, #24]
 80028aa:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80028ac:	f7ff fe50 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 80028b0:	9b02      	ldr	r3, [sp, #8]
 80028b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028b4:	9b01      	ldr	r3, [sp, #4]
 80028b6:	4013      	ands	r3, r2
 80028b8:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80028ba:	9b03      	ldr	r3, [sp, #12]
 80028bc:	2b00      	cmp	r3, #0
 80028be:	d10a      	bne.n	80028d6 <chEvtWaitAny+0x36>
    ctp->p_u.ewmask = events;
 80028c0:	9b02      	ldr	r3, [sp, #8]
 80028c2:	9a01      	ldr	r2, [sp, #4]
 80028c4:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 80028c6:	200a      	movs	r0, #10
 80028c8:	f7fe f992 	bl	8000bf0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80028cc:	9b02      	ldr	r3, [sp, #8]
 80028ce:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028d0:	9b01      	ldr	r3, [sp, #4]
 80028d2:	4013      	ands	r3, r2
 80028d4:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 80028d6:	9b02      	ldr	r3, [sp, #8]
 80028d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028da:	9b03      	ldr	r3, [sp, #12]
 80028dc:	43db      	mvns	r3, r3
 80028de:	401a      	ands	r2, r3
 80028e0:	9b02      	ldr	r3, [sp, #8]
 80028e2:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80028e4:	f7ff fe3c 	bl	8002560 <chSysUnlock>

  return m;
 80028e8:	9b03      	ldr	r3, [sp, #12]
}
 80028ea:	4618      	mov	r0, r3
 80028ec:	b005      	add	sp, #20
 80028ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80028f2:	bf00      	nop
 80028f4:	200039a8 	.word	0x200039a8
 80028f8:	f3af 8000 	nop.w
 80028fc:	f3af 8000 	nop.w

08002900 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002900:	b500      	push	{lr}
 8002902:	b085      	sub	sp, #20
 8002904:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002906:	4b10      	ldr	r3, [pc, #64]	; (8002948 <chEvtWaitAll+0x48>)
 8002908:	699b      	ldr	r3, [r3, #24]
 800290a:	9303      	str	r3, [sp, #12]

  chSysLock();
 800290c:	f7ff fe20 	bl	8002550 <chSysLock>
  if ((ctp->p_epending & events) != events) {
 8002910:	9b03      	ldr	r3, [sp, #12]
 8002912:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002914:	9b01      	ldr	r3, [sp, #4]
 8002916:	401a      	ands	r2, r3
 8002918:	9b01      	ldr	r3, [sp, #4]
 800291a:	429a      	cmp	r2, r3
 800291c:	d005      	beq.n	800292a <chEvtWaitAll+0x2a>
    ctp->p_u.ewmask = events;
 800291e:	9b03      	ldr	r3, [sp, #12]
 8002920:	9a01      	ldr	r2, [sp, #4]
 8002922:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8002924:	200b      	movs	r0, #11
 8002926:	f7fe f963 	bl	8000bf0 <chSchGoSleepS>
  }
  ctp->p_epending &= ~events;
 800292a:	9b03      	ldr	r3, [sp, #12]
 800292c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800292e:	9b01      	ldr	r3, [sp, #4]
 8002930:	43db      	mvns	r3, r3
 8002932:	401a      	ands	r2, r3
 8002934:	9b03      	ldr	r3, [sp, #12]
 8002936:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002938:	f7ff fe12 	bl	8002560 <chSysUnlock>

  return events;
 800293c:	9b01      	ldr	r3, [sp, #4]
}
 800293e:	4618      	mov	r0, r3
 8002940:	b005      	add	sp, #20
 8002942:	f85d fb04 	ldr.w	pc, [sp], #4
 8002946:	bf00      	nop
 8002948:	200039a8 	.word	0x200039a8
 800294c:	f3af 8000 	nop.w

08002950 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 8002950:	b500      	push	{lr}
 8002952:	b085      	sub	sp, #20
 8002954:	9001      	str	r0, [sp, #4]
 8002956:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002958:	4b1c      	ldr	r3, [pc, #112]	; (80029cc <chEvtWaitOneTimeout+0x7c>)
 800295a:	699b      	ldr	r3, [r3, #24]
 800295c:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800295e:	f7ff fdf7 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 8002962:	9b02      	ldr	r3, [sp, #8]
 8002964:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002966:	9b01      	ldr	r3, [sp, #4]
 8002968:	4013      	ands	r3, r2
 800296a:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800296c:	9b03      	ldr	r3, [sp, #12]
 800296e:	2b00      	cmp	r3, #0
 8002970:	d119      	bne.n	80029a6 <chEvtWaitOneTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 8002972:	9b00      	ldr	r3, [sp, #0]
 8002974:	2b00      	cmp	r3, #0
 8002976:	d103      	bne.n	8002980 <chEvtWaitOneTimeout+0x30>
      chSysUnlock();
 8002978:	f7ff fdf2 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 800297c:	2300      	movs	r3, #0
 800297e:	e021      	b.n	80029c4 <chEvtWaitOneTimeout+0x74>
    }
    ctp->p_u.ewmask = events;
 8002980:	9b02      	ldr	r3, [sp, #8]
 8002982:	9a01      	ldr	r2, [sp, #4]
 8002984:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002986:	200a      	movs	r0, #10
 8002988:	9900      	ldr	r1, [sp, #0]
 800298a:	f7fe f999 	bl	8000cc0 <chSchGoSleepTimeoutS>
 800298e:	4603      	mov	r3, r0
 8002990:	2b00      	cmp	r3, #0
 8002992:	da03      	bge.n	800299c <chEvtWaitOneTimeout+0x4c>
      chSysUnlock();
 8002994:	f7ff fde4 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002998:	2300      	movs	r3, #0
 800299a:	e013      	b.n	80029c4 <chEvtWaitOneTimeout+0x74>
    }
    m = ctp->p_epending & events;
 800299c:	9b02      	ldr	r3, [sp, #8]
 800299e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029a0:	9b01      	ldr	r3, [sp, #4]
 80029a2:	4013      	ands	r3, r2
 80029a4:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 80029a6:	9b03      	ldr	r3, [sp, #12]
 80029a8:	425b      	negs	r3, r3
 80029aa:	9a03      	ldr	r2, [sp, #12]
 80029ac:	4013      	ands	r3, r2
 80029ae:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 80029b0:	9b02      	ldr	r3, [sp, #8]
 80029b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029b4:	9b03      	ldr	r3, [sp, #12]
 80029b6:	43db      	mvns	r3, r3
 80029b8:	401a      	ands	r2, r3
 80029ba:	9b02      	ldr	r3, [sp, #8]
 80029bc:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80029be:	f7ff fdcf 	bl	8002560 <chSysUnlock>

  return m;
 80029c2:	9b03      	ldr	r3, [sp, #12]
}
 80029c4:	4618      	mov	r0, r3
 80029c6:	b005      	add	sp, #20
 80029c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80029cc:	200039a8 	.word	0x200039a8

080029d0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 80029d0:	b500      	push	{lr}
 80029d2:	b085      	sub	sp, #20
 80029d4:	9001      	str	r0, [sp, #4]
 80029d6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 80029d8:	4b1a      	ldr	r3, [pc, #104]	; (8002a44 <chEvtWaitAnyTimeout+0x74>)
 80029da:	699b      	ldr	r3, [r3, #24]
 80029dc:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80029de:	f7ff fdb7 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 80029e2:	9b02      	ldr	r3, [sp, #8]
 80029e4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029e6:	9b01      	ldr	r3, [sp, #4]
 80029e8:	4013      	ands	r3, r2
 80029ea:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80029ec:	9b03      	ldr	r3, [sp, #12]
 80029ee:	2b00      	cmp	r3, #0
 80029f0:	d119      	bne.n	8002a26 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 80029f2:	9b00      	ldr	r3, [sp, #0]
 80029f4:	2b00      	cmp	r3, #0
 80029f6:	d103      	bne.n	8002a00 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
 80029f8:	f7ff fdb2 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 80029fc:	2300      	movs	r3, #0
 80029fe:	e01c      	b.n	8002a3a <chEvtWaitAnyTimeout+0x6a>
    }
    ctp->p_u.ewmask = events;
 8002a00:	9b02      	ldr	r3, [sp, #8]
 8002a02:	9a01      	ldr	r2, [sp, #4]
 8002a04:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002a06:	200a      	movs	r0, #10
 8002a08:	9900      	ldr	r1, [sp, #0]
 8002a0a:	f7fe f959 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002a0e:	4603      	mov	r3, r0
 8002a10:	2b00      	cmp	r3, #0
 8002a12:	da03      	bge.n	8002a1c <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
 8002a14:	f7ff fda4 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a18:	2300      	movs	r3, #0
 8002a1a:	e00e      	b.n	8002a3a <chEvtWaitAnyTimeout+0x6a>
    }
    m = ctp->p_epending & events;
 8002a1c:	9b02      	ldr	r3, [sp, #8]
 8002a1e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a20:	9b01      	ldr	r3, [sp, #4]
 8002a22:	4013      	ands	r3, r2
 8002a24:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 8002a26:	9b02      	ldr	r3, [sp, #8]
 8002a28:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a2a:	9b03      	ldr	r3, [sp, #12]
 8002a2c:	43db      	mvns	r3, r3
 8002a2e:	401a      	ands	r2, r3
 8002a30:	9b02      	ldr	r3, [sp, #8]
 8002a32:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002a34:	f7ff fd94 	bl	8002560 <chSysUnlock>

  return m;
 8002a38:	9b03      	ldr	r3, [sp, #12]
}
 8002a3a:	4618      	mov	r0, r3
 8002a3c:	b005      	add	sp, #20
 8002a3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a42:	bf00      	nop
 8002a44:	200039a8 	.word	0x200039a8
 8002a48:	f3af 8000 	nop.w
 8002a4c:	f3af 8000 	nop.w

08002a50 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8002a50:	b500      	push	{lr}
 8002a52:	b085      	sub	sp, #20
 8002a54:	9001      	str	r0, [sp, #4]
 8002a56:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002a58:	4b17      	ldr	r3, [pc, #92]	; (8002ab8 <chEvtWaitAllTimeout+0x68>)
 8002a5a:	699b      	ldr	r3, [r3, #24]
 8002a5c:	9303      	str	r3, [sp, #12]

  chSysLock();
 8002a5e:	f7ff fd77 	bl	8002550 <chSysLock>
  if ((ctp->p_epending & events) != events) {
 8002a62:	9b03      	ldr	r3, [sp, #12]
 8002a64:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a66:	9b01      	ldr	r3, [sp, #4]
 8002a68:	401a      	ands	r2, r3
 8002a6a:	9b01      	ldr	r3, [sp, #4]
 8002a6c:	429a      	cmp	r2, r3
 8002a6e:	d014      	beq.n	8002a9a <chEvtWaitAllTimeout+0x4a>
    if (TIME_IMMEDIATE == time) {
 8002a70:	9b00      	ldr	r3, [sp, #0]
 8002a72:	2b00      	cmp	r3, #0
 8002a74:	d103      	bne.n	8002a7e <chEvtWaitAllTimeout+0x2e>
      chSysUnlock();
 8002a76:	f7ff fd73 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a7a:	2300      	movs	r3, #0
 8002a7c:	e017      	b.n	8002aae <chEvtWaitAllTimeout+0x5e>
    }
    ctp->p_u.ewmask = events;
 8002a7e:	9b03      	ldr	r3, [sp, #12]
 8002a80:	9a01      	ldr	r2, [sp, #4]
 8002a82:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8002a84:	200b      	movs	r0, #11
 8002a86:	9900      	ldr	r1, [sp, #0]
 8002a88:	f7fe f91a 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002a8c:	4603      	mov	r3, r0
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	da03      	bge.n	8002a9a <chEvtWaitAllTimeout+0x4a>
      chSysUnlock();
 8002a92:	f7ff fd65 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a96:	2300      	movs	r3, #0
 8002a98:	e009      	b.n	8002aae <chEvtWaitAllTimeout+0x5e>
    }
  }
  ctp->p_epending &= ~events;
 8002a9a:	9b03      	ldr	r3, [sp, #12]
 8002a9c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a9e:	9b01      	ldr	r3, [sp, #4]
 8002aa0:	43db      	mvns	r3, r3
 8002aa2:	401a      	ands	r2, r3
 8002aa4:	9b03      	ldr	r3, [sp, #12]
 8002aa6:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002aa8:	f7ff fd5a 	bl	8002560 <chSysUnlock>

  return events;
 8002aac:	9b01      	ldr	r3, [sp, #4]
}
 8002aae:	4618      	mov	r0, r3
 8002ab0:	b005      	add	sp, #20
 8002ab2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ab6:	bf00      	nop
 8002ab8:	200039a8 	.word	0x200039a8
 8002abc:	f3af 8000 	nop.w

08002ac0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002ac0:	b082      	sub	sp, #8
 8002ac2:	2320      	movs	r3, #32
 8002ac4:	9301      	str	r3, [sp, #4]
 8002ac6:	9b01      	ldr	r3, [sp, #4]
 8002ac8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002acc:	b002      	add	sp, #8
 8002ace:	4770      	bx	lr

08002ad0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002ad0:	b082      	sub	sp, #8
 8002ad2:	2300      	movs	r3, #0
 8002ad4:	9301      	str	r3, [sp, #4]
 8002ad6:	9b01      	ldr	r3, [sp, #4]
 8002ad8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002adc:	b002      	add	sp, #8
 8002ade:	4770      	bx	lr

08002ae0 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8002ae0:	b082      	sub	sp, #8
 8002ae2:	9001      	str	r0, [sp, #4]
 8002ae4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8002ae6:	9b01      	ldr	r3, [sp, #4]
 8002ae8:	9a00      	ldr	r2, [sp, #0]
 8002aea:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8002aec:	9b00      	ldr	r3, [sp, #0]
 8002aee:	685a      	ldr	r2, [r3, #4]
 8002af0:	9b01      	ldr	r3, [sp, #4]
 8002af2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8002af4:	9b01      	ldr	r3, [sp, #4]
 8002af6:	685b      	ldr	r3, [r3, #4]
 8002af8:	9a01      	ldr	r2, [sp, #4]
 8002afa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8002afc:	9b00      	ldr	r3, [sp, #0]
 8002afe:	9a01      	ldr	r2, [sp, #4]
 8002b00:	605a      	str	r2, [r3, #4]
}
 8002b02:	b002      	add	sp, #8
 8002b04:	4770      	bx	lr
 8002b06:	bf00      	nop
 8002b08:	f3af 8000 	nop.w
 8002b0c:	f3af 8000 	nop.w

08002b10 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002b10:	b084      	sub	sp, #16
 8002b12:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8002b14:	9b01      	ldr	r3, [sp, #4]
 8002b16:	681b      	ldr	r3, [r3, #0]
 8002b18:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8002b1a:	9b03      	ldr	r3, [sp, #12]
 8002b1c:	681a      	ldr	r2, [r3, #0]
 8002b1e:	9b01      	ldr	r3, [sp, #4]
 8002b20:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002b22:	9b01      	ldr	r3, [sp, #4]
 8002b24:	681b      	ldr	r3, [r3, #0]
 8002b26:	9a01      	ldr	r2, [sp, #4]
 8002b28:	605a      	str	r2, [r3, #4]

  return tp;
 8002b2a:	9b03      	ldr	r3, [sp, #12]
}
 8002b2c:	4618      	mov	r0, r3
 8002b2e:	b004      	add	sp, #16
 8002b30:	4770      	bx	lr
 8002b32:	bf00      	nop
 8002b34:	f3af 8000 	nop.w
 8002b38:	f3af 8000 	nop.w
 8002b3c:	f3af 8000 	nop.w

08002b40 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002b40:	b508      	push	{r3, lr}

  port_lock();
 8002b42:	f7ff ffbd 	bl	8002ac0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002b46:	bd08      	pop	{r3, pc}
 8002b48:	f3af 8000 	nop.w
 8002b4c:	f3af 8000 	nop.w

08002b50 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002b50:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002b52:	f7ff ffbd 	bl	8002ad0 <port_unlock>
}
 8002b56:	bd08      	pop	{r3, pc}
 8002b58:	f3af 8000 	nop.w
 8002b5c:	f3af 8000 	nop.w

08002b60 <chMsgIsPendingI>:
 * @param[in] tp        pointer to the thread
 * @return              The pending messages status.
 *
 * @iclass
 */
static inline bool chMsgIsPendingI(thread_t *tp) {
 8002b60:	b082      	sub	sp, #8
 8002b62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 8002b64:	9b01      	ldr	r3, [sp, #4]
 8002b66:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002b68:	9b01      	ldr	r3, [sp, #4]
 8002b6a:	3328      	adds	r3, #40	; 0x28
 8002b6c:	429a      	cmp	r2, r3
 8002b6e:	bf0c      	ite	eq
 8002b70:	2300      	moveq	r3, #0
 8002b72:	2301      	movne	r3, #1
 8002b74:	b2db      	uxtb	r3, r3
}
 8002b76:	4618      	mov	r0, r3
 8002b78:	b002      	add	sp, #8
 8002b7a:	4770      	bx	lr
 8002b7c:	f3af 8000 	nop.w

08002b80 <chMsgReleaseS>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {
 8002b80:	b500      	push	{lr}
 8002b82:	b083      	sub	sp, #12
 8002b84:	9001      	str	r0, [sp, #4]
 8002b86:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002b88:	9801      	ldr	r0, [sp, #4]
 8002b8a:	9900      	ldr	r1, [sp, #0]
 8002b8c:	f7fe f8d0 	bl	8000d30 <chSchWakeupS>
}
 8002b90:	b003      	add	sp, #12
 8002b92:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b96:	bf00      	nop
 8002b98:	f3af 8000 	nop.w
 8002b9c:	f3af 8000 	nop.w

08002ba0 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8002ba0:	b500      	push	{lr}
 8002ba2:	b085      	sub	sp, #20
 8002ba4:	9001      	str	r0, [sp, #4]
 8002ba6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002ba8:	4b13      	ldr	r3, [pc, #76]	; (8002bf8 <chMsgSend+0x58>)
 8002baa:	699b      	ldr	r3, [r3, #24]
 8002bac:	9303      	str	r3, [sp, #12]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002bae:	f7ff ffc7 	bl	8002b40 <chSysLock>
  ctp->p_msg = msg;
 8002bb2:	9b03      	ldr	r3, [sp, #12]
 8002bb4:	9a00      	ldr	r2, [sp, #0]
 8002bb6:	631a      	str	r2, [r3, #48]	; 0x30
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8002bb8:	9b01      	ldr	r3, [sp, #4]
 8002bba:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8002bbe:	9b03      	ldr	r3, [sp, #12]
 8002bc0:	621a      	str	r2, [r3, #32]
  msg_insert(ctp, &tp->p_msgqueue);
 8002bc2:	9b01      	ldr	r3, [sp, #4]
 8002bc4:	3328      	adds	r3, #40	; 0x28
 8002bc6:	9803      	ldr	r0, [sp, #12]
 8002bc8:	4619      	mov	r1, r3
 8002bca:	f7ff ff89 	bl	8002ae0 <queue_insert>
  if (tp->p_state == CH_STATE_WTMSG) {
 8002bce:	9b01      	ldr	r3, [sp, #4]
 8002bd0:	7f1b      	ldrb	r3, [r3, #28]
 8002bd2:	2b0e      	cmp	r3, #14
 8002bd4:	d102      	bne.n	8002bdc <chMsgSend+0x3c>
    (void) chSchReadyI(tp);
 8002bd6:	9801      	ldr	r0, [sp, #4]
 8002bd8:	f7fd ffe2 	bl	8000ba0 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8002bdc:	200c      	movs	r0, #12
 8002bde:	f7fe f807 	bl	8000bf0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8002be2:	9b03      	ldr	r3, [sp, #12]
 8002be4:	6a1b      	ldr	r3, [r3, #32]
 8002be6:	9300      	str	r3, [sp, #0]
  chSysUnlock();
 8002be8:	f7ff ffb2 	bl	8002b50 <chSysUnlock>

  return msg;
 8002bec:	9b00      	ldr	r3, [sp, #0]
}
 8002bee:	4618      	mov	r0, r3
 8002bf0:	b005      	add	sp, #20
 8002bf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002bf6:	bf00      	nop
 8002bf8:	200039a8 	.word	0x200039a8
 8002bfc:	f3af 8000 	nop.w

08002c00 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8002c00:	b500      	push	{lr}
 8002c02:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8002c04:	f7ff ff9c 	bl	8002b40 <chSysLock>
  if (!chMsgIsPendingI(currp)) {
 8002c08:	4b0f      	ldr	r3, [pc, #60]	; (8002c48 <chMsgWait+0x48>)
 8002c0a:	699b      	ldr	r3, [r3, #24]
 8002c0c:	4618      	mov	r0, r3
 8002c0e:	f7ff ffa7 	bl	8002b60 <chMsgIsPendingI>
 8002c12:	4603      	mov	r3, r0
 8002c14:	f083 0301 	eor.w	r3, r3, #1
 8002c18:	b2db      	uxtb	r3, r3
 8002c1a:	2b00      	cmp	r3, #0
 8002c1c:	d002      	beq.n	8002c24 <chMsgWait+0x24>
    chSchGoSleepS(CH_STATE_WTMSG);
 8002c1e:	200e      	movs	r0, #14
 8002c20:	f7fd ffe6 	bl	8000bf0 <chSchGoSleepS>
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
 8002c24:	4b08      	ldr	r3, [pc, #32]	; (8002c48 <chMsgWait+0x48>)
 8002c26:	699b      	ldr	r3, [r3, #24]
 8002c28:	3328      	adds	r3, #40	; 0x28
 8002c2a:	4618      	mov	r0, r3
 8002c2c:	f7ff ff70 	bl	8002b10 <queue_fifo_remove>
 8002c30:	9001      	str	r0, [sp, #4]
  tp->p_state = CH_STATE_SNDMSG;
 8002c32:	9b01      	ldr	r3, [sp, #4]
 8002c34:	220d      	movs	r2, #13
 8002c36:	771a      	strb	r2, [r3, #28]
  chSysUnlock();
 8002c38:	f7ff ff8a 	bl	8002b50 <chSysUnlock>

  return tp;
 8002c3c:	9b01      	ldr	r3, [sp, #4]
}
 8002c3e:	4618      	mov	r0, r3
 8002c40:	b003      	add	sp, #12
 8002c42:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c46:	bf00      	nop
 8002c48:	200039a8 	.word	0x200039a8
 8002c4c:	f3af 8000 	nop.w

08002c50 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8002c50:	b500      	push	{lr}
 8002c52:	b083      	sub	sp, #12
 8002c54:	9001      	str	r0, [sp, #4]
 8002c56:	9100      	str	r1, [sp, #0]

  chSysLock();
 8002c58:	f7ff ff72 	bl	8002b40 <chSysLock>
  chDbgAssert(tp->p_state == CH_STATE_SNDMSG, "invalid state");
  chMsgReleaseS(tp, msg);
 8002c5c:	9801      	ldr	r0, [sp, #4]
 8002c5e:	9900      	ldr	r1, [sp, #0]
 8002c60:	f7ff ff8e 	bl	8002b80 <chMsgReleaseS>
  chSysUnlock();
 8002c64:	f7ff ff74 	bl	8002b50 <chSysUnlock>
}
 8002c68:	b003      	add	sp, #12
 8002c6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c6e:	bf00      	nop

08002c70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002c70:	b082      	sub	sp, #8
 8002c72:	2320      	movs	r3, #32
 8002c74:	9301      	str	r3, [sp, #4]
 8002c76:	9b01      	ldr	r3, [sp, #4]
 8002c78:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c7c:	b002      	add	sp, #8
 8002c7e:	4770      	bx	lr

08002c80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002c80:	b082      	sub	sp, #8
 8002c82:	2300      	movs	r3, #0
 8002c84:	9301      	str	r3, [sp, #4]
 8002c86:	9b01      	ldr	r3, [sp, #4]
 8002c88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c8c:	b002      	add	sp, #8
 8002c8e:	4770      	bx	lr

08002c90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002c90:	b508      	push	{r3, lr}

  port_lock();
 8002c92:	f7ff ffed 	bl	8002c70 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002c96:	bd08      	pop	{r3, pc}
 8002c98:	f3af 8000 	nop.w
 8002c9c:	f3af 8000 	nop.w

08002ca0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002ca0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002ca2:	f7ff ffed 	bl	8002c80 <port_unlock>
}
 8002ca6:	bd08      	pop	{r3, pc}
 8002ca8:	f3af 8000 	nop.w
 8002cac:	f3af 8000 	nop.w

08002cb0 <chSemFastWaitI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastWaitI(semaphore_t *sp) {
 8002cb0:	b082      	sub	sp, #8
 8002cb2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt--;
 8002cb4:	9b01      	ldr	r3, [sp, #4]
 8002cb6:	689b      	ldr	r3, [r3, #8]
 8002cb8:	1e5a      	subs	r2, r3, #1
 8002cba:	9b01      	ldr	r3, [sp, #4]
 8002cbc:	609a      	str	r2, [r3, #8]
}
 8002cbe:	b002      	add	sp, #8
 8002cc0:	4770      	bx	lr
 8002cc2:	bf00      	nop
 8002cc4:	f3af 8000 	nop.w
 8002cc8:	f3af 8000 	nop.w
 8002ccc:	f3af 8000 	nop.w

08002cd0 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8002cd0:	b082      	sub	sp, #8
 8002cd2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 8002cd4:	9b01      	ldr	r3, [sp, #4]
 8002cd6:	689b      	ldr	r3, [r3, #8]
}
 8002cd8:	4618      	mov	r0, r3
 8002cda:	b002      	add	sp, #8
 8002cdc:	4770      	bx	lr
 8002cde:	bf00      	nop

08002ce0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8002ce0:	b500      	push	{lr}
 8002ce2:	b085      	sub	sp, #20
 8002ce4:	9003      	str	r0, [sp, #12]
 8002ce6:	9102      	str	r1, [sp, #8]
 8002ce8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 8002cea:	9b03      	ldr	r3, [sp, #12]
 8002cec:	9a02      	ldr	r2, [sp, #8]
 8002cee:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
 8002cf0:	9b03      	ldr	r3, [sp, #12]
 8002cf2:	9a02      	ldr	r2, [sp, #8]
 8002cf4:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 8002cf6:	9b03      	ldr	r3, [sp, #12]
 8002cf8:	9a02      	ldr	r2, [sp, #8]
 8002cfa:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
 8002cfc:	9b01      	ldr	r3, [sp, #4]
 8002cfe:	009b      	lsls	r3, r3, #2
 8002d00:	9a02      	ldr	r2, [sp, #8]
 8002d02:	441a      	add	r2, r3
 8002d04:	9b03      	ldr	r3, [sp, #12]
 8002d06:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
 8002d08:	9b03      	ldr	r3, [sp, #12]
 8002d0a:	331c      	adds	r3, #28
 8002d0c:	4618      	mov	r0, r3
 8002d0e:	9901      	ldr	r1, [sp, #4]
 8002d10:	f7fe fed6 	bl	8001ac0 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 8002d14:	9b03      	ldr	r3, [sp, #12]
 8002d16:	3310      	adds	r3, #16
 8002d18:	4618      	mov	r0, r3
 8002d1a:	2100      	movs	r1, #0
 8002d1c:	f7fe fed0 	bl	8001ac0 <chSemObjectInit>
}
 8002d20:	b005      	add	sp, #20
 8002d22:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d26:	bf00      	nop
 8002d28:	f3af 8000 	nop.w
 8002d2c:	f3af 8000 	nop.w

08002d30 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8002d30:	b500      	push	{lr}
 8002d32:	b083      	sub	sp, #12
 8002d34:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002d36:	f7ff ffab 	bl	8002c90 <chSysLock>
  chMBResetI(mbp);
 8002d3a:	9801      	ldr	r0, [sp, #4]
 8002d3c:	f000 f808 	bl	8002d50 <chMBResetI>
  chSchRescheduleS();
 8002d40:	f7fe f81e 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8002d44:	f7ff ffac 	bl	8002ca0 <chSysUnlock>
}
 8002d48:	b003      	add	sp, #12
 8002d4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d4e:	bf00      	nop

08002d50 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8002d50:	b500      	push	{lr}
 8002d52:	b083      	sub	sp, #12
 8002d54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8002d56:	9b01      	ldr	r3, [sp, #4]
 8002d58:	681a      	ldr	r2, [r3, #0]
 8002d5a:	9b01      	ldr	r3, [sp, #4]
 8002d5c:	609a      	str	r2, [r3, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
 8002d5e:	9b01      	ldr	r3, [sp, #4]
 8002d60:	681a      	ldr	r2, [r3, #0]
 8002d62:	9b01      	ldr	r3, [sp, #4]
 8002d64:	60da      	str	r2, [r3, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8002d66:	9b01      	ldr	r3, [sp, #4]
 8002d68:	f103 021c 	add.w	r2, r3, #28
 8002d6c:	9b01      	ldr	r3, [sp, #4]
 8002d6e:	685b      	ldr	r3, [r3, #4]
 8002d70:	4619      	mov	r1, r3
 8002d72:	9b01      	ldr	r3, [sp, #4]
 8002d74:	681b      	ldr	r3, [r3, #0]
 8002d76:	1acb      	subs	r3, r1, r3
 8002d78:	109b      	asrs	r3, r3, #2
 8002d7a:	4610      	mov	r0, r2
 8002d7c:	4619      	mov	r1, r3
 8002d7e:	f7fe fec7 	bl	8001b10 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 8002d82:	9b01      	ldr	r3, [sp, #4]
 8002d84:	3310      	adds	r3, #16
 8002d86:	4618      	mov	r0, r3
 8002d88:	2100      	movs	r1, #0
 8002d8a:	f7fe fec1 	bl	8001b10 <chSemResetI>
}
 8002d8e:	b003      	add	sp, #12
 8002d90:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d94:	f3af 8000 	nop.w
 8002d98:	f3af 8000 	nop.w
 8002d9c:	f3af 8000 	nop.w

08002da0 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002da0:	b500      	push	{lr}
 8002da2:	b087      	sub	sp, #28
 8002da4:	9003      	str	r0, [sp, #12]
 8002da6:	9102      	str	r1, [sp, #8]
 8002da8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002daa:	f7ff ff71 	bl	8002c90 <chSysLock>
  rdymsg = chMBPostS(mbp, msg, timeout);
 8002dae:	9803      	ldr	r0, [sp, #12]
 8002db0:	9902      	ldr	r1, [sp, #8]
 8002db2:	9a01      	ldr	r2, [sp, #4]
 8002db4:	f000 f80c 	bl	8002dd0 <chMBPostS>
 8002db8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002dba:	f7ff ff71 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002dbe:	9b05      	ldr	r3, [sp, #20]
}
 8002dc0:	4618      	mov	r0, r3
 8002dc2:	b007      	add	sp, #28
 8002dc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002dc8:	f3af 8000 	nop.w
 8002dcc:	f3af 8000 	nop.w

08002dd0 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b087      	sub	sp, #28
 8002dd4:	9003      	str	r0, [sp, #12]
 8002dd6:	9102      	str	r1, [sp, #8]
 8002dd8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002dda:	9b03      	ldr	r3, [sp, #12]
 8002ddc:	331c      	adds	r3, #28
 8002dde:	4618      	mov	r0, r3
 8002de0:	9901      	ldr	r1, [sp, #4]
 8002de2:	f7fe ff05 	bl	8001bf0 <chSemWaitTimeoutS>
 8002de6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002de8:	9b05      	ldr	r3, [sp, #20]
 8002dea:	2b00      	cmp	r3, #0
 8002dec:	d117      	bne.n	8002e1e <chMBPostS+0x4e>
    *mbp->mb_wrptr++ = msg;
 8002dee:	9b03      	ldr	r3, [sp, #12]
 8002df0:	689b      	ldr	r3, [r3, #8]
 8002df2:	1d19      	adds	r1, r3, #4
 8002df4:	9a03      	ldr	r2, [sp, #12]
 8002df6:	6091      	str	r1, [r2, #8]
 8002df8:	9a02      	ldr	r2, [sp, #8]
 8002dfa:	601a      	str	r2, [r3, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8002dfc:	9b03      	ldr	r3, [sp, #12]
 8002dfe:	689a      	ldr	r2, [r3, #8]
 8002e00:	9b03      	ldr	r3, [sp, #12]
 8002e02:	685b      	ldr	r3, [r3, #4]
 8002e04:	429a      	cmp	r2, r3
 8002e06:	d303      	bcc.n	8002e10 <chMBPostS+0x40>
      mbp->mb_wrptr = mbp->mb_buffer;
 8002e08:	9b03      	ldr	r3, [sp, #12]
 8002e0a:	681a      	ldr	r2, [r3, #0]
 8002e0c:	9b03      	ldr	r3, [sp, #12]
 8002e0e:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002e10:	9b03      	ldr	r3, [sp, #12]
 8002e12:	3310      	adds	r3, #16
 8002e14:	4618      	mov	r0, r3
 8002e16:	f7fe ff3b 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 8002e1a:	f7fd ffb1 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8002e1e:	9b05      	ldr	r3, [sp, #20]
}
 8002e20:	4618      	mov	r0, r3
 8002e22:	b007      	add	sp, #28
 8002e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e28:	f3af 8000 	nop.w
 8002e2c:	f3af 8000 	nop.w

08002e30 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002e30:	b500      	push	{lr}
 8002e32:	b083      	sub	sp, #12
 8002e34:	9001      	str	r0, [sp, #4]
 8002e36:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002e38:	9b01      	ldr	r3, [sp, #4]
 8002e3a:	331c      	adds	r3, #28
 8002e3c:	4618      	mov	r0, r3
 8002e3e:	f7ff ff47 	bl	8002cd0 <chSemGetCounterI>
 8002e42:	4603      	mov	r3, r0
 8002e44:	2b00      	cmp	r3, #0
 8002e46:	dc02      	bgt.n	8002e4e <chMBPostI+0x1e>
    return MSG_TIMEOUT;
 8002e48:	f04f 33ff 	mov.w	r3, #4294967295
 8002e4c:	e01b      	b.n	8002e86 <chMBPostI+0x56>
  }

  chSemFastWaitI(&mbp->mb_emptysem);
 8002e4e:	9b01      	ldr	r3, [sp, #4]
 8002e50:	331c      	adds	r3, #28
 8002e52:	4618      	mov	r0, r3
 8002e54:	f7ff ff2c 	bl	8002cb0 <chSemFastWaitI>
  *mbp->mb_wrptr++ = msg;
 8002e58:	9b01      	ldr	r3, [sp, #4]
 8002e5a:	689b      	ldr	r3, [r3, #8]
 8002e5c:	1d19      	adds	r1, r3, #4
 8002e5e:	9a01      	ldr	r2, [sp, #4]
 8002e60:	6091      	str	r1, [r2, #8]
 8002e62:	9a00      	ldr	r2, [sp, #0]
 8002e64:	601a      	str	r2, [r3, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8002e66:	9b01      	ldr	r3, [sp, #4]
 8002e68:	689a      	ldr	r2, [r3, #8]
 8002e6a:	9b01      	ldr	r3, [sp, #4]
 8002e6c:	685b      	ldr	r3, [r3, #4]
 8002e6e:	429a      	cmp	r2, r3
 8002e70:	d303      	bcc.n	8002e7a <chMBPostI+0x4a>
     mbp->mb_wrptr = mbp->mb_buffer;
 8002e72:	9b01      	ldr	r3, [sp, #4]
 8002e74:	681a      	ldr	r2, [r3, #0]
 8002e76:	9b01      	ldr	r3, [sp, #4]
 8002e78:	609a      	str	r2, [r3, #8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 8002e7a:	9b01      	ldr	r3, [sp, #4]
 8002e7c:	3310      	adds	r3, #16
 8002e7e:	4618      	mov	r0, r3
 8002e80:	f7fe ff06 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8002e84:	2300      	movs	r3, #0
}
 8002e86:	4618      	mov	r0, r3
 8002e88:	b003      	add	sp, #12
 8002e8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e8e:	bf00      	nop

08002e90 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002e90:	b500      	push	{lr}
 8002e92:	b087      	sub	sp, #28
 8002e94:	9003      	str	r0, [sp, #12]
 8002e96:	9102      	str	r1, [sp, #8]
 8002e98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002e9a:	f7ff fef9 	bl	8002c90 <chSysLock>
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
 8002e9e:	9803      	ldr	r0, [sp, #12]
 8002ea0:	9902      	ldr	r1, [sp, #8]
 8002ea2:	9a01      	ldr	r2, [sp, #4]
 8002ea4:	f000 f80c 	bl	8002ec0 <chMBPostAheadS>
 8002ea8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002eaa:	f7ff fef9 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002eae:	9b05      	ldr	r3, [sp, #20]
}
 8002eb0:	4618      	mov	r0, r3
 8002eb2:	b007      	add	sp, #28
 8002eb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002eb8:	f3af 8000 	nop.w
 8002ebc:	f3af 8000 	nop.w

08002ec0 <chMBPostAheadS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002ec0:	b500      	push	{lr}
 8002ec2:	b087      	sub	sp, #28
 8002ec4:	9003      	str	r0, [sp, #12]
 8002ec6:	9102      	str	r1, [sp, #8]
 8002ec8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002eca:	9b03      	ldr	r3, [sp, #12]
 8002ecc:	331c      	adds	r3, #28
 8002ece:	4618      	mov	r0, r3
 8002ed0:	9901      	ldr	r1, [sp, #4]
 8002ed2:	f7fe fe8d 	bl	8001bf0 <chSemWaitTimeoutS>
 8002ed6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002ed8:	9b05      	ldr	r3, [sp, #20]
 8002eda:	2b00      	cmp	r3, #0
 8002edc:	d11a      	bne.n	8002f14 <chMBPostAheadS+0x54>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002ede:	9b03      	ldr	r3, [sp, #12]
 8002ee0:	68db      	ldr	r3, [r3, #12]
 8002ee2:	1f1a      	subs	r2, r3, #4
 8002ee4:	9b03      	ldr	r3, [sp, #12]
 8002ee6:	60da      	str	r2, [r3, #12]
 8002ee8:	9b03      	ldr	r3, [sp, #12]
 8002eea:	68da      	ldr	r2, [r3, #12]
 8002eec:	9b03      	ldr	r3, [sp, #12]
 8002eee:	681b      	ldr	r3, [r3, #0]
 8002ef0:	429a      	cmp	r2, r3
 8002ef2:	d204      	bcs.n	8002efe <chMBPostAheadS+0x3e>
      mbp->mb_rdptr = mbp->mb_top - 1;
 8002ef4:	9b03      	ldr	r3, [sp, #12]
 8002ef6:	685b      	ldr	r3, [r3, #4]
 8002ef8:	1f1a      	subs	r2, r3, #4
 8002efa:	9b03      	ldr	r3, [sp, #12]
 8002efc:	60da      	str	r2, [r3, #12]
    }
    *mbp->mb_rdptr = msg;
 8002efe:	9b03      	ldr	r3, [sp, #12]
 8002f00:	68db      	ldr	r3, [r3, #12]
 8002f02:	9a02      	ldr	r2, [sp, #8]
 8002f04:	601a      	str	r2, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 8002f06:	9b03      	ldr	r3, [sp, #12]
 8002f08:	3310      	adds	r3, #16
 8002f0a:	4618      	mov	r0, r3
 8002f0c:	f7fe fec0 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 8002f10:	f7fd ff36 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8002f14:	9b05      	ldr	r3, [sp, #20]
}
 8002f16:	4618      	mov	r0, r3
 8002f18:	b007      	add	sp, #28
 8002f1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f1e:	bf00      	nop

08002f20 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8002f20:	b500      	push	{lr}
 8002f22:	b083      	sub	sp, #12
 8002f24:	9001      	str	r0, [sp, #4]
 8002f26:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002f28:	9b01      	ldr	r3, [sp, #4]
 8002f2a:	331c      	adds	r3, #28
 8002f2c:	4618      	mov	r0, r3
 8002f2e:	f7ff fecf 	bl	8002cd0 <chSemGetCounterI>
 8002f32:	4603      	mov	r3, r0
 8002f34:	2b00      	cmp	r3, #0
 8002f36:	dc02      	bgt.n	8002f3e <chMBPostAheadI+0x1e>
    return MSG_TIMEOUT;
 8002f38:	f04f 33ff 	mov.w	r3, #4294967295
 8002f3c:	e01e      	b.n	8002f7c <chMBPostAheadI+0x5c>
  }
  chSemFastWaitI(&mbp->mb_emptysem);
 8002f3e:	9b01      	ldr	r3, [sp, #4]
 8002f40:	331c      	adds	r3, #28
 8002f42:	4618      	mov	r0, r3
 8002f44:	f7ff feb4 	bl	8002cb0 <chSemFastWaitI>
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002f48:	9b01      	ldr	r3, [sp, #4]
 8002f4a:	68db      	ldr	r3, [r3, #12]
 8002f4c:	1f1a      	subs	r2, r3, #4
 8002f4e:	9b01      	ldr	r3, [sp, #4]
 8002f50:	60da      	str	r2, [r3, #12]
 8002f52:	9b01      	ldr	r3, [sp, #4]
 8002f54:	68da      	ldr	r2, [r3, #12]
 8002f56:	9b01      	ldr	r3, [sp, #4]
 8002f58:	681b      	ldr	r3, [r3, #0]
 8002f5a:	429a      	cmp	r2, r3
 8002f5c:	d204      	bcs.n	8002f68 <chMBPostAheadI+0x48>
    mbp->mb_rdptr = mbp->mb_top - 1;
 8002f5e:	9b01      	ldr	r3, [sp, #4]
 8002f60:	685b      	ldr	r3, [r3, #4]
 8002f62:	1f1a      	subs	r2, r3, #4
 8002f64:	9b01      	ldr	r3, [sp, #4]
 8002f66:	60da      	str	r2, [r3, #12]
  }
  *mbp->mb_rdptr = msg;
 8002f68:	9b01      	ldr	r3, [sp, #4]
 8002f6a:	68db      	ldr	r3, [r3, #12]
 8002f6c:	9a00      	ldr	r2, [sp, #0]
 8002f6e:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 8002f70:	9b01      	ldr	r3, [sp, #4]
 8002f72:	3310      	adds	r3, #16
 8002f74:	4618      	mov	r0, r3
 8002f76:	f7fe fe8b 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8002f7a:	2300      	movs	r3, #0
}
 8002f7c:	4618      	mov	r0, r3
 8002f7e:	b003      	add	sp, #12
 8002f80:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f84:	f3af 8000 	nop.w
 8002f88:	f3af 8000 	nop.w
 8002f8c:	f3af 8000 	nop.w

08002f90 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002f90:	b500      	push	{lr}
 8002f92:	b087      	sub	sp, #28
 8002f94:	9003      	str	r0, [sp, #12]
 8002f96:	9102      	str	r1, [sp, #8]
 8002f98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002f9a:	f7ff fe79 	bl	8002c90 <chSysLock>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 8002f9e:	9803      	ldr	r0, [sp, #12]
 8002fa0:	9902      	ldr	r1, [sp, #8]
 8002fa2:	9a01      	ldr	r2, [sp, #4]
 8002fa4:	f000 f80c 	bl	8002fc0 <chMBFetchS>
 8002fa8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002faa:	f7ff fe79 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002fae:	9b05      	ldr	r3, [sp, #20]
}
 8002fb0:	4618      	mov	r0, r3
 8002fb2:	b007      	add	sp, #28
 8002fb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fb8:	f3af 8000 	nop.w
 8002fbc:	f3af 8000 	nop.w

08002fc0 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002fc0:	b500      	push	{lr}
 8002fc2:	b087      	sub	sp, #28
 8002fc4:	9003      	str	r0, [sp, #12]
 8002fc6:	9102      	str	r1, [sp, #8]
 8002fc8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 8002fca:	9b03      	ldr	r3, [sp, #12]
 8002fcc:	3310      	adds	r3, #16
 8002fce:	4618      	mov	r0, r3
 8002fd0:	9901      	ldr	r1, [sp, #4]
 8002fd2:	f7fe fe0d 	bl	8001bf0 <chSemWaitTimeoutS>
 8002fd6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002fd8:	9b05      	ldr	r3, [sp, #20]
 8002fda:	2b00      	cmp	r3, #0
 8002fdc:	d118      	bne.n	8003010 <chMBFetchS+0x50>
    *msgp = *mbp->mb_rdptr++;
 8002fde:	9b03      	ldr	r3, [sp, #12]
 8002fe0:	68db      	ldr	r3, [r3, #12]
 8002fe2:	1d19      	adds	r1, r3, #4
 8002fe4:	9a03      	ldr	r2, [sp, #12]
 8002fe6:	60d1      	str	r1, [r2, #12]
 8002fe8:	681a      	ldr	r2, [r3, #0]
 8002fea:	9b02      	ldr	r3, [sp, #8]
 8002fec:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8002fee:	9b03      	ldr	r3, [sp, #12]
 8002ff0:	68da      	ldr	r2, [r3, #12]
 8002ff2:	9b03      	ldr	r3, [sp, #12]
 8002ff4:	685b      	ldr	r3, [r3, #4]
 8002ff6:	429a      	cmp	r2, r3
 8002ff8:	d303      	bcc.n	8003002 <chMBFetchS+0x42>
      mbp->mb_rdptr = mbp->mb_buffer;
 8002ffa:	9b03      	ldr	r3, [sp, #12]
 8002ffc:	681a      	ldr	r2, [r3, #0]
 8002ffe:	9b03      	ldr	r3, [sp, #12]
 8003000:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8003002:	9b03      	ldr	r3, [sp, #12]
 8003004:	331c      	adds	r3, #28
 8003006:	4618      	mov	r0, r3
 8003008:	f7fe fe42 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 800300c:	f7fd feb8 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8003010:	9b05      	ldr	r3, [sp, #20]
}
 8003012:	4618      	mov	r0, r3
 8003014:	b007      	add	sp, #28
 8003016:	f85d fb04 	ldr.w	pc, [sp], #4
 800301a:	bf00      	nop
 800301c:	f3af 8000 	nop.w

08003020 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8003020:	b500      	push	{lr}
 8003022:	b083      	sub	sp, #12
 8003024:	9001      	str	r0, [sp, #4]
 8003026:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 8003028:	9b01      	ldr	r3, [sp, #4]
 800302a:	3310      	adds	r3, #16
 800302c:	4618      	mov	r0, r3
 800302e:	f7ff fe4f 	bl	8002cd0 <chSemGetCounterI>
 8003032:	4603      	mov	r3, r0
 8003034:	2b00      	cmp	r3, #0
 8003036:	dc02      	bgt.n	800303e <chMBFetchI+0x1e>
    return MSG_TIMEOUT;
 8003038:	f04f 33ff 	mov.w	r3, #4294967295
 800303c:	e01c      	b.n	8003078 <chMBFetchI+0x58>
  }
  chSemFastWaitI(&mbp->mb_fullsem);
 800303e:	9b01      	ldr	r3, [sp, #4]
 8003040:	3310      	adds	r3, #16
 8003042:	4618      	mov	r0, r3
 8003044:	f7ff fe34 	bl	8002cb0 <chSemFastWaitI>
  *msgp = *mbp->mb_rdptr++;
 8003048:	9b01      	ldr	r3, [sp, #4]
 800304a:	68db      	ldr	r3, [r3, #12]
 800304c:	1d19      	adds	r1, r3, #4
 800304e:	9a01      	ldr	r2, [sp, #4]
 8003050:	60d1      	str	r1, [r2, #12]
 8003052:	681a      	ldr	r2, [r3, #0]
 8003054:	9b00      	ldr	r3, [sp, #0]
 8003056:	601a      	str	r2, [r3, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8003058:	9b01      	ldr	r3, [sp, #4]
 800305a:	68da      	ldr	r2, [r3, #12]
 800305c:	9b01      	ldr	r3, [sp, #4]
 800305e:	685b      	ldr	r3, [r3, #4]
 8003060:	429a      	cmp	r2, r3
 8003062:	d303      	bcc.n	800306c <chMBFetchI+0x4c>
    mbp->mb_rdptr = mbp->mb_buffer;
 8003064:	9b01      	ldr	r3, [sp, #4]
 8003066:	681a      	ldr	r2, [r3, #0]
 8003068:	9b01      	ldr	r3, [sp, #4]
 800306a:	60da      	str	r2, [r3, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 800306c:	9b01      	ldr	r3, [sp, #4]
 800306e:	331c      	adds	r3, #28
 8003070:	4618      	mov	r0, r3
 8003072:	f7fe fe0d 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8003076:	2300      	movs	r3, #0
}
 8003078:	4618      	mov	r0, r3
 800307a:	b003      	add	sp, #12
 800307c:	f85d fb04 	ldr.w	pc, [sp], #4

08003080 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003080:	b082      	sub	sp, #8
 8003082:	2320      	movs	r3, #32
 8003084:	9301      	str	r3, [sp, #4]
 8003086:	9b01      	ldr	r3, [sp, #4]
 8003088:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800308c:	b002      	add	sp, #8
 800308e:	4770      	bx	lr

08003090 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003090:	b082      	sub	sp, #8
 8003092:	2300      	movs	r3, #0
 8003094:	9301      	str	r3, [sp, #4]
 8003096:	9b01      	ldr	r3, [sp, #4]
 8003098:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800309c:	b002      	add	sp, #8
 800309e:	4770      	bx	lr

080030a0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80030a0:	b082      	sub	sp, #8
 80030a2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80030a4:	9b01      	ldr	r3, [sp, #4]
 80030a6:	9a01      	ldr	r2, [sp, #4]
 80030a8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80030aa:	9b01      	ldr	r3, [sp, #4]
 80030ac:	9a01      	ldr	r2, [sp, #4]
 80030ae:	605a      	str	r2, [r3, #4]
}
 80030b0:	b002      	add	sp, #8
 80030b2:	4770      	bx	lr
 80030b4:	f3af 8000 	nop.w
 80030b8:	f3af 8000 	nop.w
 80030bc:	f3af 8000 	nop.w

080030c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80030c0:	b508      	push	{r3, lr}

  port_lock();
 80030c2:	f7ff ffdd 	bl	8003080 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80030c6:	bd08      	pop	{r3, pc}
 80030c8:	f3af 8000 	nop.w
 80030cc:	f3af 8000 	nop.w

080030d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80030d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80030d2:	f7ff ffdd 	bl	8003090 <port_unlock>
}
 80030d6:	bd08      	pop	{r3, pc}
 80030d8:	f3af 8000 	nop.w
 80030dc:	f3af 8000 	nop.w

080030e0 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 80030e0:	b500      	push	{lr}
 80030e2:	b083      	sub	sp, #12
 80030e4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 80030e6:	9801      	ldr	r0, [sp, #4]
 80030e8:	f7ff ffda 	bl	80030a0 <queue_init>
}
 80030ec:	b003      	add	sp, #12
 80030ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80030f2:	bf00      	nop
 80030f4:	f3af 8000 	nop.w
 80030f8:	f3af 8000 	nop.w
 80030fc:	f3af 8000 	nop.w

08003100 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8003100:	b082      	sub	sp, #8
 8003102:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8003104:	9b01      	ldr	r3, [sp, #4]
 8003106:	689b      	ldr	r3, [r3, #8]
 8003108:	2b00      	cmp	r3, #0
 800310a:	bf14      	ite	ne
 800310c:	2300      	movne	r3, #0
 800310e:	2301      	moveq	r3, #1
 8003110:	b2db      	uxtb	r3, r3
}
 8003112:	4618      	mov	r0, r3
 8003114:	b002      	add	sp, #8
 8003116:	4770      	bx	lr
 8003118:	f3af 8000 	nop.w
 800311c:	f3af 8000 	nop.w

08003120 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8003120:	b082      	sub	sp, #8
 8003122:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8003124:	9b01      	ldr	r3, [sp, #4]
 8003126:	695a      	ldr	r2, [r3, #20]
 8003128:	9b01      	ldr	r3, [sp, #4]
 800312a:	699b      	ldr	r3, [r3, #24]
 800312c:	429a      	cmp	r2, r3
 800312e:	d105      	bne.n	800313c <chIQIsFullI+0x1c>
 8003130:	9b01      	ldr	r3, [sp, #4]
 8003132:	689b      	ldr	r3, [r3, #8]
 8003134:	2b00      	cmp	r3, #0
 8003136:	d001      	beq.n	800313c <chIQIsFullI+0x1c>
 8003138:	2301      	movs	r3, #1
 800313a:	e000      	b.n	800313e <chIQIsFullI+0x1e>
 800313c:	2300      	movs	r3, #0
 800313e:	f003 0301 	and.w	r3, r3, #1
 8003142:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003144:	4618      	mov	r0, r3
 8003146:	b002      	add	sp, #8
 8003148:	4770      	bx	lr
 800314a:	bf00      	nop
 800314c:	f3af 8000 	nop.w

08003150 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8003150:	b082      	sub	sp, #8
 8003152:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8003154:	9b01      	ldr	r3, [sp, #4]
 8003156:	695a      	ldr	r2, [r3, #20]
 8003158:	9b01      	ldr	r3, [sp, #4]
 800315a:	699b      	ldr	r3, [r3, #24]
 800315c:	429a      	cmp	r2, r3
 800315e:	d105      	bne.n	800316c <chOQIsEmptyI+0x1c>
 8003160:	9b01      	ldr	r3, [sp, #4]
 8003162:	689b      	ldr	r3, [r3, #8]
 8003164:	2b00      	cmp	r3, #0
 8003166:	d001      	beq.n	800316c <chOQIsEmptyI+0x1c>
 8003168:	2301      	movs	r3, #1
 800316a:	e000      	b.n	800316e <chOQIsEmptyI+0x1e>
 800316c:	2300      	movs	r3, #0
 800316e:	f003 0301 	and.w	r3, r3, #1
 8003172:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003174:	4618      	mov	r0, r3
 8003176:	b002      	add	sp, #8
 8003178:	4770      	bx	lr
 800317a:	bf00      	nop
 800317c:	f3af 8000 	nop.w

08003180 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8003180:	b082      	sub	sp, #8
 8003182:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8003184:	9b01      	ldr	r3, [sp, #4]
 8003186:	689b      	ldr	r3, [r3, #8]
 8003188:	2b00      	cmp	r3, #0
 800318a:	bf14      	ite	ne
 800318c:	2300      	movne	r3, #0
 800318e:	2301      	moveq	r3, #1
 8003190:	b2db      	uxtb	r3, r3
}
 8003192:	4618      	mov	r0, r3
 8003194:	b002      	add	sp, #8
 8003196:	4770      	bx	lr
 8003198:	f3af 8000 	nop.w
 800319c:	f3af 8000 	nop.w

080031a0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 80031a0:	b500      	push	{lr}
 80031a2:	b085      	sub	sp, #20
 80031a4:	9003      	str	r0, [sp, #12]
 80031a6:	9102      	str	r1, [sp, #8]
 80031a8:	9201      	str	r2, [sp, #4]
 80031aa:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 80031ac:	9b03      	ldr	r3, [sp, #12]
 80031ae:	4618      	mov	r0, r3
 80031b0:	f7ff ff96 	bl	80030e0 <chThdQueueObjectInit>
  iqp->q_counter = 0;
 80031b4:	9b03      	ldr	r3, [sp, #12]
 80031b6:	2200      	movs	r2, #0
 80031b8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 80031ba:	9b03      	ldr	r3, [sp, #12]
 80031bc:	9a02      	ldr	r2, [sp, #8]
 80031be:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 80031c0:	9b03      	ldr	r3, [sp, #12]
 80031c2:	9a02      	ldr	r2, [sp, #8]
 80031c4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 80031c6:	9b03      	ldr	r3, [sp, #12]
 80031c8:	9a02      	ldr	r2, [sp, #8]
 80031ca:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 80031cc:	9a02      	ldr	r2, [sp, #8]
 80031ce:	9b01      	ldr	r3, [sp, #4]
 80031d0:	441a      	add	r2, r3
 80031d2:	9b03      	ldr	r3, [sp, #12]
 80031d4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 80031d6:	9b03      	ldr	r3, [sp, #12]
 80031d8:	9a00      	ldr	r2, [sp, #0]
 80031da:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 80031dc:	9b03      	ldr	r3, [sp, #12]
 80031de:	9a06      	ldr	r2, [sp, #24]
 80031e0:	621a      	str	r2, [r3, #32]
}
 80031e2:	b005      	add	sp, #20
 80031e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80031e8:	f3af 8000 	nop.w
 80031ec:	f3af 8000 	nop.w

080031f0 <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void chIQResetI(input_queue_t *iqp) {
 80031f0:	b500      	push	{lr}
 80031f2:	b083      	sub	sp, #12
 80031f4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 80031f6:	9b01      	ldr	r3, [sp, #4]
 80031f8:	68da      	ldr	r2, [r3, #12]
 80031fa:	9b01      	ldr	r3, [sp, #4]
 80031fc:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr = iqp->q_buffer;
 80031fe:	9b01      	ldr	r3, [sp, #4]
 8003200:	68da      	ldr	r2, [r3, #12]
 8003202:	9b01      	ldr	r3, [sp, #4]
 8003204:	615a      	str	r2, [r3, #20]
  iqp->q_counter = 0;
 8003206:	9b01      	ldr	r3, [sp, #4]
 8003208:	2200      	movs	r2, #0
 800320a:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 800320c:	9b01      	ldr	r3, [sp, #4]
 800320e:	4618      	mov	r0, r3
 8003210:	f06f 0101 	mvn.w	r1, #1
 8003214:	f7fe f9cc 	bl	80015b0 <chThdDequeueAllI>
}
 8003218:	b003      	add	sp, #12
 800321a:	f85d fb04 	ldr.w	pc, [sp], #4
 800321e:	bf00      	nop

08003220 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8003220:	b500      	push	{lr}
 8003222:	b083      	sub	sp, #12
 8003224:	9001      	str	r0, [sp, #4]
 8003226:	460b      	mov	r3, r1
 8003228:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
 800322c:	9801      	ldr	r0, [sp, #4]
 800322e:	f7ff ff77 	bl	8003120 <chIQIsFullI>
 8003232:	4603      	mov	r3, r0
 8003234:	2b00      	cmp	r3, #0
 8003236:	d002      	beq.n	800323e <chIQPutI+0x1e>
    return Q_FULL;
 8003238:	f06f 0303 	mvn.w	r3, #3
 800323c:	e01c      	b.n	8003278 <chIQPutI+0x58>
  }

  iqp->q_counter++;
 800323e:	9b01      	ldr	r3, [sp, #4]
 8003240:	689b      	ldr	r3, [r3, #8]
 8003242:	1c5a      	adds	r2, r3, #1
 8003244:	9b01      	ldr	r3, [sp, #4]
 8003246:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8003248:	9b01      	ldr	r3, [sp, #4]
 800324a:	695b      	ldr	r3, [r3, #20]
 800324c:	1c59      	adds	r1, r3, #1
 800324e:	9a01      	ldr	r2, [sp, #4]
 8003250:	6151      	str	r1, [r2, #20]
 8003252:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8003256:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8003258:	9b01      	ldr	r3, [sp, #4]
 800325a:	695a      	ldr	r2, [r3, #20]
 800325c:	9b01      	ldr	r3, [sp, #4]
 800325e:	691b      	ldr	r3, [r3, #16]
 8003260:	429a      	cmp	r2, r3
 8003262:	d303      	bcc.n	800326c <chIQPutI+0x4c>
    iqp->q_wrptr = iqp->q_buffer;
 8003264:	9b01      	ldr	r3, [sp, #4]
 8003266:	68da      	ldr	r2, [r3, #12]
 8003268:	9b01      	ldr	r3, [sp, #4]
 800326a:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 800326c:	9b01      	ldr	r3, [sp, #4]
 800326e:	4618      	mov	r0, r3
 8003270:	2100      	movs	r1, #0
 8003272:	f7fe f985 	bl	8001580 <chThdDequeueNextI>

  return Q_OK;
 8003276:	2300      	movs	r3, #0
}
 8003278:	4618      	mov	r0, r3
 800327a:	b003      	add	sp, #12
 800327c:	f85d fb04 	ldr.w	pc, [sp], #4

08003280 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8003280:	b500      	push	{lr}
 8003282:	b085      	sub	sp, #20
 8003284:	9001      	str	r0, [sp, #4]
 8003286:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 8003288:	f7ff ff1a 	bl	80030c0 <chSysLock>
  if (iqp->q_notify != NULL) {
 800328c:	9b01      	ldr	r3, [sp, #4]
 800328e:	69db      	ldr	r3, [r3, #28]
 8003290:	2b00      	cmp	r3, #0
 8003292:	d004      	beq.n	800329e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
 8003294:	9b01      	ldr	r3, [sp, #4]
 8003296:	69db      	ldr	r3, [r3, #28]
 8003298:	9801      	ldr	r0, [sp, #4]
 800329a:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
 800329c:	e00d      	b.n	80032ba <chIQGetTimeout+0x3a>
 800329e:	e00c      	b.n	80032ba <chIQGetTimeout+0x3a>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80032a0:	9b01      	ldr	r3, [sp, #4]
 80032a2:	4618      	mov	r0, r3
 80032a4:	9900      	ldr	r1, [sp, #0]
 80032a6:	f7fe f94b 	bl	8001540 <chThdEnqueueTimeoutS>
 80032aa:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
 80032ac:	9b03      	ldr	r3, [sp, #12]
 80032ae:	2b00      	cmp	r3, #0
 80032b0:	da03      	bge.n	80032ba <chIQGetTimeout+0x3a>
      chSysUnlock();
 80032b2:	f7ff ff0d 	bl	80030d0 <chSysUnlock>
      return msg;
 80032b6:	9b03      	ldr	r3, [sp, #12]
 80032b8:	e020      	b.n	80032fc <chIQGetTimeout+0x7c>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 80032ba:	9801      	ldr	r0, [sp, #4]
 80032bc:	f7ff ff20 	bl	8003100 <chIQIsEmptyI>
 80032c0:	4603      	mov	r3, r0
 80032c2:	2b00      	cmp	r3, #0
 80032c4:	d1ec      	bne.n	80032a0 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80032c6:	9b01      	ldr	r3, [sp, #4]
 80032c8:	689b      	ldr	r3, [r3, #8]
 80032ca:	1e5a      	subs	r2, r3, #1
 80032cc:	9b01      	ldr	r3, [sp, #4]
 80032ce:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 80032d0:	9b01      	ldr	r3, [sp, #4]
 80032d2:	699b      	ldr	r3, [r3, #24]
 80032d4:	1c59      	adds	r1, r3, #1
 80032d6:	9a01      	ldr	r2, [sp, #4]
 80032d8:	6191      	str	r1, [r2, #24]
 80032da:	781b      	ldrb	r3, [r3, #0]
 80032dc:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 80032e0:	9b01      	ldr	r3, [sp, #4]
 80032e2:	699a      	ldr	r2, [r3, #24]
 80032e4:	9b01      	ldr	r3, [sp, #4]
 80032e6:	691b      	ldr	r3, [r3, #16]
 80032e8:	429a      	cmp	r2, r3
 80032ea:	d303      	bcc.n	80032f4 <chIQGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
 80032ec:	9b01      	ldr	r3, [sp, #4]
 80032ee:	68da      	ldr	r2, [r3, #12]
 80032f0:	9b01      	ldr	r3, [sp, #4]
 80032f2:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 80032f4:	f7ff feec 	bl	80030d0 <chSysUnlock>

  return (msg_t)b;
 80032f8:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 80032fc:	4618      	mov	r0, r3
 80032fe:	b005      	add	sp, #20
 8003300:	f85d fb04 	ldr.w	pc, [sp], #4
 8003304:	f3af 8000 	nop.w
 8003308:	f3af 8000 	nop.w
 800330c:	f3af 8000 	nop.w

08003310 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8003310:	b500      	push	{lr}
 8003312:	b087      	sub	sp, #28
 8003314:	9003      	str	r0, [sp, #12]
 8003316:	9102      	str	r1, [sp, #8]
 8003318:	9201      	str	r2, [sp, #4]
 800331a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 800331c:	9b03      	ldr	r3, [sp, #12]
 800331e:	69db      	ldr	r3, [r3, #28]
 8003320:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8003322:	2300      	movs	r3, #0
 8003324:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003326:	f7ff fecb 	bl	80030c0 <chSysLock>
  while (true) {
    if (nfy != NULL) {
 800332a:	9b04      	ldr	r3, [sp, #16]
 800332c:	2b00      	cmp	r3, #0
 800332e:	d003      	beq.n	8003338 <chIQReadTimeout+0x28>
      nfy(iqp);
 8003330:	9b04      	ldr	r3, [sp, #16]
 8003332:	9803      	ldr	r0, [sp, #12]
 8003334:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
 8003336:	e00c      	b.n	8003352 <chIQReadTimeout+0x42>
 8003338:	e00b      	b.n	8003352 <chIQReadTimeout+0x42>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800333a:	9b03      	ldr	r3, [sp, #12]
 800333c:	4618      	mov	r0, r3
 800333e:	9900      	ldr	r1, [sp, #0]
 8003340:	f7fe f8fe 	bl	8001540 <chThdEnqueueTimeoutS>
 8003344:	4603      	mov	r3, r0
 8003346:	2b00      	cmp	r3, #0
 8003348:	d003      	beq.n	8003352 <chIQReadTimeout+0x42>
        chSysUnlock();
 800334a:	f7ff fec1 	bl	80030d0 <chSysUnlock>
        return r;
 800334e:	9b05      	ldr	r3, [sp, #20]
 8003350:	e02e      	b.n	80033b0 <chIQReadTimeout+0xa0>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8003352:	9803      	ldr	r0, [sp, #12]
 8003354:	f7ff fed4 	bl	8003100 <chIQIsEmptyI>
 8003358:	4603      	mov	r3, r0
 800335a:	2b00      	cmp	r3, #0
 800335c:	d1ed      	bne.n	800333a <chIQReadTimeout+0x2a>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800335e:	9b03      	ldr	r3, [sp, #12]
 8003360:	689b      	ldr	r3, [r3, #8]
 8003362:	1e5a      	subs	r2, r3, #1
 8003364:	9b03      	ldr	r3, [sp, #12]
 8003366:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8003368:	9b02      	ldr	r3, [sp, #8]
 800336a:	1c5a      	adds	r2, r3, #1
 800336c:	9202      	str	r2, [sp, #8]
 800336e:	9a03      	ldr	r2, [sp, #12]
 8003370:	6992      	ldr	r2, [r2, #24]
 8003372:	1c50      	adds	r0, r2, #1
 8003374:	9903      	ldr	r1, [sp, #12]
 8003376:	6188      	str	r0, [r1, #24]
 8003378:	7812      	ldrb	r2, [r2, #0]
 800337a:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800337c:	9b03      	ldr	r3, [sp, #12]
 800337e:	699a      	ldr	r2, [r3, #24]
 8003380:	9b03      	ldr	r3, [sp, #12]
 8003382:	691b      	ldr	r3, [r3, #16]
 8003384:	429a      	cmp	r2, r3
 8003386:	d303      	bcc.n	8003390 <chIQReadTimeout+0x80>
      iqp->q_rdptr = iqp->q_buffer;
 8003388:	9b03      	ldr	r3, [sp, #12]
 800338a:	68da      	ldr	r2, [r3, #12]
 800338c:	9b03      	ldr	r3, [sp, #12]
 800338e:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8003390:	f7ff fe9e 	bl	80030d0 <chSysUnlock>

    r++;
 8003394:	9b05      	ldr	r3, [sp, #20]
 8003396:	3301      	adds	r3, #1
 8003398:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 800339a:	9b01      	ldr	r3, [sp, #4]
 800339c:	3b01      	subs	r3, #1
 800339e:	9301      	str	r3, [sp, #4]
 80033a0:	9b01      	ldr	r3, [sp, #4]
 80033a2:	2b00      	cmp	r3, #0
 80033a4:	d101      	bne.n	80033aa <chIQReadTimeout+0x9a>
      return r;
 80033a6:	9b05      	ldr	r3, [sp, #20]
 80033a8:	e002      	b.n	80033b0 <chIQReadTimeout+0xa0>
    }

    chSysLock();
 80033aa:	f7ff fe89 	bl	80030c0 <chSysLock>
  }
 80033ae:	e7bc      	b.n	800332a <chIQReadTimeout+0x1a>
}
 80033b0:	4618      	mov	r0, r3
 80033b2:	b007      	add	sp, #28
 80033b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80033b8:	f3af 8000 	nop.w
 80033bc:	f3af 8000 	nop.w

080033c0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 80033c0:	b500      	push	{lr}
 80033c2:	b085      	sub	sp, #20
 80033c4:	9003      	str	r0, [sp, #12]
 80033c6:	9102      	str	r1, [sp, #8]
 80033c8:	9201      	str	r2, [sp, #4]
 80033ca:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 80033cc:	9b03      	ldr	r3, [sp, #12]
 80033ce:	4618      	mov	r0, r3
 80033d0:	f7ff fe86 	bl	80030e0 <chThdQueueObjectInit>
  oqp->q_counter = size;
 80033d4:	9b03      	ldr	r3, [sp, #12]
 80033d6:	9a01      	ldr	r2, [sp, #4]
 80033d8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 80033da:	9b03      	ldr	r3, [sp, #12]
 80033dc:	9a02      	ldr	r2, [sp, #8]
 80033de:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 80033e0:	9b03      	ldr	r3, [sp, #12]
 80033e2:	9a02      	ldr	r2, [sp, #8]
 80033e4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 80033e6:	9b03      	ldr	r3, [sp, #12]
 80033e8:	9a02      	ldr	r2, [sp, #8]
 80033ea:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 80033ec:	9a02      	ldr	r2, [sp, #8]
 80033ee:	9b01      	ldr	r3, [sp, #4]
 80033f0:	441a      	add	r2, r3
 80033f2:	9b03      	ldr	r3, [sp, #12]
 80033f4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 80033f6:	9b03      	ldr	r3, [sp, #12]
 80033f8:	9a00      	ldr	r2, [sp, #0]
 80033fa:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 80033fc:	9b03      	ldr	r3, [sp, #12]
 80033fe:	9a06      	ldr	r2, [sp, #24]
 8003400:	621a      	str	r2, [r3, #32]
}
 8003402:	b005      	add	sp, #20
 8003404:	f85d fb04 	ldr.w	pc, [sp], #4
 8003408:	f3af 8000 	nop.w
 800340c:	f3af 8000 	nop.w

08003410 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 8003410:	b500      	push	{lr}
 8003412:	b083      	sub	sp, #12
 8003414:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8003416:	9b01      	ldr	r3, [sp, #4]
 8003418:	68da      	ldr	r2, [r3, #12]
 800341a:	9b01      	ldr	r3, [sp, #4]
 800341c:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr = oqp->q_buffer;
 800341e:	9b01      	ldr	r3, [sp, #4]
 8003420:	68da      	ldr	r2, [r3, #12]
 8003422:	9b01      	ldr	r3, [sp, #4]
 8003424:	615a      	str	r2, [r3, #20]
  oqp->q_counter = chQSizeX(oqp);
 8003426:	9b01      	ldr	r3, [sp, #4]
 8003428:	691b      	ldr	r3, [r3, #16]
 800342a:	461a      	mov	r2, r3
 800342c:	9b01      	ldr	r3, [sp, #4]
 800342e:	68db      	ldr	r3, [r3, #12]
 8003430:	1ad3      	subs	r3, r2, r3
 8003432:	461a      	mov	r2, r3
 8003434:	9b01      	ldr	r3, [sp, #4]
 8003436:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 8003438:	9b01      	ldr	r3, [sp, #4]
 800343a:	4618      	mov	r0, r3
 800343c:	f06f 0101 	mvn.w	r1, #1
 8003440:	f7fe f8b6 	bl	80015b0 <chThdDequeueAllI>
}
 8003444:	b003      	add	sp, #12
 8003446:	f85d fb04 	ldr.w	pc, [sp], #4
 800344a:	bf00      	nop
 800344c:	f3af 8000 	nop.w

08003450 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003450:	b500      	push	{lr}
 8003452:	b087      	sub	sp, #28
 8003454:	9003      	str	r0, [sp, #12]
 8003456:	460b      	mov	r3, r1
 8003458:	9201      	str	r2, [sp, #4]
 800345a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 800345e:	f7ff fe2f 	bl	80030c0 <chSysLock>
  while (chOQIsFullI(oqp)) {
 8003462:	e00c      	b.n	800347e <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003464:	9b03      	ldr	r3, [sp, #12]
 8003466:	4618      	mov	r0, r3
 8003468:	9901      	ldr	r1, [sp, #4]
 800346a:	f7fe f869 	bl	8001540 <chThdEnqueueTimeoutS>
 800346e:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 8003470:	9b05      	ldr	r3, [sp, #20]
 8003472:	2b00      	cmp	r3, #0
 8003474:	da03      	bge.n	800347e <chOQPutTimeout+0x2e>
      chSysUnlock();
 8003476:	f7ff fe2b 	bl	80030d0 <chSysUnlock>
      return msg;
 800347a:	9b05      	ldr	r3, [sp, #20]
 800347c:	e027      	b.n	80034ce <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800347e:	9803      	ldr	r0, [sp, #12]
 8003480:	f7ff fe7e 	bl	8003180 <chOQIsFullI>
 8003484:	4603      	mov	r3, r0
 8003486:	2b00      	cmp	r3, #0
 8003488:	d1ec      	bne.n	8003464 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800348a:	9b03      	ldr	r3, [sp, #12]
 800348c:	689b      	ldr	r3, [r3, #8]
 800348e:	1e5a      	subs	r2, r3, #1
 8003490:	9b03      	ldr	r3, [sp, #12]
 8003492:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8003494:	9b03      	ldr	r3, [sp, #12]
 8003496:	695b      	ldr	r3, [r3, #20]
 8003498:	1c59      	adds	r1, r3, #1
 800349a:	9a03      	ldr	r2, [sp, #12]
 800349c:	6151      	str	r1, [r2, #20]
 800349e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80034a2:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80034a4:	9b03      	ldr	r3, [sp, #12]
 80034a6:	695a      	ldr	r2, [r3, #20]
 80034a8:	9b03      	ldr	r3, [sp, #12]
 80034aa:	691b      	ldr	r3, [r3, #16]
 80034ac:	429a      	cmp	r2, r3
 80034ae:	d303      	bcc.n	80034b8 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
 80034b0:	9b03      	ldr	r3, [sp, #12]
 80034b2:	68da      	ldr	r2, [r3, #12]
 80034b4:	9b03      	ldr	r3, [sp, #12]
 80034b6:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80034b8:	9b03      	ldr	r3, [sp, #12]
 80034ba:	69db      	ldr	r3, [r3, #28]
 80034bc:	2b00      	cmp	r3, #0
 80034be:	d003      	beq.n	80034c8 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
 80034c0:	9b03      	ldr	r3, [sp, #12]
 80034c2:	69db      	ldr	r3, [r3, #28]
 80034c4:	9803      	ldr	r0, [sp, #12]
 80034c6:	4798      	blx	r3
  }
  chSysUnlock();
 80034c8:	f7ff fe02 	bl	80030d0 <chSysUnlock>

  return Q_OK;
 80034cc:	2300      	movs	r3, #0
}
 80034ce:	4618      	mov	r0, r3
 80034d0:	b007      	add	sp, #28
 80034d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80034d6:	bf00      	nop
 80034d8:	f3af 8000 	nop.w
 80034dc:	f3af 8000 	nop.w

080034e0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 80034e0:	b500      	push	{lr}
 80034e2:	b085      	sub	sp, #20
 80034e4:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
 80034e6:	9801      	ldr	r0, [sp, #4]
 80034e8:	f7ff fe32 	bl	8003150 <chOQIsEmptyI>
 80034ec:	4603      	mov	r3, r0
 80034ee:	2b00      	cmp	r3, #0
 80034f0:	d002      	beq.n	80034f8 <chOQGetI+0x18>
    return Q_EMPTY;
 80034f2:	f06f 0302 	mvn.w	r3, #2
 80034f6:	e01d      	b.n	8003534 <chOQGetI+0x54>
  }

  oqp->q_counter++;
 80034f8:	9b01      	ldr	r3, [sp, #4]
 80034fa:	689b      	ldr	r3, [r3, #8]
 80034fc:	1c5a      	adds	r2, r3, #1
 80034fe:	9b01      	ldr	r3, [sp, #4]
 8003500:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8003502:	9b01      	ldr	r3, [sp, #4]
 8003504:	699b      	ldr	r3, [r3, #24]
 8003506:	1c59      	adds	r1, r3, #1
 8003508:	9a01      	ldr	r2, [sp, #4]
 800350a:	6191      	str	r1, [r2, #24]
 800350c:	781b      	ldrb	r3, [r3, #0]
 800350e:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8003512:	9b01      	ldr	r3, [sp, #4]
 8003514:	699a      	ldr	r2, [r3, #24]
 8003516:	9b01      	ldr	r3, [sp, #4]
 8003518:	691b      	ldr	r3, [r3, #16]
 800351a:	429a      	cmp	r2, r3
 800351c:	d303      	bcc.n	8003526 <chOQGetI+0x46>
    oqp->q_rdptr = oqp->q_buffer;
 800351e:	9b01      	ldr	r3, [sp, #4]
 8003520:	68da      	ldr	r2, [r3, #12]
 8003522:	9b01      	ldr	r3, [sp, #4]
 8003524:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8003526:	9b01      	ldr	r3, [sp, #4]
 8003528:	4618      	mov	r0, r3
 800352a:	2100      	movs	r1, #0
 800352c:	f7fe f828 	bl	8001580 <chThdDequeueNextI>

  return (msg_t)b;
 8003530:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8003534:	4618      	mov	r0, r3
 8003536:	b005      	add	sp, #20
 8003538:	f85d fb04 	ldr.w	pc, [sp], #4
 800353c:	f3af 8000 	nop.w

08003540 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8003540:	b500      	push	{lr}
 8003542:	b087      	sub	sp, #28
 8003544:	9003      	str	r0, [sp, #12]
 8003546:	9102      	str	r1, [sp, #8]
 8003548:	9201      	str	r2, [sp, #4]
 800354a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 800354c:	9b03      	ldr	r3, [sp, #12]
 800354e:	69db      	ldr	r3, [r3, #28]
 8003550:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8003552:	2300      	movs	r3, #0
 8003554:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003556:	f7ff fdb3 	bl	80030c0 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
 800355a:	e00b      	b.n	8003574 <chOQWriteTimeout+0x34>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 800355c:	9b03      	ldr	r3, [sp, #12]
 800355e:	4618      	mov	r0, r3
 8003560:	9900      	ldr	r1, [sp, #0]
 8003562:	f7fd ffed 	bl	8001540 <chThdEnqueueTimeoutS>
 8003566:	4603      	mov	r3, r0
 8003568:	2b00      	cmp	r3, #0
 800356a:	d003      	beq.n	8003574 <chOQWriteTimeout+0x34>
        chSysUnlock();
 800356c:	f7ff fdb0 	bl	80030d0 <chSysUnlock>
        return w;
 8003570:	9b05      	ldr	r3, [sp, #20]
 8003572:	e035      	b.n	80035e0 <chOQWriteTimeout+0xa0>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8003574:	9803      	ldr	r0, [sp, #12]
 8003576:	f7ff fe03 	bl	8003180 <chOQIsFullI>
 800357a:	4603      	mov	r3, r0
 800357c:	2b00      	cmp	r3, #0
 800357e:	d1ed      	bne.n	800355c <chOQWriteTimeout+0x1c>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8003580:	9b03      	ldr	r3, [sp, #12]
 8003582:	689b      	ldr	r3, [r3, #8]
 8003584:	1e5a      	subs	r2, r3, #1
 8003586:	9b03      	ldr	r3, [sp, #12]
 8003588:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 800358a:	9b03      	ldr	r3, [sp, #12]
 800358c:	695b      	ldr	r3, [r3, #20]
 800358e:	1c59      	adds	r1, r3, #1
 8003590:	9a03      	ldr	r2, [sp, #12]
 8003592:	6151      	str	r1, [r2, #20]
 8003594:	9a02      	ldr	r2, [sp, #8]
 8003596:	1c51      	adds	r1, r2, #1
 8003598:	9102      	str	r1, [sp, #8]
 800359a:	7812      	ldrb	r2, [r2, #0]
 800359c:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800359e:	9b03      	ldr	r3, [sp, #12]
 80035a0:	695a      	ldr	r2, [r3, #20]
 80035a2:	9b03      	ldr	r3, [sp, #12]
 80035a4:	691b      	ldr	r3, [r3, #16]
 80035a6:	429a      	cmp	r2, r3
 80035a8:	d303      	bcc.n	80035b2 <chOQWriteTimeout+0x72>
      oqp->q_wrptr = oqp->q_buffer;
 80035aa:	9b03      	ldr	r3, [sp, #12]
 80035ac:	68da      	ldr	r2, [r3, #12]
 80035ae:	9b03      	ldr	r3, [sp, #12]
 80035b0:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 80035b2:	9b04      	ldr	r3, [sp, #16]
 80035b4:	2b00      	cmp	r3, #0
 80035b6:	d002      	beq.n	80035be <chOQWriteTimeout+0x7e>
      nfy(oqp);
 80035b8:	9b04      	ldr	r3, [sp, #16]
 80035ba:	9803      	ldr	r0, [sp, #12]
 80035bc:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80035be:	f7ff fd87 	bl	80030d0 <chSysUnlock>

    w++;
 80035c2:	9b05      	ldr	r3, [sp, #20]
 80035c4:	3301      	adds	r3, #1
 80035c6:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80035c8:	9b01      	ldr	r3, [sp, #4]
 80035ca:	3b01      	subs	r3, #1
 80035cc:	9301      	str	r3, [sp, #4]
 80035ce:	9b01      	ldr	r3, [sp, #4]
 80035d0:	2b00      	cmp	r3, #0
 80035d2:	d101      	bne.n	80035d8 <chOQWriteTimeout+0x98>
      return w;
 80035d4:	9b05      	ldr	r3, [sp, #20]
 80035d6:	e003      	b.n	80035e0 <chOQWriteTimeout+0xa0>
    }
    chSysLock();
 80035d8:	f7ff fd72 	bl	80030c0 <chSysLock>
  }
 80035dc:	bf00      	nop

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80035de:	e7c9      	b.n	8003574 <chOQWriteTimeout+0x34>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80035e0:	4618      	mov	r0, r3
 80035e2:	b007      	add	sp, #28
 80035e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80035e8:	f3af 8000 	nop.w
 80035ec:	f3af 8000 	nop.w

080035f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80035f0:	b082      	sub	sp, #8
 80035f2:	2320      	movs	r3, #32
 80035f4:	9301      	str	r3, [sp, #4]
 80035f6:	9b01      	ldr	r3, [sp, #4]
 80035f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80035fc:	b002      	add	sp, #8
 80035fe:	4770      	bx	lr

08003600 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003600:	b082      	sub	sp, #8
 8003602:	2300      	movs	r3, #0
 8003604:	9301      	str	r3, [sp, #4]
 8003606:	9b01      	ldr	r3, [sp, #4]
 8003608:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800360c:	b002      	add	sp, #8
 800360e:	4770      	bx	lr

08003610 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003610:	b508      	push	{r3, lr}

  port_lock();
 8003612:	f7ff ffed 	bl	80035f0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003616:	bd08      	pop	{r3, pc}
 8003618:	f3af 8000 	nop.w
 800361c:	f3af 8000 	nop.w

08003620 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003620:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003622:	f7ff ffed 	bl	8003600 <port_unlock>
}
 8003626:	bd08      	pop	{r3, pc}
 8003628:	f3af 8000 	nop.w
 800362c:	f3af 8000 	nop.w

08003630 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003630:	4b06      	ldr	r3, [pc, #24]	; (800364c <_core_init+0x1c>)
 8003632:	3307      	adds	r3, #7
 8003634:	f023 0307 	bic.w	r3, r3, #7
 8003638:	461a      	mov	r2, r3
 800363a:	4b05      	ldr	r3, [pc, #20]	; (8003650 <_core_init+0x20>)
 800363c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800363e:	4b05      	ldr	r3, [pc, #20]	; (8003654 <_core_init+0x24>)
 8003640:	f023 0307 	bic.w	r3, r3, #7
 8003644:	461a      	mov	r2, r3
 8003646:	4b04      	ldr	r3, [pc, #16]	; (8003658 <_core_init+0x28>)
 8003648:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 800364a:	4770      	bx	lr
 800364c:	20006d20 	.word	0x20006d20
 8003650:	20001220 	.word	0x20001220
 8003654:	20018000 	.word	0x20018000
 8003658:	20001224 	.word	0x20001224
 800365c:	f3af 8000 	nop.w

08003660 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8003660:	b500      	push	{lr}
 8003662:	b085      	sub	sp, #20
 8003664:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8003666:	f7ff ffd3 	bl	8003610 <chSysLock>
  p = chCoreAllocI(size);
 800366a:	9801      	ldr	r0, [sp, #4]
 800366c:	f000 f808 	bl	8003680 <chCoreAllocI>
 8003670:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003672:	f7ff ffd5 	bl	8003620 <chSysUnlock>

  return p;
 8003676:	9b03      	ldr	r3, [sp, #12]
}
 8003678:	4618      	mov	r0, r3
 800367a:	b005      	add	sp, #20
 800367c:	f85d fb04 	ldr.w	pc, [sp], #4

08003680 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8003680:	b084      	sub	sp, #16
 8003682:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8003684:	9b01      	ldr	r3, [sp, #4]
 8003686:	3307      	adds	r3, #7
 8003688:	f023 0307 	bic.w	r3, r3, #7
 800368c:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800368e:	4b0c      	ldr	r3, [pc, #48]	; (80036c0 <chCoreAllocI+0x40>)
 8003690:	681b      	ldr	r3, [r3, #0]
 8003692:	461a      	mov	r2, r3
 8003694:	4b0b      	ldr	r3, [pc, #44]	; (80036c4 <chCoreAllocI+0x44>)
 8003696:	681b      	ldr	r3, [r3, #0]
 8003698:	1ad3      	subs	r3, r2, r3
 800369a:	461a      	mov	r2, r3
 800369c:	9b01      	ldr	r3, [sp, #4]
 800369e:	429a      	cmp	r2, r3
 80036a0:	d201      	bcs.n	80036a6 <chCoreAllocI+0x26>
  /*lint -restore*/
    return NULL;
 80036a2:	2300      	movs	r3, #0
 80036a4:	e009      	b.n	80036ba <chCoreAllocI+0x3a>
  }
  p = nextmem;
 80036a6:	4b07      	ldr	r3, [pc, #28]	; (80036c4 <chCoreAllocI+0x44>)
 80036a8:	681b      	ldr	r3, [r3, #0]
 80036aa:	9303      	str	r3, [sp, #12]
  nextmem += size;
 80036ac:	4b05      	ldr	r3, [pc, #20]	; (80036c4 <chCoreAllocI+0x44>)
 80036ae:	681a      	ldr	r2, [r3, #0]
 80036b0:	9b01      	ldr	r3, [sp, #4]
 80036b2:	441a      	add	r2, r3
 80036b4:	4b03      	ldr	r3, [pc, #12]	; (80036c4 <chCoreAllocI+0x44>)
 80036b6:	601a      	str	r2, [r3, #0]

  return p;
 80036b8:	9b03      	ldr	r3, [sp, #12]
}
 80036ba:	4618      	mov	r0, r3
 80036bc:	b004      	add	sp, #16
 80036be:	4770      	bx	lr
 80036c0:	20001224 	.word	0x20001224
 80036c4:	20001220 	.word	0x20001220
 80036c8:	f3af 8000 	nop.w
 80036cc:	f3af 8000 	nop.w

080036d0 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 80036d0:	4b03      	ldr	r3, [pc, #12]	; (80036e0 <chCoreGetStatusX+0x10>)
 80036d2:	681b      	ldr	r3, [r3, #0]
 80036d4:	461a      	mov	r2, r3
 80036d6:	4b03      	ldr	r3, [pc, #12]	; (80036e4 <chCoreGetStatusX+0x14>)
 80036d8:	681b      	ldr	r3, [r3, #0]
 80036da:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 80036dc:	4618      	mov	r0, r3
 80036de:	4770      	bx	lr
 80036e0:	20001224 	.word	0x20001224
 80036e4:	20001220 	.word	0x20001220
 80036e8:	f3af 8000 	nop.w
 80036ec:	f3af 8000 	nop.w

080036f0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80036f0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 80036f2:	4b06      	ldr	r3, [pc, #24]	; (800370c <_heap_init+0x1c>)
 80036f4:	4a06      	ldr	r2, [pc, #24]	; (8003710 <_heap_init+0x20>)
 80036f6:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 80036f8:	4b04      	ldr	r3, [pc, #16]	; (800370c <_heap_init+0x1c>)
 80036fa:	2200      	movs	r2, #0
 80036fc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80036fe:	4b03      	ldr	r3, [pc, #12]	; (800370c <_heap_init+0x1c>)
 8003700:	2200      	movs	r2, #0
 8003702:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8003704:	4803      	ldr	r0, [pc, #12]	; (8003714 <_heap_init+0x24>)
 8003706:	f7fe fbf3 	bl	8001ef0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 800370a:	bd08      	pop	{r3, pc}
 800370c:	20001228 	.word	0x20001228
 8003710:	08003661 	.word	0x08003661
 8003714:	20001238 	.word	0x20001238
 8003718:	f3af 8000 	nop.w
 800371c:	f3af 8000 	nop.w

08003720 <chHeapObjectInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
 8003720:	b500      	push	{lr}
 8003722:	b087      	sub	sp, #28
 8003724:	9003      	str	r0, [sp, #12]
 8003726:	9102      	str	r1, [sp, #8]
 8003728:	9201      	str	r2, [sp, #4]
  union heap_header *hp = buf;
 800372a:	9b02      	ldr	r3, [sp, #8]
 800372c:	9305      	str	r3, [sp, #20]

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 800372e:	9b03      	ldr	r3, [sp, #12]
 8003730:	2200      	movs	r2, #0
 8003732:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
 8003734:	9b03      	ldr	r3, [sp, #12]
 8003736:	9a05      	ldr	r2, [sp, #20]
 8003738:	609a      	str	r2, [r3, #8]
  heapp->h_free.h.size = 0;
 800373a:	9b03      	ldr	r3, [sp, #12]
 800373c:	2200      	movs	r2, #0
 800373e:	60da      	str	r2, [r3, #12]
  hp->h.u.next = NULL;
 8003740:	9b05      	ldr	r3, [sp, #20]
 8003742:	2200      	movs	r2, #0
 8003744:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
 8003746:	9b01      	ldr	r3, [sp, #4]
 8003748:	f1a3 0208 	sub.w	r2, r3, #8
 800374c:	9b05      	ldr	r3, [sp, #20]
 800374e:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8003750:	9b03      	ldr	r3, [sp, #12]
 8003752:	3310      	adds	r3, #16
 8003754:	4618      	mov	r0, r3
 8003756:	f7fe fbcb 	bl	8001ef0 <chMtxObjectInit>
#else
  chSemObjectInit(&heapp->h_sem, (cnt_t)1);
#endif
}
 800375a:	b007      	add	sp, #28
 800375c:	f85d fb04 	ldr.w	pc, [sp], #4

08003760 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8003760:	b500      	push	{lr}
 8003762:	b087      	sub	sp, #28
 8003764:	9001      	str	r0, [sp, #4]
 8003766:	9100      	str	r1, [sp, #0]
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 8003768:	9b01      	ldr	r3, [sp, #4]
 800376a:	2b00      	cmp	r3, #0
 800376c:	d101      	bne.n	8003772 <chHeapAlloc+0x12>
    heapp = &default_heap;
 800376e:	4b37      	ldr	r3, [pc, #220]	; (800384c <chHeapAlloc+0xec>)
 8003770:	9301      	str	r3, [sp, #4]
  }

  size = MEM_ALIGN_NEXT(size);
 8003772:	9b00      	ldr	r3, [sp, #0]
 8003774:	3307      	adds	r3, #7
 8003776:	f023 0307 	bic.w	r3, r3, #7
 800377a:	9300      	str	r3, [sp, #0]
  qp = &heapp->h_free;
 800377c:	9b01      	ldr	r3, [sp, #4]
 800377e:	3308      	adds	r3, #8
 8003780:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 8003782:	9b01      	ldr	r3, [sp, #4]
 8003784:	3310      	adds	r3, #16
 8003786:	4618      	mov	r0, r3
 8003788:	f7fe fbc2 	bl	8001f10 <chMtxLock>
  while (qp->h.u.next != NULL) {
 800378c:	e036      	b.n	80037fc <chHeapAlloc+0x9c>
    hp = qp->h.u.next;
 800378e:	9b05      	ldr	r3, [sp, #20]
 8003790:	681b      	ldr	r3, [r3, #0]
 8003792:	9304      	str	r3, [sp, #16]
    if (hp->h.size >= size) {
 8003794:	9b04      	ldr	r3, [sp, #16]
 8003796:	685a      	ldr	r2, [r3, #4]
 8003798:	9b00      	ldr	r3, [sp, #0]
 800379a:	429a      	cmp	r2, r3
 800379c:	d32c      	bcc.n	80037f8 <chHeapAlloc+0x98>
      if (hp->h.size < (size + sizeof(union heap_header))) {
 800379e:	9b04      	ldr	r3, [sp, #16]
 80037a0:	685a      	ldr	r2, [r3, #4]
 80037a2:	9b00      	ldr	r3, [sp, #0]
 80037a4:	3308      	adds	r3, #8
 80037a6:	429a      	cmp	r2, r3
 80037a8:	d204      	bcs.n	80037b4 <chHeapAlloc+0x54>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 80037aa:	9b04      	ldr	r3, [sp, #16]
 80037ac:	681a      	ldr	r2, [r3, #0]
 80037ae:	9b05      	ldr	r3, [sp, #20]
 80037b0:	601a      	str	r2, [r3, #0]
 80037b2:	e016      	b.n	80037e2 <chHeapAlloc+0x82>
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 80037b4:	9b00      	ldr	r3, [sp, #0]
 80037b6:	3308      	adds	r3, #8
 80037b8:	9a04      	ldr	r2, [sp, #16]
 80037ba:	4413      	add	r3, r2
 80037bc:	9303      	str	r3, [sp, #12]
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80037be:	9b04      	ldr	r3, [sp, #16]
 80037c0:	681a      	ldr	r2, [r3, #0]
 80037c2:	9b03      	ldr	r3, [sp, #12]
 80037c4:	601a      	str	r2, [r3, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 80037c6:	9b04      	ldr	r3, [sp, #16]
 80037c8:	685a      	ldr	r2, [r3, #4]
 80037ca:	9b00      	ldr	r3, [sp, #0]
 80037cc:	1ad3      	subs	r3, r2, r3
 80037ce:	f1a3 0208 	sub.w	r2, r3, #8
 80037d2:	9b03      	ldr	r3, [sp, #12]
 80037d4:	605a      	str	r2, [r3, #4]
        qp->h.u.next = fp;
 80037d6:	9b05      	ldr	r3, [sp, #20]
 80037d8:	9a03      	ldr	r2, [sp, #12]
 80037da:	601a      	str	r2, [r3, #0]
        hp->h.size = size;
 80037dc:	9b04      	ldr	r3, [sp, #16]
 80037de:	9a00      	ldr	r2, [sp, #0]
 80037e0:	605a      	str	r2, [r3, #4]
      }
      hp->h.u.heap = heapp;
 80037e2:	9b04      	ldr	r3, [sp, #16]
 80037e4:	9a01      	ldr	r2, [sp, #4]
 80037e6:	601a      	str	r2, [r3, #0]
      H_UNLOCK(heapp);
 80037e8:	9b01      	ldr	r3, [sp, #4]
 80037ea:	3310      	adds	r3, #16
 80037ec:	4618      	mov	r0, r3
 80037ee:	f7fe fc37 	bl	8002060 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 80037f2:	9b04      	ldr	r3, [sp, #16]
 80037f4:	3308      	adds	r3, #8
 80037f6:	e024      	b.n	8003842 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
    qp = hp;
 80037f8:	9b04      	ldr	r3, [sp, #16]
 80037fa:	9305      	str	r3, [sp, #20]

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 80037fc:	9b05      	ldr	r3, [sp, #20]
 80037fe:	681b      	ldr	r3, [r3, #0]
 8003800:	2b00      	cmp	r3, #0
 8003802:	d1c4      	bne.n	800378e <chHeapAlloc+0x2e>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8003804:	9b01      	ldr	r3, [sp, #4]
 8003806:	3310      	adds	r3, #16
 8003808:	4618      	mov	r0, r3
 800380a:	f7fe fc29 	bl	8002060 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 800380e:	9b01      	ldr	r3, [sp, #4]
 8003810:	681b      	ldr	r3, [r3, #0]
 8003812:	2b00      	cmp	r3, #0
 8003814:	d014      	beq.n	8003840 <chHeapAlloc+0xe0>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8003816:	9b01      	ldr	r3, [sp, #4]
 8003818:	681b      	ldr	r3, [r3, #0]
 800381a:	9a00      	ldr	r2, [sp, #0]
 800381c:	3208      	adds	r2, #8
 800381e:	4610      	mov	r0, r2
 8003820:	4798      	blx	r3
 8003822:	9004      	str	r0, [sp, #16]
    if (hp != NULL) {
 8003824:	9b04      	ldr	r3, [sp, #16]
 8003826:	2b00      	cmp	r3, #0
 8003828:	d00a      	beq.n	8003840 <chHeapAlloc+0xe0>
      hp->h.u.heap = heapp;
 800382a:	9b04      	ldr	r3, [sp, #16]
 800382c:	9a01      	ldr	r2, [sp, #4]
 800382e:	601a      	str	r2, [r3, #0]
      hp->h.size = size;
 8003830:	9b04      	ldr	r3, [sp, #16]
 8003832:	9a00      	ldr	r2, [sp, #0]
 8003834:	605a      	str	r2, [r3, #4]
      hp++;
 8003836:	9b04      	ldr	r3, [sp, #16]
 8003838:	3308      	adds	r3, #8
 800383a:	9304      	str	r3, [sp, #16]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 800383c:	9b04      	ldr	r3, [sp, #16]
 800383e:	e000      	b.n	8003842 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
  }

  return NULL;
 8003840:	2300      	movs	r3, #0
}
 8003842:	4618      	mov	r0, r3
 8003844:	b007      	add	sp, #28
 8003846:	f85d fb04 	ldr.w	pc, [sp], #4
 800384a:	bf00      	nop
 800384c:	20001228 	.word	0x20001228

08003850 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8003850:	b500      	push	{lr}
 8003852:	b087      	sub	sp, #28
 8003854:	9001      	str	r0, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8003856:	9b01      	ldr	r3, [sp, #4]
 8003858:	3b08      	subs	r3, #8
 800385a:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = hp->h.u.heap;
 800385c:	9b04      	ldr	r3, [sp, #16]
 800385e:	681b      	ldr	r3, [r3, #0]
 8003860:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
 8003862:	9b03      	ldr	r3, [sp, #12]
 8003864:	3308      	adds	r3, #8
 8003866:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 8003868:	9b03      	ldr	r3, [sp, #12]
 800386a:	3310      	adds	r3, #16
 800386c:	4618      	mov	r0, r3
 800386e:	f7fe fb4f 	bl	8001f10 <chMtxLock>
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8003872:	9b03      	ldr	r3, [sp, #12]
 8003874:	f103 0208 	add.w	r2, r3, #8
 8003878:	9b05      	ldr	r3, [sp, #20]
 800387a:	429a      	cmp	r2, r3
 800387c:	d003      	beq.n	8003886 <chHeapFree+0x36>
 800387e:	9a04      	ldr	r2, [sp, #16]
 8003880:	9b05      	ldr	r3, [sp, #20]
 8003882:	429a      	cmp	r2, r3
 8003884:	d93e      	bls.n	8003904 <chHeapFree+0xb4>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8003886:	9b05      	ldr	r3, [sp, #20]
 8003888:	681b      	ldr	r3, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 800388a:	2b00      	cmp	r3, #0
 800388c:	d004      	beq.n	8003898 <chHeapFree+0x48>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 800388e:	9b05      	ldr	r3, [sp, #20]
 8003890:	681a      	ldr	r2, [r3, #0]
 8003892:	9b04      	ldr	r3, [sp, #16]
 8003894:	429a      	cmp	r2, r3
 8003896:	d935      	bls.n	8003904 <chHeapFree+0xb4>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8003898:	9b05      	ldr	r3, [sp, #20]
 800389a:	681a      	ldr	r2, [r3, #0]
 800389c:	9b04      	ldr	r3, [sp, #16]
 800389e:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
 80038a0:	9b05      	ldr	r3, [sp, #20]
 80038a2:	9a04      	ldr	r2, [sp, #16]
 80038a4:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80038a6:	9b04      	ldr	r3, [sp, #16]
 80038a8:	685b      	ldr	r3, [r3, #4]
 80038aa:	3308      	adds	r3, #8
 80038ac:	9a04      	ldr	r2, [sp, #16]
 80038ae:	441a      	add	r2, r3
 80038b0:	9b04      	ldr	r3, [sp, #16]
 80038b2:	681b      	ldr	r3, [r3, #0]
 80038b4:	429a      	cmp	r2, r3
 80038b6:	d10e      	bne.n	80038d6 <chHeapFree+0x86>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 80038b8:	9b04      	ldr	r3, [sp, #16]
 80038ba:	685a      	ldr	r2, [r3, #4]
 80038bc:	9b04      	ldr	r3, [sp, #16]
 80038be:	681b      	ldr	r3, [r3, #0]
 80038c0:	685b      	ldr	r3, [r3, #4]
 80038c2:	4413      	add	r3, r2
 80038c4:	f103 0208 	add.w	r2, r3, #8
 80038c8:	9b04      	ldr	r3, [sp, #16]
 80038ca:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 80038cc:	9b04      	ldr	r3, [sp, #16]
 80038ce:	681b      	ldr	r3, [r3, #0]
 80038d0:	681a      	ldr	r2, [r3, #0]
 80038d2:	9b04      	ldr	r3, [sp, #16]
 80038d4:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
 80038d6:	9b05      	ldr	r3, [sp, #20]
 80038d8:	685b      	ldr	r3, [r3, #4]
 80038da:	3308      	adds	r3, #8
 80038dc:	9a05      	ldr	r2, [sp, #20]
 80038de:	441a      	add	r2, r3
 80038e0:	9b04      	ldr	r3, [sp, #16]
 80038e2:	429a      	cmp	r2, r3
 80038e4:	d10d      	bne.n	8003902 <chHeapFree+0xb2>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 80038e6:	9b05      	ldr	r3, [sp, #20]
 80038e8:	685a      	ldr	r2, [r3, #4]
 80038ea:	9b04      	ldr	r3, [sp, #16]
 80038ec:	685b      	ldr	r3, [r3, #4]
 80038ee:	4413      	add	r3, r2
 80038f0:	f103 0208 	add.w	r2, r3, #8
 80038f4:	9b05      	ldr	r3, [sp, #20]
 80038f6:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 80038f8:	9b04      	ldr	r3, [sp, #16]
 80038fa:	681a      	ldr	r2, [r3, #0]
 80038fc:	9b05      	ldr	r3, [sp, #20]
 80038fe:	601a      	str	r2, [r3, #0]
      }
      break;
 8003900:	e004      	b.n	800390c <chHeapFree+0xbc>
 8003902:	e003      	b.n	800390c <chHeapFree+0xbc>
    }
    qp = qp->h.u.next;
 8003904:	9b05      	ldr	r3, [sp, #20]
 8003906:	681b      	ldr	r3, [r3, #0]
 8003908:	9305      	str	r3, [sp, #20]
  }
 800390a:	e7b2      	b.n	8003872 <chHeapFree+0x22>
  H_UNLOCK(heapp);
 800390c:	9b03      	ldr	r3, [sp, #12]
 800390e:	3310      	adds	r3, #16
 8003910:	4618      	mov	r0, r3
 8003912:	f7fe fba5 	bl	8002060 <chMtxUnlock>

  return;
 8003916:	bf00      	nop
}
 8003918:	b007      	add	sp, #28
 800391a:	f85d fb04 	ldr.w	pc, [sp], #4
 800391e:	bf00      	nop

08003920 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8003920:	b500      	push	{lr}
 8003922:	b087      	sub	sp, #28
 8003924:	9001      	str	r0, [sp, #4]
 8003926:	9100      	str	r1, [sp, #0]
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
 8003928:	9b01      	ldr	r3, [sp, #4]
 800392a:	2b00      	cmp	r3, #0
 800392c:	d101      	bne.n	8003932 <chHeapStatus+0x12>
    heapp = &default_heap;
 800392e:	4b17      	ldr	r3, [pc, #92]	; (800398c <chHeapStatus+0x6c>)
 8003930:	9301      	str	r3, [sp, #4]
  }

  H_LOCK(heapp);
 8003932:	9b01      	ldr	r3, [sp, #4]
 8003934:	3310      	adds	r3, #16
 8003936:	4618      	mov	r0, r3
 8003938:	f7fe faea 	bl	8001f10 <chMtxLock>
  sz = 0;
 800393c:	2300      	movs	r3, #0
 800393e:	9303      	str	r3, [sp, #12]
  n = 0;
 8003940:	2300      	movs	r3, #0
 8003942:	9304      	str	r3, [sp, #16]
  qp = &heapp->h_free;
 8003944:	9b01      	ldr	r3, [sp, #4]
 8003946:	3308      	adds	r3, #8
 8003948:	9305      	str	r3, [sp, #20]
  while (qp->h.u.next != NULL) {
 800394a:	e00b      	b.n	8003964 <chHeapStatus+0x44>
    sz += qp->h.u.next->h.size;
 800394c:	9b05      	ldr	r3, [sp, #20]
 800394e:	681b      	ldr	r3, [r3, #0]
 8003950:	685b      	ldr	r3, [r3, #4]
 8003952:	9a03      	ldr	r2, [sp, #12]
 8003954:	4413      	add	r3, r2
 8003956:	9303      	str	r3, [sp, #12]
    n++;
 8003958:	9b04      	ldr	r3, [sp, #16]
 800395a:	3301      	adds	r3, #1
 800395c:	9304      	str	r3, [sp, #16]
    qp = qp->h.u.next;
 800395e:	9b05      	ldr	r3, [sp, #20]
 8003960:	681b      	ldr	r3, [r3, #0]
 8003962:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8003964:	9b05      	ldr	r3, [sp, #20]
 8003966:	681b      	ldr	r3, [r3, #0]
 8003968:	2b00      	cmp	r3, #0
 800396a:	d1ef      	bne.n	800394c <chHeapStatus+0x2c>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 800396c:	9b00      	ldr	r3, [sp, #0]
 800396e:	2b00      	cmp	r3, #0
 8003970:	d002      	beq.n	8003978 <chHeapStatus+0x58>
    *sizep = sz;
 8003972:	9b00      	ldr	r3, [sp, #0]
 8003974:	9a03      	ldr	r2, [sp, #12]
 8003976:	601a      	str	r2, [r3, #0]
  }
  H_UNLOCK(heapp);
 8003978:	9b01      	ldr	r3, [sp, #4]
 800397a:	3310      	adds	r3, #16
 800397c:	4618      	mov	r0, r3
 800397e:	f7fe fb6f 	bl	8002060 <chMtxUnlock>

  return n;
 8003982:	9b04      	ldr	r3, [sp, #16]
}
 8003984:	4618      	mov	r0, r3
 8003986:	b007      	add	sp, #28
 8003988:	f85d fb04 	ldr.w	pc, [sp], #4
 800398c:	20001228 	.word	0x20001228

08003990 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003990:	b082      	sub	sp, #8
 8003992:	2320      	movs	r3, #32
 8003994:	9301      	str	r3, [sp, #4]
 8003996:	9b01      	ldr	r3, [sp, #4]
 8003998:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800399c:	b002      	add	sp, #8
 800399e:	4770      	bx	lr

080039a0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80039a0:	b082      	sub	sp, #8
 80039a2:	2300      	movs	r3, #0
 80039a4:	9301      	str	r3, [sp, #4]
 80039a6:	9b01      	ldr	r3, [sp, #4]
 80039a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80039ac:	b002      	add	sp, #8
 80039ae:	4770      	bx	lr

080039b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80039b0:	b508      	push	{r3, lr}

  port_lock();
 80039b2:	f7ff ffed 	bl	8003990 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80039b6:	bd08      	pop	{r3, pc}
 80039b8:	f3af 8000 	nop.w
 80039bc:	f3af 8000 	nop.w

080039c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80039c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80039c2:	f7ff ffed 	bl	80039a0 <port_unlock>
}
 80039c6:	bd08      	pop	{r3, pc}
 80039c8:	f3af 8000 	nop.w
 80039cc:	f3af 8000 	nop.w

080039d0 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 80039d0:	b500      	push	{lr}
 80039d2:	b083      	sub	sp, #12
 80039d4:	9001      	str	r0, [sp, #4]
 80039d6:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
 80039d8:	9801      	ldr	r0, [sp, #4]
 80039da:	9900      	ldr	r1, [sp, #0]
 80039dc:	f000 f870 	bl	8003ac0 <chPoolFree>
}
 80039e0:	b003      	add	sp, #12
 80039e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80039e6:	bf00      	nop
 80039e8:	f3af 8000 	nop.w
 80039ec:	f3af 8000 	nop.w

080039f0 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 80039f0:	b084      	sub	sp, #16
 80039f2:	9003      	str	r0, [sp, #12]
 80039f4:	9102      	str	r1, [sp, #8]
 80039f6:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80039f8:	9b03      	ldr	r3, [sp, #12]
 80039fa:	2200      	movs	r2, #0
 80039fc:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 80039fe:	9b03      	ldr	r3, [sp, #12]
 8003a00:	9a02      	ldr	r2, [sp, #8]
 8003a02:	605a      	str	r2, [r3, #4]
  mp->mp_provider = provider;
 8003a04:	9b03      	ldr	r3, [sp, #12]
 8003a06:	9a01      	ldr	r2, [sp, #4]
 8003a08:	609a      	str	r2, [r3, #8]
}
 8003a0a:	b004      	add	sp, #16
 8003a0c:	4770      	bx	lr
 8003a0e:	bf00      	nop

08003a10 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8003a10:	b500      	push	{lr}
 8003a12:	b085      	sub	sp, #20
 8003a14:	9003      	str	r0, [sp, #12]
 8003a16:	9102      	str	r1, [sp, #8]
 8003a18:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003a1a:	e00b      	b.n	8003a34 <chPoolLoadArray+0x24>
    chPoolAdd(mp, p);
 8003a1c:	9803      	ldr	r0, [sp, #12]
 8003a1e:	9902      	ldr	r1, [sp, #8]
 8003a20:	f7ff ffd6 	bl	80039d0 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8003a24:	9b03      	ldr	r3, [sp, #12]
 8003a26:	685b      	ldr	r3, [r3, #4]
 8003a28:	9a02      	ldr	r2, [sp, #8]
 8003a2a:	4413      	add	r3, r2
 8003a2c:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 8003a2e:	9b01      	ldr	r3, [sp, #4]
 8003a30:	3b01      	subs	r3, #1
 8003a32:	9301      	str	r3, [sp, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003a34:	9b01      	ldr	r3, [sp, #4]
 8003a36:	2b00      	cmp	r3, #0
 8003a38:	d1f0      	bne.n	8003a1c <chPoolLoadArray+0xc>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    /*lint -restore*/
    n--;
  }
}
 8003a3a:	b005      	add	sp, #20
 8003a3c:	f85d fb04 	ldr.w	pc, [sp], #4

08003a40 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 8003a40:	b500      	push	{lr}
 8003a42:	b085      	sub	sp, #20
 8003a44:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->mp_next;
 8003a46:	9b01      	ldr	r3, [sp, #4]
 8003a48:	681b      	ldr	r3, [r3, #0]
 8003a4a:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8003a4c:	9b03      	ldr	r3, [sp, #12]
 8003a4e:	2b00      	cmp	r3, #0
 8003a50:	d005      	beq.n	8003a5e <chPoolAllocI+0x1e>
    mp->mp_next = mp->mp_next->ph_next;
 8003a52:	9b01      	ldr	r3, [sp, #4]
 8003a54:	681b      	ldr	r3, [r3, #0]
 8003a56:	681a      	ldr	r2, [r3, #0]
 8003a58:	9b01      	ldr	r3, [sp, #4]
 8003a5a:	601a      	str	r2, [r3, #0]
 8003a5c:	e00a      	b.n	8003a74 <chPoolAllocI+0x34>
  }
  else if (mp->mp_provider != NULL) {
 8003a5e:	9b01      	ldr	r3, [sp, #4]
 8003a60:	689b      	ldr	r3, [r3, #8]
 8003a62:	2b00      	cmp	r3, #0
 8003a64:	d006      	beq.n	8003a74 <chPoolAllocI+0x34>
    objp = mp->mp_provider(mp->mp_object_size);
 8003a66:	9b01      	ldr	r3, [sp, #4]
 8003a68:	689b      	ldr	r3, [r3, #8]
 8003a6a:	9a01      	ldr	r2, [sp, #4]
 8003a6c:	6852      	ldr	r2, [r2, #4]
 8003a6e:	4610      	mov	r0, r2
 8003a70:	4798      	blx	r3
 8003a72:	9003      	str	r0, [sp, #12]
  }
  /*lint -restore*/

  return objp;
 8003a74:	9b03      	ldr	r3, [sp, #12]
}
 8003a76:	4618      	mov	r0, r3
 8003a78:	b005      	add	sp, #20
 8003a7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a7e:	bf00      	nop

08003a80 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8003a80:	b500      	push	{lr}
 8003a82:	b085      	sub	sp, #20
 8003a84:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
 8003a86:	f7ff ff93 	bl	80039b0 <chSysLock>
  objp = chPoolAllocI(mp);
 8003a8a:	9801      	ldr	r0, [sp, #4]
 8003a8c:	f7ff ffd8 	bl	8003a40 <chPoolAllocI>
 8003a90:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003a92:	f7ff ff95 	bl	80039c0 <chSysUnlock>

  return objp;
 8003a96:	9b03      	ldr	r3, [sp, #12]
}
 8003a98:	4618      	mov	r0, r3
 8003a9a:	b005      	add	sp, #20
 8003a9c:	f85d fb04 	ldr.w	pc, [sp], #4

08003aa0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8003aa0:	b084      	sub	sp, #16
 8003aa2:	9001      	str	r0, [sp, #4]
 8003aa4:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8003aa6:	9b00      	ldr	r3, [sp, #0]
 8003aa8:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8003aaa:	9b01      	ldr	r3, [sp, #4]
 8003aac:	681a      	ldr	r2, [r3, #0]
 8003aae:	9b03      	ldr	r3, [sp, #12]
 8003ab0:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
 8003ab2:	9b01      	ldr	r3, [sp, #4]
 8003ab4:	9a03      	ldr	r2, [sp, #12]
 8003ab6:	601a      	str	r2, [r3, #0]
}
 8003ab8:	b004      	add	sp, #16
 8003aba:	4770      	bx	lr
 8003abc:	f3af 8000 	nop.w

08003ac0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8003ac0:	b500      	push	{lr}
 8003ac2:	b083      	sub	sp, #12
 8003ac4:	9001      	str	r0, [sp, #4]
 8003ac6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8003ac8:	f7ff ff72 	bl	80039b0 <chSysLock>
  chPoolFreeI(mp, objp);
 8003acc:	9801      	ldr	r0, [sp, #4]
 8003ace:	9900      	ldr	r1, [sp, #0]
 8003ad0:	f7ff ffe6 	bl	8003aa0 <chPoolFreeI>
  chSysUnlock();
 8003ad4:	f7ff ff74 	bl	80039c0 <chSysUnlock>
}
 8003ad8:	b003      	add	sp, #12
 8003ada:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ade:	bf00      	nop

08003ae0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003ae0:	b082      	sub	sp, #8
 8003ae2:	2320      	movs	r3, #32
 8003ae4:	9301      	str	r3, [sp, #4]
 8003ae6:	9b01      	ldr	r3, [sp, #4]
 8003ae8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003aec:	b002      	add	sp, #8
 8003aee:	4770      	bx	lr

08003af0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003af0:	b082      	sub	sp, #8
 8003af2:	2300      	movs	r3, #0
 8003af4:	9301      	str	r3, [sp, #4]
 8003af6:	9b01      	ldr	r3, [sp, #4]
 8003af8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003afc:	b002      	add	sp, #8
 8003afe:	4770      	bx	lr

08003b00 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8003b00:	b508      	push	{r3, lr}

  port_lock();
 8003b02:	f7ff ffed 	bl	8003ae0 <port_lock>
}
 8003b06:	bd08      	pop	{r3, pc}
 8003b08:	f3af 8000 	nop.w
 8003b0c:	f3af 8000 	nop.w

08003b10 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003b10:	b508      	push	{r3, lr}

  port_unlock();
 8003b12:	f7ff ffed 	bl	8003af0 <port_unlock>
}
 8003b16:	bd08      	pop	{r3, pc}
 8003b18:	f3af 8000 	nop.w
 8003b1c:	f3af 8000 	nop.w

08003b20 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8003b20:	b510      	push	{r4, lr}
 8003b22:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003b24:	f3ef 8309 	mrs	r3, PSP
 8003b28:	461c      	mov	r4, r3
  return(result);
 8003b2a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 8003b2c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003b2e:	9b01      	ldr	r3, [sp, #4]
 8003b30:	3320      	adds	r3, #32
 8003b32:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8003b34:	9b01      	ldr	r3, [sp, #4]
 8003b36:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003b38:	9b00      	ldr	r3, [sp, #0]
 8003b3a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8003b3e:	f7ff ffe7 	bl	8003b10 <port_unlock_from_isr>
}
 8003b42:	b002      	add	sp, #8
 8003b44:	bd10      	pop	{r4, pc}
 8003b46:	bf00      	nop
 8003b48:	f3af 8000 	nop.w
 8003b4c:	f3af 8000 	nop.w

08003b50 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8003b50:	b510      	push	{r4, lr}
 8003b52:	b082      	sub	sp, #8

  port_lock_from_isr();
 8003b54:	f7ff ffd4 	bl	8003b00 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003b58:	4b13      	ldr	r3, [pc, #76]	; (8003ba8 <_port_irq_epilogue+0x58>)
 8003b5a:	685b      	ldr	r3, [r3, #4]
 8003b5c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003b60:	2b00      	cmp	r3, #0
 8003b62:	d01d      	beq.n	8003ba0 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003b64:	f3ef 8309 	mrs	r3, PSP
 8003b68:	461c      	mov	r4, r3
  return(result);
 8003b6a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8003b6c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8003b6e:	9b01      	ldr	r3, [sp, #4]
 8003b70:	3b20      	subs	r3, #32
 8003b72:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003b74:	9b01      	ldr	r3, [sp, #4]
 8003b76:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8003b7a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8003b7c:	9b01      	ldr	r3, [sp, #4]
 8003b7e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003b80:	9b00      	ldr	r3, [sp, #0]
 8003b82:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003b86:	f7fd f90b 	bl	8000da0 <chSchIsPreemptionRequired>
 8003b8a:	4603      	mov	r3, r0
 8003b8c:	2b00      	cmp	r3, #0
 8003b8e:	d003      	beq.n	8003b98 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003b90:	9b01      	ldr	r3, [sp, #4]
 8003b92:	4a06      	ldr	r2, [pc, #24]	; (8003bac <_port_irq_epilogue+0x5c>)
 8003b94:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003b96:	e005      	b.n	8003ba4 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003b98:	9b01      	ldr	r3, [sp, #4]
 8003b9a:	4a05      	ldr	r2, [pc, #20]	; (8003bb0 <_port_irq_epilogue+0x60>)
 8003b9c:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003b9e:	e001      	b.n	8003ba4 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
 8003ba0:	f7ff ffb6 	bl	8003b10 <port_unlock_from_isr>
}
 8003ba4:	b002      	add	sp, #8
 8003ba6:	bd10      	pop	{r4, pc}
 8003ba8:	e000ed00 	.word	0xe000ed00
 8003bac:	08000301 	.word	0x08000301
 8003bb0:	08000304 	.word	0x08000304
 8003bb4:	f3af 8000 	nop.w
 8003bb8:	f3af 8000 	nop.w
 8003bbc:	f3af 8000 	nop.w

08003bc0 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8003bc0:	4770      	bx	lr
 8003bc2:	bf00      	nop
 8003bc4:	f3af 8000 	nop.w
 8003bc8:	f3af 8000 	nop.w
 8003bcc:	f3af 8000 	nop.w

08003bd0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8003bd0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8003bd2:	f7ff fff5 	bl	8003bc0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8003bd6:	f003 fc63 	bl	80074a0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8003bda:	4809      	ldr	r0, [pc, #36]	; (8003c00 <halInit+0x30>)
 8003bdc:	f004 fa28 	bl	8008030 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8003be0:	f002 fade 	bl	80061a0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
 8003be4:	f001 ff44 	bl	8005a70 <sdcInit>
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8003be8:	f002 fc32 	bl	8006450 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8003bec:	f003 f820 	bl	8006c30 <usbInit>
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
#endif
#if (HAL_USE_RTC == TRUE) || defined(__DOXYGEN__)
  rtcInit();
 8003bf0:	f001 fa36 	bl	8005060 <rtcInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8003bf4:	f007 ff94 	bl	800bb20 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8003bf8:	f000 f832 	bl	8003c60 <stInit>
#endif
}
 8003bfc:	bd08      	pop	{r3, pc}
 8003bfe:	bf00      	nop
 8003c00:	0801ac50 	.word	0x0801ac50
 8003c04:	f3af 8000 	nop.w
 8003c08:	f3af 8000 	nop.w
 8003c0c:	f3af 8000 	nop.w

08003c10 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8003c10:	b082      	sub	sp, #8
 8003c12:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003c14:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c18:	9a01      	ldr	r2, [sp, #4]
 8003c1a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003c1c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c20:	2200      	movs	r2, #0
 8003c22:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003c24:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c28:	2202      	movs	r2, #2
 8003c2a:	60da      	str	r2, [r3, #12]
}
 8003c2c:	b002      	add	sp, #8
 8003c2e:	4770      	bx	lr

08003c30 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003c30:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c34:	2200      	movs	r2, #0
 8003c36:	60da      	str	r2, [r3, #12]
}
 8003c38:	4770      	bx	lr
 8003c3a:	bf00      	nop
 8003c3c:	f3af 8000 	nop.w

08003c40 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8003c40:	b082      	sub	sp, #8
 8003c42:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003c44:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c48:	9a01      	ldr	r2, [sp, #4]
 8003c4a:	635a      	str	r2, [r3, #52]	; 0x34
}
 8003c4c:	b002      	add	sp, #8
 8003c4e:	4770      	bx	lr

08003c50 <st_lld_get_alarm>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_alarm(void) {

  return (systime_t)STM32_ST_TIM->CCR[0];
 8003c50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c54:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 8003c56:	4618      	mov	r0, r3
 8003c58:	4770      	bx	lr
 8003c5a:	bf00      	nop
 8003c5c:	f3af 8000 	nop.w

08003c60 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8003c60:	b508      	push	{r3, lr}

  st_lld_init();
 8003c62:	f004 f99d 	bl	8007fa0 <st_lld_init>
}
 8003c66:	bd08      	pop	{r3, pc}
 8003c68:	f3af 8000 	nop.w
 8003c6c:	f3af 8000 	nop.w

08003c70 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8003c70:	b500      	push	{lr}
 8003c72:	b083      	sub	sp, #12
 8003c74:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8003c76:	9801      	ldr	r0, [sp, #4]
 8003c78:	f7ff ffca 	bl	8003c10 <st_lld_start_alarm>
}
 8003c7c:	b003      	add	sp, #12
 8003c7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c82:	bf00      	nop
 8003c84:	f3af 8000 	nop.w
 8003c88:	f3af 8000 	nop.w
 8003c8c:	f3af 8000 	nop.w

08003c90 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8003c90:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8003c92:	f7ff ffcd 	bl	8003c30 <st_lld_stop_alarm>
}
 8003c96:	bd08      	pop	{r3, pc}
 8003c98:	f3af 8000 	nop.w
 8003c9c:	f3af 8000 	nop.w

08003ca0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8003ca0:	b500      	push	{lr}
 8003ca2:	b083      	sub	sp, #12
 8003ca4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8003ca6:	9801      	ldr	r0, [sp, #4]
 8003ca8:	f7ff ffca 	bl	8003c40 <st_lld_set_alarm>
}
 8003cac:	b003      	add	sp, #12
 8003cae:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cb2:	bf00      	nop
 8003cb4:	f3af 8000 	nop.w
 8003cb8:	f3af 8000 	nop.w
 8003cbc:	f3af 8000 	nop.w

08003cc0 <stGetAlarm>:
 *
 * @return              The currently set alarm time.
 *
 * @api
 */
systime_t stGetAlarm(void) {
 8003cc0:	b508      	push	{r3, lr}

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  return st_lld_get_alarm();
 8003cc2:	f7ff ffc5 	bl	8003c50 <st_lld_get_alarm>
 8003cc6:	4603      	mov	r3, r0
}
 8003cc8:	4618      	mov	r0, r3
 8003cca:	bd08      	pop	{r3, pc}
 8003ccc:	f3af 8000 	nop.w

08003cd0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003cd0:	b082      	sub	sp, #8
 8003cd2:	2320      	movs	r3, #32
 8003cd4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003cd6:	9b01      	ldr	r3, [sp, #4]
 8003cd8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003cdc:	b002      	add	sp, #8
 8003cde:	4770      	bx	lr

08003ce0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003ce0:	b082      	sub	sp, #8
 8003ce2:	2300      	movs	r3, #0
 8003ce4:	9301      	str	r3, [sp, #4]
 8003ce6:	9b01      	ldr	r3, [sp, #4]
 8003ce8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003cec:	b002      	add	sp, #8
 8003cee:	4770      	bx	lr

08003cf0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8003cf0:	b082      	sub	sp, #8
 8003cf2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8003cf4:	9b01      	ldr	r3, [sp, #4]
 8003cf6:	9a01      	ldr	r2, [sp, #4]
 8003cf8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8003cfa:	9b01      	ldr	r3, [sp, #4]
 8003cfc:	9a01      	ldr	r2, [sp, #4]
 8003cfe:	605a      	str	r2, [r3, #4]
}
 8003d00:	b002      	add	sp, #8
 8003d02:	4770      	bx	lr
 8003d04:	f3af 8000 	nop.w
 8003d08:	f3af 8000 	nop.w
 8003d0c:	f3af 8000 	nop.w

08003d10 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003d10:	b508      	push	{r3, lr}

  port_lock();
 8003d12:	f7ff ffdd 	bl	8003cd0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003d16:	bd08      	pop	{r3, pc}
 8003d18:	f3af 8000 	nop.w
 8003d1c:	f3af 8000 	nop.w

08003d20 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003d20:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003d22:	f7ff ffdd 	bl	8003ce0 <port_unlock>
}
 8003d26:	bd08      	pop	{r3, pc}
 8003d28:	f3af 8000 	nop.w
 8003d2c:	f3af 8000 	nop.w

08003d30 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8003d30:	4b01      	ldr	r3, [pc, #4]	; (8003d38 <chVTGetSystemTimeX+0x8>)
 8003d32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003d34:	4618      	mov	r0, r3
 8003d36:	4770      	bx	lr
 8003d38:	200039a8 	.word	0x200039a8
 8003d3c:	f3af 8000 	nop.w

08003d40 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8003d40:	b500      	push	{lr}
 8003d42:	b083      	sub	sp, #12
 8003d44:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8003d46:	9801      	ldr	r0, [sp, #4]
 8003d48:	f7ff ffd2 	bl	8003cf0 <queue_init>
}
 8003d4c:	b003      	add	sp, #12
 8003d4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d52:	bf00      	nop
 8003d54:	f3af 8000 	nop.w
 8003d58:	f3af 8000 	nop.w
 8003d5c:	f3af 8000 	nop.w

08003d60 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003d60:	b508      	push	{r3, lr}

  chSysLock();
 8003d62:	f7ff ffd5 	bl	8003d10 <chSysLock>
}
 8003d66:	bd08      	pop	{r3, pc}
 8003d68:	f3af 8000 	nop.w
 8003d6c:	f3af 8000 	nop.w

08003d70 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003d70:	b508      	push	{r3, lr}

  chSysUnlock();
 8003d72:	f7ff ffd5 	bl	8003d20 <chSysUnlock>
}
 8003d76:	bd08      	pop	{r3, pc}
 8003d78:	f3af 8000 	nop.w
 8003d7c:	f3af 8000 	nop.w

08003d80 <osalOsGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8003d80:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8003d82:	f7ff ffd5 	bl	8003d30 <chVTGetSystemTimeX>
 8003d86:	4603      	mov	r3, r0
}
 8003d88:	4618      	mov	r0, r3
 8003d8a:	bd08      	pop	{r3, pc}
 8003d8c:	f3af 8000 	nop.w

08003d90 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8003d90:	b500      	push	{lr}
 8003d92:	b083      	sub	sp, #12
 8003d94:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8003d96:	9801      	ldr	r0, [sp, #4]
 8003d98:	f7ff ffd2 	bl	8003d40 <chThdQueueObjectInit>
}
 8003d9c:	b003      	add	sp, #12
 8003d9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003da2:	bf00      	nop
 8003da4:	f3af 8000 	nop.w
 8003da8:	f3af 8000 	nop.w
 8003dac:	f3af 8000 	nop.w

08003db0 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8003db0:	b500      	push	{lr}
 8003db2:	b083      	sub	sp, #12
 8003db4:	9001      	str	r0, [sp, #4]
 8003db6:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8003db8:	9801      	ldr	r0, [sp, #4]
 8003dba:	9900      	ldr	r1, [sp, #0]
 8003dbc:	f7fd fbc0 	bl	8001540 <chThdEnqueueTimeoutS>
 8003dc0:	4603      	mov	r3, r0
}
 8003dc2:	4618      	mov	r0, r3
 8003dc4:	b003      	add	sp, #12
 8003dc6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003dca:	bf00      	nop
 8003dcc:	f3af 8000 	nop.w

08003dd0 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8003dd0:	b500      	push	{lr}
 8003dd2:	b083      	sub	sp, #12
 8003dd4:	9001      	str	r0, [sp, #4]
 8003dd6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8003dd8:	9801      	ldr	r0, [sp, #4]
 8003dda:	9900      	ldr	r1, [sp, #0]
 8003ddc:	f7fd fbd0 	bl	8001580 <chThdDequeueNextI>
}
 8003de0:	b003      	add	sp, #12
 8003de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003de6:	bf00      	nop
 8003de8:	f3af 8000 	nop.w
 8003dec:	f3af 8000 	nop.w

08003df0 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8003df0:	b500      	push	{lr}
 8003df2:	b083      	sub	sp, #12
 8003df4:	9001      	str	r0, [sp, #4]
 8003df6:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8003df8:	9801      	ldr	r0, [sp, #4]
 8003dfa:	9900      	ldr	r1, [sp, #0]
 8003dfc:	f7fd fbd8 	bl	80015b0 <chThdDequeueAllI>
}
 8003e00:	b003      	add	sp, #12
 8003e02:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e06:	bf00      	nop
 8003e08:	f3af 8000 	nop.w
 8003e0c:	f3af 8000 	nop.w

08003e10 <ibqObjectInit>:
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 8003e10:	b500      	push	{lr}
 8003e12:	b085      	sub	sp, #20
 8003e14:	9003      	str	r0, [sp, #12]
 8003e16:	9102      	str	r1, [sp, #8]
 8003e18:	9201      	str	r2, [sp, #4]
 8003e1a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
 8003e1c:	9b03      	ldr	r3, [sp, #12]
 8003e1e:	4618      	mov	r0, r3
 8003e20:	f7ff ffb6 	bl	8003d90 <osalThreadQueueObjectInit>
  ibqp->bcounter = 0;
 8003e24:	9b03      	ldr	r3, [sp, #12]
 8003e26:	2200      	movs	r2, #0
 8003e28:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = bp;
 8003e2a:	9b03      	ldr	r3, [sp, #12]
 8003e2c:	9a02      	ldr	r2, [sp, #8]
 8003e2e:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = bp;
 8003e30:	9b03      	ldr	r3, [sp, #12]
 8003e32:	9a02      	ldr	r2, [sp, #8]
 8003e34:	60da      	str	r2, [r3, #12]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8003e36:	9b01      	ldr	r3, [sp, #4]
 8003e38:	3304      	adds	r3, #4
 8003e3a:	9a00      	ldr	r2, [sp, #0]
 8003e3c:	fb02 f303 	mul.w	r3, r2, r3
 8003e40:	9a02      	ldr	r2, [sp, #8]
 8003e42:	441a      	add	r2, r3
 8003e44:	9b03      	ldr	r3, [sp, #12]
 8003e46:	615a      	str	r2, [r3, #20]
  ibqp->bsize    = size + sizeof (size_t);
 8003e48:	9b01      	ldr	r3, [sp, #4]
 8003e4a:	1d1a      	adds	r2, r3, #4
 8003e4c:	9b03      	ldr	r3, [sp, #12]
 8003e4e:	619a      	str	r2, [r3, #24]
  ibqp->bn       = n;
 8003e50:	9b03      	ldr	r3, [sp, #12]
 8003e52:	9a00      	ldr	r2, [sp, #0]
 8003e54:	61da      	str	r2, [r3, #28]
  ibqp->buffers  = bp;
 8003e56:	9b03      	ldr	r3, [sp, #12]
 8003e58:	9a02      	ldr	r2, [sp, #8]
 8003e5a:	621a      	str	r2, [r3, #32]
  ibqp->ptr      = NULL;
 8003e5c:	9b03      	ldr	r3, [sp, #12]
 8003e5e:	2200      	movs	r2, #0
 8003e60:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8003e62:	9b03      	ldr	r3, [sp, #12]
 8003e64:	2200      	movs	r2, #0
 8003e66:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->notify   = infy;
 8003e68:	9b03      	ldr	r3, [sp, #12]
 8003e6a:	9a06      	ldr	r2, [sp, #24]
 8003e6c:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->link     = link;
 8003e6e:	9b03      	ldr	r3, [sp, #12]
 8003e70:	9a07      	ldr	r2, [sp, #28]
 8003e72:	631a      	str	r2, [r3, #48]	; 0x30
}
 8003e74:	b005      	add	sp, #20
 8003e76:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e7a:	bf00      	nop
 8003e7c:	f3af 8000 	nop.w

08003e80 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 8003e80:	b500      	push	{lr}
 8003e82:	b083      	sub	sp, #12
 8003e84:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  ibqp->bcounter = 0;
 8003e86:	9b01      	ldr	r3, [sp, #4]
 8003e88:	2200      	movs	r2, #0
 8003e8a:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = ibqp->buffers;
 8003e8c:	9b01      	ldr	r3, [sp, #4]
 8003e8e:	6a1a      	ldr	r2, [r3, #32]
 8003e90:	9b01      	ldr	r3, [sp, #4]
 8003e92:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = ibqp->buffers;
 8003e94:	9b01      	ldr	r3, [sp, #4]
 8003e96:	6a1a      	ldr	r2, [r3, #32]
 8003e98:	9b01      	ldr	r3, [sp, #4]
 8003e9a:	60da      	str	r2, [r3, #12]
  ibqp->ptr      = NULL;
 8003e9c:	9b01      	ldr	r3, [sp, #4]
 8003e9e:	2200      	movs	r2, #0
 8003ea0:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8003ea2:	9b01      	ldr	r3, [sp, #4]
 8003ea4:	2200      	movs	r2, #0
 8003ea6:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 8003ea8:	9b01      	ldr	r3, [sp, #4]
 8003eaa:	4618      	mov	r0, r3
 8003eac:	f06f 0101 	mvn.w	r1, #1
 8003eb0:	f7ff ff9e 	bl	8003df0 <osalThreadDequeueAllI>
}
 8003eb4:	b003      	add	sp, #12
 8003eb6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003eba:	bf00      	nop
 8003ebc:	f3af 8000 	nop.w

08003ec0 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 8003ec0:	b082      	sub	sp, #8
 8003ec2:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  if (ibqIsFullI(ibqp)) {
 8003ec4:	9b01      	ldr	r3, [sp, #4]
 8003ec6:	68da      	ldr	r2, [r3, #12]
 8003ec8:	9b01      	ldr	r3, [sp, #4]
 8003eca:	691b      	ldr	r3, [r3, #16]
 8003ecc:	429a      	cmp	r2, r3
 8003ece:	d105      	bne.n	8003edc <ibqGetEmptyBufferI+0x1c>
 8003ed0:	9b01      	ldr	r3, [sp, #4]
 8003ed2:	689b      	ldr	r3, [r3, #8]
 8003ed4:	2b00      	cmp	r3, #0
 8003ed6:	d001      	beq.n	8003edc <ibqGetEmptyBufferI+0x1c>
 8003ed8:	2301      	movs	r3, #1
 8003eda:	e000      	b.n	8003ede <ibqGetEmptyBufferI+0x1e>
 8003edc:	2300      	movs	r3, #0
 8003ede:	f003 0301 	and.w	r3, r3, #1
 8003ee2:	b2db      	uxtb	r3, r3
 8003ee4:	2b00      	cmp	r3, #0
 8003ee6:	d001      	beq.n	8003eec <ibqGetEmptyBufferI+0x2c>
    return NULL;
 8003ee8:	2300      	movs	r3, #0
 8003eea:	e002      	b.n	8003ef2 <ibqGetEmptyBufferI+0x32>
  }

  return ibqp->bwrptr + sizeof (size_t);
 8003eec:	9b01      	ldr	r3, [sp, #4]
 8003eee:	68db      	ldr	r3, [r3, #12]
 8003ef0:	3304      	adds	r3, #4
}
 8003ef2:	4618      	mov	r0, r3
 8003ef4:	b002      	add	sp, #8
 8003ef6:	4770      	bx	lr
 8003ef8:	f3af 8000 	nop.w
 8003efc:	f3af 8000 	nop.w

08003f00 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 8003f00:	b500      	push	{lr}
 8003f02:	b083      	sub	sp, #12
 8003f04:	9001      	str	r0, [sp, #4]
 8003f06:	9100      	str	r1, [sp, #0]

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 8003f08:	9b01      	ldr	r3, [sp, #4]
 8003f0a:	68db      	ldr	r3, [r3, #12]
 8003f0c:	9a00      	ldr	r2, [sp, #0]
 8003f0e:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 8003f10:	9b01      	ldr	r3, [sp, #4]
 8003f12:	689b      	ldr	r3, [r3, #8]
 8003f14:	1c5a      	adds	r2, r3, #1
 8003f16:	9b01      	ldr	r3, [sp, #4]
 8003f18:	609a      	str	r2, [r3, #8]
  ibqp->bwrptr += ibqp->bsize;
 8003f1a:	9b01      	ldr	r3, [sp, #4]
 8003f1c:	68da      	ldr	r2, [r3, #12]
 8003f1e:	9b01      	ldr	r3, [sp, #4]
 8003f20:	699b      	ldr	r3, [r3, #24]
 8003f22:	441a      	add	r2, r3
 8003f24:	9b01      	ldr	r3, [sp, #4]
 8003f26:	60da      	str	r2, [r3, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
 8003f28:	9b01      	ldr	r3, [sp, #4]
 8003f2a:	68da      	ldr	r2, [r3, #12]
 8003f2c:	9b01      	ldr	r3, [sp, #4]
 8003f2e:	695b      	ldr	r3, [r3, #20]
 8003f30:	429a      	cmp	r2, r3
 8003f32:	d303      	bcc.n	8003f3c <ibqPostFullBufferI+0x3c>
    ibqp->bwrptr = ibqp->buffers;
 8003f34:	9b01      	ldr	r3, [sp, #4]
 8003f36:	6a1a      	ldr	r2, [r3, #32]
 8003f38:	9b01      	ldr	r3, [sp, #4]
 8003f3a:	60da      	str	r2, [r3, #12]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 8003f3c:	9b01      	ldr	r3, [sp, #4]
 8003f3e:	4618      	mov	r0, r3
 8003f40:	2100      	movs	r1, #0
 8003f42:	f7ff ff45 	bl	8003dd0 <osalThreadDequeueNextI>
}
 8003f46:	b003      	add	sp, #12
 8003f48:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f4c:	f3af 8000 	nop.w

08003f50 <ibqGetFullBufferTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetFullBufferTimeout(input_buffers_queue_t *ibqp,
                              systime_t timeout) {
 8003f50:	b500      	push	{lr}
 8003f52:	b085      	sub	sp, #20
 8003f54:	9001      	str	r0, [sp, #4]
 8003f56:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8003f58:	f7ff ff02 	bl	8003d60 <osalSysLock>
  msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8003f5c:	9801      	ldr	r0, [sp, #4]
 8003f5e:	9900      	ldr	r1, [sp, #0]
 8003f60:	f000 f80e 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 8003f64:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 8003f66:	f7ff ff03 	bl	8003d70 <osalSysUnlock>

  return msg;
 8003f6a:	9b03      	ldr	r3, [sp, #12]
}
 8003f6c:	4618      	mov	r0, r3
 8003f6e:	b005      	add	sp, #20
 8003f70:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f74:	f3af 8000 	nop.w
 8003f78:	f3af 8000 	nop.w
 8003f7c:	f3af 8000 	nop.w

08003f80 <ibqGetFullBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 8003f80:	b500      	push	{lr}
 8003f82:	b085      	sub	sp, #20
 8003f84:	9001      	str	r0, [sp, #4]
 8003f86:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8003f88:	e00a      	b.n	8003fa0 <ibqGetFullBufferTimeoutS+0x20>
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 8003f8a:	9b01      	ldr	r3, [sp, #4]
 8003f8c:	4618      	mov	r0, r3
 8003f8e:	9900      	ldr	r1, [sp, #0]
 8003f90:	f7ff ff0e 	bl	8003db0 <osalThreadEnqueueTimeoutS>
 8003f94:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8003f96:	9b03      	ldr	r3, [sp, #12]
 8003f98:	2b00      	cmp	r3, #0
 8003f9a:	da01      	bge.n	8003fa0 <ibqGetFullBufferTimeoutS+0x20>
       return msg;
 8003f9c:	9b03      	ldr	r3, [sp, #12]
 8003f9e:	e011      	b.n	8003fc4 <ibqGetFullBufferTimeoutS+0x44>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8003fa0:	9b01      	ldr	r3, [sp, #4]
 8003fa2:	689b      	ldr	r3, [r3, #8]
 8003fa4:	2b00      	cmp	r3, #0
 8003fa6:	d0f0      	beq.n	8003f8a <ibqGetFullBufferTimeoutS+0xa>
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8003fa8:	9b01      	ldr	r3, [sp, #4]
 8003faa:	691b      	ldr	r3, [r3, #16]
 8003fac:	1d1a      	adds	r2, r3, #4
 8003fae:	9b01      	ldr	r3, [sp, #4]
 8003fb0:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8003fb2:	9b01      	ldr	r3, [sp, #4]
 8003fb4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003fb6:	9b01      	ldr	r3, [sp, #4]
 8003fb8:	691b      	ldr	r3, [r3, #16]
 8003fba:	681b      	ldr	r3, [r3, #0]
 8003fbc:	441a      	add	r2, r3
 8003fbe:	9b01      	ldr	r3, [sp, #4]
 8003fc0:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8003fc2:	2300      	movs	r3, #0
}
 8003fc4:	4618      	mov	r0, r3
 8003fc6:	b005      	add	sp, #20
 8003fc8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fcc:	f3af 8000 	nop.w

08003fd0 <ibqReleaseEmptyBuffer>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @api
 */
void ibqReleaseEmptyBuffer(input_buffers_queue_t *ibqp) {
 8003fd0:	b500      	push	{lr}
 8003fd2:	b083      	sub	sp, #12
 8003fd4:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8003fd6:	f7ff fec3 	bl	8003d60 <osalSysLock>
  ibqReleaseEmptyBufferS(ibqp);
 8003fda:	9801      	ldr	r0, [sp, #4]
 8003fdc:	f000 f808 	bl	8003ff0 <ibqReleaseEmptyBufferS>
  osalSysUnlock();
 8003fe0:	f7ff fec6 	bl	8003d70 <osalSysUnlock>
}
 8003fe4:	b003      	add	sp, #12
 8003fe6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fea:	bf00      	nop
 8003fec:	f3af 8000 	nop.w

08003ff0 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8003ff0:	b500      	push	{lr}
 8003ff2:	b083      	sub	sp, #12
 8003ff4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8003ff6:	9b01      	ldr	r3, [sp, #4]
 8003ff8:	689b      	ldr	r3, [r3, #8]
 8003ffa:	1e5a      	subs	r2, r3, #1
 8003ffc:	9b01      	ldr	r3, [sp, #4]
 8003ffe:	609a      	str	r2, [r3, #8]
  ibqp->brdptr += ibqp->bsize;
 8004000:	9b01      	ldr	r3, [sp, #4]
 8004002:	691a      	ldr	r2, [r3, #16]
 8004004:	9b01      	ldr	r3, [sp, #4]
 8004006:	699b      	ldr	r3, [r3, #24]
 8004008:	441a      	add	r2, r3
 800400a:	9b01      	ldr	r3, [sp, #4]
 800400c:	611a      	str	r2, [r3, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 800400e:	9b01      	ldr	r3, [sp, #4]
 8004010:	691a      	ldr	r2, [r3, #16]
 8004012:	9b01      	ldr	r3, [sp, #4]
 8004014:	695b      	ldr	r3, [r3, #20]
 8004016:	429a      	cmp	r2, r3
 8004018:	d303      	bcc.n	8004022 <ibqReleaseEmptyBufferS+0x32>
    ibqp->brdptr = ibqp->buffers;
 800401a:	9b01      	ldr	r3, [sp, #4]
 800401c:	6a1a      	ldr	r2, [r3, #32]
 800401e:	9b01      	ldr	r3, [sp, #4]
 8004020:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8004022:	9b01      	ldr	r3, [sp, #4]
 8004024:	2200      	movs	r2, #0
 8004026:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8004028:	9b01      	ldr	r3, [sp, #4]
 800402a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800402c:	2b00      	cmp	r3, #0
 800402e:	d003      	beq.n	8004038 <ibqReleaseEmptyBufferS+0x48>
    ibqp->notify(ibqp);
 8004030:	9b01      	ldr	r3, [sp, #4]
 8004032:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004034:	9801      	ldr	r0, [sp, #4]
 8004036:	4798      	blx	r3
  }
}
 8004038:	b003      	add	sp, #12
 800403a:	f85d fb04 	ldr.w	pc, [sp], #4
 800403e:	bf00      	nop

08004040 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8004040:	b500      	push	{lr}
 8004042:	b085      	sub	sp, #20
 8004044:	9001      	str	r0, [sp, #4]
 8004046:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004048:	f7ff fe8a 	bl	8003d60 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 800404c:	9b01      	ldr	r3, [sp, #4]
 800404e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004050:	2b00      	cmp	r3, #0
 8004052:	d10b      	bne.n	800406c <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004054:	9801      	ldr	r0, [sp, #4]
 8004056:	9900      	ldr	r1, [sp, #0]
 8004058:	f7ff ff92 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 800405c:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 800405e:	9b03      	ldr	r3, [sp, #12]
 8004060:	2b00      	cmp	r3, #0
 8004062:	d003      	beq.n	800406c <ibqGetTimeout+0x2c>
      osalSysUnlock();
 8004064:	f7ff fe84 	bl	8003d70 <osalSysUnlock>
      return msg;
 8004068:	9b03      	ldr	r3, [sp, #12]
 800406a:	e014      	b.n	8004096 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 800406c:	9b01      	ldr	r3, [sp, #4]
 800406e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004070:	781b      	ldrb	r3, [r3, #0]
 8004072:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 8004074:	9b01      	ldr	r3, [sp, #4]
 8004076:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004078:	1c5a      	adds	r2, r3, #1
 800407a:	9b01      	ldr	r3, [sp, #4]
 800407c:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 800407e:	9b01      	ldr	r3, [sp, #4]
 8004080:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004082:	9b01      	ldr	r3, [sp, #4]
 8004084:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004086:	429a      	cmp	r2, r3
 8004088:	d302      	bcc.n	8004090 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 800408a:	9801      	ldr	r0, [sp, #4]
 800408c:	f7ff ffb0 	bl	8003ff0 <ibqReleaseEmptyBufferS>
  }

  osalSysUnlock();
 8004090:	f7ff fe6e 	bl	8003d70 <osalSysUnlock>
  return msg;
 8004094:	9b03      	ldr	r3, [sp, #12]
}
 8004096:	4618      	mov	r0, r3
 8004098:	b005      	add	sp, #20
 800409a:	f85d fb04 	ldr.w	pc, [sp], #4
 800409e:	bf00      	nop

080040a0 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 80040a0:	b500      	push	{lr}
 80040a2:	b08b      	sub	sp, #44	; 0x2c
 80040a4:	9003      	str	r0, [sp, #12]
 80040a6:	9102      	str	r1, [sp, #8]
 80040a8:	9201      	str	r2, [sp, #4]
 80040aa:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 80040ac:	2300      	movs	r3, #0
 80040ae:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 80040b0:	f7ff fe56 	bl	8003d60 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80040b4:	f7ff fe64 	bl	8003d80 <osalOsGetSystemTimeX>
 80040b8:	4602      	mov	r2, r0
 80040ba:	9b00      	ldr	r3, [sp, #0]
 80040bc:	4413      	add	r3, r2
 80040be:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 80040c0:	9b03      	ldr	r3, [sp, #12]
 80040c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80040c4:	2b00      	cmp	r3, #0
 80040c6:	d126      	bne.n	8004116 <ibqReadTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80040c8:	9b00      	ldr	r3, [sp, #0]
 80040ca:	f1b3 3fff 	cmp.w	r3, #4294967295
 80040ce:	d002      	beq.n	80040d6 <ibqReadTimeout+0x36>
 80040d0:	9b00      	ldr	r3, [sp, #0]
 80040d2:	2b00      	cmp	r3, #0
 80040d4:	d105      	bne.n	80040e2 <ibqReadTimeout+0x42>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80040d6:	9803      	ldr	r0, [sp, #12]
 80040d8:	9900      	ldr	r1, [sp, #0]
 80040da:	f7ff ff51 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 80040de:	9007      	str	r0, [sp, #28]
 80040e0:	e012      	b.n	8004108 <ibqReadTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80040e2:	f7ff fe4d 	bl	8003d80 <osalOsGetSystemTimeX>
 80040e6:	4603      	mov	r3, r0
 80040e8:	9a06      	ldr	r2, [sp, #24]
 80040ea:	1ad3      	subs	r3, r2, r3
 80040ec:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80040ee:	9a05      	ldr	r2, [sp, #20]
 80040f0:	9b00      	ldr	r3, [sp, #0]
 80040f2:	429a      	cmp	r2, r3
 80040f4:	d903      	bls.n	80040fe <ibqReadTimeout+0x5e>
          osalSysUnlock();
 80040f6:	f7ff fe3b 	bl	8003d70 <osalSysUnlock>
          return r;
 80040fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80040fc:	e05c      	b.n	80041b8 <ibqReadTimeout+0x118>
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 80040fe:	9803      	ldr	r0, [sp, #12]
 8004100:	9905      	ldr	r1, [sp, #20]
 8004102:	f7ff ff3d 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 8004106:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8004108:	9b07      	ldr	r3, [sp, #28]
 800410a:	2b00      	cmp	r3, #0
 800410c:	d003      	beq.n	8004116 <ibqReadTimeout+0x76>
        osalSysUnlock();
 800410e:	f7ff fe2f 	bl	8003d70 <osalSysUnlock>
        return r;
 8004112:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004114:	e050      	b.n	80041b8 <ibqReadTimeout+0x118>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004116:	9b03      	ldr	r3, [sp, #12]
 8004118:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800411a:	461a      	mov	r2, r3
 800411c:	9b03      	ldr	r3, [sp, #12]
 800411e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004120:	1ad3      	subs	r3, r2, r3
 8004122:	9308      	str	r3, [sp, #32]
    if (size > (n - r)) {
 8004124:	9a01      	ldr	r2, [sp, #4]
 8004126:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004128:	1ad2      	subs	r2, r2, r3
 800412a:	9b08      	ldr	r3, [sp, #32]
 800412c:	429a      	cmp	r2, r3
 800412e:	d203      	bcs.n	8004138 <ibqReadTimeout+0x98>
      size = n - r;
 8004130:	9a01      	ldr	r2, [sp, #4]
 8004132:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004134:	1ad3      	subs	r3, r2, r3
 8004136:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004138:	9b08      	ldr	r3, [sp, #32]
 800413a:	2b40      	cmp	r3, #64	; 0x40
 800413c:	d913      	bls.n	8004166 <ibqReadTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 800413e:	9b03      	ldr	r3, [sp, #12]
 8004140:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004142:	9802      	ldr	r0, [sp, #8]
 8004144:	4619      	mov	r1, r3
 8004146:	2240      	movs	r2, #64	; 0x40
 8004148:	f013 fa4a 	bl	80175e0 <memcpy>
      bp        += 64U;
 800414c:	9b02      	ldr	r3, [sp, #8]
 800414e:	3340      	adds	r3, #64	; 0x40
 8004150:	9302      	str	r3, [sp, #8]
      ibqp->ptr += 64U;
 8004152:	9b03      	ldr	r3, [sp, #12]
 8004154:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004156:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800415a:	9b03      	ldr	r3, [sp, #12]
 800415c:	625a      	str	r2, [r3, #36]	; 0x24
      r         += 64U;
 800415e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004160:	3340      	adds	r3, #64	; 0x40
 8004162:	9309      	str	r3, [sp, #36]	; 0x24
 8004164:	e014      	b.n	8004190 <ibqReadTimeout+0xf0>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 8004166:	9b03      	ldr	r3, [sp, #12]
 8004168:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800416a:	9802      	ldr	r0, [sp, #8]
 800416c:	4619      	mov	r1, r3
 800416e:	9a08      	ldr	r2, [sp, #32]
 8004170:	f013 fa36 	bl	80175e0 <memcpy>
      bp        += size;
 8004174:	9a02      	ldr	r2, [sp, #8]
 8004176:	9b08      	ldr	r3, [sp, #32]
 8004178:	4413      	add	r3, r2
 800417a:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 800417c:	9b03      	ldr	r3, [sp, #12]
 800417e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004180:	9b08      	ldr	r3, [sp, #32]
 8004182:	441a      	add	r2, r3
 8004184:	9b03      	ldr	r3, [sp, #12]
 8004186:	625a      	str	r2, [r3, #36]	; 0x24
      r         += size;
 8004188:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800418a:	9b08      	ldr	r3, [sp, #32]
 800418c:	4413      	add	r3, r2
 800418e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8004190:	9b03      	ldr	r3, [sp, #12]
 8004192:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004194:	9b03      	ldr	r3, [sp, #12]
 8004196:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004198:	429a      	cmp	r2, r3
 800419a:	d302      	bcc.n	80041a2 <ibqReadTimeout+0x102>
      ibqReleaseEmptyBufferS(ibqp);
 800419c:	9803      	ldr	r0, [sp, #12]
 800419e:	f7ff ff27 	bl	8003ff0 <ibqReleaseEmptyBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 80041a2:	f7ff fde5 	bl	8003d70 <osalSysUnlock>
    if (r >= n) {
 80041a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80041a8:	9b01      	ldr	r3, [sp, #4]
 80041aa:	429a      	cmp	r2, r3
 80041ac:	d301      	bcc.n	80041b2 <ibqReadTimeout+0x112>
      return r;
 80041ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80041b0:	e002      	b.n	80041b8 <ibqReadTimeout+0x118>
    }
    osalSysLock();
 80041b2:	f7ff fdd5 	bl	8003d60 <osalSysLock>
  }
 80041b6:	e783      	b.n	80040c0 <ibqReadTimeout+0x20>
}
 80041b8:	4618      	mov	r0, r3
 80041ba:	b00b      	add	sp, #44	; 0x2c
 80041bc:	f85d fb04 	ldr.w	pc, [sp], #4

080041c0 <obqObjectInit>:
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 80041c0:	b500      	push	{lr}
 80041c2:	b085      	sub	sp, #20
 80041c4:	9003      	str	r0, [sp, #12]
 80041c6:	9102      	str	r1, [sp, #8]
 80041c8:	9201      	str	r2, [sp, #4]
 80041ca:	9300      	str	r3, [sp, #0]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
 80041cc:	9b03      	ldr	r3, [sp, #12]
 80041ce:	4618      	mov	r0, r3
 80041d0:	f7ff fdde 	bl	8003d90 <osalThreadQueueObjectInit>
  obqp->bcounter = n;
 80041d4:	9b03      	ldr	r3, [sp, #12]
 80041d6:	9a00      	ldr	r2, [sp, #0]
 80041d8:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = bp;
 80041da:	9b03      	ldr	r3, [sp, #12]
 80041dc:	9a02      	ldr	r2, [sp, #8]
 80041de:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = bp;
 80041e0:	9b03      	ldr	r3, [sp, #12]
 80041e2:	9a02      	ldr	r2, [sp, #8]
 80041e4:	60da      	str	r2, [r3, #12]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80041e6:	9b01      	ldr	r3, [sp, #4]
 80041e8:	3304      	adds	r3, #4
 80041ea:	9a00      	ldr	r2, [sp, #0]
 80041ec:	fb02 f303 	mul.w	r3, r2, r3
 80041f0:	9a02      	ldr	r2, [sp, #8]
 80041f2:	441a      	add	r2, r3
 80041f4:	9b03      	ldr	r3, [sp, #12]
 80041f6:	615a      	str	r2, [r3, #20]
  obqp->bsize    = size + sizeof (size_t);
 80041f8:	9b01      	ldr	r3, [sp, #4]
 80041fa:	1d1a      	adds	r2, r3, #4
 80041fc:	9b03      	ldr	r3, [sp, #12]
 80041fe:	619a      	str	r2, [r3, #24]
  obqp->bn       = n;
 8004200:	9b03      	ldr	r3, [sp, #12]
 8004202:	9a00      	ldr	r2, [sp, #0]
 8004204:	61da      	str	r2, [r3, #28]
  obqp->buffers  = bp;
 8004206:	9b03      	ldr	r3, [sp, #12]
 8004208:	9a02      	ldr	r2, [sp, #8]
 800420a:	621a      	str	r2, [r3, #32]
  obqp->ptr      = NULL;
 800420c:	9b03      	ldr	r3, [sp, #12]
 800420e:	2200      	movs	r2, #0
 8004210:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004212:	9b03      	ldr	r3, [sp, #12]
 8004214:	2200      	movs	r2, #0
 8004216:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->notify   = onfy;
 8004218:	9b03      	ldr	r3, [sp, #12]
 800421a:	9a06      	ldr	r2, [sp, #24]
 800421c:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->link     = link;
 800421e:	9b03      	ldr	r3, [sp, #12]
 8004220:	9a07      	ldr	r2, [sp, #28]
 8004222:	631a      	str	r2, [r3, #48]	; 0x30
}
 8004224:	b005      	add	sp, #20
 8004226:	f85d fb04 	ldr.w	pc, [sp], #4
 800422a:	bf00      	nop
 800422c:	f3af 8000 	nop.w

08004230 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 8004230:	b500      	push	{lr}
 8004232:	b083      	sub	sp, #12
 8004234:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  obqp->bcounter = bqSizeX(obqp);
 8004236:	9b01      	ldr	r3, [sp, #4]
 8004238:	69da      	ldr	r2, [r3, #28]
 800423a:	9b01      	ldr	r3, [sp, #4]
 800423c:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = obqp->buffers;
 800423e:	9b01      	ldr	r3, [sp, #4]
 8004240:	6a1a      	ldr	r2, [r3, #32]
 8004242:	9b01      	ldr	r3, [sp, #4]
 8004244:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = obqp->buffers;
 8004246:	9b01      	ldr	r3, [sp, #4]
 8004248:	6a1a      	ldr	r2, [r3, #32]
 800424a:	9b01      	ldr	r3, [sp, #4]
 800424c:	60da      	str	r2, [r3, #12]
  obqp->ptr      = NULL;
 800424e:	9b01      	ldr	r3, [sp, #4]
 8004250:	2200      	movs	r2, #0
 8004252:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004254:	9b01      	ldr	r3, [sp, #4]
 8004256:	2200      	movs	r2, #0
 8004258:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800425a:	9b01      	ldr	r3, [sp, #4]
 800425c:	4618      	mov	r0, r3
 800425e:	f06f 0101 	mvn.w	r1, #1
 8004262:	f7ff fdc5 	bl	8003df0 <osalThreadDequeueAllI>
}
 8004266:	b003      	add	sp, #12
 8004268:	f85d fb04 	ldr.w	pc, [sp], #4
 800426c:	f3af 8000 	nop.w

08004270 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 8004270:	b082      	sub	sp, #8
 8004272:	9001      	str	r0, [sp, #4]
 8004274:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 8004276:	9b01      	ldr	r3, [sp, #4]
 8004278:	68da      	ldr	r2, [r3, #12]
 800427a:	9b01      	ldr	r3, [sp, #4]
 800427c:	691b      	ldr	r3, [r3, #16]
 800427e:	429a      	cmp	r2, r3
 8004280:	d105      	bne.n	800428e <obqGetFullBufferI+0x1e>
 8004282:	9b01      	ldr	r3, [sp, #4]
 8004284:	689b      	ldr	r3, [r3, #8]
 8004286:	2b00      	cmp	r3, #0
 8004288:	d001      	beq.n	800428e <obqGetFullBufferI+0x1e>
 800428a:	2301      	movs	r3, #1
 800428c:	e000      	b.n	8004290 <obqGetFullBufferI+0x20>
 800428e:	2300      	movs	r3, #0
 8004290:	f003 0301 	and.w	r3, r3, #1
 8004294:	b2db      	uxtb	r3, r3
 8004296:	2b00      	cmp	r3, #0
 8004298:	d001      	beq.n	800429e <obqGetFullBufferI+0x2e>
    return NULL;
 800429a:	2300      	movs	r3, #0
 800429c:	e007      	b.n	80042ae <obqGetFullBufferI+0x3e>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 800429e:	9b01      	ldr	r3, [sp, #4]
 80042a0:	691b      	ldr	r3, [r3, #16]
 80042a2:	681a      	ldr	r2, [r3, #0]
 80042a4:	9b00      	ldr	r3, [sp, #0]
 80042a6:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 80042a8:	9b01      	ldr	r3, [sp, #4]
 80042aa:	691b      	ldr	r3, [r3, #16]
 80042ac:	3304      	adds	r3, #4
}
 80042ae:	4618      	mov	r0, r3
 80042b0:	b002      	add	sp, #8
 80042b2:	4770      	bx	lr
 80042b4:	f3af 8000 	nop.w
 80042b8:	f3af 8000 	nop.w
 80042bc:	f3af 8000 	nop.w

080042c0 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 80042c0:	b500      	push	{lr}
 80042c2:	b083      	sub	sp, #12
 80042c4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 80042c6:	9b01      	ldr	r3, [sp, #4]
 80042c8:	689b      	ldr	r3, [r3, #8]
 80042ca:	1c5a      	adds	r2, r3, #1
 80042cc:	9b01      	ldr	r3, [sp, #4]
 80042ce:	609a      	str	r2, [r3, #8]
  obqp->brdptr += obqp->bsize;
 80042d0:	9b01      	ldr	r3, [sp, #4]
 80042d2:	691a      	ldr	r2, [r3, #16]
 80042d4:	9b01      	ldr	r3, [sp, #4]
 80042d6:	699b      	ldr	r3, [r3, #24]
 80042d8:	441a      	add	r2, r3
 80042da:	9b01      	ldr	r3, [sp, #4]
 80042dc:	611a      	str	r2, [r3, #16]
  if (obqp->brdptr >= obqp->btop) {
 80042de:	9b01      	ldr	r3, [sp, #4]
 80042e0:	691a      	ldr	r2, [r3, #16]
 80042e2:	9b01      	ldr	r3, [sp, #4]
 80042e4:	695b      	ldr	r3, [r3, #20]
 80042e6:	429a      	cmp	r2, r3
 80042e8:	d303      	bcc.n	80042f2 <obqReleaseEmptyBufferI+0x32>
    obqp->brdptr = obqp->buffers;
 80042ea:	9b01      	ldr	r3, [sp, #4]
 80042ec:	6a1a      	ldr	r2, [r3, #32]
 80042ee:	9b01      	ldr	r3, [sp, #4]
 80042f0:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 80042f2:	9b01      	ldr	r3, [sp, #4]
 80042f4:	4618      	mov	r0, r3
 80042f6:	2100      	movs	r1, #0
 80042f8:	f7ff fd6a 	bl	8003dd0 <osalThreadDequeueNextI>
}
 80042fc:	b003      	add	sp, #12
 80042fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004302:	bf00      	nop
 8004304:	f3af 8000 	nop.w
 8004308:	f3af 8000 	nop.w
 800430c:	f3af 8000 	nop.w

08004310 <obqGetEmptyBufferTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqGetEmptyBufferTimeout(output_buffers_queue_t *obqp,
                                systime_t timeout) {
 8004310:	b500      	push	{lr}
 8004312:	b085      	sub	sp, #20
 8004314:	9001      	str	r0, [sp, #4]
 8004316:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004318:	f7ff fd22 	bl	8003d60 <osalSysLock>
  msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800431c:	9801      	ldr	r0, [sp, #4]
 800431e:	9900      	ldr	r1, [sp, #0]
 8004320:	f000 f80e 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 8004324:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 8004326:	f7ff fd23 	bl	8003d70 <osalSysUnlock>

  return msg;
 800432a:	9b03      	ldr	r3, [sp, #12]
}
 800432c:	4618      	mov	r0, r3
 800432e:	b005      	add	sp, #20
 8004330:	f85d fb04 	ldr.w	pc, [sp], #4
 8004334:	f3af 8000 	nop.w
 8004338:	f3af 8000 	nop.w
 800433c:	f3af 8000 	nop.w

08004340 <obqGetEmptyBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {
 8004340:	b500      	push	{lr}
 8004342:	b085      	sub	sp, #20
 8004344:	9001      	str	r0, [sp, #4]
 8004346:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004348:	e00a      	b.n	8004360 <obqGetEmptyBufferTimeoutS+0x20>
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 800434a:	9b01      	ldr	r3, [sp, #4]
 800434c:	4618      	mov	r0, r3
 800434e:	9900      	ldr	r1, [sp, #0]
 8004350:	f7ff fd2e 	bl	8003db0 <osalThreadEnqueueTimeoutS>
 8004354:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8004356:	9b03      	ldr	r3, [sp, #12]
 8004358:	2b00      	cmp	r3, #0
 800435a:	da01      	bge.n	8004360 <obqGetEmptyBufferTimeoutS+0x20>
      return msg;
 800435c:	9b03      	ldr	r3, [sp, #12]
 800435e:	e010      	b.n	8004382 <obqGetEmptyBufferTimeoutS+0x42>
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004360:	9b01      	ldr	r3, [sp, #4]
 8004362:	689b      	ldr	r3, [r3, #8]
 8004364:	2b00      	cmp	r3, #0
 8004366:	d0f0      	beq.n	800434a <obqGetEmptyBufferTimeoutS+0xa>
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8004368:	9b01      	ldr	r3, [sp, #4]
 800436a:	68db      	ldr	r3, [r3, #12]
 800436c:	1d1a      	adds	r2, r3, #4
 800436e:	9b01      	ldr	r3, [sp, #4]
 8004370:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top = obqp->bwrptr + obqp->bsize;
 8004372:	9b01      	ldr	r3, [sp, #4]
 8004374:	68da      	ldr	r2, [r3, #12]
 8004376:	9b01      	ldr	r3, [sp, #4]
 8004378:	699b      	ldr	r3, [r3, #24]
 800437a:	441a      	add	r2, r3
 800437c:	9b01      	ldr	r3, [sp, #4]
 800437e:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8004380:	2300      	movs	r3, #0
}
 8004382:	4618      	mov	r0, r3
 8004384:	b005      	add	sp, #20
 8004386:	f85d fb04 	ldr.w	pc, [sp], #4
 800438a:	bf00      	nop
 800438c:	f3af 8000 	nop.w

08004390 <obqPostFullBuffer>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @api
 */
void obqPostFullBuffer(output_buffers_queue_t *obqp, size_t size) {
 8004390:	b500      	push	{lr}
 8004392:	b083      	sub	sp, #12
 8004394:	9001      	str	r0, [sp, #4]
 8004396:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8004398:	f7ff fce2 	bl	8003d60 <osalSysLock>
  obqPostFullBufferS(obqp, size);
 800439c:	9801      	ldr	r0, [sp, #4]
 800439e:	9900      	ldr	r1, [sp, #0]
 80043a0:	f000 f806 	bl	80043b0 <obqPostFullBufferS>
  osalSysUnlock();
 80043a4:	f7ff fce4 	bl	8003d70 <osalSysUnlock>
}
 80043a8:	b003      	add	sp, #12
 80043aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80043ae:	bf00      	nop

080043b0 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 80043b0:	b500      	push	{lr}
 80043b2:	b083      	sub	sp, #12
 80043b4:	9001      	str	r0, [sp, #4]
 80043b6:	9100      	str	r1, [sp, #0]
  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 80043b8:	9b01      	ldr	r3, [sp, #4]
 80043ba:	68db      	ldr	r3, [r3, #12]
 80043bc:	9a00      	ldr	r2, [sp, #0]
 80043be:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 80043c0:	9b01      	ldr	r3, [sp, #4]
 80043c2:	689b      	ldr	r3, [r3, #8]
 80043c4:	1e5a      	subs	r2, r3, #1
 80043c6:	9b01      	ldr	r3, [sp, #4]
 80043c8:	609a      	str	r2, [r3, #8]
  obqp->bwrptr += obqp->bsize;
 80043ca:	9b01      	ldr	r3, [sp, #4]
 80043cc:	68da      	ldr	r2, [r3, #12]
 80043ce:	9b01      	ldr	r3, [sp, #4]
 80043d0:	699b      	ldr	r3, [r3, #24]
 80043d2:	441a      	add	r2, r3
 80043d4:	9b01      	ldr	r3, [sp, #4]
 80043d6:	60da      	str	r2, [r3, #12]
  if (obqp->bwrptr >= obqp->btop) {
 80043d8:	9b01      	ldr	r3, [sp, #4]
 80043da:	68da      	ldr	r2, [r3, #12]
 80043dc:	9b01      	ldr	r3, [sp, #4]
 80043de:	695b      	ldr	r3, [r3, #20]
 80043e0:	429a      	cmp	r2, r3
 80043e2:	d303      	bcc.n	80043ec <obqPostFullBufferS+0x3c>
    obqp->bwrptr = obqp->buffers;
 80043e4:	9b01      	ldr	r3, [sp, #4]
 80043e6:	6a1a      	ldr	r2, [r3, #32]
 80043e8:	9b01      	ldr	r3, [sp, #4]
 80043ea:	60da      	str	r2, [r3, #12]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 80043ec:	9b01      	ldr	r3, [sp, #4]
 80043ee:	2200      	movs	r2, #0
 80043f0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 80043f2:	9b01      	ldr	r3, [sp, #4]
 80043f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80043f6:	2b00      	cmp	r3, #0
 80043f8:	d003      	beq.n	8004402 <obqPostFullBufferS+0x52>
    obqp->notify(obqp);
 80043fa:	9b01      	ldr	r3, [sp, #4]
 80043fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80043fe:	9801      	ldr	r0, [sp, #4]
 8004400:	4798      	blx	r3
  }
}
 8004402:	b003      	add	sp, #12
 8004404:	f85d fb04 	ldr.w	pc, [sp], #4
 8004408:	f3af 8000 	nop.w
 800440c:	f3af 8000 	nop.w

08004410 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 8004410:	b500      	push	{lr}
 8004412:	b087      	sub	sp, #28
 8004414:	9003      	str	r0, [sp, #12]
 8004416:	460b      	mov	r3, r1
 8004418:	9201      	str	r2, [sp, #4]
 800441a:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 800441e:	f7ff fc9f 	bl	8003d60 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8004422:	9b03      	ldr	r3, [sp, #12]
 8004424:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004426:	2b00      	cmp	r3, #0
 8004428:	d10b      	bne.n	8004442 <obqPutTimeout+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800442a:	9803      	ldr	r0, [sp, #12]
 800442c:	9901      	ldr	r1, [sp, #4]
 800442e:	f7ff ff87 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 8004432:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 8004434:	9b05      	ldr	r3, [sp, #20]
 8004436:	2b00      	cmp	r3, #0
 8004438:	d003      	beq.n	8004442 <obqPutTimeout+0x32>
      osalSysUnlock();
 800443a:	f7ff fc99 	bl	8003d70 <osalSysUnlock>
      return msg;
 800443e:	9b05      	ldr	r3, [sp, #20]
 8004440:	e019      	b.n	8004476 <obqPutTimeout+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8004442:	9b03      	ldr	r3, [sp, #12]
 8004444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004446:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800444a:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 800444c:	9b03      	ldr	r3, [sp, #12]
 800444e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004450:	1c5a      	adds	r2, r3, #1
 8004452:	9b03      	ldr	r3, [sp, #12]
 8004454:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8004456:	9b03      	ldr	r3, [sp, #12]
 8004458:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800445a:	9b03      	ldr	r3, [sp, #12]
 800445c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800445e:	429a      	cmp	r2, r3
 8004460:	d306      	bcc.n	8004470 <obqPutTimeout+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8004462:	9b03      	ldr	r3, [sp, #12]
 8004464:	699b      	ldr	r3, [r3, #24]
 8004466:	3b04      	subs	r3, #4
 8004468:	9803      	ldr	r0, [sp, #12]
 800446a:	4619      	mov	r1, r3
 800446c:	f7ff ffa0 	bl	80043b0 <obqPostFullBufferS>
  }

  osalSysUnlock();
 8004470:	f7ff fc7e 	bl	8003d70 <osalSysUnlock>
  return MSG_OK;
 8004474:	2300      	movs	r3, #0
}
 8004476:	4618      	mov	r0, r3
 8004478:	b007      	add	sp, #28
 800447a:	f85d fb04 	ldr.w	pc, [sp], #4
 800447e:	bf00      	nop

08004480 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8004480:	b500      	push	{lr}
 8004482:	b08b      	sub	sp, #44	; 0x2c
 8004484:	9003      	str	r0, [sp, #12]
 8004486:	9102      	str	r1, [sp, #8]
 8004488:	9201      	str	r2, [sp, #4]
 800448a:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 800448c:	2300      	movs	r3, #0
 800448e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 8004490:	f7ff fc66 	bl	8003d60 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004494:	f7ff fc74 	bl	8003d80 <osalOsGetSystemTimeX>
 8004498:	4602      	mov	r2, r0
 800449a:	9b00      	ldr	r3, [sp, #0]
 800449c:	4413      	add	r3, r2
 800449e:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 80044a0:	9b03      	ldr	r3, [sp, #12]
 80044a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80044a4:	2b00      	cmp	r3, #0
 80044a6:	d126      	bne.n	80044f6 <obqWriteTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80044a8:	9b00      	ldr	r3, [sp, #0]
 80044aa:	f1b3 3fff 	cmp.w	r3, #4294967295
 80044ae:	d002      	beq.n	80044b6 <obqWriteTimeout+0x36>
 80044b0:	9b00      	ldr	r3, [sp, #0]
 80044b2:	2b00      	cmp	r3, #0
 80044b4:	d105      	bne.n	80044c2 <obqWriteTimeout+0x42>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80044b6:	9803      	ldr	r0, [sp, #12]
 80044b8:	9900      	ldr	r1, [sp, #0]
 80044ba:	f7ff ff41 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 80044be:	9007      	str	r0, [sp, #28]
 80044c0:	e012      	b.n	80044e8 <obqWriteTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80044c2:	f7ff fc5d 	bl	8003d80 <osalOsGetSystemTimeX>
 80044c6:	4603      	mov	r3, r0
 80044c8:	9a06      	ldr	r2, [sp, #24]
 80044ca:	1ad3      	subs	r3, r2, r3
 80044cc:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80044ce:	9a05      	ldr	r2, [sp, #20]
 80044d0:	9b00      	ldr	r3, [sp, #0]
 80044d2:	429a      	cmp	r2, r3
 80044d4:	d903      	bls.n	80044de <obqWriteTimeout+0x5e>
          osalSysUnlock();
 80044d6:	f7ff fc4b 	bl	8003d70 <osalSysUnlock>
          return w;
 80044da:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044dc:	e060      	b.n	80045a0 <obqWriteTimeout+0x120>
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 80044de:	9803      	ldr	r0, [sp, #12]
 80044e0:	9905      	ldr	r1, [sp, #20]
 80044e2:	f7ff ff2d 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 80044e6:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 80044e8:	9b07      	ldr	r3, [sp, #28]
 80044ea:	2b00      	cmp	r3, #0
 80044ec:	d003      	beq.n	80044f6 <obqWriteTimeout+0x76>
        osalSysUnlock();
 80044ee:	f7ff fc3f 	bl	8003d70 <osalSysUnlock>
        return w;
 80044f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044f4:	e054      	b.n	80045a0 <obqWriteTimeout+0x120>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 80044f6:	9b03      	ldr	r3, [sp, #12]
 80044f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80044fa:	461a      	mov	r2, r3
 80044fc:	9b03      	ldr	r3, [sp, #12]
 80044fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004500:	1ad3      	subs	r3, r2, r3
 8004502:	9308      	str	r3, [sp, #32]
    if (size > (n - w)) {
 8004504:	9a01      	ldr	r2, [sp, #4]
 8004506:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004508:	1ad2      	subs	r2, r2, r3
 800450a:	9b08      	ldr	r3, [sp, #32]
 800450c:	429a      	cmp	r2, r3
 800450e:	d203      	bcs.n	8004518 <obqWriteTimeout+0x98>
      size = n - w;
 8004510:	9a01      	ldr	r2, [sp, #4]
 8004512:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004514:	1ad3      	subs	r3, r2, r3
 8004516:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004518:	9b08      	ldr	r3, [sp, #32]
 800451a:	2b40      	cmp	r3, #64	; 0x40
 800451c:	d913      	bls.n	8004546 <obqWriteTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 800451e:	9b03      	ldr	r3, [sp, #12]
 8004520:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004522:	4618      	mov	r0, r3
 8004524:	9902      	ldr	r1, [sp, #8]
 8004526:	2240      	movs	r2, #64	; 0x40
 8004528:	f013 f85a 	bl	80175e0 <memcpy>
      bp        += 64U;
 800452c:	9b02      	ldr	r3, [sp, #8]
 800452e:	3340      	adds	r3, #64	; 0x40
 8004530:	9302      	str	r3, [sp, #8]
      obqp->ptr += 64U;
 8004532:	9b03      	ldr	r3, [sp, #12]
 8004534:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004536:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800453a:	9b03      	ldr	r3, [sp, #12]
 800453c:	625a      	str	r2, [r3, #36]	; 0x24
      w         += 64U;
 800453e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004540:	3340      	adds	r3, #64	; 0x40
 8004542:	9309      	str	r3, [sp, #36]	; 0x24
 8004544:	e014      	b.n	8004570 <obqWriteTimeout+0xf0>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 8004546:	9b03      	ldr	r3, [sp, #12]
 8004548:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800454a:	4618      	mov	r0, r3
 800454c:	9902      	ldr	r1, [sp, #8]
 800454e:	9a08      	ldr	r2, [sp, #32]
 8004550:	f013 f846 	bl	80175e0 <memcpy>
      bp        += size;
 8004554:	9a02      	ldr	r2, [sp, #8]
 8004556:	9b08      	ldr	r3, [sp, #32]
 8004558:	4413      	add	r3, r2
 800455a:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 800455c:	9b03      	ldr	r3, [sp, #12]
 800455e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004560:	9b08      	ldr	r3, [sp, #32]
 8004562:	441a      	add	r2, r3
 8004564:	9b03      	ldr	r3, [sp, #12]
 8004566:	625a      	str	r2, [r3, #36]	; 0x24
      w         += size;
 8004568:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800456a:	9b08      	ldr	r3, [sp, #32]
 800456c:	4413      	add	r3, r2
 800456e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8004570:	9b03      	ldr	r3, [sp, #12]
 8004572:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004574:	9b03      	ldr	r3, [sp, #12]
 8004576:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004578:	429a      	cmp	r2, r3
 800457a:	d306      	bcc.n	800458a <obqWriteTimeout+0x10a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800457c:	9b03      	ldr	r3, [sp, #12]
 800457e:	699b      	ldr	r3, [r3, #24]
 8004580:	3b04      	subs	r3, #4
 8004582:	9803      	ldr	r0, [sp, #12]
 8004584:	4619      	mov	r1, r3
 8004586:	f7ff ff13 	bl	80043b0 <obqPostFullBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 800458a:	f7ff fbf1 	bl	8003d70 <osalSysUnlock>
    if (w >= n) {
 800458e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004590:	9b01      	ldr	r3, [sp, #4]
 8004592:	429a      	cmp	r2, r3
 8004594:	d301      	bcc.n	800459a <obqWriteTimeout+0x11a>
      return w;
 8004596:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004598:	e002      	b.n	80045a0 <obqWriteTimeout+0x120>
    }
    osalSysLock();
 800459a:	f7ff fbe1 	bl	8003d60 <osalSysLock>
  }
 800459e:	e77f      	b.n	80044a0 <obqWriteTimeout+0x20>
}
 80045a0:	4618      	mov	r0, r3
 80045a2:	b00b      	add	sp, #44	; 0x2c
 80045a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80045a8:	f3af 8000 	nop.w
 80045ac:	f3af 8000 	nop.w

080045b0 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 80045b0:	b084      	sub	sp, #16
 80045b2:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80045b4:	9b01      	ldr	r3, [sp, #4]
 80045b6:	68da      	ldr	r2, [r3, #12]
 80045b8:	9b01      	ldr	r3, [sp, #4]
 80045ba:	691b      	ldr	r3, [r3, #16]
 80045bc:	429a      	cmp	r2, r3
 80045be:	d105      	bne.n	80045cc <obqTryFlushI+0x1c>
 80045c0:	9b01      	ldr	r3, [sp, #4]
 80045c2:	689b      	ldr	r3, [r3, #8]
 80045c4:	2b00      	cmp	r3, #0
 80045c6:	d001      	beq.n	80045cc <obqTryFlushI+0x1c>
 80045c8:	2301      	movs	r3, #1
 80045ca:	e000      	b.n	80045ce <obqTryFlushI+0x1e>
 80045cc:	2300      	movs	r3, #0
 80045ce:	f003 0301 	and.w	r3, r3, #1
 80045d2:	b2db      	uxtb	r3, r3
 80045d4:	2b00      	cmp	r3, #0
 80045d6:	d02d      	beq.n	8004634 <obqTryFlushI+0x84>
 80045d8:	9b01      	ldr	r3, [sp, #4]
 80045da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045dc:	2b00      	cmp	r3, #0
 80045de:	d029      	beq.n	8004634 <obqTryFlushI+0x84>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80045e0:	9b01      	ldr	r3, [sp, #4]
 80045e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045e4:	461a      	mov	r2, r3
 80045e6:	9b01      	ldr	r3, [sp, #4]
 80045e8:	68db      	ldr	r3, [r3, #12]
 80045ea:	1ad3      	subs	r3, r2, r3
 80045ec:	3b04      	subs	r3, #4
 80045ee:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 80045f0:	9b03      	ldr	r3, [sp, #12]
 80045f2:	2b00      	cmp	r3, #0
 80045f4:	d01e      	beq.n	8004634 <obqTryFlushI+0x84>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 80045f6:	9b01      	ldr	r3, [sp, #4]
 80045f8:	68db      	ldr	r3, [r3, #12]
 80045fa:	9a03      	ldr	r2, [sp, #12]
 80045fc:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 80045fe:	9b01      	ldr	r3, [sp, #4]
 8004600:	689b      	ldr	r3, [r3, #8]
 8004602:	1e5a      	subs	r2, r3, #1
 8004604:	9b01      	ldr	r3, [sp, #4]
 8004606:	609a      	str	r2, [r3, #8]
      obqp->bwrptr += obqp->bsize;
 8004608:	9b01      	ldr	r3, [sp, #4]
 800460a:	68da      	ldr	r2, [r3, #12]
 800460c:	9b01      	ldr	r3, [sp, #4]
 800460e:	699b      	ldr	r3, [r3, #24]
 8004610:	441a      	add	r2, r3
 8004612:	9b01      	ldr	r3, [sp, #4]
 8004614:	60da      	str	r2, [r3, #12]
      if (obqp->bwrptr >= obqp->btop) {
 8004616:	9b01      	ldr	r3, [sp, #4]
 8004618:	68da      	ldr	r2, [r3, #12]
 800461a:	9b01      	ldr	r3, [sp, #4]
 800461c:	695b      	ldr	r3, [r3, #20]
 800461e:	429a      	cmp	r2, r3
 8004620:	d303      	bcc.n	800462a <obqTryFlushI+0x7a>
        obqp->bwrptr = obqp->buffers;
 8004622:	9b01      	ldr	r3, [sp, #4]
 8004624:	6a1a      	ldr	r2, [r3, #32]
 8004626:	9b01      	ldr	r3, [sp, #4]
 8004628:	60da      	str	r2, [r3, #12]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 800462a:	9b01      	ldr	r3, [sp, #4]
 800462c:	2200      	movs	r2, #0
 800462e:	625a      	str	r2, [r3, #36]	; 0x24

      return true;
 8004630:	2301      	movs	r3, #1
 8004632:	e000      	b.n	8004636 <obqTryFlushI+0x86>
    }
  }
  return false;
 8004634:	2300      	movs	r3, #0
}
 8004636:	4618      	mov	r0, r3
 8004638:	b004      	add	sp, #16
 800463a:	4770      	bx	lr
 800463c:	f3af 8000 	nop.w

08004640 <obqFlush>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @api
 */
void obqFlush(output_buffers_queue_t *obqp) {
 8004640:	b500      	push	{lr}
 8004642:	b085      	sub	sp, #20
 8004644:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8004646:	f7ff fb8b 	bl	8003d60 <osalSysLock>

  /* If there is a buffer partially filled and not being written.*/
  if (obqp->ptr != NULL) {
 800464a:	9b01      	ldr	r3, [sp, #4]
 800464c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800464e:	2b00      	cmp	r3, #0
 8004650:	d00e      	beq.n	8004670 <obqFlush+0x30>
    size_t size = (size_t)obqp->ptr - (size_t)obqp->bwrptr - sizeof (size_t);
 8004652:	9b01      	ldr	r3, [sp, #4]
 8004654:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004656:	461a      	mov	r2, r3
 8004658:	9b01      	ldr	r3, [sp, #4]
 800465a:	68db      	ldr	r3, [r3, #12]
 800465c:	1ad3      	subs	r3, r2, r3
 800465e:	3b04      	subs	r3, #4
 8004660:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 8004662:	9b03      	ldr	r3, [sp, #12]
 8004664:	2b00      	cmp	r3, #0
 8004666:	d003      	beq.n	8004670 <obqFlush+0x30>
      obqPostFullBufferS(obqp, size);
 8004668:	9801      	ldr	r0, [sp, #4]
 800466a:	9903      	ldr	r1, [sp, #12]
 800466c:	f7ff fea0 	bl	80043b0 <obqPostFullBufferS>
    }
  }

  osalSysUnlock();
 8004670:	f7ff fb7e 	bl	8003d70 <osalSysUnlock>
}
 8004674:	b005      	add	sp, #20
 8004676:	f85d fb04 	ldr.w	pc, [sp], #4
 800467a:	bf00      	nop
 800467c:	f3af 8000 	nop.w

08004680 <_mmcsd_get_slice>:
 *
 * @notapi
 */
uint32_t _mmcsd_get_slice(const uint32_t *data,
                          uint32_t end,
                          uint32_t start) {
 8004680:	b088      	sub	sp, #32
 8004682:	9003      	str	r0, [sp, #12]
 8004684:	9102      	str	r1, [sp, #8]
 8004686:	9201      	str	r2, [sp, #4]
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
 8004688:	9b01      	ldr	r3, [sp, #4]
 800468a:	095b      	lsrs	r3, r3, #5
 800468c:	9307      	str	r3, [sp, #28]
  startoff = start % 32U;
 800468e:	9b01      	ldr	r3, [sp, #4]
 8004690:	f003 031f 	and.w	r3, r3, #31
 8004694:	9306      	str	r3, [sp, #24]
  endidx   = end / 32U;
 8004696:	9b02      	ldr	r3, [sp, #8]
 8004698:	095b      	lsrs	r3, r3, #5
 800469a:	9305      	str	r3, [sp, #20]
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 800469c:	9b02      	ldr	r3, [sp, #8]
 800469e:	f003 031f 	and.w	r3, r3, #31
 80046a2:	3301      	adds	r3, #1
 80046a4:	2201      	movs	r2, #1
 80046a6:	fa02 f303 	lsl.w	r3, r2, r3
 80046aa:	3b01      	subs	r3, #1
 80046ac:	9304      	str	r3, [sp, #16]

  /* One or two pieces?*/
  if (startidx < endidx) {
 80046ae:	9a07      	ldr	r2, [sp, #28]
 80046b0:	9b05      	ldr	r3, [sp, #20]
 80046b2:	429a      	cmp	r2, r3
 80046b4:	d214      	bcs.n	80046e0 <_mmcsd_get_slice+0x60>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80046b6:	9b07      	ldr	r3, [sp, #28]
 80046b8:	009b      	lsls	r3, r3, #2
 80046ba:	9a03      	ldr	r2, [sp, #12]
 80046bc:	4413      	add	r3, r2
 80046be:	681a      	ldr	r2, [r3, #0]
 80046c0:	9b06      	ldr	r3, [sp, #24]
 80046c2:	40da      	lsrs	r2, r3
           ((data[endidx] & endmask) << (32U - startoff));
 80046c4:	9b05      	ldr	r3, [sp, #20]
 80046c6:	009b      	lsls	r3, r3, #2
 80046c8:	9903      	ldr	r1, [sp, #12]
 80046ca:	440b      	add	r3, r1
 80046cc:	6819      	ldr	r1, [r3, #0]
 80046ce:	9b04      	ldr	r3, [sp, #16]
 80046d0:	4019      	ands	r1, r3
 80046d2:	9b06      	ldr	r3, [sp, #24]
 80046d4:	f1c3 0320 	rsb	r3, r3, #32
 80046d8:	fa01 f303 	lsl.w	r3, r1, r3
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80046dc:	4313      	orrs	r3, r2
 80046de:	e009      	b.n	80046f4 <_mmcsd_get_slice+0x74>
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 80046e0:	9b07      	ldr	r3, [sp, #28]
 80046e2:	009b      	lsls	r3, r3, #2
 80046e4:	9a03      	ldr	r2, [sp, #12]
 80046e6:	4413      	add	r3, r2
 80046e8:	681a      	ldr	r2, [r3, #0]
 80046ea:	9b04      	ldr	r3, [sp, #16]
 80046ec:	401a      	ands	r2, r3
 80046ee:	9b06      	ldr	r3, [sp, #24]
 80046f0:	fa22 f303 	lsr.w	r3, r2, r3
}
 80046f4:	4618      	mov	r0, r3
 80046f6:	b008      	add	sp, #32
 80046f8:	4770      	bx	lr
 80046fa:	bf00      	nop
 80046fc:	f3af 8000 	nop.w

08004700 <_mmcsd_get_capacity>:
 * @return              The card capacity.
 * @retval 0            CSD format error
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
 8004700:	b500      	push	{lr}
 8004702:	b087      	sub	sp, #28
 8004704:	9001      	str	r0, [sp, #4]
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8004706:	9801      	ldr	r0, [sp, #4]
 8004708:	217f      	movs	r1, #127	; 0x7f
 800470a:	227e      	movs	r2, #126	; 0x7e
 800470c:	f7ff ffb8 	bl	8004680 <_mmcsd_get_slice>
 8004710:	4603      	mov	r3, r0
 8004712:	2b00      	cmp	r3, #0
 8004714:	d004      	beq.n	8004720 <_mmcsd_get_capacity+0x20>
 8004716:	2b01      	cmp	r3, #1
 8004718:	d01e      	beq.n	8004758 <_mmcsd_get_capacity+0x58>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
  default:
    /* Reserved value detected.*/
    break;
 800471a:	bf00      	nop
  }
  return 0U;
 800471c:	2300      	movs	r3, #0
 800471e:	e023      	b.n	8004768 <_mmcsd_get_capacity+0x68>
  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8004720:	9801      	ldr	r0, [sp, #4]
 8004722:	2149      	movs	r1, #73	; 0x49
 8004724:	223e      	movs	r2, #62	; 0x3e
 8004726:	f7ff ffab 	bl	8004680 <_mmcsd_get_slice>
 800472a:	9005      	str	r0, [sp, #20]
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 800472c:	9801      	ldr	r0, [sp, #4]
 800472e:	2131      	movs	r1, #49	; 0x31
 8004730:	222f      	movs	r2, #47	; 0x2f
 8004732:	f7ff ffa5 	bl	8004680 <_mmcsd_get_slice>
 8004736:	9004      	str	r0, [sp, #16]
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8004738:	9801      	ldr	r0, [sp, #4]
 800473a:	2153      	movs	r1, #83	; 0x53
 800473c:	2250      	movs	r2, #80	; 0x50
 800473e:	f7ff ff9f 	bl	8004680 <_mmcsd_get_slice>
 8004742:	9003      	str	r0, [sp, #12]
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 8004744:	9b05      	ldr	r3, [sp, #20]
 8004746:	1c5a      	adds	r2, r3, #1
 8004748:	9b04      	ldr	r3, [sp, #16]
 800474a:	3302      	adds	r3, #2
 800474c:	409a      	lsls	r2, r3
 800474e:	9b03      	ldr	r3, [sp, #12]
 8004750:	3b09      	subs	r3, #9
 8004752:	fa02 f303 	lsl.w	r3, r2, r3
 8004756:	e007      	b.n	8004768 <_mmcsd_get_capacity+0x68>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 8004758:	9801      	ldr	r0, [sp, #4]
 800475a:	2145      	movs	r1, #69	; 0x45
 800475c:	2230      	movs	r2, #48	; 0x30
 800475e:	f7ff ff8f 	bl	8004680 <_mmcsd_get_slice>
 8004762:	4603      	mov	r3, r0
 8004764:	3301      	adds	r3, #1
 8004766:	029b      	lsls	r3, r3, #10
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
}
 8004768:	4618      	mov	r0, r3
 800476a:	b007      	add	sp, #28
 800476c:	f85d fb04 	ldr.w	pc, [sp], #4

08004770 <_mmcsd_get_capacity_ext>:
 *
 * @return              The card capacity.
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {
 8004770:	b082      	sub	sp, #8
 8004772:	9001      	str	r0, [sp, #4]

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004774:	9b01      	ldr	r3, [sp, #4]
 8004776:	33d7      	adds	r3, #215	; 0xd7
 8004778:	781b      	ldrb	r3, [r3, #0]
 800477a:	061a      	lsls	r2, r3, #24
         ((uint32_t)ext_csd[214] << 16U) +
 800477c:	9b01      	ldr	r3, [sp, #4]
 800477e:	33d6      	adds	r3, #214	; 0xd6
 8004780:	781b      	ldrb	r3, [r3, #0]
 8004782:	041b      	lsls	r3, r3, #16
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004784:	441a      	add	r2, r3
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
 8004786:	9b01      	ldr	r3, [sp, #4]
 8004788:	33d5      	adds	r3, #213	; 0xd5
 800478a:	781b      	ldrb	r3, [r3, #0]
 800478c:	021b      	lsls	r3, r3, #8
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
 800478e:	441a      	add	r2, r3
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
 8004790:	9b01      	ldr	r3, [sp, #4]
 8004792:	33d4      	adds	r3, #212	; 0xd4
 8004794:	781b      	ldrb	r3, [r3, #0]
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004796:	4413      	add	r3, r2
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
}
 8004798:	4618      	mov	r0, r3
 800479a:	b002      	add	sp, #8
 800479c:	4770      	bx	lr
 800479e:	bf00      	nop

080047a0 <_mmcsd_unpack_sdc_cid>:
 * @param[out] cidsdc   pointer to the @p unpacked_sdc_cid_t object
 *
 * @notapi
 */
void _mmcsd_unpack_sdc_cid(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_cid_t *cidsdc) {
 80047a0:	b500      	push	{lr}
 80047a2:	b085      	sub	sp, #20
 80047a4:	9001      	str	r0, [sp, #4]
 80047a6:	9100      	str	r1, [sp, #0]
  const uint32_t *cid;

  osalDbgCheck((NULL != sdcp) && (NULL != cidsdc));

  cid = sdcp->cid;
 80047a8:	9b01      	ldr	r3, [sp, #4]
 80047aa:	3308      	adds	r3, #8
 80047ac:	9303      	str	r3, [sp, #12]
  cidsdc->crc    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_CRC_SLICE);
 80047ae:	9803      	ldr	r0, [sp, #12]
 80047b0:	2107      	movs	r1, #7
 80047b2:	2201      	movs	r2, #1
 80047b4:	f7ff ff64 	bl	8004680 <_mmcsd_get_slice>
 80047b8:	4603      	mov	r3, r0
 80047ba:	b2da      	uxtb	r2, r3
 80047bc:	9b00      	ldr	r3, [sp, #0]
 80047be:	751a      	strb	r2, [r3, #20]
  cidsdc->mdt_y  = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_SDC_MDT_Y_SLICE) +
 80047c0:	9803      	ldr	r0, [sp, #12]
 80047c2:	2113      	movs	r1, #19
 80047c4:	220c      	movs	r2, #12
 80047c6:	f7ff ff5b 	bl	8004680 <_mmcsd_get_slice>
 80047ca:	4603      	mov	r3, r0
 80047cc:	b29b      	uxth	r3, r3
 80047ce:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 80047d2:	b29a      	uxth	r2, r3
 80047d4:	9b00      	ldr	r3, [sp, #0]
 80047d6:	825a      	strh	r2, [r3, #18]
                             2000U;
  cidsdc->mdt_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_MDT_M_SLICE);
 80047d8:	9803      	ldr	r0, [sp, #12]
 80047da:	210b      	movs	r1, #11
 80047dc:	2208      	movs	r2, #8
 80047de:	f7ff ff4f 	bl	8004680 <_mmcsd_get_slice>
 80047e2:	4603      	mov	r3, r0
 80047e4:	b2da      	uxtb	r2, r3
 80047e6:	9b00      	ldr	r3, [sp, #0]
 80047e8:	741a      	strb	r2, [r3, #16]
  cidsdc->mid    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_MID_SLICE);
 80047ea:	9803      	ldr	r0, [sp, #12]
 80047ec:	217f      	movs	r1, #127	; 0x7f
 80047ee:	2278      	movs	r2, #120	; 0x78
 80047f0:	f7ff ff46 	bl	8004680 <_mmcsd_get_slice>
 80047f4:	4603      	mov	r3, r0
 80047f6:	b2da      	uxtb	r2, r3
 80047f8:	9b00      	ldr	r3, [sp, #0]
 80047fa:	701a      	strb	r2, [r3, #0]
  cidsdc->oid    = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_SDC_OID_SLICE);
 80047fc:	9803      	ldr	r0, [sp, #12]
 80047fe:	2177      	movs	r1, #119	; 0x77
 8004800:	2268      	movs	r2, #104	; 0x68
 8004802:	f7ff ff3d 	bl	8004680 <_mmcsd_get_slice>
 8004806:	4603      	mov	r3, r0
 8004808:	b29a      	uxth	r2, r3
 800480a:	9b00      	ldr	r3, [sp, #0]
 800480c:	805a      	strh	r2, [r3, #2]
  cidsdc->pnm[4] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM0_SLICE);
 800480e:	9803      	ldr	r0, [sp, #12]
 8004810:	2147      	movs	r1, #71	; 0x47
 8004812:	2240      	movs	r2, #64	; 0x40
 8004814:	f7ff ff34 	bl	8004680 <_mmcsd_get_slice>
 8004818:	4603      	mov	r3, r0
 800481a:	b2da      	uxtb	r2, r3
 800481c:	9b00      	ldr	r3, [sp, #0]
 800481e:	721a      	strb	r2, [r3, #8]
  cidsdc->pnm[3] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM1_SLICE);
 8004820:	9803      	ldr	r0, [sp, #12]
 8004822:	214f      	movs	r1, #79	; 0x4f
 8004824:	2248      	movs	r2, #72	; 0x48
 8004826:	f7ff ff2b 	bl	8004680 <_mmcsd_get_slice>
 800482a:	4603      	mov	r3, r0
 800482c:	b2da      	uxtb	r2, r3
 800482e:	9b00      	ldr	r3, [sp, #0]
 8004830:	71da      	strb	r2, [r3, #7]
  cidsdc->pnm[2] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM2_SLICE);
 8004832:	9803      	ldr	r0, [sp, #12]
 8004834:	2157      	movs	r1, #87	; 0x57
 8004836:	2250      	movs	r2, #80	; 0x50
 8004838:	f7ff ff22 	bl	8004680 <_mmcsd_get_slice>
 800483c:	4603      	mov	r3, r0
 800483e:	b2da      	uxtb	r2, r3
 8004840:	9b00      	ldr	r3, [sp, #0]
 8004842:	719a      	strb	r2, [r3, #6]
  cidsdc->pnm[1] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM3_SLICE);
 8004844:	9803      	ldr	r0, [sp, #12]
 8004846:	215f      	movs	r1, #95	; 0x5f
 8004848:	2258      	movs	r2, #88	; 0x58
 800484a:	f7ff ff19 	bl	8004680 <_mmcsd_get_slice>
 800484e:	4603      	mov	r3, r0
 8004850:	b2da      	uxtb	r2, r3
 8004852:	9b00      	ldr	r3, [sp, #0]
 8004854:	715a      	strb	r2, [r3, #5]
  cidsdc->pnm[0] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM4_SLICE);
 8004856:	9803      	ldr	r0, [sp, #12]
 8004858:	2167      	movs	r1, #103	; 0x67
 800485a:	2260      	movs	r2, #96	; 0x60
 800485c:	f7ff ff10 	bl	8004680 <_mmcsd_get_slice>
 8004860:	4603      	mov	r3, r0
 8004862:	b2da      	uxtb	r2, r3
 8004864:	9b00      	ldr	r3, [sp, #0]
 8004866:	711a      	strb	r2, [r3, #4]
  cidsdc->prv_n  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_PRV_N_SLICE);
 8004868:	9803      	ldr	r0, [sp, #12]
 800486a:	213f      	movs	r1, #63	; 0x3f
 800486c:	223c      	movs	r2, #60	; 0x3c
 800486e:	f7ff ff07 	bl	8004680 <_mmcsd_get_slice>
 8004872:	4603      	mov	r3, r0
 8004874:	b2da      	uxtb	r2, r3
 8004876:	9b00      	ldr	r3, [sp, #0]
 8004878:	725a      	strb	r2, [r3, #9]
  cidsdc->prv_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_PRV_M_SLICE);
 800487a:	9803      	ldr	r0, [sp, #12]
 800487c:	213b      	movs	r1, #59	; 0x3b
 800487e:	2238      	movs	r2, #56	; 0x38
 8004880:	f7ff fefe 	bl	8004680 <_mmcsd_get_slice>
 8004884:	4603      	mov	r3, r0
 8004886:	b2da      	uxtb	r2, r3
 8004888:	9b00      	ldr	r3, [sp, #0]
 800488a:	729a      	strb	r2, [r3, #10]
  cidsdc->psn    =           _mmcsd_get_slice(cid, MMCSD_CID_SDC_PSN_SLICE);
 800488c:	9803      	ldr	r0, [sp, #12]
 800488e:	2137      	movs	r1, #55	; 0x37
 8004890:	2218      	movs	r2, #24
 8004892:	f7ff fef5 	bl	8004680 <_mmcsd_get_slice>
 8004896:	4602      	mov	r2, r0
 8004898:	9b00      	ldr	r3, [sp, #0]
 800489a:	60da      	str	r2, [r3, #12]
}
 800489c:	b005      	add	sp, #20
 800489e:	f85d fb04 	ldr.w	pc, [sp], #4
 80048a2:	bf00      	nop
 80048a4:	f3af 8000 	nop.w
 80048a8:	f3af 8000 	nop.w
 80048ac:	f3af 8000 	nop.w

080048b0 <_mmcsd_unpack_mmc_cid>:
 * @param[out] cidmmc   pointer to the @p unpacked_mmc_cid_t object
 *
 * @notapi
 */
void _mmcsd_unpack_mmc_cid(const MMCSDBlockDevice *sdcp,
                           unpacked_mmc_cid_t *cidmmc) {
 80048b0:	b500      	push	{lr}
 80048b2:	b085      	sub	sp, #20
 80048b4:	9001      	str	r0, [sp, #4]
 80048b6:	9100      	str	r1, [sp, #0]
  const uint32_t *cid;

  osalDbgCheck((NULL != sdcp) && (NULL != cidmmc));

  cid = sdcp->cid;
 80048b8:	9b01      	ldr	r3, [sp, #4]
 80048ba:	3308      	adds	r3, #8
 80048bc:	9303      	str	r3, [sp, #12]
  cidmmc->crc    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_CRC_SLICE);
 80048be:	9803      	ldr	r0, [sp, #12]
 80048c0:	2107      	movs	r1, #7
 80048c2:	2201      	movs	r2, #1
 80048c4:	f7ff fedc 	bl	8004680 <_mmcsd_get_slice>
 80048c8:	4603      	mov	r3, r0
 80048ca:	b2da      	uxtb	r2, r3
 80048cc:	9b00      	ldr	r3, [sp, #0]
 80048ce:	751a      	strb	r2, [r3, #20]
  cidmmc->mdt_y  = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_MMC_MDT_Y_SLICE) +
 80048d0:	9803      	ldr	r0, [sp, #12]
 80048d2:	210b      	movs	r1, #11
 80048d4:	2208      	movs	r2, #8
 80048d6:	f7ff fed3 	bl	8004680 <_mmcsd_get_slice>
 80048da:	4603      	mov	r3, r0
 80048dc:	b29b      	uxth	r3, r3
 80048de:	f203 73cd 	addw	r3, r3, #1997	; 0x7cd
 80048e2:	b29a      	uxth	r2, r3
 80048e4:	9b00      	ldr	r3, [sp, #0]
 80048e6:	825a      	strh	r2, [r3, #18]
                             1997U;
  cidmmc->mdt_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_MDT_M_SLICE);
 80048e8:	9803      	ldr	r0, [sp, #12]
 80048ea:	210f      	movs	r1, #15
 80048ec:	220c      	movs	r2, #12
 80048ee:	f7ff fec7 	bl	8004680 <_mmcsd_get_slice>
 80048f2:	4603      	mov	r3, r0
 80048f4:	b2da      	uxtb	r2, r3
 80048f6:	9b00      	ldr	r3, [sp, #0]
 80048f8:	741a      	strb	r2, [r3, #16]
  cidmmc->mid    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_MID_SLICE);
 80048fa:	9803      	ldr	r0, [sp, #12]
 80048fc:	217f      	movs	r1, #127	; 0x7f
 80048fe:	2278      	movs	r2, #120	; 0x78
 8004900:	f7ff febe 	bl	8004680 <_mmcsd_get_slice>
 8004904:	4603      	mov	r3, r0
 8004906:	b2da      	uxtb	r2, r3
 8004908:	9b00      	ldr	r3, [sp, #0]
 800490a:	701a      	strb	r2, [r3, #0]
  cidmmc->oid    = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_MMC_OID_SLICE);
 800490c:	9803      	ldr	r0, [sp, #12]
 800490e:	2177      	movs	r1, #119	; 0x77
 8004910:	2268      	movs	r2, #104	; 0x68
 8004912:	f7ff feb5 	bl	8004680 <_mmcsd_get_slice>
 8004916:	4603      	mov	r3, r0
 8004918:	b29a      	uxth	r2, r3
 800491a:	9b00      	ldr	r3, [sp, #0]
 800491c:	805a      	strh	r2, [r3, #2]
  cidmmc->pnm[5] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM0_SLICE);
 800491e:	9803      	ldr	r0, [sp, #12]
 8004920:	213f      	movs	r1, #63	; 0x3f
 8004922:	2238      	movs	r2, #56	; 0x38
 8004924:	f7ff feac 	bl	8004680 <_mmcsd_get_slice>
 8004928:	4603      	mov	r3, r0
 800492a:	b2da      	uxtb	r2, r3
 800492c:	9b00      	ldr	r3, [sp, #0]
 800492e:	725a      	strb	r2, [r3, #9]
  cidmmc->pnm[4] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM1_SLICE);
 8004930:	9803      	ldr	r0, [sp, #12]
 8004932:	2147      	movs	r1, #71	; 0x47
 8004934:	2240      	movs	r2, #64	; 0x40
 8004936:	f7ff fea3 	bl	8004680 <_mmcsd_get_slice>
 800493a:	4603      	mov	r3, r0
 800493c:	b2da      	uxtb	r2, r3
 800493e:	9b00      	ldr	r3, [sp, #0]
 8004940:	721a      	strb	r2, [r3, #8]
  cidmmc->pnm[3] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM2_SLICE);
 8004942:	9803      	ldr	r0, [sp, #12]
 8004944:	214f      	movs	r1, #79	; 0x4f
 8004946:	2248      	movs	r2, #72	; 0x48
 8004948:	f7ff fe9a 	bl	8004680 <_mmcsd_get_slice>
 800494c:	4603      	mov	r3, r0
 800494e:	b2da      	uxtb	r2, r3
 8004950:	9b00      	ldr	r3, [sp, #0]
 8004952:	71da      	strb	r2, [r3, #7]
  cidmmc->pnm[2] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM3_SLICE);
 8004954:	9803      	ldr	r0, [sp, #12]
 8004956:	2157      	movs	r1, #87	; 0x57
 8004958:	2250      	movs	r2, #80	; 0x50
 800495a:	f7ff fe91 	bl	8004680 <_mmcsd_get_slice>
 800495e:	4603      	mov	r3, r0
 8004960:	b2da      	uxtb	r2, r3
 8004962:	9b00      	ldr	r3, [sp, #0]
 8004964:	719a      	strb	r2, [r3, #6]
  cidmmc->pnm[1] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM4_SLICE);
 8004966:	9803      	ldr	r0, [sp, #12]
 8004968:	215f      	movs	r1, #95	; 0x5f
 800496a:	2258      	movs	r2, #88	; 0x58
 800496c:	f7ff fe88 	bl	8004680 <_mmcsd_get_slice>
 8004970:	4603      	mov	r3, r0
 8004972:	b2da      	uxtb	r2, r3
 8004974:	9b00      	ldr	r3, [sp, #0]
 8004976:	715a      	strb	r2, [r3, #5]
  cidmmc->pnm[0] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM5_SLICE);
 8004978:	9803      	ldr	r0, [sp, #12]
 800497a:	2167      	movs	r1, #103	; 0x67
 800497c:	2260      	movs	r2, #96	; 0x60
 800497e:	f7ff fe7f 	bl	8004680 <_mmcsd_get_slice>
 8004982:	4603      	mov	r3, r0
 8004984:	b2da      	uxtb	r2, r3
 8004986:	9b00      	ldr	r3, [sp, #0]
 8004988:	711a      	strb	r2, [r3, #4]
  cidmmc->prv_n  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_PRV_N_SLICE);
 800498a:	9803      	ldr	r0, [sp, #12]
 800498c:	2137      	movs	r1, #55	; 0x37
 800498e:	2234      	movs	r2, #52	; 0x34
 8004990:	f7ff fe76 	bl	8004680 <_mmcsd_get_slice>
 8004994:	4603      	mov	r3, r0
 8004996:	b2da      	uxtb	r2, r3
 8004998:	9b00      	ldr	r3, [sp, #0]
 800499a:	729a      	strb	r2, [r3, #10]
  cidmmc->prv_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_PRV_M_SLICE);
 800499c:	9803      	ldr	r0, [sp, #12]
 800499e:	2133      	movs	r1, #51	; 0x33
 80049a0:	2230      	movs	r2, #48	; 0x30
 80049a2:	f7ff fe6d 	bl	8004680 <_mmcsd_get_slice>
 80049a6:	4603      	mov	r3, r0
 80049a8:	b2da      	uxtb	r2, r3
 80049aa:	9b00      	ldr	r3, [sp, #0]
 80049ac:	72da      	strb	r2, [r3, #11]
  cidmmc->psn    =           _mmcsd_get_slice(cid, MMCSD_CID_MMC_PSN_SLICE);
 80049ae:	9803      	ldr	r0, [sp, #12]
 80049b0:	212f      	movs	r1, #47	; 0x2f
 80049b2:	2210      	movs	r2, #16
 80049b4:	f7ff fe64 	bl	8004680 <_mmcsd_get_slice>
 80049b8:	4602      	mov	r2, r0
 80049ba:	9b00      	ldr	r3, [sp, #0]
 80049bc:	60da      	str	r2, [r3, #12]
}
 80049be:	b005      	add	sp, #20
 80049c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80049c4:	f3af 8000 	nop.w
 80049c8:	f3af 8000 	nop.w
 80049cc:	f3af 8000 	nop.w

080049d0 <_mmcsd_unpack_csd_mmc>:
 * @param[out] csdmmc   pointer to the @p unpacked_mmc_csd_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_mmc(const MMCSDBlockDevice *sdcp,
                           unpacked_mmc_csd_t *csdmmc) {
 80049d0:	b500      	push	{lr}
 80049d2:	b085      	sub	sp, #20
 80049d4:	9001      	str	r0, [sp, #4]
 80049d6:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck((NULL != sdcp) && (NULL != csdmmc));

  csd = sdcp->csd;
 80049d8:	9b01      	ldr	r3, [sp, #4]
 80049da:	3318      	adds	r3, #24
 80049dc:	9303      	str	r3, [sp, #12]
  csdmmc->c_size             = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_MMC_C_SIZE_SLICE);
 80049de:	9803      	ldr	r0, [sp, #12]
 80049e0:	2149      	movs	r1, #73	; 0x49
 80049e2:	223e      	movs	r2, #62	; 0x3e
 80049e4:	f7ff fe4c 	bl	8004680 <_mmcsd_get_slice>
 80049e8:	4603      	mov	r3, r0
 80049ea:	b29a      	uxth	r2, r3
 80049ec:	9b00      	ldr	r3, [sp, #0]
 80049ee:	81da      	strh	r2, [r3, #14]
  csdmmc->c_size_mult        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_C_SIZE_MULT_SLICE);
 80049f0:	9803      	ldr	r0, [sp, #12]
 80049f2:	2131      	movs	r1, #49	; 0x31
 80049f4:	222f      	movs	r2, #47	; 0x2f
 80049f6:	f7ff fe43 	bl	8004680 <_mmcsd_get_slice>
 80049fa:	4603      	mov	r3, r0
 80049fc:	b2da      	uxtb	r2, r3
 80049fe:	9b00      	ldr	r3, [sp, #0]
 8004a00:	751a      	strb	r2, [r3, #20]
  csdmmc->ccc                = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_MMC_CCC_SLICE);
 8004a02:	9803      	ldr	r0, [sp, #12]
 8004a04:	215f      	movs	r1, #95	; 0x5f
 8004a06:	2254      	movs	r2, #84	; 0x54
 8004a08:	f7ff fe3a 	bl	8004680 <_mmcsd_get_slice>
 8004a0c:	4603      	mov	r3, r0
 8004a0e:	b29a      	uxth	r2, r3
 8004a10:	9b00      	ldr	r3, [sp, #0]
 8004a12:	80da      	strh	r2, [r3, #6]
  csdmmc->copy               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_COPY_SLICE);
 8004a14:	9803      	ldr	r0, [sp, #12]
 8004a16:	210e      	movs	r1, #14
 8004a18:	220e      	movs	r2, #14
 8004a1a:	f7ff fe31 	bl	8004680 <_mmcsd_get_slice>
 8004a1e:	4603      	mov	r3, r0
 8004a20:	b2da      	uxtb	r2, r3
 8004a22:	9b00      	ldr	r3, [sp, #0]
 8004a24:	77da      	strb	r2, [r3, #31]
  csdmmc->crc                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_CRC_SLICE);
 8004a26:	9803      	ldr	r0, [sp, #12]
 8004a28:	2107      	movs	r1, #7
 8004a2a:	2201      	movs	r2, #1
 8004a2c:	f7ff fe28 	bl	8004680 <_mmcsd_get_slice>
 8004a30:	4603      	mov	r3, r0
 8004a32:	b2da      	uxtb	r2, r3
 8004a34:	9b00      	ldr	r3, [sp, #0]
 8004a36:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  csdmmc->csd_structure      = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE);
 8004a3a:	9803      	ldr	r0, [sp, #12]
 8004a3c:	217f      	movs	r1, #127	; 0x7f
 8004a3e:	227e      	movs	r2, #126	; 0x7e
 8004a40:	f7ff fe1e 	bl	8004680 <_mmcsd_get_slice>
 8004a44:	4603      	mov	r3, r0
 8004a46:	b2da      	uxtb	r2, r3
 8004a48:	9b00      	ldr	r3, [sp, #0]
 8004a4a:	701a      	strb	r2, [r3, #0]
  csdmmc->dsr_imp            = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_DSR_IMP_SLICE);
 8004a4c:	9803      	ldr	r0, [sp, #12]
 8004a4e:	214c      	movs	r1, #76	; 0x4c
 8004a50:	224c      	movs	r2, #76	; 0x4c
 8004a52:	f7ff fe15 	bl	8004680 <_mmcsd_get_slice>
 8004a56:	4603      	mov	r3, r0
 8004a58:	b2da      	uxtb	r2, r3
 8004a5a:	9b00      	ldr	r3, [sp, #0]
 8004a5c:	731a      	strb	r2, [r3, #12]
  csdmmc->ecc                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ECC_SLICE);
 8004a5e:	9803      	ldr	r0, [sp, #12]
 8004a60:	2109      	movs	r1, #9
 8004a62:	2208      	movs	r2, #8
 8004a64:	f7ff fe0c 	bl	8004680 <_mmcsd_get_slice>
 8004a68:	4603      	mov	r3, r0
 8004a6a:	b2da      	uxtb	r2, r3
 8004a6c:	9b00      	ldr	r3, [sp, #0]
 8004a6e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  csdmmc->erase_grp_mult     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ERASE_GRP_MULT_SLICE);
 8004a72:	9803      	ldr	r0, [sp, #12]
 8004a74:	2129      	movs	r1, #41	; 0x29
 8004a76:	2225      	movs	r2, #37	; 0x25
 8004a78:	f7ff fe02 	bl	8004680 <_mmcsd_get_slice>
 8004a7c:	4603      	mov	r3, r0
 8004a7e:	b2da      	uxtb	r2, r3
 8004a80:	9b00      	ldr	r3, [sp, #0]
 8004a82:	759a      	strb	r2, [r3, #22]
  csdmmc->erase_grp_size     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ERASE_GRP_SIZE_SLICE);
 8004a84:	9803      	ldr	r0, [sp, #12]
 8004a86:	212e      	movs	r1, #46	; 0x2e
 8004a88:	222a      	movs	r2, #42	; 0x2a
 8004a8a:	f7ff fdf9 	bl	8004680 <_mmcsd_get_slice>
 8004a8e:	4603      	mov	r3, r0
 8004a90:	b2da      	uxtb	r2, r3
 8004a92:	9b00      	ldr	r3, [sp, #0]
 8004a94:	755a      	strb	r2, [r3, #21]
  csdmmc->file_format        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_FILE_FORMAT_SLICE);
 8004a96:	9803      	ldr	r0, [sp, #12]
 8004a98:	210b      	movs	r1, #11
 8004a9a:	220a      	movs	r2, #10
 8004a9c:	f7ff fdf0 	bl	8004680 <_mmcsd_get_slice>
 8004aa0:	4603      	mov	r3, r0
 8004aa2:	b2da      	uxtb	r2, r3
 8004aa4:	9b00      	ldr	r3, [sp, #0]
 8004aa6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  csdmmc->file_format_grp    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_FILE_FORMAT_GRP_SLICE);
 8004aaa:	9803      	ldr	r0, [sp, #12]
 8004aac:	210f      	movs	r1, #15
 8004aae:	220f      	movs	r2, #15
 8004ab0:	f7ff fde6 	bl	8004680 <_mmcsd_get_slice>
 8004ab4:	4603      	mov	r3, r0
 8004ab6:	b2da      	uxtb	r2, r3
 8004ab8:	9b00      	ldr	r3, [sp, #0]
 8004aba:	779a      	strb	r2, [r3, #30]
  csdmmc->nsac               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_NSAC_SLICE);
 8004abc:	9803      	ldr	r0, [sp, #12]
 8004abe:	216f      	movs	r1, #111	; 0x6f
 8004ac0:	2268      	movs	r2, #104	; 0x68
 8004ac2:	f7ff fddd 	bl	8004680 <_mmcsd_get_slice>
 8004ac6:	4603      	mov	r3, r0
 8004ac8:	b2da      	uxtb	r2, r3
 8004aca:	9b00      	ldr	r3, [sp, #0]
 8004acc:	70da      	strb	r2, [r3, #3]
  csdmmc->perm_write_protect = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_PERM_WRITE_PROTECT_SLICE);
 8004ace:	9803      	ldr	r0, [sp, #12]
 8004ad0:	210d      	movs	r1, #13
 8004ad2:	220d      	movs	r2, #13
 8004ad4:	f7ff fdd4 	bl	8004680 <_mmcsd_get_slice>
 8004ad8:	4603      	mov	r3, r0
 8004ada:	b2da      	uxtb	r2, r3
 8004adc:	9b00      	ldr	r3, [sp, #0]
 8004ade:	f883 2020 	strb.w	r2, [r3, #32]
  csdmmc->r2w_factor         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_R2W_FACTOR_SLICE);
 8004ae2:	9803      	ldr	r0, [sp, #12]
 8004ae4:	211c      	movs	r1, #28
 8004ae6:	221a      	movs	r2, #26
 8004ae8:	f7ff fdca 	bl	8004680 <_mmcsd_get_slice>
 8004aec:	4603      	mov	r3, r0
 8004aee:	b2da      	uxtb	r2, r3
 8004af0:	9b00      	ldr	r3, [sp, #0]
 8004af2:	769a      	strb	r2, [r3, #26]
  csdmmc->read_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BL_LEN_SLICE);
 8004af4:	9803      	ldr	r0, [sp, #12]
 8004af6:	2153      	movs	r1, #83	; 0x53
 8004af8:	2250      	movs	r2, #80	; 0x50
 8004afa:	f7ff fdc1 	bl	8004680 <_mmcsd_get_slice>
 8004afe:	4603      	mov	r3, r0
 8004b00:	b2da      	uxtb	r2, r3
 8004b02:	9b00      	ldr	r3, [sp, #0]
 8004b04:	721a      	strb	r2, [r3, #8]
  csdmmc->read_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BL_PARTIAL_SLICE);
 8004b06:	9803      	ldr	r0, [sp, #12]
 8004b08:	214f      	movs	r1, #79	; 0x4f
 8004b0a:	224f      	movs	r2, #79	; 0x4f
 8004b0c:	f7ff fdb8 	bl	8004680 <_mmcsd_get_slice>
 8004b10:	4603      	mov	r3, r0
 8004b12:	b2da      	uxtb	r2, r3
 8004b14:	9b00      	ldr	r3, [sp, #0]
 8004b16:	725a      	strb	r2, [r3, #9]
  csdmmc->read_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BLK_MISALIGN_SLICE);
 8004b18:	9803      	ldr	r0, [sp, #12]
 8004b1a:	214d      	movs	r1, #77	; 0x4d
 8004b1c:	224d      	movs	r2, #77	; 0x4d
 8004b1e:	f7ff fdaf 	bl	8004680 <_mmcsd_get_slice>
 8004b22:	4603      	mov	r3, r0
 8004b24:	b2da      	uxtb	r2, r3
 8004b26:	9b00      	ldr	r3, [sp, #0]
 8004b28:	72da      	strb	r2, [r3, #11]
  csdmmc->spec_vers          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_SPEC_VERS_SLICE);
 8004b2a:	9803      	ldr	r0, [sp, #12]
 8004b2c:	217d      	movs	r1, #125	; 0x7d
 8004b2e:	227a      	movs	r2, #122	; 0x7a
 8004b30:	f7ff fda6 	bl	8004680 <_mmcsd_get_slice>
 8004b34:	4603      	mov	r3, r0
 8004b36:	b2da      	uxtb	r2, r3
 8004b38:	9b00      	ldr	r3, [sp, #0]
 8004b3a:	705a      	strb	r2, [r3, #1]
  csdmmc->taac               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TAAC_SLICE);
 8004b3c:	9803      	ldr	r0, [sp, #12]
 8004b3e:	2177      	movs	r1, #119	; 0x77
 8004b40:	2270      	movs	r2, #112	; 0x70
 8004b42:	f7ff fd9d 	bl	8004680 <_mmcsd_get_slice>
 8004b46:	4603      	mov	r3, r0
 8004b48:	b2da      	uxtb	r2, r3
 8004b4a:	9b00      	ldr	r3, [sp, #0]
 8004b4c:	709a      	strb	r2, [r3, #2]
  csdmmc->tmp_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TMP_WRITE_PROTECT_SLICE);
 8004b4e:	9803      	ldr	r0, [sp, #12]
 8004b50:	210c      	movs	r1, #12
 8004b52:	220c      	movs	r2, #12
 8004b54:	f7ff fd94 	bl	8004680 <_mmcsd_get_slice>
 8004b58:	4603      	mov	r3, r0
 8004b5a:	b2da      	uxtb	r2, r3
 8004b5c:	9b00      	ldr	r3, [sp, #0]
 8004b5e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  csdmmc->tran_speed         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TRAN_SPEED_SLICE);
 8004b62:	9803      	ldr	r0, [sp, #12]
 8004b64:	2167      	movs	r1, #103	; 0x67
 8004b66:	2260      	movs	r2, #96	; 0x60
 8004b68:	f7ff fd8a 	bl	8004680 <_mmcsd_get_slice>
 8004b6c:	4603      	mov	r3, r0
 8004b6e:	b2da      	uxtb	r2, r3
 8004b70:	9b00      	ldr	r3, [sp, #0]
 8004b72:	711a      	strb	r2, [r3, #4]
  csdmmc->vdd_r_curr_max     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_R_CURR_MAX_SLICE);
 8004b74:	9803      	ldr	r0, [sp, #12]
 8004b76:	213a      	movs	r1, #58	; 0x3a
 8004b78:	2238      	movs	r2, #56	; 0x38
 8004b7a:	f7ff fd81 	bl	8004680 <_mmcsd_get_slice>
 8004b7e:	4603      	mov	r3, r0
 8004b80:	b2da      	uxtb	r2, r3
 8004b82:	9b00      	ldr	r3, [sp, #0]
 8004b84:	745a      	strb	r2, [r3, #17]
  csdmmc->vdd_r_curr_min     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_R_CURR_MIN_SLICE);
 8004b86:	9803      	ldr	r0, [sp, #12]
 8004b88:	213d      	movs	r1, #61	; 0x3d
 8004b8a:	223b      	movs	r2, #59	; 0x3b
 8004b8c:	f7ff fd78 	bl	8004680 <_mmcsd_get_slice>
 8004b90:	4603      	mov	r3, r0
 8004b92:	b2da      	uxtb	r2, r3
 8004b94:	9b00      	ldr	r3, [sp, #0]
 8004b96:	741a      	strb	r2, [r3, #16]
  csdmmc->vdd_w_curr_max     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_W_CURR_MAX_SLICE);
 8004b98:	9803      	ldr	r0, [sp, #12]
 8004b9a:	2134      	movs	r1, #52	; 0x34
 8004b9c:	2232      	movs	r2, #50	; 0x32
 8004b9e:	f7ff fd6f 	bl	8004680 <_mmcsd_get_slice>
 8004ba2:	4603      	mov	r3, r0
 8004ba4:	b2da      	uxtb	r2, r3
 8004ba6:	9b00      	ldr	r3, [sp, #0]
 8004ba8:	74da      	strb	r2, [r3, #19]
  csdmmc->vdd_w_curr_min     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_W_CURR_MIN_SLICE);
 8004baa:	9803      	ldr	r0, [sp, #12]
 8004bac:	2137      	movs	r1, #55	; 0x37
 8004bae:	2235      	movs	r2, #53	; 0x35
 8004bb0:	f7ff fd66 	bl	8004680 <_mmcsd_get_slice>
 8004bb4:	4603      	mov	r3, r0
 8004bb6:	b2da      	uxtb	r2, r3
 8004bb8:	9b00      	ldr	r3, [sp, #0]
 8004bba:	749a      	strb	r2, [r3, #18]
  csdmmc->wp_grp_enable      = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WP_GRP_ENABLE_SLICE);
 8004bbc:	9803      	ldr	r0, [sp, #12]
 8004bbe:	211f      	movs	r1, #31
 8004bc0:	221f      	movs	r2, #31
 8004bc2:	f7ff fd5d 	bl	8004680 <_mmcsd_get_slice>
 8004bc6:	4603      	mov	r3, r0
 8004bc8:	b2da      	uxtb	r2, r3
 8004bca:	9b00      	ldr	r3, [sp, #0]
 8004bcc:	761a      	strb	r2, [r3, #24]
  csdmmc->wp_grp_size        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WP_GRP_SIZE_SLICE);
 8004bce:	9803      	ldr	r0, [sp, #12]
 8004bd0:	2124      	movs	r1, #36	; 0x24
 8004bd2:	2220      	movs	r2, #32
 8004bd4:	f7ff fd54 	bl	8004680 <_mmcsd_get_slice>
 8004bd8:	4603      	mov	r3, r0
 8004bda:	b2da      	uxtb	r2, r3
 8004bdc:	9b00      	ldr	r3, [sp, #0]
 8004bde:	75da      	strb	r2, [r3, #23]
  csdmmc->write_bl_len       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BL_LEN_SLICE);
 8004be0:	9803      	ldr	r0, [sp, #12]
 8004be2:	2119      	movs	r1, #25
 8004be4:	2216      	movs	r2, #22
 8004be6:	f7ff fd4b 	bl	8004680 <_mmcsd_get_slice>
 8004bea:	4603      	mov	r3, r0
 8004bec:	b2da      	uxtb	r2, r3
 8004bee:	9b00      	ldr	r3, [sp, #0]
 8004bf0:	76da      	strb	r2, [r3, #27]
  csdmmc->write_bl_partial   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BL_PARTIAL_SLICE);
 8004bf2:	9803      	ldr	r0, [sp, #12]
 8004bf4:	2115      	movs	r1, #21
 8004bf6:	2215      	movs	r2, #21
 8004bf8:	f7ff fd42 	bl	8004680 <_mmcsd_get_slice>
 8004bfc:	4603      	mov	r3, r0
 8004bfe:	b2da      	uxtb	r2, r3
 8004c00:	9b00      	ldr	r3, [sp, #0]
 8004c02:	771a      	strb	r2, [r3, #28]
  csdmmc->write_blk_misalign = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BLK_MISALIGN_SLICE);
 8004c04:	9803      	ldr	r0, [sp, #12]
 8004c06:	214e      	movs	r1, #78	; 0x4e
 8004c08:	224e      	movs	r2, #78	; 0x4e
 8004c0a:	f7ff fd39 	bl	8004680 <_mmcsd_get_slice>
 8004c0e:	4603      	mov	r3, r0
 8004c10:	b2da      	uxtb	r2, r3
 8004c12:	9b00      	ldr	r3, [sp, #0]
 8004c14:	729a      	strb	r2, [r3, #10]
}
 8004c16:	b005      	add	sp, #20
 8004c18:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c1c:	f3af 8000 	nop.w

08004c20 <_mmcsd_unpack_csd_v10>:
 * @param[out] csd10    pointer to the @p unpacked_sdc_csd_10_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_v10(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_csd_10_t *csd10) {
 8004c20:	b500      	push	{lr}
 8004c22:	b085      	sub	sp, #20
 8004c24:	9001      	str	r0, [sp, #4]
 8004c26:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck(NULL != sdcp);

  csd = sdcp->csd;
 8004c28:	9b01      	ldr	r3, [sp, #4]
 8004c2a:	3318      	adds	r3, #24
 8004c2c:	9303      	str	r3, [sp, #12]
  csd10->c_size              = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8004c2e:	9803      	ldr	r0, [sp, #12]
 8004c30:	2149      	movs	r1, #73	; 0x49
 8004c32:	223e      	movs	r2, #62	; 0x3e
 8004c34:	f7ff fd24 	bl	8004680 <_mmcsd_get_slice>
 8004c38:	4603      	mov	r3, r0
 8004c3a:	b29a      	uxth	r2, r3
 8004c3c:	9b00      	ldr	r3, [sp, #0]
 8004c3e:	819a      	strh	r2, [r3, #12]
  csd10->c_size_mult         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 8004c40:	9803      	ldr	r0, [sp, #12]
 8004c42:	2131      	movs	r1, #49	; 0x31
 8004c44:	222f      	movs	r2, #47	; 0x2f
 8004c46:	f7ff fd1b 	bl	8004680 <_mmcsd_get_slice>
 8004c4a:	4603      	mov	r3, r0
 8004c4c:	b2da      	uxtb	r2, r3
 8004c4e:	9b00      	ldr	r3, [sp, #0]
 8004c50:	749a      	strb	r2, [r3, #18]
  csd10->ccc                 = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_10_CCC_SLICE);
 8004c52:	9803      	ldr	r0, [sp, #12]
 8004c54:	215f      	movs	r1, #95	; 0x5f
 8004c56:	2254      	movs	r2, #84	; 0x54
 8004c58:	f7ff fd12 	bl	8004680 <_mmcsd_get_slice>
 8004c5c:	4603      	mov	r3, r0
 8004c5e:	b29a      	uxth	r2, r3
 8004c60:	9b00      	ldr	r3, [sp, #0]
 8004c62:	809a      	strh	r2, [r3, #4]
  csd10->copy                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_COPY_SLICE);
 8004c64:	9803      	ldr	r0, [sp, #12]
 8004c66:	210e      	movs	r1, #14
 8004c68:	220e      	movs	r2, #14
 8004c6a:	f7ff fd09 	bl	8004680 <_mmcsd_get_slice>
 8004c6e:	4603      	mov	r3, r0
 8004c70:	b2da      	uxtb	r2, r3
 8004c72:	9b00      	ldr	r3, [sp, #0]
 8004c74:	76da      	strb	r2, [r3, #27]
  csd10->crc                 = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_CRC_SLICE);
 8004c76:	9803      	ldr	r0, [sp, #12]
 8004c78:	2107      	movs	r1, #7
 8004c7a:	2201      	movs	r2, #1
 8004c7c:	f7ff fd00 	bl	8004680 <_mmcsd_get_slice>
 8004c80:	4603      	mov	r3, r0
 8004c82:	b2da      	uxtb	r2, r3
 8004c84:	9b00      	ldr	r3, [sp, #0]
 8004c86:	77da      	strb	r2, [r3, #31]
  csd10->csd_structure       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE);
 8004c88:	9803      	ldr	r0, [sp, #12]
 8004c8a:	217f      	movs	r1, #127	; 0x7f
 8004c8c:	227e      	movs	r2, #126	; 0x7e
 8004c8e:	f7ff fcf7 	bl	8004680 <_mmcsd_get_slice>
 8004c92:	4603      	mov	r3, r0
 8004c94:	b2da      	uxtb	r2, r3
 8004c96:	9b00      	ldr	r3, [sp, #0]
 8004c98:	701a      	strb	r2, [r3, #0]
  csd10->dsr_imp             = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_DSR_IMP_SLICE);
 8004c9a:	9803      	ldr	r0, [sp, #12]
 8004c9c:	214c      	movs	r1, #76	; 0x4c
 8004c9e:	224c      	movs	r2, #76	; 0x4c
 8004ca0:	f7ff fcee 	bl	8004680 <_mmcsd_get_slice>
 8004ca4:	4603      	mov	r3, r0
 8004ca6:	b2da      	uxtb	r2, r3
 8004ca8:	9b00      	ldr	r3, [sp, #0]
 8004caa:	729a      	strb	r2, [r3, #10]
  csd10->erase_blk_en        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_ERASE_BLK_EN_SLICE);
 8004cac:	9803      	ldr	r0, [sp, #12]
 8004cae:	212e      	movs	r1, #46	; 0x2e
 8004cb0:	222e      	movs	r2, #46	; 0x2e
 8004cb2:	f7ff fce5 	bl	8004680 <_mmcsd_get_slice>
 8004cb6:	4603      	mov	r3, r0
 8004cb8:	b2da      	uxtb	r2, r3
 8004cba:	9b00      	ldr	r3, [sp, #0]
 8004cbc:	74da      	strb	r2, [r3, #19]
  csd10->erase_sector_size   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_ERASE_SECTOR_SIZE_SLICE);
 8004cbe:	9803      	ldr	r0, [sp, #12]
 8004cc0:	212d      	movs	r1, #45	; 0x2d
 8004cc2:	2227      	movs	r2, #39	; 0x27
 8004cc4:	f7ff fcdc 	bl	8004680 <_mmcsd_get_slice>
 8004cc8:	4603      	mov	r3, r0
 8004cca:	b2da      	uxtb	r2, r3
 8004ccc:	9b00      	ldr	r3, [sp, #0]
 8004cce:	751a      	strb	r2, [r3, #20]
  csd10->file_format         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_FILE_FORMAT_SLICE);
 8004cd0:	9803      	ldr	r0, [sp, #12]
 8004cd2:	210b      	movs	r1, #11
 8004cd4:	220a      	movs	r2, #10
 8004cd6:	f7ff fcd3 	bl	8004680 <_mmcsd_get_slice>
 8004cda:	4603      	mov	r3, r0
 8004cdc:	b2da      	uxtb	r2, r3
 8004cde:	9b00      	ldr	r3, [sp, #0]
 8004ce0:	779a      	strb	r2, [r3, #30]
  csd10->file_format_grp     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_FILE_FORMAT_GRP_SLICE);
 8004ce2:	9803      	ldr	r0, [sp, #12]
 8004ce4:	210f      	movs	r1, #15
 8004ce6:	220f      	movs	r2, #15
 8004ce8:	f7ff fcca 	bl	8004680 <_mmcsd_get_slice>
 8004cec:	4603      	mov	r3, r0
 8004cee:	b2da      	uxtb	r2, r3
 8004cf0:	9b00      	ldr	r3, [sp, #0]
 8004cf2:	769a      	strb	r2, [r3, #26]
  csd10->nsac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_NSAC_SLICE);
 8004cf4:	9803      	ldr	r0, [sp, #12]
 8004cf6:	216f      	movs	r1, #111	; 0x6f
 8004cf8:	2268      	movs	r2, #104	; 0x68
 8004cfa:	f7ff fcc1 	bl	8004680 <_mmcsd_get_slice>
 8004cfe:	4603      	mov	r3, r0
 8004d00:	b2da      	uxtb	r2, r3
 8004d02:	9b00      	ldr	r3, [sp, #0]
 8004d04:	709a      	strb	r2, [r3, #2]
  csd10->perm_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_PERM_WRITE_PROTECT_SLICE);
 8004d06:	9803      	ldr	r0, [sp, #12]
 8004d08:	210d      	movs	r1, #13
 8004d0a:	220d      	movs	r2, #13
 8004d0c:	f7ff fcb8 	bl	8004680 <_mmcsd_get_slice>
 8004d10:	4603      	mov	r3, r0
 8004d12:	b2da      	uxtb	r2, r3
 8004d14:	9b00      	ldr	r3, [sp, #0]
 8004d16:	771a      	strb	r2, [r3, #28]
  csd10->r2w_factor          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_R2W_FACTOR_SLICE);
 8004d18:	9803      	ldr	r0, [sp, #12]
 8004d1a:	211c      	movs	r1, #28
 8004d1c:	221a      	movs	r2, #26
 8004d1e:	f7ff fcaf 	bl	8004680 <_mmcsd_get_slice>
 8004d22:	4603      	mov	r3, r0
 8004d24:	b2da      	uxtb	r2, r3
 8004d26:	9b00      	ldr	r3, [sp, #0]
 8004d28:	75da      	strb	r2, [r3, #23]
  csd10->read_bl_len         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8004d2a:	9803      	ldr	r0, [sp, #12]
 8004d2c:	2153      	movs	r1, #83	; 0x53
 8004d2e:	2250      	movs	r2, #80	; 0x50
 8004d30:	f7ff fca6 	bl	8004680 <_mmcsd_get_slice>
 8004d34:	4603      	mov	r3, r0
 8004d36:	b2da      	uxtb	r2, r3
 8004d38:	9b00      	ldr	r3, [sp, #0]
 8004d3a:	719a      	strb	r2, [r3, #6]
  csd10->read_bl_partial     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_PARTIAL_SLICE);
 8004d3c:	9803      	ldr	r0, [sp, #12]
 8004d3e:	214f      	movs	r1, #79	; 0x4f
 8004d40:	224f      	movs	r2, #79	; 0x4f
 8004d42:	f7ff fc9d 	bl	8004680 <_mmcsd_get_slice>
 8004d46:	4603      	mov	r3, r0
 8004d48:	b2da      	uxtb	r2, r3
 8004d4a:	9b00      	ldr	r3, [sp, #0]
 8004d4c:	71da      	strb	r2, [r3, #7]
  csd10->read_blk_misalign   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BLK_MISALIGN_SLICE);
 8004d4e:	9803      	ldr	r0, [sp, #12]
 8004d50:	214d      	movs	r1, #77	; 0x4d
 8004d52:	224d      	movs	r2, #77	; 0x4d
 8004d54:	f7ff fc94 	bl	8004680 <_mmcsd_get_slice>
 8004d58:	4603      	mov	r3, r0
 8004d5a:	b2da      	uxtb	r2, r3
 8004d5c:	9b00      	ldr	r3, [sp, #0]
 8004d5e:	725a      	strb	r2, [r3, #9]
  csd10->taac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TAAC_SLICE);
 8004d60:	9803      	ldr	r0, [sp, #12]
 8004d62:	2177      	movs	r1, #119	; 0x77
 8004d64:	2270      	movs	r2, #112	; 0x70
 8004d66:	f7ff fc8b 	bl	8004680 <_mmcsd_get_slice>
 8004d6a:	4603      	mov	r3, r0
 8004d6c:	b2da      	uxtb	r2, r3
 8004d6e:	9b00      	ldr	r3, [sp, #0]
 8004d70:	705a      	strb	r2, [r3, #1]
  csd10->tmp_write_protect   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TMP_WRITE_PROTECT_SLICE);
 8004d72:	9803      	ldr	r0, [sp, #12]
 8004d74:	210c      	movs	r1, #12
 8004d76:	220c      	movs	r2, #12
 8004d78:	f7ff fc82 	bl	8004680 <_mmcsd_get_slice>
 8004d7c:	4603      	mov	r3, r0
 8004d7e:	b2da      	uxtb	r2, r3
 8004d80:	9b00      	ldr	r3, [sp, #0]
 8004d82:	775a      	strb	r2, [r3, #29]
  csd10->tran_speed          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TRANS_SPEED_SLICE);
 8004d84:	9803      	ldr	r0, [sp, #12]
 8004d86:	2167      	movs	r1, #103	; 0x67
 8004d88:	2260      	movs	r2, #96	; 0x60
 8004d8a:	f7ff fc79 	bl	8004680 <_mmcsd_get_slice>
 8004d8e:	4603      	mov	r3, r0
 8004d90:	b2da      	uxtb	r2, r3
 8004d92:	9b00      	ldr	r3, [sp, #0]
 8004d94:	70da      	strb	r2, [r3, #3]
  csd10->wp_grp_enable       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WP_GRP_ENABLE_SLICE);
 8004d96:	9803      	ldr	r0, [sp, #12]
 8004d98:	211f      	movs	r1, #31
 8004d9a:	221f      	movs	r2, #31
 8004d9c:	f7ff fc70 	bl	8004680 <_mmcsd_get_slice>
 8004da0:	4603      	mov	r3, r0
 8004da2:	b2da      	uxtb	r2, r3
 8004da4:	9b00      	ldr	r3, [sp, #0]
 8004da6:	759a      	strb	r2, [r3, #22]
  csd10->wp_grp_size         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WP_GRP_SIZE_SLICE);
 8004da8:	9803      	ldr	r0, [sp, #12]
 8004daa:	2126      	movs	r1, #38	; 0x26
 8004dac:	2220      	movs	r2, #32
 8004dae:	f7ff fc67 	bl	8004680 <_mmcsd_get_slice>
 8004db2:	4603      	mov	r3, r0
 8004db4:	b2da      	uxtb	r2, r3
 8004db6:	9b00      	ldr	r3, [sp, #0]
 8004db8:	755a      	strb	r2, [r3, #21]
  csd10->write_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BL_LEN_SLICE);
 8004dba:	9803      	ldr	r0, [sp, #12]
 8004dbc:	2119      	movs	r1, #25
 8004dbe:	220c      	movs	r2, #12
 8004dc0:	f7ff fc5e 	bl	8004680 <_mmcsd_get_slice>
 8004dc4:	4603      	mov	r3, r0
 8004dc6:	b2da      	uxtb	r2, r3
 8004dc8:	9b00      	ldr	r3, [sp, #0]
 8004dca:	761a      	strb	r2, [r3, #24]
  csd10->write_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BL_PARTIAL_SLICE);
 8004dcc:	9803      	ldr	r0, [sp, #12]
 8004dce:	2115      	movs	r1, #21
 8004dd0:	2215      	movs	r2, #21
 8004dd2:	f7ff fc55 	bl	8004680 <_mmcsd_get_slice>
 8004dd6:	4603      	mov	r3, r0
 8004dd8:	b2da      	uxtb	r2, r3
 8004dda:	9b00      	ldr	r3, [sp, #0]
 8004ddc:	765a      	strb	r2, [r3, #25]
  csd10->write_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BLK_MISALIGN_SLICE);
 8004dde:	9803      	ldr	r0, [sp, #12]
 8004de0:	214e      	movs	r1, #78	; 0x4e
 8004de2:	224e      	movs	r2, #78	; 0x4e
 8004de4:	f7ff fc4c 	bl	8004680 <_mmcsd_get_slice>
 8004de8:	4603      	mov	r3, r0
 8004dea:	b2da      	uxtb	r2, r3
 8004dec:	9b00      	ldr	r3, [sp, #0]
 8004dee:	721a      	strb	r2, [r3, #8]
}
 8004df0:	b005      	add	sp, #20
 8004df2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004df6:	bf00      	nop
 8004df8:	f3af 8000 	nop.w
 8004dfc:	f3af 8000 	nop.w

08004e00 <_mmcsd_unpack_csd_v20>:
 * @param[out] csd20    pointer to the @p unpacked_sdc_csd_20_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_v20(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_csd_20_t *csd20) {
 8004e00:	b500      	push	{lr}
 8004e02:	b085      	sub	sp, #20
 8004e04:	9001      	str	r0, [sp, #4]
 8004e06:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck(NULL != sdcp);

  csd = sdcp->csd;
 8004e08:	9b01      	ldr	r3, [sp, #4]
 8004e0a:	3318      	adds	r3, #24
 8004e0c:	9303      	str	r3, [sp, #12]
  csd20->c_size              =           _mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE);
 8004e0e:	9803      	ldr	r0, [sp, #12]
 8004e10:	2145      	movs	r1, #69	; 0x45
 8004e12:	2230      	movs	r2, #48	; 0x30
 8004e14:	f7ff fc34 	bl	8004680 <_mmcsd_get_slice>
 8004e18:	4602      	mov	r2, r0
 8004e1a:	9b00      	ldr	r3, [sp, #0]
 8004e1c:	60da      	str	r2, [r3, #12]
  csd20->crc                 = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_CRC_SLICE);
 8004e1e:	9803      	ldr	r0, [sp, #12]
 8004e20:	2107      	movs	r1, #7
 8004e22:	2201      	movs	r2, #1
 8004e24:	f7ff fc2c 	bl	8004680 <_mmcsd_get_slice>
 8004e28:	4603      	mov	r3, r0
 8004e2a:	b2da      	uxtb	r2, r3
 8004e2c:	9b00      	ldr	r3, [sp, #0]
 8004e2e:	771a      	strb	r2, [r3, #28]
  csd20->ccc                 = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_20_CCC_SLICE);
 8004e30:	9803      	ldr	r0, [sp, #12]
 8004e32:	215f      	movs	r1, #95	; 0x5f
 8004e34:	2254      	movs	r2, #84	; 0x54
 8004e36:	f7ff fc23 	bl	8004680 <_mmcsd_get_slice>
 8004e3a:	4603      	mov	r3, r0
 8004e3c:	b29a      	uxth	r2, r3
 8004e3e:	9b00      	ldr	r3, [sp, #0]
 8004e40:	809a      	strh	r2, [r3, #4]
  csd20->copy                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_COPY_SLICE);
 8004e42:	9803      	ldr	r0, [sp, #12]
 8004e44:	210e      	movs	r1, #14
 8004e46:	220e      	movs	r2, #14
 8004e48:	f7ff fc1a 	bl	8004680 <_mmcsd_get_slice>
 8004e4c:	4603      	mov	r3, r0
 8004e4e:	b2da      	uxtb	r2, r3
 8004e50:	9b00      	ldr	r3, [sp, #0]
 8004e52:	761a      	strb	r2, [r3, #24]
  csd20->csd_structure       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_CSD_STRUCTURE_SLICE);
 8004e54:	9803      	ldr	r0, [sp, #12]
 8004e56:	217f      	movs	r1, #127	; 0x7f
 8004e58:	227e      	movs	r2, #126	; 0x7e
 8004e5a:	f7ff fc11 	bl	8004680 <_mmcsd_get_slice>
 8004e5e:	4603      	mov	r3, r0
 8004e60:	b2da      	uxtb	r2, r3
 8004e62:	9b00      	ldr	r3, [sp, #0]
 8004e64:	701a      	strb	r2, [r3, #0]
  csd20->dsr_imp             = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_DSR_IMP_SLICE);
 8004e66:	9803      	ldr	r0, [sp, #12]
 8004e68:	214c      	movs	r1, #76	; 0x4c
 8004e6a:	224c      	movs	r2, #76	; 0x4c
 8004e6c:	f7ff fc08 	bl	8004680 <_mmcsd_get_slice>
 8004e70:	4603      	mov	r3, r0
 8004e72:	b2da      	uxtb	r2, r3
 8004e74:	9b00      	ldr	r3, [sp, #0]
 8004e76:	729a      	strb	r2, [r3, #10]
  csd20->erase_blk_en        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_ERASE_BLK_EN_SLICE);
 8004e78:	9803      	ldr	r0, [sp, #12]
 8004e7a:	212e      	movs	r1, #46	; 0x2e
 8004e7c:	222e      	movs	r2, #46	; 0x2e
 8004e7e:	f7ff fbff 	bl	8004680 <_mmcsd_get_slice>
 8004e82:	4603      	mov	r3, r0
 8004e84:	b2da      	uxtb	r2, r3
 8004e86:	9b00      	ldr	r3, [sp, #0]
 8004e88:	741a      	strb	r2, [r3, #16]
  csd20->file_format         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_FILE_FORMAT_SLICE);
 8004e8a:	9803      	ldr	r0, [sp, #12]
 8004e8c:	210b      	movs	r1, #11
 8004e8e:	220a      	movs	r2, #10
 8004e90:	f7ff fbf6 	bl	8004680 <_mmcsd_get_slice>
 8004e94:	4603      	mov	r3, r0
 8004e96:	b2da      	uxtb	r2, r3
 8004e98:	9b00      	ldr	r3, [sp, #0]
 8004e9a:	76da      	strb	r2, [r3, #27]
  csd20->file_format_grp     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_FILE_FORMAT_GRP_SLICE);
 8004e9c:	9803      	ldr	r0, [sp, #12]
 8004e9e:	210f      	movs	r1, #15
 8004ea0:	220f      	movs	r2, #15
 8004ea2:	f7ff fbed 	bl	8004680 <_mmcsd_get_slice>
 8004ea6:	4603      	mov	r3, r0
 8004ea8:	b2da      	uxtb	r2, r3
 8004eaa:	9b00      	ldr	r3, [sp, #0]
 8004eac:	75da      	strb	r2, [r3, #23]
  csd20->nsac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_NSAC_SLICE);
 8004eae:	9803      	ldr	r0, [sp, #12]
 8004eb0:	216f      	movs	r1, #111	; 0x6f
 8004eb2:	2268      	movs	r2, #104	; 0x68
 8004eb4:	f7ff fbe4 	bl	8004680 <_mmcsd_get_slice>
 8004eb8:	4603      	mov	r3, r0
 8004eba:	b2da      	uxtb	r2, r3
 8004ebc:	9b00      	ldr	r3, [sp, #0]
 8004ebe:	709a      	strb	r2, [r3, #2]
  csd20->perm_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_PERM_WRITE_PROTECT_SLICE);
 8004ec0:	9803      	ldr	r0, [sp, #12]
 8004ec2:	210d      	movs	r1, #13
 8004ec4:	220d      	movs	r2, #13
 8004ec6:	f7ff fbdb 	bl	8004680 <_mmcsd_get_slice>
 8004eca:	4603      	mov	r3, r0
 8004ecc:	b2da      	uxtb	r2, r3
 8004ece:	9b00      	ldr	r3, [sp, #0]
 8004ed0:	765a      	strb	r2, [r3, #25]
  csd20->r2w_factor          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_R2W_FACTOR_SLICE);
 8004ed2:	9803      	ldr	r0, [sp, #12]
 8004ed4:	211c      	movs	r1, #28
 8004ed6:	221a      	movs	r2, #26
 8004ed8:	f7ff fbd2 	bl	8004680 <_mmcsd_get_slice>
 8004edc:	4603      	mov	r3, r0
 8004ede:	b2da      	uxtb	r2, r3
 8004ee0:	9b00      	ldr	r3, [sp, #0]
 8004ee2:	751a      	strb	r2, [r3, #20]
  csd20->read_bl_len         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BL_LEN_SLICE);
 8004ee4:	9803      	ldr	r0, [sp, #12]
 8004ee6:	2153      	movs	r1, #83	; 0x53
 8004ee8:	2250      	movs	r2, #80	; 0x50
 8004eea:	f7ff fbc9 	bl	8004680 <_mmcsd_get_slice>
 8004eee:	4603      	mov	r3, r0
 8004ef0:	b2da      	uxtb	r2, r3
 8004ef2:	9b00      	ldr	r3, [sp, #0]
 8004ef4:	719a      	strb	r2, [r3, #6]
  csd20->read_bl_partial     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BL_PARTIAL_SLICE);
 8004ef6:	9803      	ldr	r0, [sp, #12]
 8004ef8:	214f      	movs	r1, #79	; 0x4f
 8004efa:	224f      	movs	r2, #79	; 0x4f
 8004efc:	f7ff fbc0 	bl	8004680 <_mmcsd_get_slice>
 8004f00:	4603      	mov	r3, r0
 8004f02:	b2da      	uxtb	r2, r3
 8004f04:	9b00      	ldr	r3, [sp, #0]
 8004f06:	71da      	strb	r2, [r3, #7]
  csd20->read_blk_misalign   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BLK_MISALIGN_SLICE);
 8004f08:	9803      	ldr	r0, [sp, #12]
 8004f0a:	214d      	movs	r1, #77	; 0x4d
 8004f0c:	224d      	movs	r2, #77	; 0x4d
 8004f0e:	f7ff fbb7 	bl	8004680 <_mmcsd_get_slice>
 8004f12:	4603      	mov	r3, r0
 8004f14:	b2da      	uxtb	r2, r3
 8004f16:	9b00      	ldr	r3, [sp, #0]
 8004f18:	725a      	strb	r2, [r3, #9]
  csd20->erase_sector_size   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_ERASE_SECTOR_SIZE_SLICE);
 8004f1a:	9803      	ldr	r0, [sp, #12]
 8004f1c:	212d      	movs	r1, #45	; 0x2d
 8004f1e:	2227      	movs	r2, #39	; 0x27
 8004f20:	f7ff fbae 	bl	8004680 <_mmcsd_get_slice>
 8004f24:	4603      	mov	r3, r0
 8004f26:	b2da      	uxtb	r2, r3
 8004f28:	9b00      	ldr	r3, [sp, #0]
 8004f2a:	745a      	strb	r2, [r3, #17]
  csd20->taac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TAAC_SLICE);
 8004f2c:	9803      	ldr	r0, [sp, #12]
 8004f2e:	2177      	movs	r1, #119	; 0x77
 8004f30:	2270      	movs	r2, #112	; 0x70
 8004f32:	f7ff fba5 	bl	8004680 <_mmcsd_get_slice>
 8004f36:	4603      	mov	r3, r0
 8004f38:	b2da      	uxtb	r2, r3
 8004f3a:	9b00      	ldr	r3, [sp, #0]
 8004f3c:	705a      	strb	r2, [r3, #1]
  csd20->tmp_write_protect   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TMP_WRITE_PROTECT_SLICE);
 8004f3e:	9803      	ldr	r0, [sp, #12]
 8004f40:	210c      	movs	r1, #12
 8004f42:	220c      	movs	r2, #12
 8004f44:	f7ff fb9c 	bl	8004680 <_mmcsd_get_slice>
 8004f48:	4603      	mov	r3, r0
 8004f4a:	b2da      	uxtb	r2, r3
 8004f4c:	9b00      	ldr	r3, [sp, #0]
 8004f4e:	769a      	strb	r2, [r3, #26]
  csd20->tran_speed          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TRANS_SPEED_SLICE);
 8004f50:	9803      	ldr	r0, [sp, #12]
 8004f52:	2167      	movs	r1, #103	; 0x67
 8004f54:	2260      	movs	r2, #96	; 0x60
 8004f56:	f7ff fb93 	bl	8004680 <_mmcsd_get_slice>
 8004f5a:	4603      	mov	r3, r0
 8004f5c:	b2da      	uxtb	r2, r3
 8004f5e:	9b00      	ldr	r3, [sp, #0]
 8004f60:	70da      	strb	r2, [r3, #3]
  csd20->wp_grp_enable       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WP_GRP_ENABLE_SLICE);
 8004f62:	9803      	ldr	r0, [sp, #12]
 8004f64:	211f      	movs	r1, #31
 8004f66:	221f      	movs	r2, #31
 8004f68:	f7ff fb8a 	bl	8004680 <_mmcsd_get_slice>
 8004f6c:	4603      	mov	r3, r0
 8004f6e:	b2da      	uxtb	r2, r3
 8004f70:	9b00      	ldr	r3, [sp, #0]
 8004f72:	74da      	strb	r2, [r3, #19]
  csd20->wp_grp_size         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WP_GRP_SIZE_SLICE);
 8004f74:	9803      	ldr	r0, [sp, #12]
 8004f76:	2126      	movs	r1, #38	; 0x26
 8004f78:	2220      	movs	r2, #32
 8004f7a:	f7ff fb81 	bl	8004680 <_mmcsd_get_slice>
 8004f7e:	4603      	mov	r3, r0
 8004f80:	b2da      	uxtb	r2, r3
 8004f82:	9b00      	ldr	r3, [sp, #0]
 8004f84:	749a      	strb	r2, [r3, #18]
  csd20->write_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BL_LEN_SLICE);
 8004f86:	9803      	ldr	r0, [sp, #12]
 8004f88:	2119      	movs	r1, #25
 8004f8a:	220c      	movs	r2, #12
 8004f8c:	f7ff fb78 	bl	8004680 <_mmcsd_get_slice>
 8004f90:	4603      	mov	r3, r0
 8004f92:	b2da      	uxtb	r2, r3
 8004f94:	9b00      	ldr	r3, [sp, #0]
 8004f96:	755a      	strb	r2, [r3, #21]
  csd20->write_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BL_PARTIAL_SLICE);
 8004f98:	9803      	ldr	r0, [sp, #12]
 8004f9a:	2115      	movs	r1, #21
 8004f9c:	2215      	movs	r2, #21
 8004f9e:	f7ff fb6f 	bl	8004680 <_mmcsd_get_slice>
 8004fa2:	4603      	mov	r3, r0
 8004fa4:	b2da      	uxtb	r2, r3
 8004fa6:	9b00      	ldr	r3, [sp, #0]
 8004fa8:	759a      	strb	r2, [r3, #22]
  csd20->write_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BLK_MISALIGN_SLICE);
 8004faa:	9803      	ldr	r0, [sp, #12]
 8004fac:	214e      	movs	r1, #78	; 0x4e
 8004fae:	224e      	movs	r2, #78	; 0x4e
 8004fb0:	f7ff fb66 	bl	8004680 <_mmcsd_get_slice>
 8004fb4:	4603      	mov	r3, r0
 8004fb6:	b2da      	uxtb	r2, r3
 8004fb8:	9b00      	ldr	r3, [sp, #0]
 8004fba:	721a      	strb	r2, [r3, #8]
}
 8004fbc:	b005      	add	sp, #20
 8004fbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fc2:	bf00      	nop
 8004fc4:	f3af 8000 	nop.w
 8004fc8:	f3af 8000 	nop.w
 8004fcc:	f3af 8000 	nop.w

08004fd0 <palReadBus>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @return              The bus logical states.
 *
 * @special
 */
ioportmask_t palReadBus(IOBus *bus) {
 8004fd0:	b082      	sub	sp, #8
 8004fd2:	9001      	str	r0, [sp, #4]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  return palReadGroup(bus->portid, bus->mask, bus->offset);
 8004fd4:	9b01      	ldr	r3, [sp, #4]
 8004fd6:	681b      	ldr	r3, [r3, #0]
 8004fd8:	691a      	ldr	r2, [r3, #16]
 8004fda:	9b01      	ldr	r3, [sp, #4]
 8004fdc:	689b      	ldr	r3, [r3, #8]
 8004fde:	40da      	lsrs	r2, r3
 8004fe0:	9b01      	ldr	r3, [sp, #4]
 8004fe2:	685b      	ldr	r3, [r3, #4]
 8004fe4:	4013      	ands	r3, r2
}
 8004fe6:	4618      	mov	r0, r3
 8004fe8:	b002      	add	sp, #8
 8004fea:	4770      	bx	lr
 8004fec:	f3af 8000 	nop.w

08004ff0 <palWriteBus>:
 *                      the bus width are masked so most significant bits are
 *                      lost.
 *
 * @special
 */
void palWriteBus(IOBus *bus, ioportmask_t bits) {
 8004ff0:	b082      	sub	sp, #8
 8004ff2:	9001      	str	r0, [sp, #4]
 8004ff4:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palWriteGroup(bus->portid, bus->mask, bus->offset, bits);
 8004ff6:	9b01      	ldr	r3, [sp, #4]
 8004ff8:	681b      	ldr	r3, [r3, #0]
 8004ffa:	9a00      	ldr	r2, [sp, #0]
 8004ffc:	43d1      	mvns	r1, r2
 8004ffe:	9a01      	ldr	r2, [sp, #4]
 8005000:	6852      	ldr	r2, [r2, #4]
 8005002:	4011      	ands	r1, r2
 8005004:	9a01      	ldr	r2, [sp, #4]
 8005006:	6892      	ldr	r2, [r2, #8]
 8005008:	3210      	adds	r2, #16
 800500a:	4091      	lsls	r1, r2
 800500c:	9a01      	ldr	r2, [sp, #4]
 800500e:	6850      	ldr	r0, [r2, #4]
 8005010:	9a00      	ldr	r2, [sp, #0]
 8005012:	4010      	ands	r0, r2
 8005014:	9a01      	ldr	r2, [sp, #4]
 8005016:	6892      	ldr	r2, [r2, #8]
 8005018:	fa00 f202 	lsl.w	r2, r0, r2
 800501c:	430a      	orrs	r2, r1
 800501e:	619a      	str	r2, [r3, #24]
}
 8005020:	b002      	add	sp, #8
 8005022:	4770      	bx	lr
 8005024:	f3af 8000 	nop.w
 8005028:	f3af 8000 	nop.w
 800502c:	f3af 8000 	nop.w

08005030 <palSetBusMode>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @param[in] mode      the mode
 *
 * @special
 */
void palSetBusMode(IOBus *bus, iomode_t mode) {
 8005030:	b500      	push	{lr}
 8005032:	b083      	sub	sp, #12
 8005034:	9001      	str	r0, [sp, #4]
 8005036:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palSetGroupMode(bus->portid, bus->mask, bus->offset, mode);
 8005038:	9b01      	ldr	r3, [sp, #4]
 800503a:	681a      	ldr	r2, [r3, #0]
 800503c:	9b01      	ldr	r3, [sp, #4]
 800503e:	6859      	ldr	r1, [r3, #4]
 8005040:	9b01      	ldr	r3, [sp, #4]
 8005042:	689b      	ldr	r3, [r3, #8]
 8005044:	fa01 f303 	lsl.w	r3, r1, r3
 8005048:	4610      	mov	r0, r2
 800504a:	4619      	mov	r1, r3
 800504c:	9a00      	ldr	r2, [sp, #0]
 800504e:	f003 f83f 	bl	80080d0 <_pal_lld_setgroupmode>
}
 8005052:	b003      	add	sp, #12
 8005054:	f85d fb04 	ldr.w	pc, [sp], #4
 8005058:	f3af 8000 	nop.w
 800505c:	f3af 8000 	nop.w

08005060 <rtcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void rtcInit(void) {
 8005060:	b508      	push	{r3, lr}

  rtc_lld_init();
 8005062:	f004 fe9d 	bl	8009da0 <rtc_lld_init>
}
 8005066:	bd08      	pop	{r3, pc}
 8005068:	f3af 8000 	nop.w
 800506c:	f3af 8000 	nop.w

08005070 <rtcObjectInit>:
 *
 * @param[out] rtcp     pointer to RTC driver structure
 *
 * @init
 */
void rtcObjectInit(RTCDriver *rtcp) {
 8005070:	b082      	sub	sp, #8
 8005072:	9001      	str	r0, [sp, #4]
#if RTC_HAS_STORAGE == TRUE
  rtcp->vmt = &_rtc_lld_vmt;
#else
  (void)rtcp;
#endif
}
 8005074:	b002      	add	sp, #8
 8005076:	4770      	bx	lr
 8005078:	f3af 8000 	nop.w
 800507c:	f3af 8000 	nop.w

08005080 <rtcSetTime>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 *
 * @special
 */
void rtcSetTime(RTCDriver *rtcp, const RTCDateTime *timespec) {
 8005080:	b500      	push	{lr}
 8005082:	b083      	sub	sp, #12
 8005084:	9001      	str	r0, [sp, #4]
 8005086:	9100      	str	r1, [sp, #0]

  osalDbgCheck((rtcp != NULL) && (timespec != NULL));

  rtc_lld_set_time(rtcp, timespec);
 8005088:	9801      	ldr	r0, [sp, #4]
 800508a:	9900      	ldr	r1, [sp, #0]
 800508c:	f004 fec8 	bl	8009e20 <rtc_lld_set_time>
}
 8005090:	b003      	add	sp, #12
 8005092:	f85d fb04 	ldr.w	pc, [sp], #4
 8005096:	bf00      	nop
 8005098:	f3af 8000 	nop.w
 800509c:	f3af 8000 	nop.w

080050a0 <rtcGetTime>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @special
 */
void rtcGetTime(RTCDriver *rtcp, RTCDateTime *timespec) {
 80050a0:	b500      	push	{lr}
 80050a2:	b083      	sub	sp, #12
 80050a4:	9001      	str	r0, [sp, #4]
 80050a6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((rtcp != NULL) && (timespec != NULL));

  rtc_lld_get_time(rtcp, timespec);
 80050a8:	9801      	ldr	r0, [sp, #4]
 80050aa:	9900      	ldr	r1, [sp, #0]
 80050ac:	f004 fee8 	bl	8009e80 <rtc_lld_get_time>
}
 80050b0:	b003      	add	sp, #12
 80050b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80050b6:	bf00      	nop
 80050b8:	f3af 8000 	nop.w
 80050bc:	f3af 8000 	nop.w

080050c0 <rtcSetAlarm>:
 *
 * @special
 */
void rtcSetAlarm(RTCDriver *rtcp,
                 rtcalarm_t alarm,
                 const RTCAlarm *alarmspec) {
 80050c0:	b500      	push	{lr}
 80050c2:	b085      	sub	sp, #20
 80050c4:	9003      	str	r0, [sp, #12]
 80050c6:	9102      	str	r1, [sp, #8]
 80050c8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((rtcp != NULL) && (alarm < (rtcalarm_t)RTC_ALARMS));

  rtc_lld_set_alarm(rtcp, alarm, alarmspec);
 80050ca:	9803      	ldr	r0, [sp, #12]
 80050cc:	9902      	ldr	r1, [sp, #8]
 80050ce:	9a01      	ldr	r2, [sp, #4]
 80050d0:	f004 ff36 	bl	8009f40 <rtc_lld_set_alarm>
}
 80050d4:	b005      	add	sp, #20
 80050d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80050da:	bf00      	nop
 80050dc:	f3af 8000 	nop.w

080050e0 <rtcGetAlarm>:
 *
 * @special
 */
void rtcGetAlarm(RTCDriver *rtcp,
                 rtcalarm_t alarm,
                 RTCAlarm *alarmspec) {
 80050e0:	b500      	push	{lr}
 80050e2:	b085      	sub	sp, #20
 80050e4:	9003      	str	r0, [sp, #12]
 80050e6:	9102      	str	r1, [sp, #8]
 80050e8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((rtcp != NULL) &&
               (alarm < (rtcalarm_t)RTC_ALARMS) &&
               (alarmspec != NULL));

  rtc_lld_get_alarm(rtcp, alarm, alarmspec);
 80050ea:	9803      	ldr	r0, [sp, #12]
 80050ec:	9902      	ldr	r1, [sp, #8]
 80050ee:	9a01      	ldr	r2, [sp, #4]
 80050f0:	f004 ffae 	bl	800a050 <rtc_lld_get_alarm>
}
 80050f4:	b005      	add	sp, #20
 80050f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80050fa:	bf00      	nop
 80050fc:	f3af 8000 	nop.w

08005100 <rtcConvertDateTimeToStructTm>:
 *
 * @api
 */
void rtcConvertDateTimeToStructTm(const RTCDateTime *timespec,
                                  struct tm *timp,
                                  uint32_t *tv_msec) {
 8005100:	b086      	sub	sp, #24
 8005102:	9003      	str	r0, [sp, #12]
 8005104:	9102      	str	r1, [sp, #8]
 8005106:	9201      	str	r2, [sp, #4]
  int sec;

  timp->tm_year  = (int)timespec->year + (1980 - 1900);
 8005108:	9b03      	ldr	r3, [sp, #12]
 800510a:	781b      	ldrb	r3, [r3, #0]
 800510c:	f103 0250 	add.w	r2, r3, #80	; 0x50
 8005110:	9b02      	ldr	r3, [sp, #8]
 8005112:	615a      	str	r2, [r3, #20]
  timp->tm_mon   = (int)timespec->month - 1;
 8005114:	9b03      	ldr	r3, [sp, #12]
 8005116:	785b      	ldrb	r3, [r3, #1]
 8005118:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800511c:	b2db      	uxtb	r3, r3
 800511e:	1e5a      	subs	r2, r3, #1
 8005120:	9b02      	ldr	r3, [sp, #8]
 8005122:	611a      	str	r2, [r3, #16]
  timp->tm_mday  = (int)timespec->day;
 8005124:	9b03      	ldr	r3, [sp, #12]
 8005126:	789b      	ldrb	r3, [r3, #2]
 8005128:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800512c:	b2db      	uxtb	r3, r3
 800512e:	461a      	mov	r2, r3
 8005130:	9b02      	ldr	r3, [sp, #8]
 8005132:	60da      	str	r2, [r3, #12]
  timp->tm_isdst = (int)timespec->dstflag;
 8005134:	9b03      	ldr	r3, [sp, #12]
 8005136:	785b      	ldrb	r3, [r3, #1]
 8005138:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800513c:	b2db      	uxtb	r3, r3
 800513e:	461a      	mov	r2, r3
 8005140:	9b02      	ldr	r3, [sp, #8]
 8005142:	621a      	str	r2, [r3, #32]
  timp->tm_wday  = (int)timespec->dayofweek - 1;
 8005144:	9b03      	ldr	r3, [sp, #12]
 8005146:	785b      	ldrb	r3, [r3, #1]
 8005148:	f3c3 1342 	ubfx	r3, r3, #5, #3
 800514c:	b2db      	uxtb	r3, r3
 800514e:	1e5a      	subs	r2, r3, #1
 8005150:	9b02      	ldr	r3, [sp, #8]
 8005152:	619a      	str	r2, [r3, #24]

  sec = (int)timespec->millisecond / 1000;
 8005154:	9b03      	ldr	r3, [sp, #12]
 8005156:	685b      	ldr	r3, [r3, #4]
 8005158:	f3c3 031a 	ubfx	r3, r3, #0, #27
 800515c:	4a26      	ldr	r2, [pc, #152]	; (80051f8 <rtcConvertDateTimeToStructTm+0xf8>)
 800515e:	fb82 1203 	smull	r1, r2, r2, r3
 8005162:	1192      	asrs	r2, r2, #6
 8005164:	17db      	asrs	r3, r3, #31
 8005166:	1ad3      	subs	r3, r2, r3
 8005168:	9305      	str	r3, [sp, #20]
  timp->tm_hour = sec / 3600;
 800516a:	9b05      	ldr	r3, [sp, #20]
 800516c:	4a23      	ldr	r2, [pc, #140]	; (80051fc <rtcConvertDateTimeToStructTm+0xfc>)
 800516e:	fb82 1203 	smull	r1, r2, r2, r3
 8005172:	441a      	add	r2, r3
 8005174:	12d2      	asrs	r2, r2, #11
 8005176:	17db      	asrs	r3, r3, #31
 8005178:	1ad2      	subs	r2, r2, r3
 800517a:	9b02      	ldr	r3, [sp, #8]
 800517c:	609a      	str	r2, [r3, #8]
  sec %= 3600;
 800517e:	9b05      	ldr	r3, [sp, #20]
 8005180:	4a1e      	ldr	r2, [pc, #120]	; (80051fc <rtcConvertDateTimeToStructTm+0xfc>)
 8005182:	fb82 1203 	smull	r1, r2, r2, r3
 8005186:	441a      	add	r2, r3
 8005188:	12d1      	asrs	r1, r2, #11
 800518a:	17da      	asrs	r2, r3, #31
 800518c:	1a8a      	subs	r2, r1, r2
 800518e:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8005192:	fb01 f202 	mul.w	r2, r1, r2
 8005196:	1a9b      	subs	r3, r3, r2
 8005198:	9305      	str	r3, [sp, #20]
  timp->tm_min = sec / 60;
 800519a:	9b05      	ldr	r3, [sp, #20]
 800519c:	4a18      	ldr	r2, [pc, #96]	; (8005200 <rtcConvertDateTimeToStructTm+0x100>)
 800519e:	fb82 1203 	smull	r1, r2, r2, r3
 80051a2:	441a      	add	r2, r3
 80051a4:	1152      	asrs	r2, r2, #5
 80051a6:	17db      	asrs	r3, r3, #31
 80051a8:	1ad2      	subs	r2, r2, r3
 80051aa:	9b02      	ldr	r3, [sp, #8]
 80051ac:	605a      	str	r2, [r3, #4]
  timp->tm_sec = sec % 60;
 80051ae:	9905      	ldr	r1, [sp, #20]
 80051b0:	4b13      	ldr	r3, [pc, #76]	; (8005200 <rtcConvertDateTimeToStructTm+0x100>)
 80051b2:	fb83 2301 	smull	r2, r3, r3, r1
 80051b6:	440b      	add	r3, r1
 80051b8:	115a      	asrs	r2, r3, #5
 80051ba:	17cb      	asrs	r3, r1, #31
 80051bc:	1ad2      	subs	r2, r2, r3
 80051be:	4613      	mov	r3, r2
 80051c0:	011b      	lsls	r3, r3, #4
 80051c2:	1a9b      	subs	r3, r3, r2
 80051c4:	009b      	lsls	r3, r3, #2
 80051c6:	1aca      	subs	r2, r1, r3
 80051c8:	9b02      	ldr	r3, [sp, #8]
 80051ca:	601a      	str	r2, [r3, #0]

  if (NULL != tv_msec) {
 80051cc:	9b01      	ldr	r3, [sp, #4]
 80051ce:	2b00      	cmp	r3, #0
 80051d0:	d00f      	beq.n	80051f2 <rtcConvertDateTimeToStructTm+0xf2>
    *tv_msec = (uint32_t)timespec->millisecond % 1000U;
 80051d2:	9b03      	ldr	r3, [sp, #12]
 80051d4:	685b      	ldr	r3, [r3, #4]
 80051d6:	f3c3 021a 	ubfx	r2, r3, #0, #27
 80051da:	4b07      	ldr	r3, [pc, #28]	; (80051f8 <rtcConvertDateTimeToStructTm+0xf8>)
 80051dc:	fba3 1302 	umull	r1, r3, r3, r2
 80051e0:	099b      	lsrs	r3, r3, #6
 80051e2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80051e6:	fb01 f303 	mul.w	r3, r1, r3
 80051ea:	1ad3      	subs	r3, r2, r3
 80051ec:	461a      	mov	r2, r3
 80051ee:	9b01      	ldr	r3, [sp, #4]
 80051f0:	601a      	str	r2, [r3, #0]
  }
}
 80051f2:	b006      	add	sp, #24
 80051f4:	4770      	bx	lr
 80051f6:	bf00      	nop
 80051f8:	10624dd3 	.word	0x10624dd3
 80051fc:	91a2b3c5 	.word	0x91a2b3c5
 8005200:	88888889 	.word	0x88888889
 8005204:	f3af 8000 	nop.w
 8005208:	f3af 8000 	nop.w
 800520c:	f3af 8000 	nop.w

08005210 <rtcConvertStructTmToDateTime>:
 *
 * @api
 */
void rtcConvertStructTmToDateTime(const struct tm *timp,
                                  uint32_t tv_msec,
                                  RTCDateTime *timespec) {
 8005210:	b084      	sub	sp, #16
 8005212:	9003      	str	r0, [sp, #12]
 8005214:	9102      	str	r1, [sp, #8]
 8005216:	9201      	str	r2, [sp, #4]

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
 8005218:	9b03      	ldr	r3, [sp, #12]
 800521a:	695b      	ldr	r3, [r3, #20]
 800521c:	b2db      	uxtb	r3, r3
 800521e:	3b50      	subs	r3, #80	; 0x50
 8005220:	b2d9      	uxtb	r1, r3
 8005222:	9a01      	ldr	r2, [sp, #4]
 8005224:	7813      	ldrb	r3, [r2, #0]
 8005226:	f361 0307 	bfi	r3, r1, #0, #8
 800522a:	7013      	strb	r3, [r2, #0]
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
 800522c:	9b03      	ldr	r3, [sp, #12]
 800522e:	691b      	ldr	r3, [r3, #16]
 8005230:	b2db      	uxtb	r3, r3
 8005232:	3301      	adds	r3, #1
 8005234:	b2db      	uxtb	r3, r3
 8005236:	f003 030f 	and.w	r3, r3, #15
 800523a:	b2d9      	uxtb	r1, r3
 800523c:	9a01      	ldr	r2, [sp, #4]
 800523e:	7853      	ldrb	r3, [r2, #1]
 8005240:	f361 0303 	bfi	r3, r1, #0, #4
 8005244:	7053      	strb	r3, [r2, #1]
  timespec->day       = (uint32_t)timp->tm_mday;
 8005246:	9b03      	ldr	r3, [sp, #12]
 8005248:	68db      	ldr	r3, [r3, #12]
 800524a:	b2db      	uxtb	r3, r3
 800524c:	f003 031f 	and.w	r3, r3, #31
 8005250:	b2d9      	uxtb	r1, r3
 8005252:	9a01      	ldr	r2, [sp, #4]
 8005254:	7893      	ldrb	r3, [r2, #2]
 8005256:	f361 0304 	bfi	r3, r1, #0, #5
 800525a:	7093      	strb	r3, [r2, #2]
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
 800525c:	9b03      	ldr	r3, [sp, #12]
 800525e:	699b      	ldr	r3, [r3, #24]
 8005260:	b2db      	uxtb	r3, r3
 8005262:	3301      	adds	r3, #1
 8005264:	b2db      	uxtb	r3, r3
 8005266:	f003 0307 	and.w	r3, r3, #7
 800526a:	b2d9      	uxtb	r1, r3
 800526c:	9a01      	ldr	r2, [sp, #4]
 800526e:	7853      	ldrb	r3, [r2, #1]
 8005270:	f361 1347 	bfi	r3, r1, #5, #3
 8005274:	7053      	strb	r3, [r2, #1]
  if (-1 == timp->tm_isdst) {
 8005276:	9b03      	ldr	r3, [sp, #12]
 8005278:	6a1b      	ldr	r3, [r3, #32]
 800527a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800527e:	d105      	bne.n	800528c <rtcConvertStructTmToDateTime+0x7c>
    timespec->dstflag = 0U;  /* set zero if dst is unknown */
 8005280:	9a01      	ldr	r2, [sp, #4]
 8005282:	7853      	ldrb	r3, [r2, #1]
 8005284:	f36f 1304 	bfc	r3, #4, #1
 8005288:	7053      	strb	r3, [r2, #1]
 800528a:	e00a      	b.n	80052a2 <rtcConvertStructTmToDateTime+0x92>
  }
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
 800528c:	9b03      	ldr	r3, [sp, #12]
 800528e:	6a1b      	ldr	r3, [r3, #32]
 8005290:	b2db      	uxtb	r3, r3
 8005292:	f003 0301 	and.w	r3, r3, #1
 8005296:	b2d9      	uxtb	r1, r3
 8005298:	9a01      	ldr	r2, [sp, #4]
 800529a:	7853      	ldrb	r3, [r2, #1]
 800529c:	f361 1304 	bfi	r3, r1, #4, #1
 80052a0:	7053      	strb	r3, [r2, #1]
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 80052a2:	9b03      	ldr	r3, [sp, #12]
 80052a4:	689b      	ldr	r3, [r3, #8]
 80052a6:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 80052aa:	fb02 f103 	mul.w	r1, r2, r3
                                                (timp->tm_min * 60) +
 80052ae:	9b03      	ldr	r3, [sp, #12]
 80052b0:	685a      	ldr	r2, [r3, #4]
 80052b2:	4613      	mov	r3, r2
 80052b4:	011b      	lsls	r3, r3, #4
 80052b6:	1a9b      	subs	r3, r3, r2
 80052b8:	009b      	lsls	r3, r3, #2
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 80052ba:	18ca      	adds	r2, r1, r3
                                                (timp->tm_min * 60) +
                                                 timp->tm_sec) * 1000);
 80052bc:	9b03      	ldr	r3, [sp, #12]
 80052be:	681b      	ldr	r3, [r3, #0]
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
                                                (timp->tm_min * 60) +
 80052c0:	4413      	add	r3, r2
                                                 timp->tm_sec) * 1000);
 80052c2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80052c6:	fb02 f303 	mul.w	r3, r2, r3
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 80052ca:	461a      	mov	r2, r3
 80052cc:	9b02      	ldr	r3, [sp, #8]
 80052ce:	4413      	add	r3, r2
 80052d0:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 80052d4:	9a01      	ldr	r2, [sp, #4]
 80052d6:	6853      	ldr	r3, [r2, #4]
 80052d8:	f361 031a 	bfi	r3, r1, #0, #27
 80052dc:	6053      	str	r3, [r2, #4]
                                                (timp->tm_min * 60) +
                                                 timp->tm_sec) * 1000);
  /*lint -restore*/
}
 80052de:	b004      	add	sp, #16
 80052e0:	4770      	bx	lr
 80052e2:	bf00      	nop
 80052e4:	f3af 8000 	nop.w
 80052e8:	f3af 8000 	nop.w
 80052ec:	f3af 8000 	nop.w

080052f0 <rtcConvertDateTimeToFAT>:
 * @param[out] timespec pointer to a @p RTCDateTime structure
 * @return              FAT date/time value.
 *
 * @api
 */
uint32_t rtcConvertDateTimeToFAT(const RTCDateTime *timespec) {
 80052f0:	b088      	sub	sp, #32
 80052f2:	9001      	str	r0, [sp, #4]
  uint32_t fattime;
  uint32_t sec, min, hour, day, month;

  sec   = timespec->millisecond / 1000U;
 80052f4:	9b01      	ldr	r3, [sp, #4]
 80052f6:	685b      	ldr	r3, [r3, #4]
 80052f8:	f3c3 021a 	ubfx	r2, r3, #0, #27
 80052fc:	4b39      	ldr	r3, [pc, #228]	; (80053e4 <rtcConvertDateTimeToFAT+0xf4>)
 80052fe:	fba3 1302 	umull	r1, r3, r3, r2
 8005302:	099b      	lsrs	r3, r3, #6
 8005304:	9304      	str	r3, [sp, #16]
  hour  = sec / 3600U;
 8005306:	9a04      	ldr	r2, [sp, #16]
 8005308:	4b37      	ldr	r3, [pc, #220]	; (80053e8 <rtcConvertDateTimeToFAT+0xf8>)
 800530a:	fba3 1302 	umull	r1, r3, r3, r2
 800530e:	0adb      	lsrs	r3, r3, #11
 8005310:	9307      	str	r3, [sp, #28]
  sec  %= 3600U;
 8005312:	9b04      	ldr	r3, [sp, #16]
 8005314:	4a34      	ldr	r2, [pc, #208]	; (80053e8 <rtcConvertDateTimeToFAT+0xf8>)
 8005316:	fba2 1203 	umull	r1, r2, r2, r3
 800531a:	0ad2      	lsrs	r2, r2, #11
 800531c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8005320:	fb01 f202 	mul.w	r2, r1, r2
 8005324:	1a9b      	subs	r3, r3, r2
 8005326:	9304      	str	r3, [sp, #16]
  min   = sec / 60U;
 8005328:	9a04      	ldr	r2, [sp, #16]
 800532a:	4b30      	ldr	r3, [pc, #192]	; (80053ec <rtcConvertDateTimeToFAT+0xfc>)
 800532c:	fba3 1302 	umull	r1, r3, r3, r2
 8005330:	095b      	lsrs	r3, r3, #5
 8005332:	9303      	str	r3, [sp, #12]
  sec  %= 60U;
 8005334:	9a04      	ldr	r2, [sp, #16]
 8005336:	4b2d      	ldr	r3, [pc, #180]	; (80053ec <rtcConvertDateTimeToFAT+0xfc>)
 8005338:	fba3 1302 	umull	r1, r3, r3, r2
 800533c:	0959      	lsrs	r1, r3, #5
 800533e:	460b      	mov	r3, r1
 8005340:	011b      	lsls	r3, r3, #4
 8005342:	1a5b      	subs	r3, r3, r1
 8005344:	009b      	lsls	r3, r3, #2
 8005346:	1ad3      	subs	r3, r2, r3
 8005348:	9304      	str	r3, [sp, #16]
  day   = timespec->day;
 800534a:	9b01      	ldr	r3, [sp, #4]
 800534c:	789b      	ldrb	r3, [r3, #2]
 800534e:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8005352:	b2db      	uxtb	r3, r3
 8005354:	9306      	str	r3, [sp, #24]
  month = timespec->month;
 8005356:	9b01      	ldr	r3, [sp, #4]
 8005358:	785b      	ldrb	r3, [r3, #1]
 800535a:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800535e:	b2db      	uxtb	r3, r3
 8005360:	9305      	str	r3, [sp, #20]

  /* handle DST flag */
  if (1U == timespec->dstflag) {
 8005362:	9b01      	ldr	r3, [sp, #4]
 8005364:	785b      	ldrb	r3, [r3, #1]
 8005366:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800536a:	b2db      	uxtb	r3, r3
 800536c:	2b01      	cmp	r3, #1
 800536e:	d117      	bne.n	80053a0 <rtcConvertDateTimeToFAT+0xb0>
    hour += 1U;
 8005370:	9b07      	ldr	r3, [sp, #28]
 8005372:	3301      	adds	r3, #1
 8005374:	9307      	str	r3, [sp, #28]
    if (hour == 24U) {
 8005376:	9b07      	ldr	r3, [sp, #28]
 8005378:	2b18      	cmp	r3, #24
 800537a:	d111      	bne.n	80053a0 <rtcConvertDateTimeToFAT+0xb0>
      hour = 0U;
 800537c:	2300      	movs	r3, #0
 800537e:	9307      	str	r3, [sp, #28]
      day += 1U;
 8005380:	9b06      	ldr	r3, [sp, #24]
 8005382:	3301      	adds	r3, #1
 8005384:	9306      	str	r3, [sp, #24]
      if (day > month_len[month - 1U]) {
 8005386:	9b05      	ldr	r3, [sp, #20]
 8005388:	3b01      	subs	r3, #1
 800538a:	4a19      	ldr	r2, [pc, #100]	; (80053f0 <rtcConvertDateTimeToFAT+0x100>)
 800538c:	5cd3      	ldrb	r3, [r2, r3]
 800538e:	461a      	mov	r2, r3
 8005390:	9b06      	ldr	r3, [sp, #24]
 8005392:	429a      	cmp	r2, r3
 8005394:	d204      	bcs.n	80053a0 <rtcConvertDateTimeToFAT+0xb0>
        day = 1U;
 8005396:	2301      	movs	r3, #1
 8005398:	9306      	str	r3, [sp, #24]
        month += 1U;
 800539a:	9b05      	ldr	r3, [sp, #20]
 800539c:	3301      	adds	r3, #1
 800539e:	9305      	str	r3, [sp, #20]
      }
    }
  }

  fattime  = sec   >> 1U;
 80053a0:	9b04      	ldr	r3, [sp, #16]
 80053a2:	085b      	lsrs	r3, r3, #1
 80053a4:	9302      	str	r3, [sp, #8]
  fattime |= min   << 5U;
 80053a6:	9b03      	ldr	r3, [sp, #12]
 80053a8:	015b      	lsls	r3, r3, #5
 80053aa:	9a02      	ldr	r2, [sp, #8]
 80053ac:	4313      	orrs	r3, r2
 80053ae:	9302      	str	r3, [sp, #8]
  fattime |= hour  << 11U;
 80053b0:	9b07      	ldr	r3, [sp, #28]
 80053b2:	02db      	lsls	r3, r3, #11
 80053b4:	9a02      	ldr	r2, [sp, #8]
 80053b6:	4313      	orrs	r3, r2
 80053b8:	9302      	str	r3, [sp, #8]
  fattime |= day   << 16U;
 80053ba:	9b06      	ldr	r3, [sp, #24]
 80053bc:	041b      	lsls	r3, r3, #16
 80053be:	9a02      	ldr	r2, [sp, #8]
 80053c0:	4313      	orrs	r3, r2
 80053c2:	9302      	str	r3, [sp, #8]
  fattime |= month << 21U;
 80053c4:	9b05      	ldr	r3, [sp, #20]
 80053c6:	055b      	lsls	r3, r3, #21
 80053c8:	9a02      	ldr	r2, [sp, #8]
 80053ca:	4313      	orrs	r3, r2
 80053cc:	9302      	str	r3, [sp, #8]
  fattime |= (uint32_t)timespec->year << 25U;
 80053ce:	9b01      	ldr	r3, [sp, #4]
 80053d0:	781b      	ldrb	r3, [r3, #0]
 80053d2:	065b      	lsls	r3, r3, #25
 80053d4:	9a02      	ldr	r2, [sp, #8]
 80053d6:	4313      	orrs	r3, r2
 80053d8:	9302      	str	r3, [sp, #8]

  return fattime;
 80053da:	9b02      	ldr	r3, [sp, #8]
}
 80053dc:	4618      	mov	r0, r3
 80053de:	b008      	add	sp, #32
 80053e0:	4770      	bx	lr
 80053e2:	bf00      	nop
 80053e4:	10624dd3 	.word	0x10624dd3
 80053e8:	91a2b3c5 	.word	0x91a2b3c5
 80053ec:	88888889 	.word	0x88888889
 80053f0:	0801aa60 	.word	0x0801aa60
 80053f4:	f3af 8000 	nop.w
 80053f8:	f3af 8000 	nop.w
 80053fc:	f3af 8000 	nop.w

08005400 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005400:	b082      	sub	sp, #8
 8005402:	2320      	movs	r3, #32
 8005404:	9301      	str	r3, [sp, #4]
 8005406:	9b01      	ldr	r3, [sp, #4]
 8005408:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800540c:	b002      	add	sp, #8
 800540e:	4770      	bx	lr

08005410 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005410:	b082      	sub	sp, #8
 8005412:	2300      	movs	r3, #0
 8005414:	9301      	str	r3, [sp, #4]
 8005416:	9b01      	ldr	r3, [sp, #4]
 8005418:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800541c:	b002      	add	sp, #8
 800541e:	4770      	bx	lr

08005420 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005420:	b508      	push	{r3, lr}

  port_lock();
 8005422:	f7ff ffed 	bl	8005400 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005426:	bd08      	pop	{r3, pc}
 8005428:	f3af 8000 	nop.w
 800542c:	f3af 8000 	nop.w

08005430 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005430:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005432:	f7ff ffed 	bl	8005410 <port_unlock>
}
 8005436:	bd08      	pop	{r3, pc}
 8005438:	f3af 8000 	nop.w
 800543c:	f3af 8000 	nop.w

08005440 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8005440:	b508      	push	{r3, lr}

  chSysLock();
 8005442:	f7ff ffed 	bl	8005420 <chSysLock>
}
 8005446:	bd08      	pop	{r3, pc}
 8005448:	f3af 8000 	nop.w
 800544c:	f3af 8000 	nop.w

08005450 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8005450:	b508      	push	{r3, lr}

  chSysUnlock();
 8005452:	f7ff ffed 	bl	8005430 <chSysUnlock>
}
 8005456:	bd08      	pop	{r3, pc}
 8005458:	f3af 8000 	nop.w
 800545c:	f3af 8000 	nop.w

08005460 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 8005460:	b500      	push	{lr}
 8005462:	b083      	sub	sp, #12
 8005464:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 8005466:	9801      	ldr	r0, [sp, #4]
 8005468:	f7fb ff32 	bl	80012d0 <chThdSleep>
}
 800546c:	b003      	add	sp, #12
 800546e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005472:	bf00      	nop
 8005474:	f3af 8000 	nop.w
 8005478:	f3af 8000 	nop.w
 800547c:	f3af 8000 	nop.w

08005480 <mode_detect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mode_detect(SDCDriver *sdcp) {
 8005480:	b500      	push	{lr}
 8005482:	b085      	sub	sp, #20
 8005484:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  /* V2.0 cards detection.*/
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
 8005486:	ab03      	add	r3, sp, #12
 8005488:	9801      	ldr	r0, [sp, #4]
 800548a:	2108      	movs	r1, #8
 800548c:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 8005490:	f005 fa36 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005494:	4603      	mov	r3, r0
 8005496:	f083 0301 	eor.w	r3, r3, #1
 800549a:	b2db      	uxtb	r3, r3
 800549c:	2b00      	cmp	r3, #0
 800549e:	d01a      	beq.n	80054d6 <mode_detect+0x56>
                                  MMCSD_CMD8_PATTERN, resp)) {
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 80054a0:	9b01      	ldr	r3, [sp, #4]
 80054a2:	2201      	movs	r2, #1
 80054a4:	631a      	str	r2, [r3, #48]	; 0x30
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 80054a6:	9b03      	ldr	r3, [sp, #12]
 80054a8:	0a1b      	lsrs	r3, r3, #8
 80054aa:	f003 030f 	and.w	r3, r3, #15
 80054ae:	2b01      	cmp	r3, #1
 80054b0:	d001      	beq.n	80054b6 <mode_detect+0x36>
      return HAL_FAILED;
 80054b2:	2301      	movs	r3, #1
 80054b4:	e02a      	b.n	800550c <mode_detect+0x8c>
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054b6:	ab03      	add	r3, sp, #12
 80054b8:	9801      	ldr	r0, [sp, #4]
 80054ba:	2137      	movs	r1, #55	; 0x37
 80054bc:	2200      	movs	r2, #0
 80054be:	f005 fa1f 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80054c2:	4603      	mov	r3, r0
 80054c4:	2b00      	cmp	r3, #0
 80054c6:	d104      	bne.n	80054d2 <mode_detect+0x52>
        MMCSD_R1_ERROR(resp[0])) {
 80054c8:	9a03      	ldr	r2, [sp, #12]
 80054ca:	4b12      	ldr	r3, [pc, #72]	; (8005514 <mode_detect+0x94>)
 80054cc:	4013      	ands	r3, r2
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
      return HAL_FAILED;
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054ce:	2b00      	cmp	r3, #0
 80054d0:	d01b      	beq.n	800550a <mode_detect+0x8a>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 80054d2:	2301      	movs	r3, #1
 80054d4:	e01a      	b.n	800550c <mode_detect+0x8c>
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054d6:	ab03      	add	r3, sp, #12
 80054d8:	9801      	ldr	r0, [sp, #4]
 80054da:	2137      	movs	r1, #55	; 0x37
 80054dc:	2200      	movs	r2, #0
 80054de:	f005 fa0f 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80054e2:	4603      	mov	r3, r0
 80054e4:	2b00      	cmp	r3, #0
 80054e6:	d104      	bne.n	80054f2 <mode_detect+0x72>
        MMCSD_R1_ERROR(resp[0])) {
 80054e8:	9a03      	ldr	r2, [sp, #12]
 80054ea:	4b0a      	ldr	r3, [pc, #40]	; (8005514 <mode_detect+0x94>)
 80054ec:	4013      	ands	r3, r2
      return HAL_FAILED;
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054ee:	2b00      	cmp	r3, #0
 80054f0:	d003      	beq.n	80054fa <mode_detect+0x7a>
        MMCSD_R1_ERROR(resp[0])) {
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 80054f2:	9b01      	ldr	r3, [sp, #4]
 80054f4:	2202      	movs	r2, #2
 80054f6:	631a      	str	r2, [r3, #48]	; 0x30
 80054f8:	e007      	b.n	800550a <mode_detect+0x8a>
    }
    else {
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 80054fa:	9b01      	ldr	r3, [sp, #4]
 80054fc:	2200      	movs	r2, #0
 80054fe:	631a      	str	r2, [r3, #48]	; 0x30
    
      /* Reset error flag illegal command.*/
      sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8005500:	9801      	ldr	r0, [sp, #4]
 8005502:	2100      	movs	r1, #0
 8005504:	2200      	movs	r2, #0
 8005506:	f005 f99b 	bl	800a840 <sdc_lld_send_cmd_none>
    }
  }

  return HAL_SUCCESS;
 800550a:	2300      	movs	r3, #0
}
 800550c:	4618      	mov	r0, r3
 800550e:	b005      	add	sp, #20
 8005510:	f85d fb04 	ldr.w	pc, [sp], #4
 8005514:	fdffe008 	.word	0xfdffe008
 8005518:	f3af 8000 	nop.w
 800551c:	f3af 8000 	nop.w

08005520 <mmc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_init(SDCDriver *sdcp) {
 8005520:	b500      	push	{lr}
 8005522:	b087      	sub	sp, #28
 8005524:	9001      	str	r0, [sp, #4]
  uint32_t ocr;
  unsigned i;
  uint32_t resp[1];

  ocr = 0xC0FF8000U;
 8005526:	4b18      	ldr	r3, [pc, #96]	; (8005588 <mmc_init+0x68>)
 8005528:	9304      	str	r3, [sp, #16]
  i = 0;
 800552a:	2300      	movs	r3, #0
 800552c:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_INIT, ocr, resp)) {
 800552e:	ab03      	add	r3, sp, #12
 8005530:	9801      	ldr	r0, [sp, #4]
 8005532:	2101      	movs	r1, #1
 8005534:	9a04      	ldr	r2, [sp, #16]
 8005536:	f005 f9a3 	bl	800a880 <sdc_lld_send_cmd_short>
 800553a:	4603      	mov	r3, r0
 800553c:	2b00      	cmp	r3, #0
 800553e:	d001      	beq.n	8005544 <mmc_init+0x24>
      return HAL_FAILED;
 8005540:	2301      	movs	r3, #1
 8005542:	e01d      	b.n	8005580 <mmc_init+0x60>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 8005544:	9b03      	ldr	r3, [sp, #12]
 8005546:	2b00      	cmp	r3, #0
 8005548:	da0c      	bge.n	8005564 <mmc_init+0x44>
      if ((resp[0] & 0x40000000U) != 0U) {
 800554a:	9b03      	ldr	r3, [sp, #12]
 800554c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8005550:	2b00      	cmp	r3, #0
 8005552:	d006      	beq.n	8005562 <mmc_init+0x42>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 8005554:	9b01      	ldr	r3, [sp, #4]
 8005556:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005558:	f043 0210 	orr.w	r2, r3, #16
 800555c:	9b01      	ldr	r3, [sp, #4]
 800555e:	631a      	str	r2, [r3, #48]	; 0x30
      }
      break;
 8005560:	e00d      	b.n	800557e <mmc_init+0x5e>
 8005562:	e00c      	b.n	800557e <mmc_init+0x5e>
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8005564:	9b05      	ldr	r3, [sp, #20]
 8005566:	3301      	adds	r3, #1
 8005568:	9305      	str	r3, [sp, #20]
 800556a:	9b05      	ldr	r3, [sp, #20]
 800556c:	2b63      	cmp	r3, #99	; 0x63
 800556e:	d901      	bls.n	8005574 <mmc_init+0x54>
      return HAL_FAILED;
 8005570:	2301      	movs	r3, #1
 8005572:	e005      	b.n	8005580 <mmc_init+0x60>
    }
    osalThreadSleepMilliseconds(10);
 8005574:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005578:	f7ff ff72 	bl	8005460 <osalThreadSleep>
  }
 800557c:	e7d7      	b.n	800552e <mmc_init+0xe>

  return HAL_SUCCESS;
 800557e:	2300      	movs	r3, #0
}
 8005580:	4618      	mov	r0, r3
 8005582:	b007      	add	sp, #28
 8005584:	f85d fb04 	ldr.w	pc, [sp], #4
 8005588:	c0ff8000 	.word	0xc0ff8000
 800558c:	f3af 8000 	nop.w

08005590 <sdc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_init(SDCDriver *sdcp) {
 8005590:	b500      	push	{lr}
 8005592:	b087      	sub	sp, #28
 8005594:	9001      	str	r0, [sp, #4]
  unsigned i;
  uint32_t ocr;
  uint32_t resp[1];

  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_SDV20) {
 8005596:	9b01      	ldr	r3, [sp, #4]
 8005598:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800559a:	f003 030f 	and.w	r3, r3, #15
 800559e:	2b01      	cmp	r3, #1
 80055a0:	d102      	bne.n	80055a8 <sdc_init+0x18>
    ocr = 0xC0100000U;
 80055a2:	4b22      	ldr	r3, [pc, #136]	; (800562c <sdc_init+0x9c>)
 80055a4:	9304      	str	r3, [sp, #16]
 80055a6:	e001      	b.n	80055ac <sdc_init+0x1c>
  }
  else {
    ocr = 0x80100000U;
 80055a8:	4b21      	ldr	r3, [pc, #132]	; (8005630 <sdc_init+0xa0>)
 80055aa:	9304      	str	r3, [sp, #16]
  }

  i = 0;
 80055ac:	2300      	movs	r3, #0
 80055ae:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80055b0:	ab03      	add	r3, sp, #12
 80055b2:	9801      	ldr	r0, [sp, #4]
 80055b4:	2137      	movs	r1, #55	; 0x37
 80055b6:	2200      	movs	r2, #0
 80055b8:	f005 f9a2 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80055bc:	4603      	mov	r3, r0
 80055be:	2b00      	cmp	r3, #0
 80055c0:	d104      	bne.n	80055cc <sdc_init+0x3c>
        MMCSD_R1_ERROR(resp[0])) {
 80055c2:	9a03      	ldr	r2, [sp, #12]
 80055c4:	4b1b      	ldr	r3, [pc, #108]	; (8005634 <sdc_init+0xa4>)
 80055c6:	4013      	ands	r3, r2
    ocr = 0x80100000U;
  }

  i = 0;
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80055c8:	2b00      	cmp	r3, #0
 80055ca:	d001      	beq.n	80055d0 <sdc_init+0x40>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 80055cc:	2301      	movs	r3, #1
 80055ce:	e028      	b.n	8005622 <sdc_init+0x92>
    }
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
 80055d0:	ab03      	add	r3, sp, #12
 80055d2:	9801      	ldr	r0, [sp, #4]
 80055d4:	2129      	movs	r1, #41	; 0x29
 80055d6:	9a04      	ldr	r2, [sp, #16]
 80055d8:	f005 f952 	bl	800a880 <sdc_lld_send_cmd_short>
 80055dc:	4603      	mov	r3, r0
 80055de:	2b00      	cmp	r3, #0
 80055e0:	d001      	beq.n	80055e6 <sdc_init+0x56>
      return HAL_FAILED;
 80055e2:	2301      	movs	r3, #1
 80055e4:	e01d      	b.n	8005622 <sdc_init+0x92>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 80055e6:	9b03      	ldr	r3, [sp, #12]
 80055e8:	2b00      	cmp	r3, #0
 80055ea:	da0c      	bge.n	8005606 <sdc_init+0x76>
      if ((resp[0] & 0x40000000U) != 0U) {
 80055ec:	9b03      	ldr	r3, [sp, #12]
 80055ee:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 80055f2:	2b00      	cmp	r3, #0
 80055f4:	d006      	beq.n	8005604 <sdc_init+0x74>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 80055f6:	9b01      	ldr	r3, [sp, #4]
 80055f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80055fa:	f043 0210 	orr.w	r2, r3, #16
 80055fe:	9b01      	ldr	r3, [sp, #4]
 8005600:	631a      	str	r2, [r3, #48]	; 0x30
      }
      break;
 8005602:	e00d      	b.n	8005620 <sdc_init+0x90>
 8005604:	e00c      	b.n	8005620 <sdc_init+0x90>
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8005606:	9b05      	ldr	r3, [sp, #20]
 8005608:	3301      	adds	r3, #1
 800560a:	9305      	str	r3, [sp, #20]
 800560c:	9b05      	ldr	r3, [sp, #20]
 800560e:	2b63      	cmp	r3, #99	; 0x63
 8005610:	d901      	bls.n	8005616 <sdc_init+0x86>
      return HAL_FAILED;
 8005612:	2301      	movs	r3, #1
 8005614:	e005      	b.n	8005622 <sdc_init+0x92>
    }
    osalThreadSleepMilliseconds(10);
 8005616:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800561a:	f7ff ff21 	bl	8005460 <osalThreadSleep>
  }
 800561e:	e7c7      	b.n	80055b0 <sdc_init+0x20>

  return HAL_SUCCESS;
 8005620:	2300      	movs	r3, #0
}
 8005622:	4618      	mov	r0, r3
 8005624:	b007      	add	sp, #28
 8005626:	f85d fb04 	ldr.w	pc, [sp], #4
 800562a:	bf00      	nop
 800562c:	c0100000 	.word	0xc0100000
 8005630:	80100000 	.word	0x80100000
 8005634:	fdffe008 	.word	0xfdffe008
 8005638:	f3af 8000 	nop.w
 800563c:	f3af 8000 	nop.w

08005640 <mmc_cmd6_construct>:
 * @return              CMD6 argument.
 *
 * @notapi
 */
static uint32_t mmc_cmd6_construct(mmc_switch_t access, uint32_t idx,
                                   uint32_t value, uint32_t cmd_set) {
 8005640:	b084      	sub	sp, #16
 8005642:	9102      	str	r1, [sp, #8]
 8005644:	9201      	str	r2, [sp, #4]
 8005646:	9300      	str	r3, [sp, #0]
 8005648:	4603      	mov	r3, r0
 800564a:	f88d 300f 	strb.w	r3, [sp, #15]

  osalDbgAssert(idx <= 191U, "This field is not writable");
  osalDbgAssert(cmd_set < 8U, "This field has only 3 bits");

  return ((uint32_t)access << 24U) | (idx << 16U) | (value << 8U) | cmd_set;
 800564e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8005652:	061a      	lsls	r2, r3, #24
 8005654:	9b02      	ldr	r3, [sp, #8]
 8005656:	041b      	lsls	r3, r3, #16
 8005658:	431a      	orrs	r2, r3
 800565a:	9b01      	ldr	r3, [sp, #4]
 800565c:	021b      	lsls	r3, r3, #8
 800565e:	431a      	orrs	r2, r3
 8005660:	9b00      	ldr	r3, [sp, #0]
 8005662:	4313      	orrs	r3, r2
}
 8005664:	4618      	mov	r0, r3
 8005666:	b004      	add	sp, #16
 8005668:	4770      	bx	lr
 800566a:	bf00      	nop
 800566c:	f3af 8000 	nop.w

08005670 <sdc_cmd6_construct>:
 *
 * @notapi
 */
static uint32_t sdc_cmd6_construct(sd_switch_t mode,
                                   sd_switch_function_t function,
                                   uint32_t value) {
 8005670:	b084      	sub	sp, #16
 8005672:	460b      	mov	r3, r1
 8005674:	9200      	str	r2, [sp, #0]
 8005676:	4602      	mov	r2, r0
 8005678:	f88d 2007 	strb.w	r2, [sp, #7]
 800567c:	f88d 3006 	strb.w	r3, [sp, #6]
  uint32_t ret = 0xFFFFFF;
 8005680:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8005684:	9303      	str	r3, [sp, #12]

  osalDbgAssert((value < 16U), "This field has only 4 bits");

  ret &= ~((uint32_t)0xFU << ((uint32_t)function * 4U));
 8005686:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800568a:	009b      	lsls	r3, r3, #2
 800568c:	220f      	movs	r2, #15
 800568e:	fa02 f303 	lsl.w	r3, r2, r3
 8005692:	43db      	mvns	r3, r3
 8005694:	9a03      	ldr	r2, [sp, #12]
 8005696:	4013      	ands	r3, r2
 8005698:	9303      	str	r3, [sp, #12]
  ret |= value << ((uint32_t)function * 4U);
 800569a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800569e:	009b      	lsls	r3, r3, #2
 80056a0:	9a00      	ldr	r2, [sp, #0]
 80056a2:	fa02 f303 	lsl.w	r3, r2, r3
 80056a6:	9a03      	ldr	r2, [sp, #12]
 80056a8:	4313      	orrs	r3, r2
 80056aa:	9303      	str	r3, [sp, #12]
  return ret | ((uint32_t)mode << 31U);
 80056ac:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80056b0:	07da      	lsls	r2, r3, #31
 80056b2:	9b03      	ldr	r3, [sp, #12]
 80056b4:	4313      	orrs	r3, r2
}
 80056b6:	4618      	mov	r0, r3
 80056b8:	b004      	add	sp, #16
 80056ba:	4770      	bx	lr
 80056bc:	f3af 8000 	nop.w

080056c0 <sdc_cmd6_extract_info>:
 * @return              extracted answer.
 *
 * @notapi
 */
static uint16_t sdc_cmd6_extract_info(sd_switch_function_t function,
                                      const uint8_t *buf) {
 80056c0:	b084      	sub	sp, #16
 80056c2:	4603      	mov	r3, r0
 80056c4:	9100      	str	r1, [sp, #0]
 80056c6:	f88d 3007 	strb.w	r3, [sp, #7]

  unsigned start = 12U - ((unsigned)function * 2U);
 80056ca:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80056ce:	4613      	mov	r3, r2
 80056d0:	07db      	lsls	r3, r3, #31
 80056d2:	1a9b      	subs	r3, r3, r2
 80056d4:	005b      	lsls	r3, r3, #1
 80056d6:	330c      	adds	r3, #12
 80056d8:	9303      	str	r3, [sp, #12]

  return ((uint16_t)buf[start] << 8U) | (uint16_t)buf[start + 1U];
 80056da:	9a00      	ldr	r2, [sp, #0]
 80056dc:	9b03      	ldr	r3, [sp, #12]
 80056de:	4413      	add	r3, r2
 80056e0:	781b      	ldrb	r3, [r3, #0]
 80056e2:	021b      	lsls	r3, r3, #8
 80056e4:	b29a      	uxth	r2, r3
 80056e6:	9b03      	ldr	r3, [sp, #12]
 80056e8:	3301      	adds	r3, #1
 80056ea:	9900      	ldr	r1, [sp, #0]
 80056ec:	440b      	add	r3, r1
 80056ee:	781b      	ldrb	r3, [r3, #0]
 80056f0:	4313      	orrs	r3, r2
 80056f2:	b29b      	uxth	r3, r3
 80056f4:	b29b      	uxth	r3, r3
}
 80056f6:	4618      	mov	r0, r3
 80056f8:	b004      	add	sp, #16
 80056fa:	4770      	bx	lr
 80056fc:	f3af 8000 	nop.w

08005700 <sdc_cmd6_check_status>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_cmd6_check_status(sd_switch_function_t function,
                                 const uint8_t *buf) {
 8005700:	b084      	sub	sp, #16
 8005702:	4603      	mov	r3, r0
 8005704:	9100      	str	r1, [sp, #0]
 8005706:	f88d 3007 	strb.w	r3, [sp, #7]

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 800570a:	9b00      	ldr	r3, [sp, #0]
 800570c:	330e      	adds	r3, #14
 800570e:	781b      	ldrb	r3, [r3, #0]
 8005710:	041a      	lsls	r2, r3, #16
        ((uint32_t)buf[15] << 8U) |
 8005712:	9b00      	ldr	r3, [sp, #0]
 8005714:	330f      	adds	r3, #15
 8005716:	781b      	ldrb	r3, [r3, #0]
 8005718:	021b      	lsls	r3, r3, #8
                                 const uint8_t *buf) {

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 800571a:	431a      	orrs	r2, r3
        ((uint32_t)buf[15] << 8U) |
        (uint32_t)buf[16];
 800571c:	9b00      	ldr	r3, [sp, #0]
 800571e:	3310      	adds	r3, #16
 8005720:	781b      	ldrb	r3, [r3, #0]
                                 const uint8_t *buf) {

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 8005722:	4313      	orrs	r3, r2
 8005724:	9303      	str	r3, [sp, #12]
        ((uint32_t)buf[15] << 8U) |
        (uint32_t)buf[16];
  status = (tmp >> ((uint32_t)function * 4U)) & 0xFU;
 8005726:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800572a:	009b      	lsls	r3, r3, #2
 800572c:	9a03      	ldr	r2, [sp, #12]
 800572e:	fa22 f303 	lsr.w	r3, r2, r3
 8005732:	f003 030f 	and.w	r3, r3, #15
 8005736:	9302      	str	r3, [sp, #8]
  if (0xFU != status) {
 8005738:	9b02      	ldr	r3, [sp, #8]
 800573a:	2b0f      	cmp	r3, #15
 800573c:	d001      	beq.n	8005742 <sdc_cmd6_check_status+0x42>
    return HAL_SUCCESS;
 800573e:	2300      	movs	r3, #0
 8005740:	e000      	b.n	8005744 <sdc_cmd6_check_status+0x44>
  }
  return HAL_FAILED;
 8005742:	2301      	movs	r3, #1
}
 8005744:	4618      	mov	r0, r3
 8005746:	b004      	add	sp, #16
 8005748:	4770      	bx	lr
 800574a:	bf00      	nop
 800574c:	f3af 8000 	nop.w

08005750 <sdc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8005750:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005752:	b089      	sub	sp, #36	; 0x24
 8005754:	af02      	add	r7, sp, #8
 8005756:	6078      	str	r0, [r7, #4]
 8005758:	6039      	str	r1, [r7, #0]
 800575a:	4669      	mov	r1, sp
 800575c:	460e      	mov	r6, r1
  uint32_t cmdarg;
  const size_t N = 64;
 800575e:	2140      	movs	r1, #64	; 0x40
 8005760:	6179      	str	r1, [r7, #20]
  uint8_t tmp[N];
 8005762:	6979      	ldr	r1, [r7, #20]
 8005764:	3901      	subs	r1, #1
 8005766:	6139      	str	r1, [r7, #16]
 8005768:	6979      	ldr	r1, [r7, #20]
 800576a:	4608      	mov	r0, r1
 800576c:	f04f 0100 	mov.w	r1, #0
 8005770:	00cd      	lsls	r5, r1, #3
 8005772:	ea45 7550 	orr.w	r5, r5, r0, lsr #29
 8005776:	00c4      	lsls	r4, r0, #3
 8005778:	6979      	ldr	r1, [r7, #20]
 800577a:	4608      	mov	r0, r1
 800577c:	f04f 0100 	mov.w	r1, #0
 8005780:	00cb      	lsls	r3, r1, #3
 8005782:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8005786:	00c2      	lsls	r2, r0, #3
 8005788:	697b      	ldr	r3, [r7, #20]
 800578a:	3307      	adds	r3, #7
 800578c:	08db      	lsrs	r3, r3, #3
 800578e:	00db      	lsls	r3, r3, #3
 8005790:	ebad 0d03 	sub.w	sp, sp, r3
 8005794:	ab02      	add	r3, sp, #8
 8005796:	3300      	adds	r3, #0
 8005798:	60fb      	str	r3, [r7, #12]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 800579a:	683b      	ldr	r3, [r7, #0]
 800579c:	2200      	movs	r2, #0
 800579e:	701a      	strb	r2, [r3, #0]

  /* Looks like only "high capacity" cards produce meaningful results during
     this clock detection procedure.*/
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 80057a0:	687b      	ldr	r3, [r7, #4]
 80057a2:	3318      	adds	r3, #24
 80057a4:	4618      	mov	r0, r3
 80057a6:	217f      	movs	r1, #127	; 0x7f
 80057a8:	227e      	movs	r2, #126	; 0x7e
 80057aa:	f7fe ff69 	bl	8004680 <_mmcsd_get_slice>
 80057ae:	4603      	mov	r3, r0
 80057b0:	2b00      	cmp	r3, #0
 80057b2:	d104      	bne.n	80057be <sdc_detect_bus_clk+0x6e>
    *clk = SDC_CLK_25MHz;
 80057b4:	683b      	ldr	r3, [r7, #0]
 80057b6:	2200      	movs	r2, #0
 80057b8:	701a      	strb	r2, [r3, #0]
    return HAL_SUCCESS;
 80057ba:	2300      	movs	r3, #0
 80057bc:	e03e      	b.n	800583c <sdc_detect_bus_clk+0xec>
  }

  /* Read switch functions' register.*/
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 80057be:	68fb      	ldr	r3, [r7, #12]
 80057c0:	2200      	movs	r2, #0
 80057c2:	9200      	str	r2, [sp, #0]
 80057c4:	6878      	ldr	r0, [r7, #4]
 80057c6:	4619      	mov	r1, r3
 80057c8:	697a      	ldr	r2, [r7, #20]
 80057ca:	2306      	movs	r3, #6
 80057cc:	f005 f928 	bl	800aa20 <sdc_lld_read_special>
 80057d0:	4603      	mov	r3, r0
 80057d2:	2b00      	cmp	r3, #0
 80057d4:	d001      	beq.n	80057da <sdc_detect_bus_clk+0x8a>
    return HAL_FAILED;
 80057d6:	2301      	movs	r3, #1
 80057d8:	e030      	b.n	800583c <sdc_detect_bus_clk+0xec>
  }

  /* Check card capabilities parsing acquired data.*/
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 80057da:	68fb      	ldr	r3, [r7, #12]
 80057dc:	2000      	movs	r0, #0
 80057de:	4619      	mov	r1, r3
 80057e0:	f7ff ff6e 	bl	80056c0 <sdc_cmd6_extract_info>
 80057e4:	4603      	mov	r3, r0
 80057e6:	f003 0302 	and.w	r3, r3, #2
 80057ea:	2b00      	cmp	r3, #0
 80057ec:	d025      	beq.n	800583a <sdc_detect_bus_clk+0xea>
    /* Construct command to set the bus speed.*/
    cmdarg = sdc_cmd6_construct(SD_SWITCH_SET, SD_SWITCH_FUNCTION_SPEED, 1);
 80057ee:	2001      	movs	r0, #1
 80057f0:	2100      	movs	r1, #0
 80057f2:	2201      	movs	r2, #1
 80057f4:	f7ff ff3c 	bl	8005670 <sdc_cmd6_construct>
 80057f8:	60b8      	str	r0, [r7, #8]

    /* Write constructed command and read operation status in single call.*/
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 80057fa:	68fb      	ldr	r3, [r7, #12]
 80057fc:	68ba      	ldr	r2, [r7, #8]
 80057fe:	9200      	str	r2, [sp, #0]
 8005800:	6878      	ldr	r0, [r7, #4]
 8005802:	4619      	mov	r1, r3
 8005804:	697a      	ldr	r2, [r7, #20]
 8005806:	2306      	movs	r3, #6
 8005808:	f005 f90a 	bl	800aa20 <sdc_lld_read_special>
 800580c:	4603      	mov	r3, r0
 800580e:	2b00      	cmp	r3, #0
 8005810:	d001      	beq.n	8005816 <sdc_detect_bus_clk+0xc6>
      return HAL_FAILED;
 8005812:	2301      	movs	r3, #1
 8005814:	e012      	b.n	800583c <sdc_detect_bus_clk+0xec>
    }

    /* Check card answer for success status bits.*/
    if (HAL_SUCCESS == sdc_cmd6_check_status(SD_SWITCH_FUNCTION_SPEED, tmp)) {
 8005816:	68fb      	ldr	r3, [r7, #12]
 8005818:	2000      	movs	r0, #0
 800581a:	4619      	mov	r1, r3
 800581c:	f7ff ff70 	bl	8005700 <sdc_cmd6_check_status>
 8005820:	4603      	mov	r3, r0
 8005822:	f083 0301 	eor.w	r3, r3, #1
 8005826:	b2db      	uxtb	r3, r3
 8005828:	2b00      	cmp	r3, #0
 800582a:	d003      	beq.n	8005834 <sdc_detect_bus_clk+0xe4>
      *clk = SDC_CLK_50MHz;
 800582c:	683b      	ldr	r3, [r7, #0]
 800582e:	2201      	movs	r2, #1
 8005830:	701a      	strb	r2, [r3, #0]
 8005832:	e002      	b.n	800583a <sdc_detect_bus_clk+0xea>
    }
    else {
      *clk = SDC_CLK_25MHz;
 8005834:	683b      	ldr	r3, [r7, #0]
 8005836:	2200      	movs	r2, #0
 8005838:	701a      	strb	r2, [r3, #0]
    }
  }

  return HAL_SUCCESS;
 800583a:	2300      	movs	r3, #0
 800583c:	46b5      	mov	sp, r6
}
 800583e:	4618      	mov	r0, r3
 8005840:	371c      	adds	r7, #28
 8005842:	46bd      	mov	sp, r7
 8005844:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005846:	bf00      	nop
 8005848:	f3af 8000 	nop.w
 800584c:	f3af 8000 	nop.w

08005850 <mmc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8005850:	b500      	push	{lr}
 8005852:	b087      	sub	sp, #28
 8005854:	9001      	str	r0, [sp, #4]
 8005856:	9100      	str	r1, [sp, #0]
  uint32_t cmdarg;
  uint32_t resp[1];
  uint8_t *scratchpad = sdcp->config->scratchpad;
 8005858:	9b01      	ldr	r3, [sp, #4]
 800585a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800585c:	681b      	ldr	r3, [r3, #0]
 800585e:	9305      	str	r3, [sp, #20]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 8005860:	9b00      	ldr	r3, [sp, #0]
 8005862:	2200      	movs	r2, #0
 8005864:	701a      	strb	r2, [r3, #0]

  /* Use safe default when there is no space for data.*/
  if (NULL == scratchpad) {
 8005866:	9b05      	ldr	r3, [sp, #20]
 8005868:	2b00      	cmp	r3, #0
 800586a:	d101      	bne.n	8005870 <mmc_detect_bus_clk+0x20>
    return HAL_SUCCESS;
 800586c:	2300      	movs	r3, #0
 800586e:	e01b      	b.n	80058a8 <mmc_detect_bus_clk+0x58>
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
 8005870:	2003      	movs	r0, #3
 8005872:	21b9      	movs	r1, #185	; 0xb9
 8005874:	2201      	movs	r2, #1
 8005876:	2300      	movs	r3, #0
 8005878:	f7ff fee2 	bl	8005640 <mmc_cmd6_construct>
 800587c:	9004      	str	r0, [sp, #16]
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 800587e:	ab03      	add	r3, sp, #12
 8005880:	9801      	ldr	r0, [sp, #4]
 8005882:	2106      	movs	r1, #6
 8005884:	9a04      	ldr	r2, [sp, #16]
 8005886:	f005 f83b 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800588a:	4603      	mov	r3, r0
 800588c:	f083 0301 	eor.w	r3, r3, #1
 8005890:	b2db      	uxtb	r3, r3
 8005892:	2b00      	cmp	r3, #0
 8005894:	d007      	beq.n	80058a6 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
 8005896:	9a03      	ldr	r2, [sp, #12]
 8005898:	4b05      	ldr	r3, [pc, #20]	; (80058b0 <mmc_detect_bus_clk+0x60>)
 800589a:	4013      	ands	r3, r2
  if (NULL == scratchpad) {
    return HAL_SUCCESS;
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 800589c:	2b00      	cmp	r3, #0
 800589e:	d102      	bne.n	80058a6 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
    *clk = SDC_CLK_50MHz;
 80058a0:	9b00      	ldr	r3, [sp, #0]
 80058a2:	2201      	movs	r2, #1
 80058a4:	701a      	strb	r2, [r3, #0]
  }

  return HAL_SUCCESS;
 80058a6:	2300      	movs	r3, #0
}
 80058a8:	4618      	mov	r0, r3
 80058aa:	b007      	add	sp, #28
 80058ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80058b0:	fdffe008 	.word	0xfdffe008
 80058b4:	f3af 8000 	nop.w
 80058b8:	f3af 8000 	nop.w
 80058bc:	f3af 8000 	nop.w

080058c0 <detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 80058c0:	b500      	push	{lr}
 80058c2:	b083      	sub	sp, #12
 80058c4:	9001      	str	r0, [sp, #4]
 80058c6:	9100      	str	r1, [sp, #0]

  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 80058c8:	9b01      	ldr	r3, [sp, #4]
 80058ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80058cc:	f003 030f 	and.w	r3, r3, #15
 80058d0:	2b02      	cmp	r3, #2
 80058d2:	d105      	bne.n	80058e0 <detect_bus_clk+0x20>
    return mmc_detect_bus_clk(sdcp, clk);
 80058d4:	9801      	ldr	r0, [sp, #4]
 80058d6:	9900      	ldr	r1, [sp, #0]
 80058d8:	f7ff ffba 	bl	8005850 <mmc_detect_bus_clk>
 80058dc:	4603      	mov	r3, r0
 80058de:	e004      	b.n	80058ea <detect_bus_clk+0x2a>
  }
  return sdc_detect_bus_clk(sdcp, clk);
 80058e0:	9801      	ldr	r0, [sp, #4]
 80058e2:	9900      	ldr	r1, [sp, #0]
 80058e4:	f7ff ff34 	bl	8005750 <sdc_detect_bus_clk>
 80058e8:	4603      	mov	r3, r0
}
 80058ea:	4618      	mov	r0, r3
 80058ec:	b003      	add	sp, #12
 80058ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80058f2:	bf00      	nop
 80058f4:	f3af 8000 	nop.w
 80058f8:	f3af 8000 	nop.w
 80058fc:	f3af 8000 	nop.w

08005900 <sdc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_set_bus_width(SDCDriver *sdcp) {
 8005900:	b500      	push	{lr}
 8005902:	b085      	sub	sp, #20
 8005904:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 8005906:	9b01      	ldr	r3, [sp, #4]
 8005908:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800590a:	791b      	ldrb	r3, [r3, #4]
 800590c:	2b00      	cmp	r3, #0
 800590e:	d101      	bne.n	8005914 <sdc_set_bus_width+0x14>
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 8005910:	2300      	movs	r3, #0
 8005912:	e02c      	b.n	800596e <sdc_set_bus_width+0x6e>
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 8005914:	9b01      	ldr	r3, [sp, #4]
 8005916:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005918:	791b      	ldrb	r3, [r3, #4]
 800591a:	2b01      	cmp	r3, #1
 800591c:	d124      	bne.n	8005968 <sdc_set_bus_width+0x68>
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
 800591e:	9801      	ldr	r0, [sp, #4]
 8005920:	2101      	movs	r1, #1
 8005922:	f004 ff65 	bl	800a7f0 <sdc_lld_set_bus_mode>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8005926:	9b01      	ldr	r3, [sp, #4]
 8005928:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800592a:	ab03      	add	r3, sp, #12
 800592c:	9801      	ldr	r0, [sp, #4]
 800592e:	2137      	movs	r1, #55	; 0x37
 8005930:	f004 ffe6 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005934:	4603      	mov	r3, r0
 8005936:	2b00      	cmp	r3, #0
 8005938:	d104      	bne.n	8005944 <sdc_set_bus_width+0x44>
        MMCSD_R1_ERROR(resp[0])) {
 800593a:	9a03      	ldr	r2, [sp, #12]
 800593c:	4b0e      	ldr	r3, [pc, #56]	; (8005978 <sdc_set_bus_width+0x78>)
 800593e:	4013      	ands	r3, r2
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8005940:	2b00      	cmp	r3, #0
 8005942:	d001      	beq.n	8005948 <sdc_set_bus_width+0x48>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005944:	2301      	movs	r3, #1
 8005946:	e012      	b.n	800596e <sdc_set_bus_width+0x6e>
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8005948:	ab03      	add	r3, sp, #12
 800594a:	9801      	ldr	r0, [sp, #4]
 800594c:	2106      	movs	r1, #6
 800594e:	2202      	movs	r2, #2
 8005950:	f004 ffd6 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005954:	4603      	mov	r3, r0
 8005956:	2b00      	cmp	r3, #0
 8005958:	d104      	bne.n	8005964 <sdc_set_bus_width+0x64>
        MMCSD_R1_ERROR(resp[0])) {
 800595a:	9a03      	ldr	r2, [sp, #12]
 800595c:	4b06      	ldr	r3, [pc, #24]	; (8005978 <sdc_set_bus_width+0x78>)
 800595e:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8005960:	2b00      	cmp	r3, #0
 8005962:	d003      	beq.n	800596c <sdc_set_bus_width+0x6c>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005964:	2301      	movs	r3, #1
 8005966:	e002      	b.n	800596e <sdc_set_bus_width+0x6e>
    }
  }
  else {
    /* SD card does not support 8bit bus.*/
    return HAL_FAILED;
 8005968:	2301      	movs	r3, #1
 800596a:	e000      	b.n	800596e <sdc_set_bus_width+0x6e>
  }

  return HAL_SUCCESS;
 800596c:	2300      	movs	r3, #0
}
 800596e:	4618      	mov	r0, r3
 8005970:	b005      	add	sp, #20
 8005972:	f85d fb04 	ldr.w	pc, [sp], #4
 8005976:	bf00      	nop
 8005978:	fdffe008 	.word	0xfdffe008
 800597c:	f3af 8000 	nop.w

08005980 <mmc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_set_bus_width(SDCDriver *sdcp) {
 8005980:	b500      	push	{lr}
 8005982:	b085      	sub	sp, #20
 8005984:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 8005986:	2003      	movs	r0, #3
 8005988:	21b7      	movs	r1, #183	; 0xb7
 800598a:	2200      	movs	r2, #0
 800598c:	2300      	movs	r3, #0
 800598e:	f7ff fe57 	bl	8005640 <mmc_cmd6_construct>
 8005992:	9003      	str	r0, [sp, #12]

  switch(sdcp->config->bus_width){
 8005994:	9b01      	ldr	r3, [sp, #4]
 8005996:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005998:	791b      	ldrb	r3, [r3, #4]
 800599a:	2b01      	cmp	r3, #1
 800599c:	d006      	beq.n	80059ac <mmc_set_bus_width+0x2c>
 800599e:	2b02      	cmp	r3, #2
 80059a0:	d00c      	beq.n	80059bc <mmc_set_bus_width+0x3c>
 80059a2:	2b00      	cmp	r3, #0
 80059a4:	d000      	beq.n	80059a8 <mmc_set_bus_width+0x28>
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
    break;
  default:
    osalDbgAssert(false, "unexpected case");
    break;
 80059a6:	e011      	b.n	80059cc <mmc_set_bus_width+0x4c>
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);

  switch(sdcp->config->bus_width){
  case SDC_MODE_1BIT:
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 80059a8:	2300      	movs	r3, #0
 80059aa:	e027      	b.n	80059fc <mmc_set_bus_width+0x7c>
  case SDC_MODE_4BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 80059ac:	2003      	movs	r0, #3
 80059ae:	21b7      	movs	r1, #183	; 0xb7
 80059b0:	2201      	movs	r2, #1
 80059b2:	2300      	movs	r3, #0
 80059b4:	f7ff fe44 	bl	8005640 <mmc_cmd6_construct>
 80059b8:	9003      	str	r0, [sp, #12]
    break;
 80059ba:	e007      	b.n	80059cc <mmc_set_bus_width+0x4c>
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 80059bc:	2003      	movs	r0, #3
 80059be:	21b7      	movs	r1, #183	; 0xb7
 80059c0:	2202      	movs	r2, #2
 80059c2:	2300      	movs	r3, #0
 80059c4:	f7ff fe3c 	bl	8005640 <mmc_cmd6_construct>
 80059c8:	9003      	str	r0, [sp, #12]
    break;
 80059ca:	bf00      	nop
  default:
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
 80059cc:	9b01      	ldr	r3, [sp, #4]
 80059ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80059d0:	791b      	ldrb	r3, [r3, #4]
 80059d2:	9801      	ldr	r0, [sp, #4]
 80059d4:	4619      	mov	r1, r3
 80059d6:	f004 ff0b 	bl	800a7f0 <sdc_lld_set_bus_mode>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 80059da:	ab02      	add	r3, sp, #8
 80059dc:	9801      	ldr	r0, [sp, #4]
 80059de:	2106      	movs	r1, #6
 80059e0:	9a03      	ldr	r2, [sp, #12]
 80059e2:	f004 ff8d 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80059e6:	4603      	mov	r3, r0
 80059e8:	2b00      	cmp	r3, #0
 80059ea:	d104      	bne.n	80059f6 <mmc_set_bus_width+0x76>
      MMCSD_R1_ERROR(resp[0])) {
 80059ec:	9a02      	ldr	r2, [sp, #8]
 80059ee:	4b05      	ldr	r3, [pc, #20]	; (8005a04 <mmc_set_bus_width+0x84>)
 80059f0:	4013      	ands	r3, r2
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 80059f2:	2b00      	cmp	r3, #0
 80059f4:	d001      	beq.n	80059fa <mmc_set_bus_width+0x7a>
      MMCSD_R1_ERROR(resp[0])) {
    return HAL_FAILED;
 80059f6:	2301      	movs	r3, #1
 80059f8:	e000      	b.n	80059fc <mmc_set_bus_width+0x7c>
  }

  return HAL_SUCCESS;
 80059fa:	2300      	movs	r3, #0
}
 80059fc:	4618      	mov	r0, r3
 80059fe:	b005      	add	sp, #20
 8005a00:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a04:	fdffe008 	.word	0xfdffe008
 8005a08:	f3af 8000 	nop.w
 8005a0c:	f3af 8000 	nop.w

08005a10 <_sdc_wait_for_transfer_state>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8005a10:	b500      	push	{lr}
 8005a12:	b085      	sub	sp, #20
 8005a14:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8005a16:	9b01      	ldr	r3, [sp, #4]
 8005a18:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005a1a:	ab03      	add	r3, sp, #12
 8005a1c:	9801      	ldr	r0, [sp, #4]
 8005a1e:	210d      	movs	r1, #13
 8005a20:	f004 ff6e 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005a24:	4603      	mov	r3, r0
 8005a26:	2b00      	cmp	r3, #0
 8005a28:	d104      	bne.n	8005a34 <_sdc_wait_for_transfer_state+0x24>
                                   sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
 8005a2a:	9a03      	ldr	r2, [sp, #12]
 8005a2c:	4b0d      	ldr	r3, [pc, #52]	; (8005a64 <_sdc_wait_for_transfer_state+0x54>)
 8005a2e:	4013      	ands	r3, r2
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
                                   sdcp->rca, resp) ||
 8005a30:	2b00      	cmp	r3, #0
 8005a32:	d001      	beq.n	8005a38 <_sdc_wait_for_transfer_state+0x28>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005a34:	2301      	movs	r3, #1
 8005a36:	e011      	b.n	8005a5c <_sdc_wait_for_transfer_state+0x4c>
    }

    switch (MMCSD_R1_STS(resp[0])) {
 8005a38:	9b03      	ldr	r3, [sp, #12]
 8005a3a:	0a5b      	lsrs	r3, r3, #9
 8005a3c:	f003 030f 	and.w	r3, r3, #15
 8005a40:	2b04      	cmp	r3, #4
 8005a42:	d004      	beq.n	8005a4e <_sdc_wait_for_transfer_state+0x3e>
 8005a44:	2b04      	cmp	r3, #4
 8005a46:	d308      	bcc.n	8005a5a <_sdc_wait_for_transfer_state+0x4a>
 8005a48:	2b07      	cmp	r3, #7
 8005a4a:	d806      	bhi.n	8005a5a <_sdc_wait_for_transfer_state+0x4a>
 8005a4c:	e001      	b.n	8005a52 <_sdc_wait_for_transfer_state+0x42>
    case MMCSD_STS_TRAN:
      return HAL_SUCCESS;
 8005a4e:	2300      	movs	r3, #0
 8005a50:	e004      	b.n	8005a5c <_sdc_wait_for_transfer_state+0x4c>
    case MMCSD_STS_DATA:
    case MMCSD_STS_RCV:
    case MMCSD_STS_PRG:
#if SDC_NICE_WAITING == TRUE
      osalThreadSleepMilliseconds(1);
 8005a52:	2064      	movs	r0, #100	; 0x64
 8005a54:	f7ff fd04 	bl	8005460 <osalThreadSleep>
    default:
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
    }
  }
 8005a58:	e7dd      	b.n	8005a16 <_sdc_wait_for_transfer_state+0x6>
#endif
      continue;
    default:
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
 8005a5a:	2301      	movs	r3, #1
    }
  }
}
 8005a5c:	4618      	mov	r0, r3
 8005a5e:	b005      	add	sp, #20
 8005a60:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a64:	fdffe008 	.word	0xfdffe008
 8005a68:	f3af 8000 	nop.w
 8005a6c:	f3af 8000 	nop.w

08005a70 <sdcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdcInit(void) {
 8005a70:	b508      	push	{r3, lr}

  sdc_lld_init();
 8005a72:	f004 fded 	bl	800a650 <sdc_lld_init>
}
 8005a76:	bd08      	pop	{r3, pc}
 8005a78:	f3af 8000 	nop.w
 8005a7c:	f3af 8000 	nop.w

08005a80 <sdcObjectInit>:
 *
 * @param[out] sdcp     pointer to the @p SDCDriver object
 *
 * @init
 */
void sdcObjectInit(SDCDriver *sdcp) {
 8005a80:	b082      	sub	sp, #8
 8005a82:	9001      	str	r0, [sp, #4]

  sdcp->vmt      = &sdc_vmt;
 8005a84:	9b01      	ldr	r3, [sp, #4]
 8005a86:	4a08      	ldr	r2, [pc, #32]	; (8005aa8 <sdcObjectInit+0x28>)
 8005a88:	601a      	str	r2, [r3, #0]
  sdcp->state    = BLK_STOP;
 8005a8a:	9b01      	ldr	r3, [sp, #4]
 8005a8c:	2201      	movs	r2, #1
 8005a8e:	711a      	strb	r2, [r3, #4]
  sdcp->errors   = SDC_NO_ERROR;
 8005a90:	9b01      	ldr	r3, [sp, #4]
 8005a92:	2200      	movs	r2, #0
 8005a94:	635a      	str	r2, [r3, #52]	; 0x34
  sdcp->config   = NULL;
 8005a96:	9b01      	ldr	r3, [sp, #4]
 8005a98:	2200      	movs	r2, #0
 8005a9a:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->capacity = 0;
 8005a9c:	9b01      	ldr	r3, [sp, #4]
 8005a9e:	2200      	movs	r2, #0
 8005aa0:	629a      	str	r2, [r3, #40]	; 0x28
}
 8005aa2:	b002      	add	sp, #8
 8005aa4:	4770      	bx	lr
 8005aa6:	bf00      	nop
 8005aa8:	0801aa70 	.word	0x0801aa70
 8005aac:	f3af 8000 	nop.w

08005ab0 <sdcStart>:
 *                      the driver supports a default configuration or
 *                      requires no configuration
 *
 * @api
 */
void sdcStart(SDCDriver *sdcp, const SDCConfig *config) {
 8005ab0:	b500      	push	{lr}
 8005ab2:	b083      	sub	sp, #12
 8005ab4:	9001      	str	r0, [sp, #4]
 8005ab6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005ab8:	f7ff fcc2 	bl	8005440 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdcp->config = config;
 8005abc:	9b01      	ldr	r3, [sp, #4]
 8005abe:	9a00      	ldr	r2, [sp, #0]
 8005ac0:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_start(sdcp);
 8005ac2:	9801      	ldr	r0, [sp, #4]
 8005ac4:	f004 fddc 	bl	800a680 <sdc_lld_start>
  sdcp->state = BLK_ACTIVE;
 8005ac8:	9b01      	ldr	r3, [sp, #4]
 8005aca:	2202      	movs	r2, #2
 8005acc:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005ace:	f7ff fcbf 	bl	8005450 <osalSysUnlock>
}
 8005ad2:	b003      	add	sp, #12
 8005ad4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ad8:	f3af 8000 	nop.w
 8005adc:	f3af 8000 	nop.w

08005ae0 <sdcStop>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @api
 */
void sdcStop(SDCDriver *sdcp) {
 8005ae0:	b500      	push	{lr}
 8005ae2:	b083      	sub	sp, #12
 8005ae4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005ae6:	f7ff fcab 	bl	8005440 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdc_lld_stop(sdcp);
 8005aea:	9801      	ldr	r0, [sp, #4]
 8005aec:	f004 fe10 	bl	800a710 <sdc_lld_stop>
  sdcp->state = BLK_STOP;
 8005af0:	9b01      	ldr	r3, [sp, #4]
 8005af2:	2201      	movs	r2, #1
 8005af4:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005af6:	f7ff fcab 	bl	8005450 <osalSysUnlock>
}
 8005afa:	b003      	add	sp, #12
 8005afc:	f85d fb04 	ldr.w	pc, [sp], #4

08005b00 <sdcConnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcConnect(SDCDriver *sdcp) {
 8005b00:	b500      	push	{lr}
 8005b02:	b089      	sub	sp, #36	; 0x24
 8005b04:	9003      	str	r0, [sp, #12]
  uint32_t resp[1];
  sdcbusclk_t clk = SDC_CLK_25MHz;
 8005b06:	2300      	movs	r3, #0
 8005b08:	f88d 3017 	strb.w	r3, [sp, #23]
  osalDbgCheck(sdcp != NULL);
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");

  /* Connection procedure in progress.*/
  sdcp->state = BLK_CONNECTING;
 8005b0c:	9b03      	ldr	r3, [sp, #12]
 8005b0e:	2203      	movs	r2, #3
 8005b10:	711a      	strb	r2, [r3, #4]

  /* Card clock initialization.*/
  sdc_lld_start_clk(sdcp);
 8005b12:	9803      	ldr	r0, [sp, #12]
 8005b14:	f004 fe2c 	bl	800a770 <sdc_lld_start_clk>

  /* Enforces the initial card state.*/
  sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8005b18:	9803      	ldr	r0, [sp, #12]
 8005b1a:	2100      	movs	r1, #0
 8005b1c:	2200      	movs	r2, #0
 8005b1e:	f004 fe8f 	bl	800a840 <sdc_lld_send_cmd_none>

  /* Detect card type.*/
  if (HAL_FAILED == mode_detect(sdcp)) {
 8005b22:	9803      	ldr	r0, [sp, #12]
 8005b24:	f7ff fcac 	bl	8005480 <mode_detect>
 8005b28:	4603      	mov	r3, r0
 8005b2a:	2b00      	cmp	r3, #0
 8005b2c:	d000      	beq.n	8005b30 <sdcConnect+0x30>
    goto failed;
 8005b2e:	e0ba      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Perform specific initialization procedure.*/
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
 8005b30:	9b03      	ldr	r3, [sp, #12]
 8005b32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005b34:	f003 030f 	and.w	r3, r3, #15
 8005b38:	2b02      	cmp	r3, #2
 8005b3a:	d106      	bne.n	8005b4a <sdcConnect+0x4a>
    if (HAL_FAILED == mmc_init(sdcp)) {
 8005b3c:	9803      	ldr	r0, [sp, #12]
 8005b3e:	f7ff fcef 	bl	8005520 <mmc_init>
 8005b42:	4603      	mov	r3, r0
 8005b44:	2b00      	cmp	r3, #0
 8005b46:	d007      	beq.n	8005b58 <sdcConnect+0x58>
      goto failed;
 8005b48:	e0ad      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
  }
  else {
    if (HAL_FAILED == sdc_init(sdcp)) {
 8005b4a:	9803      	ldr	r0, [sp, #12]
 8005b4c:	f7ff fd20 	bl	8005590 <sdc_init>
 8005b50:	4603      	mov	r3, r0
 8005b52:	2b00      	cmp	r3, #0
 8005b54:	d000      	beq.n	8005b58 <sdcConnect+0x58>
      goto failed;
 8005b56:	e0a6      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
  }

  /* Reads CID.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
 8005b58:	9b03      	ldr	r3, [sp, #12]
 8005b5a:	3308      	adds	r3, #8
 8005b5c:	9803      	ldr	r0, [sp, #12]
 8005b5e:	2102      	movs	r1, #2
 8005b60:	2200      	movs	r2, #0
 8005b62:	f004 ff0d 	bl	800a980 <sdc_lld_send_cmd_long_crc>
 8005b66:	4603      	mov	r3, r0
 8005b68:	2b00      	cmp	r3, #0
 8005b6a:	d000      	beq.n	8005b6e <sdcConnect+0x6e>
    goto failed;
 8005b6c:	e09b      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Asks for the RCA.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
 8005b6e:	9b03      	ldr	r3, [sp, #12]
 8005b70:	3338      	adds	r3, #56	; 0x38
 8005b72:	9803      	ldr	r0, [sp, #12]
 8005b74:	2103      	movs	r1, #3
 8005b76:	2200      	movs	r2, #0
 8005b78:	f004 fec2 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005b7c:	4603      	mov	r3, r0
 8005b7e:	2b00      	cmp	r3, #0
 8005b80:	d000      	beq.n	8005b84 <sdcConnect+0x84>
                                 0, &sdcp->rca)) {
    goto failed;
 8005b82:	e090      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8005b84:	9b03      	ldr	r3, [sp, #12]
 8005b86:	6b9a      	ldr	r2, [r3, #56]	; 0x38
                                sdcp->rca, sdcp->csd)) {
 8005b88:	9b03      	ldr	r3, [sp, #12]
 8005b8a:	3318      	adds	r3, #24
                                 0, &sdcp->rca)) {
    goto failed;
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8005b8c:	9803      	ldr	r0, [sp, #12]
 8005b8e:	2109      	movs	r1, #9
 8005b90:	f004 fef6 	bl	800a980 <sdc_lld_send_cmd_long_crc>
 8005b94:	4603      	mov	r3, r0
 8005b96:	2b00      	cmp	r3, #0
 8005b98:	d000      	beq.n	8005b9c <sdcConnect+0x9c>
                                sdcp->rca, sdcp->csd)) {
    goto failed;
 8005b9a:	e084      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Selects the card for operations.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
 8005b9c:	9b03      	ldr	r3, [sp, #12]
 8005b9e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005ba0:	ab06      	add	r3, sp, #24
 8005ba2:	9803      	ldr	r0, [sp, #12]
 8005ba4:	2107      	movs	r1, #7
 8005ba6:	f004 feab 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005baa:	4603      	mov	r3, r0
 8005bac:	2b00      	cmp	r3, #0
 8005bae:	d000      	beq.n	8005bb2 <sdcConnect+0xb2>
                                 sdcp->rca, resp)) {
    goto failed;
 8005bb0:	e079      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Switches to high speed.*/
  if (HAL_SUCCESS != detect_bus_clk(sdcp, &clk)) {
 8005bb2:	f10d 0317 	add.w	r3, sp, #23
 8005bb6:	9803      	ldr	r0, [sp, #12]
 8005bb8:	4619      	mov	r1, r3
 8005bba:	f7ff fe81 	bl	80058c0 <detect_bus_clk>
 8005bbe:	4603      	mov	r3, r0
 8005bc0:	2b00      	cmp	r3, #0
 8005bc2:	d000      	beq.n	8005bc6 <sdcConnect+0xc6>
    goto failed;
 8005bc4:	e06f      	b.n	8005ca6 <sdcConnect+0x1a6>
  }
  sdc_lld_set_data_clk(sdcp, clk);
 8005bc6:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8005bca:	9803      	ldr	r0, [sp, #12]
 8005bcc:	4619      	mov	r1, r3
 8005bce:	f004 fdef 	bl	800a7b0 <sdc_lld_set_data_clk>

  /* Reads extended CSD if needed and possible.*/
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8005bd2:	9b03      	ldr	r3, [sp, #12]
 8005bd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005bd6:	f003 030f 	and.w	r3, r3, #15
 8005bda:	2b02      	cmp	r3, #2
 8005bdc:	d12e      	bne.n	8005c3c <sdcConnect+0x13c>

    /* The card is a MMC, checking if it is a large device.*/
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 8005bde:	9b03      	ldr	r3, [sp, #12]
 8005be0:	3318      	adds	r3, #24
 8005be2:	4618      	mov	r0, r3
 8005be4:	217f      	movs	r1, #127	; 0x7f
 8005be6:	227e      	movs	r2, #126	; 0x7e
 8005be8:	f7fe fd4a 	bl	8004680 <_mmcsd_get_slice>
 8005bec:	4603      	mov	r3, r0
 8005bee:	2b01      	cmp	r3, #1
 8005bf0:	d91b      	bls.n	8005c2a <sdcConnect+0x12a>
      uint8_t *ext_csd = sdcp->config->scratchpad;
 8005bf2:	9b03      	ldr	r3, [sp, #12]
 8005bf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005bf6:	681b      	ldr	r3, [r3, #0]
 8005bf8:	9307      	str	r3, [sp, #28]

      /* Size detection requires the buffer.*/
      if (NULL == ext_csd) {
 8005bfa:	9b07      	ldr	r3, [sp, #28]
 8005bfc:	2b00      	cmp	r3, #0
 8005bfe:	d100      	bne.n	8005c02 <sdcConnect+0x102>
        goto failed;
 8005c00:	e051      	b.n	8005ca6 <sdcConnect+0x1a6>
      }

      if(sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 8005c02:	2300      	movs	r3, #0
 8005c04:	9300      	str	r3, [sp, #0]
 8005c06:	9803      	ldr	r0, [sp, #12]
 8005c08:	9907      	ldr	r1, [sp, #28]
 8005c0a:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005c0e:	2308      	movs	r3, #8
 8005c10:	f004 ff06 	bl	800aa20 <sdc_lld_read_special>
 8005c14:	4603      	mov	r3, r0
 8005c16:	2b00      	cmp	r3, #0
 8005c18:	d000      	beq.n	8005c1c <sdcConnect+0x11c>
        goto failed;
 8005c1a:	e044      	b.n	8005ca6 <sdcConnect+0x1a6>
      }

      /* Capacity from the EXT_CSD.*/
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 8005c1c:	9807      	ldr	r0, [sp, #28]
 8005c1e:	f7fe fda7 	bl	8004770 <_mmcsd_get_capacity_ext>
 8005c22:	4602      	mov	r2, r0
 8005c24:	9b03      	ldr	r3, [sp, #12]
 8005c26:	629a      	str	r2, [r3, #40]	; 0x28
 8005c28:	e010      	b.n	8005c4c <sdcConnect+0x14c>
    }
    else {
      /* Capacity from the normal CSD.*/
      sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8005c2a:	9b03      	ldr	r3, [sp, #12]
 8005c2c:	3318      	adds	r3, #24
 8005c2e:	4618      	mov	r0, r3
 8005c30:	f7fe fd66 	bl	8004700 <_mmcsd_get_capacity>
 8005c34:	4602      	mov	r2, r0
 8005c36:	9b03      	ldr	r3, [sp, #12]
 8005c38:	629a      	str	r2, [r3, #40]	; 0x28
 8005c3a:	e007      	b.n	8005c4c <sdcConnect+0x14c>
    }
  }
  else {
    /* The card is an SDC, capacity from the normal CSD.*/
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8005c3c:	9b03      	ldr	r3, [sp, #12]
 8005c3e:	3318      	adds	r3, #24
 8005c40:	4618      	mov	r0, r3
 8005c42:	f7fe fd5d 	bl	8004700 <_mmcsd_get_capacity>
 8005c46:	4602      	mov	r2, r0
 8005c48:	9b03      	ldr	r3, [sp, #12]
 8005c4a:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
 8005c4c:	ab06      	add	r3, sp, #24
 8005c4e:	9803      	ldr	r0, [sp, #12]
 8005c50:	2110      	movs	r1, #16
 8005c52:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005c56:	f004 fe53 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005c5a:	4603      	mov	r3, r0
 8005c5c:	2b00      	cmp	r3, #0
 8005c5e:	d122      	bne.n	8005ca6 <sdcConnect+0x1a6>
                                 MMCSD_BLOCK_SIZE, resp) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005c60:	9a06      	ldr	r2, [sp, #24]
 8005c62:	4b16      	ldr	r3, [pc, #88]	; (8005cbc <sdcConnect+0x1bc>)
 8005c64:	4013      	ands	r3, r2
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
                                 MMCSD_BLOCK_SIZE, resp) ||
 8005c66:	2b00      	cmp	r3, #0
 8005c68:	d11d      	bne.n	8005ca6 <sdcConnect+0x1a6>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 8005c6a:	9b03      	ldr	r3, [sp, #12]
 8005c6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005c6e:	f003 030f 	and.w	r3, r3, #15
 8005c72:	2b01      	cmp	r3, #1
 8005c74:	d902      	bls.n	8005c7c <sdcConnect+0x17c>
 8005c76:	2b02      	cmp	r3, #2
 8005c78:	d008      	beq.n	8005c8c <sdcConnect+0x18c>
      goto failed;
    }
    break;
  default:
    /* Unknown type.*/
    goto failed;
 8005c7a:	e014      	b.n	8005ca6 <sdcConnect+0x1a6>

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
  case SDC_MODE_CARDTYPE_SDV11:
  case SDC_MODE_CARDTYPE_SDV20:
    if (HAL_FAILED == sdc_set_bus_width(sdcp)) {
 8005c7c:	9803      	ldr	r0, [sp, #12]
 8005c7e:	f7ff fe3f 	bl	8005900 <sdc_set_bus_width>
 8005c82:	4603      	mov	r3, r0
 8005c84:	2b00      	cmp	r3, #0
 8005c86:	d000      	beq.n	8005c8a <sdcConnect+0x18a>
      goto failed;
 8005c88:	e00d      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
    break;
 8005c8a:	e007      	b.n	8005c9c <sdcConnect+0x19c>
  case SDC_MODE_CARDTYPE_MMC:
    if (HAL_FAILED == mmc_set_bus_width(sdcp)) {
 8005c8c:	9803      	ldr	r0, [sp, #12]
 8005c8e:	f7ff fe77 	bl	8005980 <mmc_set_bus_width>
 8005c92:	4603      	mov	r3, r0
 8005c94:	2b00      	cmp	r3, #0
 8005c96:	d000      	beq.n	8005c9a <sdcConnect+0x19a>
      goto failed;
 8005c98:	e005      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
    break;
 8005c9a:	bf00      	nop
    /* Unknown type.*/
    goto failed;
  }

  /* Initialization complete.*/
  sdcp->state = BLK_READY;
 8005c9c:	9b03      	ldr	r3, [sp, #12]
 8005c9e:	2205      	movs	r2, #5
 8005ca0:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005ca2:	2300      	movs	r3, #0
 8005ca4:	e006      	b.n	8005cb4 <sdcConnect+0x1b4>

  /* Connection failed, state reset to BLK_ACTIVE.*/
failed:
  sdc_lld_stop_clk(sdcp);
 8005ca6:	9803      	ldr	r0, [sp, #12]
 8005ca8:	f004 fd92 	bl	800a7d0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8005cac:	9b03      	ldr	r3, [sp, #12]
 8005cae:	2202      	movs	r2, #2
 8005cb0:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 8005cb2:	2301      	movs	r3, #1
}
 8005cb4:	4618      	mov	r0, r3
 8005cb6:	b009      	add	sp, #36	; 0x24
 8005cb8:	f85d fb04 	ldr.w	pc, [sp], #4
 8005cbc:	fdffe008 	.word	0xfdffe008

08005cc0 <sdcDisconnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcDisconnect(SDCDriver *sdcp) {
 8005cc0:	b500      	push	{lr}
 8005cc2:	b083      	sub	sp, #12
 8005cc4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005cc6:	f7ff fbbb 	bl	8005440 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");
  if (sdcp->state == BLK_ACTIVE) {
 8005cca:	9b01      	ldr	r3, [sp, #4]
 8005ccc:	791b      	ldrb	r3, [r3, #4]
 8005cce:	2b02      	cmp	r3, #2
 8005cd0:	d103      	bne.n	8005cda <sdcDisconnect+0x1a>
    osalSysUnlock();
 8005cd2:	f7ff fbbd 	bl	8005450 <osalSysUnlock>
    return HAL_SUCCESS;
 8005cd6:	2300      	movs	r3, #0
 8005cd8:	e019      	b.n	8005d0e <sdcDisconnect+0x4e>
  }
  sdcp->state = BLK_DISCONNECTING;
 8005cda:	9b01      	ldr	r3, [sp, #4]
 8005cdc:	2204      	movs	r2, #4
 8005cde:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005ce0:	f7ff fbb6 	bl	8005450 <osalSysUnlock>

  /* Waits for eventual pending operations completion.*/
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005ce4:	9801      	ldr	r0, [sp, #4]
 8005ce6:	f7ff fe93 	bl	8005a10 <_sdc_wait_for_transfer_state>
 8005cea:	4603      	mov	r3, r0
 8005cec:	2b00      	cmp	r3, #0
 8005cee:	d007      	beq.n	8005d00 <sdcDisconnect+0x40>
    sdc_lld_stop_clk(sdcp);
 8005cf0:	9801      	ldr	r0, [sp, #4]
 8005cf2:	f004 fd6d 	bl	800a7d0 <sdc_lld_stop_clk>
    sdcp->state = BLK_ACTIVE;
 8005cf6:	9b01      	ldr	r3, [sp, #4]
 8005cf8:	2202      	movs	r2, #2
 8005cfa:	711a      	strb	r2, [r3, #4]
    return HAL_FAILED;
 8005cfc:	2301      	movs	r3, #1
 8005cfe:	e006      	b.n	8005d0e <sdcDisconnect+0x4e>
  }

  /* Card clock stopped.*/
  sdc_lld_stop_clk(sdcp);
 8005d00:	9801      	ldr	r0, [sp, #4]
 8005d02:	f004 fd65 	bl	800a7d0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8005d06:	9b01      	ldr	r3, [sp, #4]
 8005d08:	2202      	movs	r2, #2
 8005d0a:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005d0c:	2300      	movs	r3, #0
}
 8005d0e:	4618      	mov	r0, r3
 8005d10:	b003      	add	sp, #12
 8005d12:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d16:	bf00      	nop
 8005d18:	f3af 8000 	nop.w
 8005d1c:	f3af 8000 	nop.w

08005d20 <sdcRead>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8005d20:	b500      	push	{lr}
 8005d22:	b087      	sub	sp, #28
 8005d24:	9003      	str	r0, [sp, #12]
 8005d26:	9102      	str	r1, [sp, #8]
 8005d28:	9201      	str	r2, [sp, #4]
 8005d2a:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 8005d2c:	9a02      	ldr	r2, [sp, #8]
 8005d2e:	9b00      	ldr	r3, [sp, #0]
 8005d30:	4413      	add	r3, r2
 8005d32:	1e5a      	subs	r2, r3, #1
 8005d34:	9b03      	ldr	r3, [sp, #12]
 8005d36:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005d38:	429a      	cmp	r2, r3
 8005d3a:	d907      	bls.n	8005d4c <sdcRead+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8005d3c:	9b03      	ldr	r3, [sp, #12]
 8005d3e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005d40:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8005d44:	9b03      	ldr	r3, [sp, #12]
 8005d46:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 8005d48:	2301      	movs	r3, #1
 8005d4a:	e010      	b.n	8005d6e <sdcRead+0x4e>
  }

  /* Read operation in progress.*/
  sdcp->state = BLK_READING;
 8005d4c:	9b03      	ldr	r3, [sp, #12]
 8005d4e:	2206      	movs	r2, #6
 8005d50:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_read(sdcp, startblk, buf, n);
 8005d52:	9803      	ldr	r0, [sp, #12]
 8005d54:	9902      	ldr	r1, [sp, #8]
 8005d56:	9a01      	ldr	r2, [sp, #4]
 8005d58:	9b00      	ldr	r3, [sp, #0]
 8005d5a:	f004 ffb1 	bl	800acc0 <sdc_lld_read>
 8005d5e:	4603      	mov	r3, r0
 8005d60:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Read operation finished.*/
  sdcp->state = BLK_READY;
 8005d64:	9b03      	ldr	r3, [sp, #12]
 8005d66:	2205      	movs	r2, #5
 8005d68:	711a      	strb	r2, [r3, #4]
  return status;
 8005d6a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8005d6e:	4618      	mov	r0, r3
 8005d70:	b007      	add	sp, #28
 8005d72:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d76:	bf00      	nop
 8005d78:	f3af 8000 	nop.w
 8005d7c:	f3af 8000 	nop.w

08005d80 <sdcWrite>:
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcWrite(SDCDriver *sdcp, uint32_t startblk,
              const uint8_t *buf, uint32_t n) {
 8005d80:	b500      	push	{lr}
 8005d82:	b087      	sub	sp, #28
 8005d84:	9003      	str	r0, [sp, #12]
 8005d86:	9102      	str	r1, [sp, #8]
 8005d88:	9201      	str	r2, [sp, #4]
 8005d8a:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 8005d8c:	9a02      	ldr	r2, [sp, #8]
 8005d8e:	9b00      	ldr	r3, [sp, #0]
 8005d90:	4413      	add	r3, r2
 8005d92:	1e5a      	subs	r2, r3, #1
 8005d94:	9b03      	ldr	r3, [sp, #12]
 8005d96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005d98:	429a      	cmp	r2, r3
 8005d9a:	d907      	bls.n	8005dac <sdcWrite+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8005d9c:	9b03      	ldr	r3, [sp, #12]
 8005d9e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005da0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8005da4:	9b03      	ldr	r3, [sp, #12]
 8005da6:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 8005da8:	2301      	movs	r3, #1
 8005daa:	e010      	b.n	8005dce <sdcWrite+0x4e>
  }

  /* Write operation in progress.*/
  sdcp->state = BLK_WRITING;
 8005dac:	9b03      	ldr	r3, [sp, #12]
 8005dae:	2207      	movs	r2, #7
 8005db0:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_write(sdcp, startblk, buf, n);
 8005db2:	9803      	ldr	r0, [sp, #12]
 8005db4:	9902      	ldr	r1, [sp, #8]
 8005db6:	9a01      	ldr	r2, [sp, #4]
 8005db8:	9b00      	ldr	r3, [sp, #0]
 8005dba:	f004 ffc9 	bl	800ad50 <sdc_lld_write>
 8005dbe:	4603      	mov	r3, r0
 8005dc0:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Write operation finished.*/
  sdcp->state = BLK_READY;
 8005dc4:	9b03      	ldr	r3, [sp, #12]
 8005dc6:	2205      	movs	r2, #5
 8005dc8:	711a      	strb	r2, [r3, #4]
  return status;
 8005dca:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8005dce:	4618      	mov	r0, r3
 8005dd0:	b007      	add	sp, #28
 8005dd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005dd6:	bf00      	nop
 8005dd8:	f3af 8000 	nop.w
 8005ddc:	f3af 8000 	nop.w

08005de0 <sdcGetAndClearErrors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @return              The errors mask.
 *
 * @api
 */
sdcflags_t sdcGetAndClearErrors(SDCDriver *sdcp) {
 8005de0:	b500      	push	{lr}
 8005de2:	b085      	sub	sp, #20
 8005de4:	9001      	str	r0, [sp, #4]
  sdcflags_t flags;

  osalDbgCheck(sdcp != NULL);
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  osalSysLock();
 8005de6:	f7ff fb2b 	bl	8005440 <osalSysLock>
  flags = sdcp->errors;
 8005dea:	9b01      	ldr	r3, [sp, #4]
 8005dec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005dee:	9303      	str	r3, [sp, #12]
  sdcp->errors = SDC_NO_ERROR;
 8005df0:	9b01      	ldr	r3, [sp, #4]
 8005df2:	2200      	movs	r2, #0
 8005df4:	635a      	str	r2, [r3, #52]	; 0x34
  osalSysUnlock();
 8005df6:	f7ff fb2b 	bl	8005450 <osalSysUnlock>
  return flags;
 8005dfa:	9b03      	ldr	r3, [sp, #12]
}
 8005dfc:	4618      	mov	r0, r3
 8005dfe:	b005      	add	sp, #20
 8005e00:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e04:	f3af 8000 	nop.w
 8005e08:	f3af 8000 	nop.w
 8005e0c:	f3af 8000 	nop.w

08005e10 <sdcSync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcSync(SDCDriver *sdcp) {
 8005e10:	b500      	push	{lr}
 8005e12:	b085      	sub	sp, #20
 8005e14:	9001      	str	r0, [sp, #4]
  bool result;

  osalDbgCheck(sdcp != NULL);

  if (sdcp->state != BLK_READY) {
 8005e16:	9b01      	ldr	r3, [sp, #4]
 8005e18:	791b      	ldrb	r3, [r3, #4]
 8005e1a:	2b05      	cmp	r3, #5
 8005e1c:	d001      	beq.n	8005e22 <sdcSync+0x12>
    return HAL_FAILED;
 8005e1e:	2301      	movs	r3, #1
 8005e20:	e00d      	b.n	8005e3e <sdcSync+0x2e>
  }

  /* Synchronization operation in progress.*/
  sdcp->state = BLK_SYNCING;
 8005e22:	9b01      	ldr	r3, [sp, #4]
 8005e24:	2208      	movs	r2, #8
 8005e26:	711a      	strb	r2, [r3, #4]

  result = sdc_lld_sync(sdcp);
 8005e28:	9801      	ldr	r0, [sp, #4]
 8005e2a:	f004 ffd9 	bl	800ade0 <sdc_lld_sync>
 8005e2e:	4603      	mov	r3, r0
 8005e30:	f88d 300f 	strb.w	r3, [sp, #15]

  /* Synchronization operation finished.*/
  sdcp->state = BLK_READY;
 8005e34:	9b01      	ldr	r3, [sp, #4]
 8005e36:	2205      	movs	r2, #5
 8005e38:	711a      	strb	r2, [r3, #4]
  return result;
 8005e3a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8005e3e:	4618      	mov	r0, r3
 8005e40:	b005      	add	sp, #20
 8005e42:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e46:	bf00      	nop
 8005e48:	f3af 8000 	nop.w
 8005e4c:	f3af 8000 	nop.w

08005e50 <sdcGetInfo>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {
 8005e50:	b082      	sub	sp, #8
 8005e52:	9001      	str	r0, [sp, #4]
 8005e54:	9100      	str	r1, [sp, #0]

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
 8005e56:	9b01      	ldr	r3, [sp, #4]
 8005e58:	791b      	ldrb	r3, [r3, #4]
 8005e5a:	2b05      	cmp	r3, #5
 8005e5c:	d001      	beq.n	8005e62 <sdcGetInfo+0x12>
    return HAL_FAILED;
 8005e5e:	2301      	movs	r3, #1
 8005e60:	e008      	b.n	8005e74 <sdcGetInfo+0x24>
  }

  bdip->blk_num = sdcp->capacity;
 8005e62:	9b01      	ldr	r3, [sp, #4]
 8005e64:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005e66:	9b00      	ldr	r3, [sp, #0]
 8005e68:	605a      	str	r2, [r3, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 8005e6a:	9b00      	ldr	r3, [sp, #0]
 8005e6c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005e70:	601a      	str	r2, [r3, #0]

  return HAL_SUCCESS;
 8005e72:	2300      	movs	r3, #0
}
 8005e74:	4618      	mov	r0, r3
 8005e76:	b002      	add	sp, #8
 8005e78:	4770      	bx	lr
 8005e7a:	bf00      	nop
 8005e7c:	f3af 8000 	nop.w

08005e80 <sdcErase>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcErase(SDCDriver *sdcp, uint32_t startblk, uint32_t endblk) {
 8005e80:	b500      	push	{lr}
 8005e82:	b087      	sub	sp, #28
 8005e84:	9003      	str	r0, [sp, #12]
 8005e86:	9102      	str	r1, [sp, #8]
 8005e88:	9201      	str	r2, [sp, #4]

  osalDbgCheck((sdcp != NULL));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  /* Erase operation in progress.*/
  sdcp->state = BLK_WRITING;
 8005e8a:	9b03      	ldr	r3, [sp, #12]
 8005e8c:	2207      	movs	r2, #7
 8005e8e:	711a      	strb	r2, [r3, #4]

  /* Handling command differences between HC and normal cards.*/
  if ((sdcp->cardmode & SDC_MODE_HIGH_CAPACITY) != 0U) {
 8005e90:	9b03      	ldr	r3, [sp, #12]
 8005e92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005e94:	f003 0310 	and.w	r3, r3, #16
 8005e98:	2b00      	cmp	r3, #0
 8005e9a:	d005      	beq.n	8005ea8 <sdcErase+0x28>
    startblk *= MMCSD_BLOCK_SIZE;
 8005e9c:	9b02      	ldr	r3, [sp, #8]
 8005e9e:	025b      	lsls	r3, r3, #9
 8005ea0:	9302      	str	r3, [sp, #8]
    endblk *= MMCSD_BLOCK_SIZE;
 8005ea2:	9b01      	ldr	r3, [sp, #4]
 8005ea4:	025b      	lsls	r3, r3, #9
 8005ea6:	9301      	str	r3, [sp, #4]
  }

  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005ea8:	9803      	ldr	r0, [sp, #12]
 8005eaa:	f7ff fdb1 	bl	8005a10 <_sdc_wait_for_transfer_state>
 8005eae:	4603      	mov	r3, r0
 8005eb0:	2b00      	cmp	r3, #0
 8005eb2:	d000      	beq.n	8005eb6 <sdcErase+0x36>
    goto failed;
 8005eb4:	e035      	b.n	8005f22 <sdcErase+0xa2>
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_START,
 8005eb6:	ab05      	add	r3, sp, #20
 8005eb8:	9803      	ldr	r0, [sp, #12]
 8005eba:	2120      	movs	r1, #32
 8005ebc:	9a02      	ldr	r2, [sp, #8]
 8005ebe:	f004 fd1f 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005ec2:	4603      	mov	r3, r0
 8005ec4:	2b00      	cmp	r3, #0
 8005ec6:	d12c      	bne.n	8005f22 <sdcErase+0xa2>
                                  startblk, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005ec8:	9a05      	ldr	r2, [sp, #20]
 8005eca:	4b1a      	ldr	r3, [pc, #104]	; (8005f34 <sdcErase+0xb4>)
 8005ecc:	4013      	ands	r3, r2
  if (_sdc_wait_for_transfer_state(sdcp)) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_START,
                                  startblk, resp) != HAL_SUCCESS) ||
 8005ece:	2b00      	cmp	r3, #0
 8005ed0:	d127      	bne.n	8005f22 <sdcErase+0xa2>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_END,
 8005ed2:	ab05      	add	r3, sp, #20
 8005ed4:	9803      	ldr	r0, [sp, #12]
 8005ed6:	2121      	movs	r1, #33	; 0x21
 8005ed8:	9a01      	ldr	r2, [sp, #4]
 8005eda:	f004 fd11 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005ede:	4603      	mov	r3, r0
 8005ee0:	2b00      	cmp	r3, #0
 8005ee2:	d11e      	bne.n	8005f22 <sdcErase+0xa2>
                                  endblk, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005ee4:	9a05      	ldr	r2, [sp, #20]
 8005ee6:	4b13      	ldr	r3, [pc, #76]	; (8005f34 <sdcErase+0xb4>)
 8005ee8:	4013      	ands	r3, r2
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_END,
                                  endblk, resp) != HAL_SUCCESS) ||
 8005eea:	2b00      	cmp	r3, #0
 8005eec:	d119      	bne.n	8005f22 <sdcErase+0xa2>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE,
 8005eee:	ab05      	add	r3, sp, #20
 8005ef0:	9803      	ldr	r0, [sp, #12]
 8005ef2:	2126      	movs	r1, #38	; 0x26
 8005ef4:	2200      	movs	r2, #0
 8005ef6:	f004 fd03 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005efa:	4603      	mov	r3, r0
 8005efc:	2b00      	cmp	r3, #0
 8005efe:	d110      	bne.n	8005f22 <sdcErase+0xa2>
                                  0, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005f00:	9a05      	ldr	r2, [sp, #20]
 8005f02:	4b0c      	ldr	r3, [pc, #48]	; (8005f34 <sdcErase+0xb4>)
 8005f04:	4013      	ands	r3, r2
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE,
                                  0, resp) != HAL_SUCCESS) ||
 8005f06:	2b00      	cmp	r3, #0
 8005f08:	d10b      	bne.n	8005f22 <sdcErase+0xa2>

  /* Quick sleep to allow it to transition to programming or receiving state */
  /* TODO: ??????????????????????????? */

  /* Wait for it to return to transfer state to indicate it has finished erasing */
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005f0a:	9803      	ldr	r0, [sp, #12]
 8005f0c:	f7ff fd80 	bl	8005a10 <_sdc_wait_for_transfer_state>
 8005f10:	4603      	mov	r3, r0
 8005f12:	2b00      	cmp	r3, #0
 8005f14:	d000      	beq.n	8005f18 <sdcErase+0x98>
    goto failed;
 8005f16:	e004      	b.n	8005f22 <sdcErase+0xa2>
  }

  sdcp->state = BLK_READY;
 8005f18:	9b03      	ldr	r3, [sp, #12]
 8005f1a:	2205      	movs	r2, #5
 8005f1c:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005f1e:	2300      	movs	r3, #0
 8005f20:	e003      	b.n	8005f2a <sdcErase+0xaa>

failed:
  sdcp->state = BLK_READY;
 8005f22:	9b03      	ldr	r3, [sp, #12]
 8005f24:	2205      	movs	r2, #5
 8005f26:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 8005f28:	2301      	movs	r3, #1
}
 8005f2a:	4618      	mov	r0, r3
 8005f2c:	b007      	add	sp, #28
 8005f2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f32:	bf00      	nop
 8005f34:	fdffe008 	.word	0xfdffe008
 8005f38:	f3af 8000 	nop.w
 8005f3c:	f3af 8000 	nop.w

08005f40 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005f40:	b082      	sub	sp, #8
 8005f42:	2320      	movs	r3, #32
 8005f44:	9301      	str	r3, [sp, #4]
 8005f46:	9b01      	ldr	r3, [sp, #4]
 8005f48:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005f4c:	b002      	add	sp, #8
 8005f4e:	4770      	bx	lr

08005f50 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005f50:	b082      	sub	sp, #8
 8005f52:	2300      	movs	r3, #0
 8005f54:	9301      	str	r3, [sp, #4]
 8005f56:	9b01      	ldr	r3, [sp, #4]
 8005f58:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005f5c:	b002      	add	sp, #8
 8005f5e:	4770      	bx	lr

08005f60 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005f60:	b508      	push	{r3, lr}

  port_lock();
 8005f62:	f7ff ffed 	bl	8005f40 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005f66:	bd08      	pop	{r3, pc}
 8005f68:	f3af 8000 	nop.w
 8005f6c:	f3af 8000 	nop.w

08005f70 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005f70:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005f72:	f7ff ffed 	bl	8005f50 <port_unlock>
}
 8005f76:	bd08      	pop	{r3, pc}
 8005f78:	f3af 8000 	nop.w
 8005f7c:	f3af 8000 	nop.w

08005f80 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8005f80:	b082      	sub	sp, #8
 8005f82:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8005f84:	9b01      	ldr	r3, [sp, #4]
 8005f86:	9a01      	ldr	r2, [sp, #4]
 8005f88:	601a      	str	r2, [r3, #0]
}
 8005f8a:	b002      	add	sp, #8
 8005f8c:	4770      	bx	lr
 8005f8e:	bf00      	nop

08005f90 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8005f90:	b082      	sub	sp, #8
 8005f92:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8005f94:	9b01      	ldr	r3, [sp, #4]
 8005f96:	689b      	ldr	r3, [r3, #8]
 8005f98:	2b00      	cmp	r3, #0
 8005f9a:	bf14      	ite	ne
 8005f9c:	2300      	movne	r3, #0
 8005f9e:	2301      	moveq	r3, #1
 8005fa0:	b2db      	uxtb	r3, r3
}
 8005fa2:	4618      	mov	r0, r3
 8005fa4:	b002      	add	sp, #8
 8005fa6:	4770      	bx	lr
 8005fa8:	f3af 8000 	nop.w
 8005fac:	f3af 8000 	nop.w

08005fb0 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8005fb0:	b082      	sub	sp, #8
 8005fb2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8005fb4:	9b01      	ldr	r3, [sp, #4]
 8005fb6:	689b      	ldr	r3, [r3, #8]
 8005fb8:	2b00      	cmp	r3, #0
 8005fba:	bf14      	ite	ne
 8005fbc:	2300      	movne	r3, #0
 8005fbe:	2301      	moveq	r3, #1
 8005fc0:	b2db      	uxtb	r3, r3
}
 8005fc2:	4618      	mov	r0, r3
 8005fc4:	b002      	add	sp, #8
 8005fc6:	4770      	bx	lr
 8005fc8:	f3af 8000 	nop.w
 8005fcc:	f3af 8000 	nop.w

08005fd0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8005fd0:	b508      	push	{r3, lr}

  chSysLock();
 8005fd2:	f7ff ffc5 	bl	8005f60 <chSysLock>
}
 8005fd6:	bd08      	pop	{r3, pc}
 8005fd8:	f3af 8000 	nop.w
 8005fdc:	f3af 8000 	nop.w

08005fe0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8005fe0:	b508      	push	{r3, lr}

  chSysUnlock();
 8005fe2:	f7ff ffc5 	bl	8005f70 <chSysUnlock>
}
 8005fe6:	bd08      	pop	{r3, pc}
 8005fe8:	f3af 8000 	nop.w
 8005fec:	f3af 8000 	nop.w

08005ff0 <osalOsRescheduleS>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 8005ff0:	b508      	push	{r3, lr}

  chSchRescheduleS();
 8005ff2:	f7fa fec5 	bl	8000d80 <chSchRescheduleS>
}
 8005ff6:	bd08      	pop	{r3, pc}
 8005ff8:	f3af 8000 	nop.w
 8005ffc:	f3af 8000 	nop.w

08006000 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8006000:	b500      	push	{lr}
 8006002:	b083      	sub	sp, #12
 8006004:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8006006:	9801      	ldr	r0, [sp, #4]
 8006008:	f7ff ffba 	bl	8005f80 <chEvtObjectInit>
}
 800600c:	b003      	add	sp, #12
 800600e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006012:	bf00      	nop
 8006014:	f3af 8000 	nop.w
 8006018:	f3af 8000 	nop.w
 800601c:	f3af 8000 	nop.w

08006020 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8006020:	b500      	push	{lr}
 8006022:	b083      	sub	sp, #12
 8006024:	9001      	str	r0, [sp, #4]
 8006026:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8006028:	9801      	ldr	r0, [sp, #4]
 800602a:	9900      	ldr	r1, [sp, #0]
 800602c:	f7fc fb28 	bl	8002680 <chEvtBroadcastFlagsI>
}
 8006030:	b003      	add	sp, #12
 8006032:	f85d fb04 	ldr.w	pc, [sp], #4
 8006036:	bf00      	nop
 8006038:	f3af 8000 	nop.w
 800603c:	f3af 8000 	nop.w

08006040 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8006040:	b500      	push	{lr}
 8006042:	b085      	sub	sp, #20
 8006044:	9003      	str	r0, [sp, #12]
 8006046:	9102      	str	r1, [sp, #8]
 8006048:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800604a:	9b03      	ldr	r3, [sp, #12]
 800604c:	3330      	adds	r3, #48	; 0x30
 800604e:	4618      	mov	r0, r3
 8006050:	9902      	ldr	r1, [sp, #8]
 8006052:	9a01      	ldr	r2, [sp, #4]
 8006054:	f04f 33ff 	mov.w	r3, #4294967295
 8006058:	f7fd fa72 	bl	8003540 <chOQWriteTimeout>
 800605c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800605e:	4618      	mov	r0, r3
 8006060:	b005      	add	sp, #20
 8006062:	f85d fb04 	ldr.w	pc, [sp], #4
 8006066:	bf00      	nop
 8006068:	f3af 8000 	nop.w
 800606c:	f3af 8000 	nop.w

08006070 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8006070:	b500      	push	{lr}
 8006072:	b085      	sub	sp, #20
 8006074:	9003      	str	r0, [sp, #12]
 8006076:	9102      	str	r1, [sp, #8]
 8006078:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800607a:	9b03      	ldr	r3, [sp, #12]
 800607c:	330c      	adds	r3, #12
 800607e:	4618      	mov	r0, r3
 8006080:	9902      	ldr	r1, [sp, #8]
 8006082:	9a01      	ldr	r2, [sp, #4]
 8006084:	f04f 33ff 	mov.w	r3, #4294967295
 8006088:	f7fd f942 	bl	8003310 <chIQReadTimeout>
 800608c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 800608e:	4618      	mov	r0, r3
 8006090:	b005      	add	sp, #20
 8006092:	f85d fb04 	ldr.w	pc, [sp], #4
 8006096:	bf00      	nop
 8006098:	f3af 8000 	nop.w
 800609c:	f3af 8000 	nop.w

080060a0 <put>:

static msg_t put(void *ip, uint8_t b) {
 80060a0:	b500      	push	{lr}
 80060a2:	b083      	sub	sp, #12
 80060a4:	9001      	str	r0, [sp, #4]
 80060a6:	460b      	mov	r3, r1
 80060a8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80060ac:	9b01      	ldr	r3, [sp, #4]
 80060ae:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80060b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80060b6:	4610      	mov	r0, r2
 80060b8:	4619      	mov	r1, r3
 80060ba:	f04f 32ff 	mov.w	r2, #4294967295
 80060be:	f7fd f9c7 	bl	8003450 <chOQPutTimeout>
 80060c2:	4603      	mov	r3, r0
}
 80060c4:	4618      	mov	r0, r3
 80060c6:	b003      	add	sp, #12
 80060c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80060cc:	f3af 8000 	nop.w

080060d0 <get>:

static msg_t get(void *ip) {
 80060d0:	b500      	push	{lr}
 80060d2:	b083      	sub	sp, #12
 80060d4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80060d6:	9b01      	ldr	r3, [sp, #4]
 80060d8:	330c      	adds	r3, #12
 80060da:	4618      	mov	r0, r3
 80060dc:	f04f 31ff 	mov.w	r1, #4294967295
 80060e0:	f7fd f8ce 	bl	8003280 <chIQGetTimeout>
 80060e4:	4603      	mov	r3, r0
}
 80060e6:	4618      	mov	r0, r3
 80060e8:	b003      	add	sp, #12
 80060ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80060ee:	bf00      	nop

080060f0 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80060f0:	b500      	push	{lr}
 80060f2:	b085      	sub	sp, #20
 80060f4:	9003      	str	r0, [sp, #12]
 80060f6:	460b      	mov	r3, r1
 80060f8:	9201      	str	r2, [sp, #4]
 80060fa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80060fe:	9b03      	ldr	r3, [sp, #12]
 8006100:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8006104:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006108:	4610      	mov	r0, r2
 800610a:	4619      	mov	r1, r3
 800610c:	9a01      	ldr	r2, [sp, #4]
 800610e:	f7fd f99f 	bl	8003450 <chOQPutTimeout>
 8006112:	4603      	mov	r3, r0
}
 8006114:	4618      	mov	r0, r3
 8006116:	b005      	add	sp, #20
 8006118:	f85d fb04 	ldr.w	pc, [sp], #4
 800611c:	f3af 8000 	nop.w

08006120 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
 8006120:	b500      	push	{lr}
 8006122:	b083      	sub	sp, #12
 8006124:	9001      	str	r0, [sp, #4]
 8006126:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8006128:	9b01      	ldr	r3, [sp, #4]
 800612a:	330c      	adds	r3, #12
 800612c:	4618      	mov	r0, r3
 800612e:	9900      	ldr	r1, [sp, #0]
 8006130:	f7fd f8a6 	bl	8003280 <chIQGetTimeout>
 8006134:	4603      	mov	r3, r0
}
 8006136:	4618      	mov	r0, r3
 8006138:	b003      	add	sp, #12
 800613a:	f85d fb04 	ldr.w	pc, [sp], #4
 800613e:	bf00      	nop

08006140 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8006140:	b500      	push	{lr}
 8006142:	b085      	sub	sp, #20
 8006144:	9003      	str	r0, [sp, #12]
 8006146:	9102      	str	r1, [sp, #8]
 8006148:	9201      	str	r2, [sp, #4]
 800614a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800614c:	9b03      	ldr	r3, [sp, #12]
 800614e:	3330      	adds	r3, #48	; 0x30
 8006150:	4618      	mov	r0, r3
 8006152:	9902      	ldr	r1, [sp, #8]
 8006154:	9a01      	ldr	r2, [sp, #4]
 8006156:	9b00      	ldr	r3, [sp, #0]
 8006158:	f7fd f9f2 	bl	8003540 <chOQWriteTimeout>
 800615c:	4603      	mov	r3, r0
}
 800615e:	4618      	mov	r0, r3
 8006160:	b005      	add	sp, #20
 8006162:	f85d fb04 	ldr.w	pc, [sp], #4
 8006166:	bf00      	nop
 8006168:	f3af 8000 	nop.w
 800616c:	f3af 8000 	nop.w

08006170 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8006170:	b500      	push	{lr}
 8006172:	b085      	sub	sp, #20
 8006174:	9003      	str	r0, [sp, #12]
 8006176:	9102      	str	r1, [sp, #8]
 8006178:	9201      	str	r2, [sp, #4]
 800617a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800617c:	9b03      	ldr	r3, [sp, #12]
 800617e:	330c      	adds	r3, #12
 8006180:	4618      	mov	r0, r3
 8006182:	9902      	ldr	r1, [sp, #8]
 8006184:	9a01      	ldr	r2, [sp, #4]
 8006186:	9b00      	ldr	r3, [sp, #0]
 8006188:	f7fd f8c2 	bl	8003310 <chIQReadTimeout>
 800618c:	4603      	mov	r3, r0
}
 800618e:	4618      	mov	r0, r3
 8006190:	b005      	add	sp, #20
 8006192:	f85d fb04 	ldr.w	pc, [sp], #4
 8006196:	bf00      	nop
 8006198:	f3af 8000 	nop.w
 800619c:	f3af 8000 	nop.w

080061a0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80061a0:	b508      	push	{r3, lr}

  sd_lld_init();
 80061a2:	f005 fc3d 	bl	800ba20 <sd_lld_init>
}
 80061a6:	bd08      	pop	{r3, pc}
 80061a8:	f3af 8000 	nop.w
 80061ac:	f3af 8000 	nop.w

080061b0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80061b0:	b500      	push	{lr}
 80061b2:	b087      	sub	sp, #28
 80061b4:	9005      	str	r0, [sp, #20]
 80061b6:	9104      	str	r1, [sp, #16]
 80061b8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 80061ba:	9b05      	ldr	r3, [sp, #20]
 80061bc:	4a13      	ldr	r2, [pc, #76]	; (800620c <sdObjectInit+0x5c>)
 80061be:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 80061c0:	9b05      	ldr	r3, [sp, #20]
 80061c2:	3304      	adds	r3, #4
 80061c4:	4618      	mov	r0, r3
 80061c6:	f7ff ff1b 	bl	8006000 <osalEventObjectInit>
  sdp->state = SD_STOP;
 80061ca:	9b05      	ldr	r3, [sp, #20]
 80061cc:	2201      	movs	r2, #1
 80061ce:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80061d0:	9b05      	ldr	r3, [sp, #20]
 80061d2:	f103 020c 	add.w	r2, r3, #12
 80061d6:	9b05      	ldr	r3, [sp, #20]
 80061d8:	3354      	adds	r3, #84	; 0x54
 80061da:	9905      	ldr	r1, [sp, #20]
 80061dc:	9100      	str	r1, [sp, #0]
 80061de:	4610      	mov	r0, r2
 80061e0:	4619      	mov	r1, r3
 80061e2:	2210      	movs	r2, #16
 80061e4:	9b04      	ldr	r3, [sp, #16]
 80061e6:	f7fc ffdb 	bl	80031a0 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80061ea:	9b05      	ldr	r3, [sp, #20]
 80061ec:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80061f0:	9b05      	ldr	r3, [sp, #20]
 80061f2:	3364      	adds	r3, #100	; 0x64
 80061f4:	9905      	ldr	r1, [sp, #20]
 80061f6:	9100      	str	r1, [sp, #0]
 80061f8:	4610      	mov	r0, r2
 80061fa:	4619      	mov	r1, r3
 80061fc:	2210      	movs	r2, #16
 80061fe:	9b03      	ldr	r3, [sp, #12]
 8006200:	f7fd f8de 	bl	80033c0 <chOQObjectInit>
}
 8006204:	b007      	add	sp, #28
 8006206:	f85d fb04 	ldr.w	pc, [sp], #4
 800620a:	bf00      	nop
 800620c:	0801aa90 	.word	0x0801aa90

08006210 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8006210:	b500      	push	{lr}
 8006212:	b083      	sub	sp, #12
 8006214:	9001      	str	r0, [sp, #4]
 8006216:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8006218:	f7ff feda 	bl	8005fd0 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 800621c:	9801      	ldr	r0, [sp, #4]
 800621e:	9900      	ldr	r1, [sp, #0]
 8006220:	f005 fc1e 	bl	800ba60 <sd_lld_start>
  sdp->state = SD_READY;
 8006224:	9b01      	ldr	r3, [sp, #4]
 8006226:	2202      	movs	r2, #2
 8006228:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800622a:	f7ff fed9 	bl	8005fe0 <osalSysUnlock>
}
 800622e:	b003      	add	sp, #12
 8006230:	f85d fb04 	ldr.w	pc, [sp], #4
 8006234:	f3af 8000 	nop.w
 8006238:	f3af 8000 	nop.w
 800623c:	f3af 8000 	nop.w

08006240 <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
 8006240:	b500      	push	{lr}
 8006242:	b083      	sub	sp, #12
 8006244:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8006246:	f7ff fec3 	bl	8005fd0 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_stop(sdp);
 800624a:	9801      	ldr	r0, [sp, #4]
 800624c:	f005 fc30 	bl	800bab0 <sd_lld_stop>
  sdp->state = SD_STOP;
 8006250:	9b01      	ldr	r3, [sp, #4]
 8006252:	2201      	movs	r2, #1
 8006254:	721a      	strb	r2, [r3, #8]
  oqResetI(&sdp->oqueue);
 8006256:	9b01      	ldr	r3, [sp, #4]
 8006258:	3330      	adds	r3, #48	; 0x30
 800625a:	4618      	mov	r0, r3
 800625c:	f7fd f8d8 	bl	8003410 <chOQResetI>
  iqResetI(&sdp->iqueue);
 8006260:	9b01      	ldr	r3, [sp, #4]
 8006262:	330c      	adds	r3, #12
 8006264:	4618      	mov	r0, r3
 8006266:	f7fc ffc3 	bl	80031f0 <chIQResetI>
  osalOsRescheduleS();
 800626a:	f7ff fec1 	bl	8005ff0 <osalOsRescheduleS>
  osalSysUnlock();
 800626e:	f7ff feb7 	bl	8005fe0 <osalSysUnlock>
}
 8006272:	b003      	add	sp, #12
 8006274:	f85d fb04 	ldr.w	pc, [sp], #4
 8006278:	f3af 8000 	nop.w
 800627c:	f3af 8000 	nop.w

08006280 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8006280:	b500      	push	{lr}
 8006282:	b083      	sub	sp, #12
 8006284:	9001      	str	r0, [sp, #4]
 8006286:	460b      	mov	r3, r1
 8006288:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800628c:	9b01      	ldr	r3, [sp, #4]
 800628e:	330c      	adds	r3, #12
 8006290:	4618      	mov	r0, r3
 8006292:	f7ff fe7d 	bl	8005f90 <chIQIsEmptyI>
 8006296:	4603      	mov	r3, r0
 8006298:	2b00      	cmp	r3, #0
 800629a:	d005      	beq.n	80062a8 <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800629c:	9b01      	ldr	r3, [sp, #4]
 800629e:	3304      	adds	r3, #4
 80062a0:	4618      	mov	r0, r3
 80062a2:	2104      	movs	r1, #4
 80062a4:	f7ff febc 	bl	8006020 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 80062a8:	9b01      	ldr	r3, [sp, #4]
 80062aa:	f103 020c 	add.w	r2, r3, #12
 80062ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80062b2:	4610      	mov	r0, r2
 80062b4:	4619      	mov	r1, r3
 80062b6:	f7fc ffb3 	bl	8003220 <chIQPutI>
 80062ba:	4603      	mov	r3, r0
 80062bc:	2b00      	cmp	r3, #0
 80062be:	da05      	bge.n	80062cc <sdIncomingDataI+0x4c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80062c0:	9b01      	ldr	r3, [sp, #4]
 80062c2:	3304      	adds	r3, #4
 80062c4:	4618      	mov	r0, r3
 80062c6:	2180      	movs	r1, #128	; 0x80
 80062c8:	f7ff feaa 	bl	8006020 <osalEventBroadcastFlagsI>
}
 80062cc:	b003      	add	sp, #12
 80062ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80062d2:	bf00      	nop
 80062d4:	f3af 8000 	nop.w
 80062d8:	f3af 8000 	nop.w
 80062dc:	f3af 8000 	nop.w

080062e0 <sdRequestDataI>:
 * @retval Q_EMPTY      if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
 80062e0:	b500      	push	{lr}
 80062e2:	b085      	sub	sp, #20
 80062e4:	9001      	str	r0, [sp, #4]
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
 80062e6:	9b01      	ldr	r3, [sp, #4]
 80062e8:	3330      	adds	r3, #48	; 0x30
 80062ea:	4618      	mov	r0, r3
 80062ec:	f7fd f8f8 	bl	80034e0 <chOQGetI>
 80062f0:	9003      	str	r0, [sp, #12]
  if (b < Q_OK)
 80062f2:	9b03      	ldr	r3, [sp, #12]
 80062f4:	2b00      	cmp	r3, #0
 80062f6:	da05      	bge.n	8006304 <sdRequestDataI+0x24>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 80062f8:	9b01      	ldr	r3, [sp, #4]
 80062fa:	3304      	adds	r3, #4
 80062fc:	4618      	mov	r0, r3
 80062fe:	2108      	movs	r1, #8
 8006300:	f7ff fe8e 	bl	8006020 <osalEventBroadcastFlagsI>
  return b;
 8006304:	9b03      	ldr	r3, [sp, #12]
}
 8006306:	4618      	mov	r0, r3
 8006308:	b005      	add	sp, #20
 800630a:	f85d fb04 	ldr.w	pc, [sp], #4
 800630e:	bf00      	nop

08006310 <sdPutWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdPutWouldBlock(SerialDriver *sdp) {
 8006310:	b500      	push	{lr}
 8006312:	b085      	sub	sp, #20
 8006314:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8006316:	f7ff fe5b 	bl	8005fd0 <osalSysLock>
  b = oqIsFullI(&sdp->oqueue);
 800631a:	9b01      	ldr	r3, [sp, #4]
 800631c:	3330      	adds	r3, #48	; 0x30
 800631e:	4618      	mov	r0, r3
 8006320:	f7ff fe46 	bl	8005fb0 <chOQIsFullI>
 8006324:	4603      	mov	r3, r0
 8006326:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 800632a:	f7ff fe59 	bl	8005fe0 <osalSysUnlock>

  return b;
 800632e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8006332:	4618      	mov	r0, r3
 8006334:	b005      	add	sp, #20
 8006336:	f85d fb04 	ldr.w	pc, [sp], #4
 800633a:	bf00      	nop
 800633c:	f3af 8000 	nop.w

08006340 <sdGetWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdGetWouldBlock(SerialDriver *sdp) {
 8006340:	b500      	push	{lr}
 8006342:	b085      	sub	sp, #20
 8006344:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8006346:	f7ff fe43 	bl	8005fd0 <osalSysLock>
  b = iqIsEmptyI(&sdp->iqueue);
 800634a:	9b01      	ldr	r3, [sp, #4]
 800634c:	330c      	adds	r3, #12
 800634e:	4618      	mov	r0, r3
 8006350:	f7ff fe1e 	bl	8005f90 <chIQIsEmptyI>
 8006354:	4603      	mov	r3, r0
 8006356:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 800635a:	f7ff fe41 	bl	8005fe0 <osalSysUnlock>

  return b;
 800635e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8006362:	4618      	mov	r0, r3
 8006364:	b005      	add	sp, #20
 8006366:	f85d fb04 	ldr.w	pc, [sp], #4
 800636a:	bf00      	nop
 800636c:	f3af 8000 	nop.w

08006370 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006370:	b082      	sub	sp, #8
 8006372:	2320      	movs	r3, #32
 8006374:	9301      	str	r3, [sp, #4]
 8006376:	9b01      	ldr	r3, [sp, #4]
 8006378:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800637c:	b002      	add	sp, #8
 800637e:	4770      	bx	lr

08006380 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006380:	b082      	sub	sp, #8
 8006382:	2300      	movs	r3, #0
 8006384:	9301      	str	r3, [sp, #4]
 8006386:	9b01      	ldr	r3, [sp, #4]
 8006388:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800638c:	b002      	add	sp, #8
 800638e:	4770      	bx	lr

08006390 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006390:	b508      	push	{r3, lr}

  port_lock();
 8006392:	f7ff ffed 	bl	8006370 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8006396:	bd08      	pop	{r3, pc}
 8006398:	f3af 8000 	nop.w
 800639c:	f3af 8000 	nop.w

080063a0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80063a0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80063a2:	f7ff ffed 	bl	8006380 <port_unlock>
}
 80063a6:	bd08      	pop	{r3, pc}
 80063a8:	f3af 8000 	nop.w
 80063ac:	f3af 8000 	nop.w

080063b0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80063b0:	b508      	push	{r3, lr}

  chSysLock();
 80063b2:	f7ff ffed 	bl	8006390 <chSysLock>
}
 80063b6:	bd08      	pop	{r3, pc}
 80063b8:	f3af 8000 	nop.w
 80063bc:	f3af 8000 	nop.w

080063c0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80063c0:	b508      	push	{r3, lr}

  chSysUnlock();
 80063c2:	f7ff ffed 	bl	80063a0 <chSysUnlock>
}
 80063c6:	bd08      	pop	{r3, pc}
 80063c8:	f3af 8000 	nop.w
 80063cc:	f3af 8000 	nop.w

080063d0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 80063d0:	b500      	push	{lr}
 80063d2:	b083      	sub	sp, #12
 80063d4:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 80063d6:	9801      	ldr	r0, [sp, #4]
 80063d8:	f7fb f83a 	bl	8001450 <chThdSuspendS>
 80063dc:	4603      	mov	r3, r0
}
 80063de:	4618      	mov	r0, r3
 80063e0:	b003      	add	sp, #12
 80063e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80063e6:	bf00      	nop
 80063e8:	f3af 8000 	nop.w
 80063ec:	f3af 8000 	nop.w

080063f0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80063f0:	b500      	push	{lr}
 80063f2:	b083      	sub	sp, #12
 80063f4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80063f6:	9801      	ldr	r0, [sp, #4]
 80063f8:	f7fb fd7a 	bl	8001ef0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80063fc:	b003      	add	sp, #12
 80063fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8006402:	bf00      	nop
 8006404:	f3af 8000 	nop.w
 8006408:	f3af 8000 	nop.w
 800640c:	f3af 8000 	nop.w

08006410 <osalMutexLock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 8006410:	b500      	push	{lr}
 8006412:	b083      	sub	sp, #12
 8006414:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8006416:	9801      	ldr	r0, [sp, #4]
 8006418:	f7fb fd7a 	bl	8001f10 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 800641c:	b003      	add	sp, #12
 800641e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006422:	bf00      	nop
 8006424:	f3af 8000 	nop.w
 8006428:	f3af 8000 	nop.w
 800642c:	f3af 8000 	nop.w

08006430 <osalMutexUnlock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 8006430:	b500      	push	{lr}
 8006432:	b083      	sub	sp, #12
 8006434:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8006436:	9801      	ldr	r0, [sp, #4]
 8006438:	f7fb fe12 	bl	8002060 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 800643c:	b003      	add	sp, #12
 800643e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006442:	bf00      	nop
 8006444:	f3af 8000 	nop.w
 8006448:	f3af 8000 	nop.w
 800644c:	f3af 8000 	nop.w

08006450 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 8006450:	b508      	push	{r3, lr}

  spi_lld_init();
 8006452:	f004 fdb5 	bl	800afc0 <spi_lld_init>
}
 8006456:	bd08      	pop	{r3, pc}
 8006458:	f3af 8000 	nop.w
 800645c:	f3af 8000 	nop.w

08006460 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 8006460:	b500      	push	{lr}
 8006462:	b083      	sub	sp, #12
 8006464:	9001      	str	r0, [sp, #4]

  spip->state = SPI_STOP;
 8006466:	9b01      	ldr	r3, [sp, #4]
 8006468:	2201      	movs	r2, #1
 800646a:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 800646c:	9b01      	ldr	r3, [sp, #4]
 800646e:	2200      	movs	r2, #0
 8006470:	605a      	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8006472:	9b01      	ldr	r3, [sp, #4]
 8006474:	2200      	movs	r2, #0
 8006476:	609a      	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 8006478:	9b01      	ldr	r3, [sp, #4]
 800647a:	330c      	adds	r3, #12
 800647c:	4618      	mov	r0, r3
 800647e:	f7ff ffb7 	bl	80063f0 <osalMutexObjectInit>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 8006482:	b003      	add	sp, #12
 8006484:	f85d fb04 	ldr.w	pc, [sp], #4
 8006488:	f3af 8000 	nop.w
 800648c:	f3af 8000 	nop.w

08006490 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 8006490:	b500      	push	{lr}
 8006492:	b083      	sub	sp, #12
 8006494:	9001      	str	r0, [sp, #4]
 8006496:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
 8006498:	f7ff ff8a 	bl	80063b0 <osalSysLock>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 800649c:	9b01      	ldr	r3, [sp, #4]
 800649e:	9a00      	ldr	r2, [sp, #0]
 80064a0:	605a      	str	r2, [r3, #4]
  spi_lld_start(spip);
 80064a2:	9801      	ldr	r0, [sp, #4]
 80064a4:	f004 fdac 	bl	800b000 <spi_lld_start>
  spip->state = SPI_READY;
 80064a8:	9b01      	ldr	r3, [sp, #4]
 80064aa:	2202      	movs	r2, #2
 80064ac:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80064ae:	f7ff ff87 	bl	80063c0 <osalSysUnlock>
}
 80064b2:	b003      	add	sp, #12
 80064b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80064b8:	f3af 8000 	nop.w
 80064bc:	f3af 8000 	nop.w

080064c0 <spiStop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiStop(SPIDriver *spip) {
 80064c0:	b500      	push	{lr}
 80064c2:	b083      	sub	sp, #12
 80064c4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 80064c6:	f7ff ff73 	bl	80063b0 <osalSysLock>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spi_lld_stop(spip);
 80064ca:	9801      	ldr	r0, [sp, #4]
 80064cc:	f004 fe28 	bl	800b120 <spi_lld_stop>
  spip->state = SPI_STOP;
 80064d0:	9b01      	ldr	r3, [sp, #4]
 80064d2:	2201      	movs	r2, #1
 80064d4:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80064d6:	f7ff ff73 	bl	80063c0 <osalSysUnlock>
}
 80064da:	b003      	add	sp, #12
 80064dc:	f85d fb04 	ldr.w	pc, [sp], #4

080064e0 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 80064e0:	b500      	push	{lr}
 80064e2:	b083      	sub	sp, #12
 80064e4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 80064e6:	f7ff ff63 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 80064ea:	9801      	ldr	r0, [sp, #4]
 80064ec:	f004 fe48 	bl	800b180 <spi_lld_select>
  osalSysUnlock();
 80064f0:	f7ff ff66 	bl	80063c0 <osalSysUnlock>
}
 80064f4:	b003      	add	sp, #12
 80064f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80064fa:	bf00      	nop
 80064fc:	f3af 8000 	nop.w

08006500 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 8006500:	b500      	push	{lr}
 8006502:	b083      	sub	sp, #12
 8006504:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8006506:	f7ff ff53 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
 800650a:	9801      	ldr	r0, [sp, #4]
 800650c:	f004 fe48 	bl	800b1a0 <spi_lld_unselect>
  osalSysUnlock();
 8006510:	f7ff ff56 	bl	80063c0 <osalSysUnlock>
}
 8006514:	b003      	add	sp, #12
 8006516:	f85d fb04 	ldr.w	pc, [sp], #4
 800651a:	bf00      	nop
 800651c:	f3af 8000 	nop.w

08006520 <spiStartIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiStartIgnore(SPIDriver *spip, size_t n) {
 8006520:	b500      	push	{lr}
 8006522:	b083      	sub	sp, #12
 8006524:	9001      	str	r0, [sp, #4]
 8006526:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U));

  osalSysLock();
 8006528:	f7ff ff42 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartIgnoreI(spip, n);
 800652c:	9b01      	ldr	r3, [sp, #4]
 800652e:	2203      	movs	r2, #3
 8006530:	701a      	strb	r2, [r3, #0]
 8006532:	9801      	ldr	r0, [sp, #4]
 8006534:	9900      	ldr	r1, [sp, #0]
 8006536:	f004 fe43 	bl	800b1c0 <spi_lld_ignore>
  osalSysUnlock();
 800653a:	f7ff ff41 	bl	80063c0 <osalSysUnlock>
}
 800653e:	b003      	add	sp, #12
 8006540:	f85d fb04 	ldr.w	pc, [sp], #4
 8006544:	f3af 8000 	nop.w
 8006548:	f3af 8000 	nop.w
 800654c:	f3af 8000 	nop.w

08006550 <spiStartExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiStartExchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 8006550:	b500      	push	{lr}
 8006552:	b085      	sub	sp, #20
 8006554:	9003      	str	r0, [sp, #12]
 8006556:	9102      	str	r1, [sp, #8]
 8006558:	9201      	str	r2, [sp, #4]
 800655a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 800655c:	f7ff ff28 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8006560:	9b03      	ldr	r3, [sp, #12]
 8006562:	2203      	movs	r2, #3
 8006564:	701a      	strb	r2, [r3, #0]
 8006566:	9803      	ldr	r0, [sp, #12]
 8006568:	9902      	ldr	r1, [sp, #8]
 800656a:	9a01      	ldr	r2, [sp, #4]
 800656c:	9b00      	ldr	r3, [sp, #0]
 800656e:	f004 fea7 	bl	800b2c0 <spi_lld_exchange>
  osalSysUnlock();
 8006572:	f7ff ff25 	bl	80063c0 <osalSysUnlock>
}
 8006576:	b005      	add	sp, #20
 8006578:	f85d fb04 	ldr.w	pc, [sp], #4
 800657c:	f3af 8000 	nop.w

08006580 <spiStartSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8006580:	b500      	push	{lr}
 8006582:	b085      	sub	sp, #20
 8006584:	9003      	str	r0, [sp, #12]
 8006586:	9102      	str	r1, [sp, #8]
 8006588:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 800658a:	f7ff ff11 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartSendI(spip, n, txbuf);
 800658e:	9b03      	ldr	r3, [sp, #12]
 8006590:	2203      	movs	r2, #3
 8006592:	701a      	strb	r2, [r3, #0]
 8006594:	9803      	ldr	r0, [sp, #12]
 8006596:	9902      	ldr	r1, [sp, #8]
 8006598:	9a01      	ldr	r2, [sp, #4]
 800659a:	f004 ff19 	bl	800b3d0 <spi_lld_send>
  osalSysUnlock();
 800659e:	f7ff ff0f 	bl	80063c0 <osalSysUnlock>
}
 80065a2:	b005      	add	sp, #20
 80065a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80065a8:	f3af 8000 	nop.w
 80065ac:	f3af 8000 	nop.w

080065b0 <spiStartReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiStartReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 80065b0:	b500      	push	{lr}
 80065b2:	b085      	sub	sp, #20
 80065b4:	9003      	str	r0, [sp, #12]
 80065b6:	9102      	str	r1, [sp, #8]
 80065b8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 80065ba:	f7ff fef9 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartReceiveI(spip, n, rxbuf);
 80065be:	9b03      	ldr	r3, [sp, #12]
 80065c0:	2203      	movs	r2, #3
 80065c2:	701a      	strb	r2, [r3, #0]
 80065c4:	9803      	ldr	r0, [sp, #12]
 80065c6:	9902      	ldr	r1, [sp, #8]
 80065c8:	9a01      	ldr	r2, [sp, #4]
 80065ca:	f004 ff81 	bl	800b4d0 <spi_lld_receive>
  osalSysUnlock();
 80065ce:	f7ff fef7 	bl	80063c0 <osalSysUnlock>
}
 80065d2:	b005      	add	sp, #20
 80065d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80065d8:	f3af 8000 	nop.w
 80065dc:	f3af 8000 	nop.w

080065e0 <spiIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiIgnore(SPIDriver *spip, size_t n) {
 80065e0:	b500      	push	{lr}
 80065e2:	b083      	sub	sp, #12
 80065e4:	9001      	str	r0, [sp, #4]
 80065e6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U));

  osalSysLock();
 80065e8:	f7ff fee2 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartIgnoreI(spip, n);
 80065ec:	9b01      	ldr	r3, [sp, #4]
 80065ee:	2203      	movs	r2, #3
 80065f0:	701a      	strb	r2, [r3, #0]
 80065f2:	9801      	ldr	r0, [sp, #4]
 80065f4:	9900      	ldr	r1, [sp, #0]
 80065f6:	f004 fde3 	bl	800b1c0 <spi_lld_ignore>
  (void) osalThreadSuspendS(&spip->thread);
 80065fa:	9b01      	ldr	r3, [sp, #4]
 80065fc:	3308      	adds	r3, #8
 80065fe:	4618      	mov	r0, r3
 8006600:	f7ff fee6 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 8006604:	f7ff fedc 	bl	80063c0 <osalSysUnlock>
}
 8006608:	b003      	add	sp, #12
 800660a:	f85d fb04 	ldr.w	pc, [sp], #4
 800660e:	bf00      	nop

08006610 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 8006610:	b500      	push	{lr}
 8006612:	b085      	sub	sp, #20
 8006614:	9003      	str	r0, [sp, #12]
 8006616:	9102      	str	r1, [sp, #8]
 8006618:	9201      	str	r2, [sp, #4]
 800661a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 800661c:	f7ff fec8 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8006620:	9b03      	ldr	r3, [sp, #12]
 8006622:	2203      	movs	r2, #3
 8006624:	701a      	strb	r2, [r3, #0]
 8006626:	9803      	ldr	r0, [sp, #12]
 8006628:	9902      	ldr	r1, [sp, #8]
 800662a:	9a01      	ldr	r2, [sp, #4]
 800662c:	9b00      	ldr	r3, [sp, #0]
 800662e:	f004 fe47 	bl	800b2c0 <spi_lld_exchange>
  (void) osalThreadSuspendS(&spip->thread);
 8006632:	9b03      	ldr	r3, [sp, #12]
 8006634:	3308      	adds	r3, #8
 8006636:	4618      	mov	r0, r3
 8006638:	f7ff feca 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 800663c:	f7ff fec0 	bl	80063c0 <osalSysUnlock>
}
 8006640:	b005      	add	sp, #20
 8006642:	f85d fb04 	ldr.w	pc, [sp], #4
 8006646:	bf00      	nop
 8006648:	f3af 8000 	nop.w
 800664c:	f3af 8000 	nop.w

08006650 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8006650:	b500      	push	{lr}
 8006652:	b085      	sub	sp, #20
 8006654:	9003      	str	r0, [sp, #12]
 8006656:	9102      	str	r1, [sp, #8]
 8006658:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 800665a:	f7ff fea9 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
 800665e:	9b03      	ldr	r3, [sp, #12]
 8006660:	2203      	movs	r2, #3
 8006662:	701a      	strb	r2, [r3, #0]
 8006664:	9803      	ldr	r0, [sp, #12]
 8006666:	9902      	ldr	r1, [sp, #8]
 8006668:	9a01      	ldr	r2, [sp, #4]
 800666a:	f004 feb1 	bl	800b3d0 <spi_lld_send>
  (void) osalThreadSuspendS(&spip->thread);
 800666e:	9b03      	ldr	r3, [sp, #12]
 8006670:	3308      	adds	r3, #8
 8006672:	4618      	mov	r0, r3
 8006674:	f7ff feac 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 8006678:	f7ff fea2 	bl	80063c0 <osalSysUnlock>
}
 800667c:	b005      	add	sp, #20
 800667e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006682:	bf00      	nop
 8006684:	f3af 8000 	nop.w
 8006688:	f3af 8000 	nop.w
 800668c:	f3af 8000 	nop.w

08006690 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 8006690:	b500      	push	{lr}
 8006692:	b085      	sub	sp, #20
 8006694:	9003      	str	r0, [sp, #12]
 8006696:	9102      	str	r1, [sp, #8]
 8006698:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 800669a:	f7ff fe89 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartReceiveI(spip, n, rxbuf);
 800669e:	9b03      	ldr	r3, [sp, #12]
 80066a0:	2203      	movs	r2, #3
 80066a2:	701a      	strb	r2, [r3, #0]
 80066a4:	9803      	ldr	r0, [sp, #12]
 80066a6:	9902      	ldr	r1, [sp, #8]
 80066a8:	9a01      	ldr	r2, [sp, #4]
 80066aa:	f004 ff11 	bl	800b4d0 <spi_lld_receive>
  (void) osalThreadSuspendS(&spip->thread);
 80066ae:	9b03      	ldr	r3, [sp, #12]
 80066b0:	3308      	adds	r3, #8
 80066b2:	4618      	mov	r0, r3
 80066b4:	f7ff fe8c 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 80066b8:	f7ff fe82 	bl	80063c0 <osalSysUnlock>
}
 80066bc:	b005      	add	sp, #20
 80066be:	f85d fb04 	ldr.w	pc, [sp], #4
 80066c2:	bf00      	nop
 80066c4:	f3af 8000 	nop.w
 80066c8:	f3af 8000 	nop.w
 80066cc:	f3af 8000 	nop.w

080066d0 <spiAcquireBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiAcquireBus(SPIDriver *spip) {
 80066d0:	b500      	push	{lr}
 80066d2:	b083      	sub	sp, #12
 80066d4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexLock(&spip->mutex);
 80066d6:	9b01      	ldr	r3, [sp, #4]
 80066d8:	330c      	adds	r3, #12
 80066da:	4618      	mov	r0, r3
 80066dc:	f7ff fe98 	bl	8006410 <osalMutexLock>
}
 80066e0:	b003      	add	sp, #12
 80066e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80066e6:	bf00      	nop
 80066e8:	f3af 8000 	nop.w
 80066ec:	f3af 8000 	nop.w

080066f0 <spiReleaseBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiReleaseBus(SPIDriver *spip) {
 80066f0:	b500      	push	{lr}
 80066f2:	b083      	sub	sp, #12
 80066f4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexUnlock(&spip->mutex);
 80066f6:	9b01      	ldr	r3, [sp, #4]
 80066f8:	330c      	adds	r3, #12
 80066fa:	4618      	mov	r0, r3
 80066fc:	f7ff fe98 	bl	8006430 <osalMutexUnlock>
}
 8006700:	b003      	add	sp, #12
 8006702:	f85d fb04 	ldr.w	pc, [sp], #4
 8006706:	bf00      	nop
 8006708:	f3af 8000 	nop.w
 800670c:	f3af 8000 	nop.w

08006710 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006710:	b082      	sub	sp, #8
 8006712:	2320      	movs	r3, #32
 8006714:	9301      	str	r3, [sp, #4]
 8006716:	9b01      	ldr	r3, [sp, #4]
 8006718:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800671c:	b002      	add	sp, #8
 800671e:	4770      	bx	lr

08006720 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006720:	b082      	sub	sp, #8
 8006722:	2300      	movs	r3, #0
 8006724:	9301      	str	r3, [sp, #4]
 8006726:	9b01      	ldr	r3, [sp, #4]
 8006728:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800672c:	b002      	add	sp, #8
 800672e:	4770      	bx	lr

08006730 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8006730:	b508      	push	{r3, lr}

  port_lock();
 8006732:	f7ff ffed 	bl	8006710 <port_lock>
}
 8006736:	bd08      	pop	{r3, pc}
 8006738:	f3af 8000 	nop.w
 800673c:	f3af 8000 	nop.w

08006740 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8006740:	b508      	push	{r3, lr}

  port_unlock();
 8006742:	f7ff ffed 	bl	8006720 <port_unlock>
}
 8006746:	bd08      	pop	{r3, pc}
 8006748:	f3af 8000 	nop.w
 800674c:	f3af 8000 	nop.w

08006750 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006750:	b508      	push	{r3, lr}

  port_lock();
 8006752:	f7ff ffdd 	bl	8006710 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8006756:	bd08      	pop	{r3, pc}
 8006758:	f3af 8000 	nop.w
 800675c:	f3af 8000 	nop.w

08006760 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006760:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8006762:	f7ff ffdd 	bl	8006720 <port_unlock>
}
 8006766:	bd08      	pop	{r3, pc}
 8006768:	f3af 8000 	nop.w
 800676c:	f3af 8000 	nop.w

08006770 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006770:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8006772:	f7ff ffdd 	bl	8006730 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8006776:	bd08      	pop	{r3, pc}
 8006778:	f3af 8000 	nop.w
 800677c:	f3af 8000 	nop.w

08006780 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006780:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8006782:	f7ff ffdd 	bl	8006740 <port_unlock_from_isr>
}
 8006786:	bd08      	pop	{r3, pc}
 8006788:	f3af 8000 	nop.w
 800678c:	f3af 8000 	nop.w

08006790 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8006790:	b508      	push	{r3, lr}

  chSysLock();
 8006792:	f7ff ffdd 	bl	8006750 <chSysLock>
}
 8006796:	bd08      	pop	{r3, pc}
 8006798:	f3af 8000 	nop.w
 800679c:	f3af 8000 	nop.w

080067a0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80067a0:	b508      	push	{r3, lr}

  chSysUnlock();
 80067a2:	f7ff ffdd 	bl	8006760 <chSysUnlock>
}
 80067a6:	bd08      	pop	{r3, pc}
 80067a8:	f3af 8000 	nop.w
 80067ac:	f3af 8000 	nop.w

080067b0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80067b0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80067b2:	f7ff ffdd 	bl	8006770 <chSysLockFromISR>
}
 80067b6:	bd08      	pop	{r3, pc}
 80067b8:	f3af 8000 	nop.w
 80067bc:	f3af 8000 	nop.w

080067c0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80067c0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80067c2:	f7ff ffdd 	bl	8006780 <chSysUnlockFromISR>
}
 80067c6:	bd08      	pop	{r3, pc}
 80067c8:	f3af 8000 	nop.w
 80067cc:	f3af 8000 	nop.w

080067d0 <osalOsRescheduleS>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 80067d0:	b508      	push	{r3, lr}

  chSchRescheduleS();
 80067d2:	f7fa fad5 	bl	8000d80 <chSchRescheduleS>
}
 80067d6:	bd08      	pop	{r3, pc}
 80067d8:	f3af 8000 	nop.w
 80067dc:	f3af 8000 	nop.w

080067e0 <get_hword>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 80067e0:	b084      	sub	sp, #16
 80067e2:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 80067e4:	9b01      	ldr	r3, [sp, #4]
 80067e6:	1c5a      	adds	r2, r3, #1
 80067e8:	9201      	str	r2, [sp, #4]
 80067ea:	781b      	ldrb	r3, [r3, #0]
 80067ec:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 80067f0:	9b01      	ldr	r3, [sp, #4]
 80067f2:	781b      	ldrb	r3, [r3, #0]
 80067f4:	021b      	lsls	r3, r3, #8
 80067f6:	b29a      	uxth	r2, r3
 80067f8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80067fc:	4313      	orrs	r3, r2
 80067fe:	b29b      	uxth	r3, r3
 8006800:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 8006804:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 8006808:	4618      	mov	r0, r3
 800680a:	b004      	add	sp, #16
 800680c:	4770      	bx	lr
 800680e:	bf00      	nop

08006810 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8006810:	b500      	push	{lr}
 8006812:	b083      	sub	sp, #12
 8006814:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 8006816:	9b01      	ldr	r3, [sp, #4]
 8006818:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 800681c:	9b01      	ldr	r3, [sp, #4]
 800681e:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usb_lld_set_address(usbp);
 8006822:	9801      	ldr	r0, [sp, #4]
 8006824:	f002 fcb4 	bl	8009190 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8006828:	9b01      	ldr	r3, [sp, #4]
 800682a:	685b      	ldr	r3, [r3, #4]
 800682c:	681b      	ldr	r3, [r3, #0]
 800682e:	2b00      	cmp	r3, #0
 8006830:	d005      	beq.n	800683e <set_address+0x2e>
 8006832:	9b01      	ldr	r3, [sp, #4]
 8006834:	685b      	ldr	r3, [r3, #4]
 8006836:	681b      	ldr	r3, [r3, #0]
 8006838:	9801      	ldr	r0, [sp, #4]
 800683a:	2101      	movs	r1, #1
 800683c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800683e:	9b01      	ldr	r3, [sp, #4]
 8006840:	2203      	movs	r2, #3
 8006842:	701a      	strb	r2, [r3, #0]
}
 8006844:	b003      	add	sp, #12
 8006846:	f85d fb04 	ldr.w	pc, [sp], #4
 800684a:	bf00      	nop
 800684c:	f3af 8000 	nop.w

08006850 <default_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 8006850:	b570      	push	{r4, r5, r6, lr}
 8006852:	b084      	sub	sp, #16
 8006854:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8006856:	9b01      	ldr	r3, [sp, #4]
 8006858:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800685c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8006860:	9b01      	ldr	r3, [sp, #4]
 8006862:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8006866:	021b      	lsls	r3, r3, #8
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
 8006868:	4313      	orrs	r3, r2
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800686a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800686e:	d05a      	beq.n	8006926 <default_handler+0xd6>
 8006870:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006874:	d812      	bhi.n	800689c <default_handler+0x4c>
 8006876:	2b02      	cmp	r3, #2
 8006878:	f000 810f 	beq.w	8006a9a <default_handler+0x24a>
 800687c:	2b02      	cmp	r3, #2
 800687e:	d805      	bhi.n	800688c <default_handler+0x3c>
 8006880:	2b00      	cmp	r3, #0
 8006882:	d028      	beq.n	80068d6 <default_handler+0x86>
 8006884:	2b01      	cmp	r3, #1
 8006886:	f000 80fd 	beq.w	8006a84 <default_handler+0x234>
 800688a:	e1c7      	b.n	8006c1c <default_handler+0x3cc>
 800688c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8006890:	d02e      	beq.n	80068f0 <default_handler+0xa0>
 8006892:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8006896:	f000 8157 	beq.w	8006b48 <default_handler+0x2f8>
 800689a:	e1bf      	b.n	8006c1c <default_handler+0x3cc>
 800689c:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80068a0:	d074      	beq.n	800698c <default_handler+0x13c>
 80068a2:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80068a6:	d808      	bhi.n	80068ba <default_handler+0x6a>
 80068a8:	f240 3202 	movw	r2, #770	; 0x302
 80068ac:	4293      	cmp	r3, r2
 80068ae:	f000 8180 	beq.w	8006bb2 <default_handler+0x362>
 80068b2:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80068b6:	d051      	beq.n	800695c <default_handler+0x10c>
 80068b8:	e1b0      	b.n	8006c1c <default_handler+0x3cc>
 80068ba:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 80068be:	f000 8098 	beq.w	80069f2 <default_handler+0x1a2>
 80068c2:	f640 4202 	movw	r2, #3074	; 0xc02
 80068c6:	4293      	cmp	r3, r2
 80068c8:	f000 80dc 	beq.w	8006a84 <default_handler+0x234>
 80068cc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80068d0:	f000 8082 	beq.w	80069d8 <default_handler+0x188>
 80068d4:	e1a2      	b.n	8006c1c <default_handler+0x3cc>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 80068d6:	9b01      	ldr	r3, [sp, #4]
 80068d8:	f103 0264 	add.w	r2, r3, #100	; 0x64
 80068dc:	9b01      	ldr	r3, [sp, #4]
 80068de:	651a      	str	r2, [r3, #80]	; 0x50
 80068e0:	9b01      	ldr	r3, [sp, #4]
 80068e2:	2202      	movs	r2, #2
 80068e4:	655a      	str	r2, [r3, #84]	; 0x54
 80068e6:	9b01      	ldr	r3, [sp, #4]
 80068e8:	2200      	movs	r2, #0
 80068ea:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80068ec:	2301      	movs	r3, #1
 80068ee:	e196      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80068f0:	9b01      	ldr	r3, [sp, #4]
 80068f2:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80068f6:	2b01      	cmp	r3, #1
 80068f8:	d113      	bne.n	8006922 <default_handler+0xd2>
      usbp->status &= ~2U;
 80068fa:	9b01      	ldr	r3, [sp, #4]
 80068fc:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8006900:	f023 0302 	bic.w	r3, r3, #2
 8006904:	b29a      	uxth	r2, r3
 8006906:	9b01      	ldr	r3, [sp, #4]
 8006908:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800690c:	9b01      	ldr	r3, [sp, #4]
 800690e:	2200      	movs	r2, #0
 8006910:	651a      	str	r2, [r3, #80]	; 0x50
 8006912:	9b01      	ldr	r3, [sp, #4]
 8006914:	2200      	movs	r2, #0
 8006916:	655a      	str	r2, [r3, #84]	; 0x54
 8006918:	9b01      	ldr	r3, [sp, #4]
 800691a:	2200      	movs	r2, #0
 800691c:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800691e:	2301      	movs	r3, #1
 8006920:	e17d      	b.n	8006c1e <default_handler+0x3ce>
    }
    return false;
 8006922:	2300      	movs	r3, #0
 8006924:	e17b      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8006926:	9b01      	ldr	r3, [sp, #4]
 8006928:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800692c:	2b01      	cmp	r3, #1
 800692e:	d113      	bne.n	8006958 <default_handler+0x108>
      usbp->status |= 2U;
 8006930:	9b01      	ldr	r3, [sp, #4]
 8006932:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8006936:	f043 0302 	orr.w	r3, r3, #2
 800693a:	b29a      	uxth	r2, r3
 800693c:	9b01      	ldr	r3, [sp, #4]
 800693e:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8006942:	9b01      	ldr	r3, [sp, #4]
 8006944:	2200      	movs	r2, #0
 8006946:	651a      	str	r2, [r3, #80]	; 0x50
 8006948:	9b01      	ldr	r3, [sp, #4]
 800694a:	2200      	movs	r2, #0
 800694c:	655a      	str	r2, [r3, #84]	; 0x54
 800694e:	9b01      	ldr	r3, [sp, #4]
 8006950:	2200      	movs	r2, #0
 8006952:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8006954:	2301      	movs	r3, #1
 8006956:	e162      	b.n	8006c1e <default_handler+0x3ce>
    }
    return false;
 8006958:	2300      	movs	r3, #0
 800695a:	e160      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800695c:	9b01      	ldr	r3, [sp, #4]
 800695e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8006962:	2b00      	cmp	r3, #0
 8006964:	d107      	bne.n	8006976 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 8006966:	9b01      	ldr	r3, [sp, #4]
 8006968:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800696c:	2b05      	cmp	r3, #5
 800696e:	d102      	bne.n	8006976 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
 8006970:	9801      	ldr	r0, [sp, #4]
 8006972:	f7ff ff4d 	bl	8006810 <set_address>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006976:	9b01      	ldr	r3, [sp, #4]
 8006978:	2200      	movs	r2, #0
 800697a:	651a      	str	r2, [r3, #80]	; 0x50
 800697c:	9b01      	ldr	r3, [sp, #4]
 800697e:	2200      	movs	r2, #0
 8006980:	655a      	str	r2, [r3, #84]	; 0x54
 8006982:	9b01      	ldr	r3, [sp, #4]
 8006984:	2200      	movs	r2, #0
 8006986:	659a      	str	r2, [r3, #88]	; 0x58
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 8006988:	2301      	movs	r3, #1
 800698a:	e148      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800698c:	9b01      	ldr	r3, [sp, #4]
 800698e:	685b      	ldr	r3, [r3, #4]
 8006990:	685c      	ldr	r4, [r3, #4]
 8006992:	9b01      	ldr	r3, [sp, #4]
 8006994:	f893 605f 	ldrb.w	r6, [r3, #95]	; 0x5f
 8006998:	9b01      	ldr	r3, [sp, #4]
 800699a:	f893 505e 	ldrb.w	r5, [r3, #94]	; 0x5e
 800699e:	9b01      	ldr	r3, [sp, #4]
 80069a0:	3360      	adds	r3, #96	; 0x60
 80069a2:	4618      	mov	r0, r3
 80069a4:	f7ff ff1c 	bl	80067e0 <get_hword>
 80069a8:	4603      	mov	r3, r0
 80069aa:	9801      	ldr	r0, [sp, #4]
 80069ac:	4631      	mov	r1, r6
 80069ae:	462a      	mov	r2, r5
 80069b0:	47a0      	blx	r4
 80069b2:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 80069b4:	9b03      	ldr	r3, [sp, #12]
 80069b6:	2b00      	cmp	r3, #0
 80069b8:	d101      	bne.n	80069be <default_handler+0x16e>
      return false;
 80069ba:	2300      	movs	r3, #0
 80069bc:	e12f      	b.n	8006c1e <default_handler+0x3ce>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80069be:	9b03      	ldr	r3, [sp, #12]
 80069c0:	685a      	ldr	r2, [r3, #4]
 80069c2:	9b01      	ldr	r3, [sp, #4]
 80069c4:	651a      	str	r2, [r3, #80]	; 0x50
 80069c6:	9b03      	ldr	r3, [sp, #12]
 80069c8:	681a      	ldr	r2, [r3, #0]
 80069ca:	9b01      	ldr	r3, [sp, #4]
 80069cc:	655a      	str	r2, [r3, #84]	; 0x54
 80069ce:	9b01      	ldr	r3, [sp, #4]
 80069d0:	2200      	movs	r2, #0
 80069d2:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 80069d4:	2301      	movs	r3, #1
 80069d6:	e122      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80069d8:	9b01      	ldr	r3, [sp, #4]
 80069da:	f103 0267 	add.w	r2, r3, #103	; 0x67
 80069de:	9b01      	ldr	r3, [sp, #4]
 80069e0:	651a      	str	r2, [r3, #80]	; 0x50
 80069e2:	9b01      	ldr	r3, [sp, #4]
 80069e4:	2201      	movs	r2, #1
 80069e6:	655a      	str	r2, [r3, #84]	; 0x54
 80069e8:	9b01      	ldr	r3, [sp, #4]
 80069ea:	2200      	movs	r2, #0
 80069ec:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80069ee:	2301      	movs	r3, #1
 80069f0:	e115      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 80069f2:	9b01      	ldr	r3, [sp, #4]
 80069f4:	f893 2067 	ldrb.w	r2, [r3, #103]	; 0x67
 80069f8:	9b01      	ldr	r3, [sp, #4]
 80069fa:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80069fe:	429a      	cmp	r2, r3
 8006a00:	d035      	beq.n	8006a6e <default_handler+0x21e>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 8006a02:	9b01      	ldr	r3, [sp, #4]
 8006a04:	781b      	ldrb	r3, [r3, #0]
 8006a06:	2b04      	cmp	r3, #4
 8006a08:	d118      	bne.n	8006a3c <default_handler+0x1ec>
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
 8006a0a:	f7ff fed1 	bl	80067b0 <osalSysLockFromISR>
        usbDisableEndpointsI(usbp);
 8006a0e:	9801      	ldr	r0, [sp, #4]
 8006a10:	f000 f9be 	bl	8006d90 <usbDisableEndpointsI>
        osalSysUnlockFromISR ();
 8006a14:	f7ff fed4 	bl	80067c0 <osalSysUnlockFromISR>
        usbp->configuration = 0U;
 8006a18:	9b01      	ldr	r3, [sp, #4]
 8006a1a:	2200      	movs	r2, #0
 8006a1c:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_SELECTED;
 8006a20:	9b01      	ldr	r3, [sp, #4]
 8006a22:	2203      	movs	r2, #3
 8006a24:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8006a26:	9b01      	ldr	r3, [sp, #4]
 8006a28:	685b      	ldr	r3, [r3, #4]
 8006a2a:	681b      	ldr	r3, [r3, #0]
 8006a2c:	2b00      	cmp	r3, #0
 8006a2e:	d005      	beq.n	8006a3c <default_handler+0x1ec>
 8006a30:	9b01      	ldr	r3, [sp, #4]
 8006a32:	685b      	ldr	r3, [r3, #4]
 8006a34:	681b      	ldr	r3, [r3, #0]
 8006a36:	9801      	ldr	r0, [sp, #4]
 8006a38:	2103      	movs	r1, #3
 8006a3a:	4798      	blx	r3
      }
      if (usbp->setup[2] != 0U) {
 8006a3c:	9b01      	ldr	r3, [sp, #4]
 8006a3e:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006a42:	2b00      	cmp	r3, #0
 8006a44:	d013      	beq.n	8006a6e <default_handler+0x21e>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8006a46:	9b01      	ldr	r3, [sp, #4]
 8006a48:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 8006a4c:	9b01      	ldr	r3, [sp, #4]
 8006a4e:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 8006a52:	9b01      	ldr	r3, [sp, #4]
 8006a54:	2204      	movs	r2, #4
 8006a56:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8006a58:	9b01      	ldr	r3, [sp, #4]
 8006a5a:	685b      	ldr	r3, [r3, #4]
 8006a5c:	681b      	ldr	r3, [r3, #0]
 8006a5e:	2b00      	cmp	r3, #0
 8006a60:	d005      	beq.n	8006a6e <default_handler+0x21e>
 8006a62:	9b01      	ldr	r3, [sp, #4]
 8006a64:	685b      	ldr	r3, [r3, #4]
 8006a66:	681b      	ldr	r3, [r3, #0]
 8006a68:	9801      	ldr	r0, [sp, #4]
 8006a6a:	2102      	movs	r1, #2
 8006a6c:	4798      	blx	r3
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006a6e:	9b01      	ldr	r3, [sp, #4]
 8006a70:	2200      	movs	r2, #0
 8006a72:	651a      	str	r2, [r3, #80]	; 0x50
 8006a74:	9b01      	ldr	r3, [sp, #4]
 8006a76:	2200      	movs	r2, #0
 8006a78:	655a      	str	r2, [r3, #84]	; 0x54
 8006a7a:	9b01      	ldr	r3, [sp, #4]
 8006a7c:	2200      	movs	r2, #0
 8006a7e:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006a80:	2301      	movs	r3, #1
 8006a82:	e0cc      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8006a84:	9b01      	ldr	r3, [sp, #4]
 8006a86:	4a67      	ldr	r2, [pc, #412]	; (8006c24 <default_handler+0x3d4>)
 8006a88:	651a      	str	r2, [r3, #80]	; 0x50
 8006a8a:	9b01      	ldr	r3, [sp, #4]
 8006a8c:	2202      	movs	r2, #2
 8006a8e:	655a      	str	r2, [r3, #84]	; 0x54
 8006a90:	9b01      	ldr	r3, [sp, #4]
 8006a92:	2200      	movs	r2, #0
 8006a94:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 8006a96:	2301      	movs	r3, #1
 8006a98:	e0c1      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8006a9a:	9b01      	ldr	r3, [sp, #4]
 8006a9c:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006aa0:	b2db      	uxtb	r3, r3
 8006aa2:	b25b      	sxtb	r3, r3
 8006aa4:	2b00      	cmp	r3, #0
 8006aa6:	da27      	bge.n	8006af8 <default_handler+0x2a8>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8006aa8:	9b01      	ldr	r3, [sp, #4]
 8006aaa:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006aae:	f003 030f 	and.w	r3, r3, #15
 8006ab2:	b2db      	uxtb	r3, r3
 8006ab4:	9801      	ldr	r0, [sp, #4]
 8006ab6:	4619      	mov	r1, r3
 8006ab8:	f002 fce2 	bl	8009480 <usb_lld_get_status_in>
 8006abc:	4603      	mov	r3, r0
 8006abe:	2b01      	cmp	r3, #1
 8006ac0:	d002      	beq.n	8006ac8 <default_handler+0x278>
 8006ac2:	2b02      	cmp	r3, #2
 8006ac4:	d00b      	beq.n	8006ade <default_handler+0x28e>
 8006ac6:	e015      	b.n	8006af4 <default_handler+0x2a4>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8006ac8:	9b01      	ldr	r3, [sp, #4]
 8006aca:	4a57      	ldr	r2, [pc, #348]	; (8006c28 <default_handler+0x3d8>)
 8006acc:	651a      	str	r2, [r3, #80]	; 0x50
 8006ace:	9b01      	ldr	r3, [sp, #4]
 8006ad0:	2202      	movs	r2, #2
 8006ad2:	655a      	str	r2, [r3, #84]	; 0x54
 8006ad4:	9b01      	ldr	r3, [sp, #4]
 8006ad6:	2200      	movs	r2, #0
 8006ad8:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006ada:	2301      	movs	r3, #1
 8006adc:	e09f      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8006ade:	9b01      	ldr	r3, [sp, #4]
 8006ae0:	4a52      	ldr	r2, [pc, #328]	; (8006c2c <default_handler+0x3dc>)
 8006ae2:	651a      	str	r2, [r3, #80]	; 0x50
 8006ae4:	9b01      	ldr	r3, [sp, #4]
 8006ae6:	2202      	movs	r2, #2
 8006ae8:	655a      	str	r2, [r3, #84]	; 0x54
 8006aea:	9b01      	ldr	r3, [sp, #4]
 8006aec:	2200      	movs	r2, #0
 8006aee:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006af0:	2301      	movs	r3, #1
 8006af2:	e094      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8006af4:	2300      	movs	r3, #0
 8006af6:	e092      	b.n	8006c1e <default_handler+0x3ce>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8006af8:	9b01      	ldr	r3, [sp, #4]
 8006afa:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006afe:	f003 030f 	and.w	r3, r3, #15
 8006b02:	b2db      	uxtb	r3, r3
 8006b04:	9801      	ldr	r0, [sp, #4]
 8006b06:	4619      	mov	r1, r3
 8006b08:	f002 fc9a 	bl	8009440 <usb_lld_get_status_out>
 8006b0c:	4603      	mov	r3, r0
 8006b0e:	2b01      	cmp	r3, #1
 8006b10:	d002      	beq.n	8006b18 <default_handler+0x2c8>
 8006b12:	2b02      	cmp	r3, #2
 8006b14:	d00b      	beq.n	8006b2e <default_handler+0x2de>
 8006b16:	e015      	b.n	8006b44 <default_handler+0x2f4>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8006b18:	9b01      	ldr	r3, [sp, #4]
 8006b1a:	4a43      	ldr	r2, [pc, #268]	; (8006c28 <default_handler+0x3d8>)
 8006b1c:	651a      	str	r2, [r3, #80]	; 0x50
 8006b1e:	9b01      	ldr	r3, [sp, #4]
 8006b20:	2202      	movs	r2, #2
 8006b22:	655a      	str	r2, [r3, #84]	; 0x54
 8006b24:	9b01      	ldr	r3, [sp, #4]
 8006b26:	2200      	movs	r2, #0
 8006b28:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006b2a:	2301      	movs	r3, #1
 8006b2c:	e077      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8006b2e:	9b01      	ldr	r3, [sp, #4]
 8006b30:	4a3e      	ldr	r2, [pc, #248]	; (8006c2c <default_handler+0x3dc>)
 8006b32:	651a      	str	r2, [r3, #80]	; 0x50
 8006b34:	9b01      	ldr	r3, [sp, #4]
 8006b36:	2202      	movs	r2, #2
 8006b38:	655a      	str	r2, [r3, #84]	; 0x54
 8006b3a:	9b01      	ldr	r3, [sp, #4]
 8006b3c:	2200      	movs	r2, #0
 8006b3e:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006b40:	2301      	movs	r3, #1
 8006b42:	e06c      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8006b44:	2300      	movs	r3, #0
 8006b46:	e06a      	b.n	8006c1e <default_handler+0x3ce>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8006b48:	9b01      	ldr	r3, [sp, #4]
 8006b4a:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006b4e:	2b00      	cmp	r3, #0
 8006b50:	d001      	beq.n	8006b56 <default_handler+0x306>
      return false;
 8006b52:	2300      	movs	r3, #0
 8006b54:	e063      	b.n	8006c1e <default_handler+0x3ce>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8006b56:	9b01      	ldr	r3, [sp, #4]
 8006b58:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b5c:	f003 030f 	and.w	r3, r3, #15
 8006b60:	2b00      	cmp	r3, #0
 8006b62:	d01b      	beq.n	8006b9c <default_handler+0x34c>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8006b64:	9b01      	ldr	r3, [sp, #4]
 8006b66:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b6a:	b2db      	uxtb	r3, r3
 8006b6c:	b25b      	sxtb	r3, r3
 8006b6e:	2b00      	cmp	r3, #0
 8006b70:	da0a      	bge.n	8006b88 <default_handler+0x338>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8006b72:	9b01      	ldr	r3, [sp, #4]
 8006b74:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b78:	f003 030f 	and.w	r3, r3, #15
 8006b7c:	b2db      	uxtb	r3, r3
 8006b7e:	9801      	ldr	r0, [sp, #4]
 8006b80:	4619      	mov	r1, r3
 8006b82:	f002 fe65 	bl	8009850 <usb_lld_clear_in>
 8006b86:	e009      	b.n	8006b9c <default_handler+0x34c>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8006b88:	9b01      	ldr	r3, [sp, #4]
 8006b8a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b8e:	f003 030f 	and.w	r3, r3, #15
 8006b92:	b2db      	uxtb	r3, r3
 8006b94:	9801      	ldr	r0, [sp, #4]
 8006b96:	4619      	mov	r1, r3
 8006b98:	f002 fe3a 	bl	8009810 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006b9c:	9b01      	ldr	r3, [sp, #4]
 8006b9e:	2200      	movs	r2, #0
 8006ba0:	651a      	str	r2, [r3, #80]	; 0x50
 8006ba2:	9b01      	ldr	r3, [sp, #4]
 8006ba4:	2200      	movs	r2, #0
 8006ba6:	655a      	str	r2, [r3, #84]	; 0x54
 8006ba8:	9b01      	ldr	r3, [sp, #4]
 8006baa:	2200      	movs	r2, #0
 8006bac:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006bae:	2301      	movs	r3, #1
 8006bb0:	e035      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8006bb2:	9b01      	ldr	r3, [sp, #4]
 8006bb4:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006bb8:	2b00      	cmp	r3, #0
 8006bba:	d001      	beq.n	8006bc0 <default_handler+0x370>
      return false;
 8006bbc:	2300      	movs	r3, #0
 8006bbe:	e02e      	b.n	8006c1e <default_handler+0x3ce>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8006bc0:	9b01      	ldr	r3, [sp, #4]
 8006bc2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bc6:	f003 030f 	and.w	r3, r3, #15
 8006bca:	2b00      	cmp	r3, #0
 8006bcc:	d01b      	beq.n	8006c06 <default_handler+0x3b6>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8006bce:	9b01      	ldr	r3, [sp, #4]
 8006bd0:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bd4:	b2db      	uxtb	r3, r3
 8006bd6:	b25b      	sxtb	r3, r3
 8006bd8:	2b00      	cmp	r3, #0
 8006bda:	da0a      	bge.n	8006bf2 <default_handler+0x3a2>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8006bdc:	9b01      	ldr	r3, [sp, #4]
 8006bde:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006be2:	f003 030f 	and.w	r3, r3, #15
 8006be6:	b2db      	uxtb	r3, r3
 8006be8:	9801      	ldr	r0, [sp, #4]
 8006bea:	4619      	mov	r1, r3
 8006bec:	f002 fdf0 	bl	80097d0 <usb_lld_stall_in>
 8006bf0:	e009      	b.n	8006c06 <default_handler+0x3b6>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8006bf2:	9b01      	ldr	r3, [sp, #4]
 8006bf4:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bf8:	f003 030f 	and.w	r3, r3, #15
 8006bfc:	b2db      	uxtb	r3, r3
 8006bfe:	9801      	ldr	r0, [sp, #4]
 8006c00:	4619      	mov	r1, r3
 8006c02:	f002 fdc5 	bl	8009790 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006c06:	9b01      	ldr	r3, [sp, #4]
 8006c08:	2200      	movs	r2, #0
 8006c0a:	651a      	str	r2, [r3, #80]	; 0x50
 8006c0c:	9b01      	ldr	r3, [sp, #4]
 8006c0e:	2200      	movs	r2, #0
 8006c10:	655a      	str	r2, [r3, #84]	; 0x54
 8006c12:	9b01      	ldr	r3, [sp, #4]
 8006c14:	2200      	movs	r2, #0
 8006c16:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006c18:	2301      	movs	r3, #1
 8006c1a:	e000      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 8006c1c:	2300      	movs	r3, #0
  }
}
 8006c1e:	4618      	mov	r0, r3
 8006c20:	b004      	add	sp, #16
 8006c22:	bd70      	pop	{r4, r5, r6, pc}
 8006c24:	0801aab0 	.word	0x0801aab0
 8006c28:	0801aab8 	.word	0x0801aab8
 8006c2c:	0801aab4 	.word	0x0801aab4

08006c30 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8006c30:	b508      	push	{r3, lr}

  usb_lld_init();
 8006c32:	f002 f93d 	bl	8008eb0 <usb_lld_init>
}
 8006c36:	bd08      	pop	{r3, pc}
 8006c38:	f3af 8000 	nop.w
 8006c3c:	f3af 8000 	nop.w

08006c40 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8006c40:	b084      	sub	sp, #16
 8006c42:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 8006c44:	9b01      	ldr	r3, [sp, #4]
 8006c46:	2201      	movs	r2, #1
 8006c48:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 8006c4a:	9b01      	ldr	r3, [sp, #4]
 8006c4c:	2200      	movs	r2, #0
 8006c4e:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006c50:	2300      	movs	r3, #0
 8006c52:	9303      	str	r3, [sp, #12]
 8006c54:	e00f      	b.n	8006c76 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 8006c56:	9a01      	ldr	r2, [sp, #4]
 8006c58:	9b03      	ldr	r3, [sp, #12]
 8006c5a:	3308      	adds	r3, #8
 8006c5c:	009b      	lsls	r3, r3, #2
 8006c5e:	4413      	add	r3, r2
 8006c60:	2200      	movs	r2, #0
 8006c62:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 8006c64:	9b01      	ldr	r3, [sp, #4]
 8006c66:	9a03      	ldr	r2, [sp, #12]
 8006c68:	320e      	adds	r2, #14
 8006c6a:	2100      	movs	r1, #0
 8006c6c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006c70:	9b03      	ldr	r3, [sp, #12]
 8006c72:	3301      	adds	r3, #1
 8006c74:	9303      	str	r3, [sp, #12]
 8006c76:	9b03      	ldr	r3, [sp, #12]
 8006c78:	2b04      	cmp	r3, #4
 8006c7a:	d9ec      	bls.n	8006c56 <usbObjectInit+0x16>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8006c7c:	9b01      	ldr	r3, [sp, #4]
 8006c7e:	2200      	movs	r2, #0
 8006c80:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 8006c82:	9b01      	ldr	r3, [sp, #4]
 8006c84:	2200      	movs	r2, #0
 8006c86:	815a      	strh	r2, [r3, #10]
}
 8006c88:	b004      	add	sp, #16
 8006c8a:	4770      	bx	lr
 8006c8c:	f3af 8000 	nop.w

08006c90 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 8006c90:	b500      	push	{lr}
 8006c92:	b085      	sub	sp, #20
 8006c94:	9001      	str	r0, [sp, #4]
 8006c96:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
 8006c98:	f7ff fd7a 	bl	8006790 <osalSysLock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 8006c9c:	9b01      	ldr	r3, [sp, #4]
 8006c9e:	9a00      	ldr	r2, [sp, #0]
 8006ca0:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006ca2:	2300      	movs	r3, #0
 8006ca4:	9303      	str	r3, [sp, #12]
 8006ca6:	e009      	b.n	8006cbc <usbStart+0x2c>
    usbp->epc[i] = NULL;
 8006ca8:	9a01      	ldr	r2, [sp, #4]
 8006caa:	9b03      	ldr	r3, [sp, #12]
 8006cac:	3302      	adds	r3, #2
 8006cae:	009b      	lsls	r3, r3, #2
 8006cb0:	4413      	add	r3, r2
 8006cb2:	2200      	movs	r2, #0
 8006cb4:	605a      	str	r2, [r3, #4]

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006cb6:	9b03      	ldr	r3, [sp, #12]
 8006cb8:	3301      	adds	r3, #1
 8006cba:	9303      	str	r3, [sp, #12]
 8006cbc:	9b03      	ldr	r3, [sp, #12]
 8006cbe:	2b05      	cmp	r3, #5
 8006cc0:	d9f2      	bls.n	8006ca8 <usbStart+0x18>
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 8006cc2:	9801      	ldr	r0, [sp, #4]
 8006cc4:	f002 f90c 	bl	8008ee0 <usb_lld_start>
  usbp->state = USB_READY;
 8006cc8:	9b01      	ldr	r3, [sp, #4]
 8006cca:	2202      	movs	r2, #2
 8006ccc:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8006cce:	f7ff fd67 	bl	80067a0 <osalSysUnlock>
}
 8006cd2:	b005      	add	sp, #20
 8006cd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8006cd8:	f3af 8000 	nop.w
 8006cdc:	f3af 8000 	nop.w

08006ce0 <usbStop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @api
 */
void usbStop(USBDriver *usbp) {
 8006ce0:	b500      	push	{lr}
 8006ce2:	b085      	sub	sp, #20
 8006ce4:	9001      	str	r0, [sp, #4]
  unsigned i;

  osalDbgCheck(usbp != NULL);

  osalSysLock();
 8006ce6:	f7ff fd53 	bl	8006790 <osalSysLock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY) ||
                (usbp->state == USB_SELECTED) || (usbp->state == USB_ACTIVE) ||
                (usbp->state == USB_SUSPENDED),
                "invalid state");

  usb_lld_stop(usbp);
 8006cea:	9801      	ldr	r0, [sp, #4]
 8006cec:	f002 f988 	bl	8009000 <usb_lld_stop>
  usbp->state = USB_STOP;
 8006cf0:	9b01      	ldr	r3, [sp, #4]
 8006cf2:	2201      	movs	r2, #1
 8006cf4:	701a      	strb	r2, [r3, #0]

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006cf6:	2300      	movs	r3, #0
 8006cf8:	9303      	str	r3, [sp, #12]
 8006cfa:	e009      	b.n	8006d10 <usbStop+0x30>
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 8006cfc:	9a01      	ldr	r2, [sp, #4]
 8006cfe:	9b03      	ldr	r3, [sp, #12]
 8006d00:	3302      	adds	r3, #2
 8006d02:	009b      	lsls	r3, r3, #2
 8006d04:	4413      	add	r3, r2
 8006d06:	2200      	movs	r2, #0
 8006d08:	605a      	str	r2, [r3, #4]

  usb_lld_stop(usbp);
  usbp->state = USB_STOP;

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006d0a:	9b03      	ldr	r3, [sp, #12]
 8006d0c:	3301      	adds	r3, #1
 8006d0e:	9303      	str	r3, [sp, #12]
 8006d10:	9b03      	ldr	r3, [sp, #12]
 8006d12:	2b05      	cmp	r3, #5
 8006d14:	d9f2      	bls.n	8006cfc <usbStop+0x1c>
      }
    }
#endif
    usbp->epc[i] = NULL;
  }
  osalOsRescheduleS();
 8006d16:	f7ff fd5b 	bl	80067d0 <osalOsRescheduleS>

  osalSysUnlock();
 8006d1a:	f7ff fd41 	bl	80067a0 <osalSysUnlock>
}
 8006d1e:	b005      	add	sp, #20
 8006d20:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d24:	f3af 8000 	nop.w
 8006d28:	f3af 8000 	nop.w
 8006d2c:	f3af 8000 	nop.w

08006d30 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8006d30:	b500      	push	{lr}
 8006d32:	b085      	sub	sp, #20
 8006d34:	9003      	str	r0, [sp, #12]
 8006d36:	460b      	mov	r3, r1
 8006d38:	9201      	str	r2, [sp, #4]
 8006d3a:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 8006d3e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006d42:	9a03      	ldr	r2, [sp, #12]
 8006d44:	3302      	adds	r3, #2
 8006d46:	009b      	lsls	r3, r3, #2
 8006d48:	4413      	add	r3, r2
 8006d4a:	9a01      	ldr	r2, [sp, #4]
 8006d4c:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 8006d4e:	9b01      	ldr	r3, [sp, #4]
 8006d50:	695b      	ldr	r3, [r3, #20]
 8006d52:	2b00      	cmp	r3, #0
 8006d54:	d006      	beq.n	8006d64 <usbInitEndpointI+0x34>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8006d56:	9b01      	ldr	r3, [sp, #4]
 8006d58:	695b      	ldr	r3, [r3, #20]
 8006d5a:	4618      	mov	r0, r3
 8006d5c:	2100      	movs	r1, #0
 8006d5e:	2210      	movs	r2, #16
 8006d60:	f010 fe16 	bl	8017990 <memset>
  }
  if (epcp->out_state != NULL) {
 8006d64:	9b01      	ldr	r3, [sp, #4]
 8006d66:	699b      	ldr	r3, [r3, #24]
 8006d68:	2b00      	cmp	r3, #0
 8006d6a:	d006      	beq.n	8006d7a <usbInitEndpointI+0x4a>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8006d6c:	9b01      	ldr	r3, [sp, #4]
 8006d6e:	699b      	ldr	r3, [r3, #24]
 8006d70:	4618      	mov	r0, r3
 8006d72:	2100      	movs	r1, #0
 8006d74:	2210      	movs	r2, #16
 8006d76:	f010 fe0b 	bl	8017990 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 8006d7a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006d7e:	9803      	ldr	r0, [sp, #12]
 8006d80:	4619      	mov	r1, r3
 8006d82:	f002 fa1d 	bl	80091c0 <usb_lld_init_endpoint>
}
 8006d86:	b005      	add	sp, #20
 8006d88:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d8c:	f3af 8000 	nop.w

08006d90 <usbDisableEndpointsI>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
 8006d90:	b500      	push	{lr}
 8006d92:	b085      	sub	sp, #20
 8006d94:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8006d96:	9b01      	ldr	r3, [sp, #4]
 8006d98:	891b      	ldrh	r3, [r3, #8]
 8006d9a:	f003 0301 	and.w	r3, r3, #1
 8006d9e:	b29a      	uxth	r2, r3
 8006da0:	9b01      	ldr	r3, [sp, #4]
 8006da2:	811a      	strh	r2, [r3, #8]
  usbp->receiving    &= 1U;
 8006da4:	9b01      	ldr	r3, [sp, #4]
 8006da6:	895b      	ldrh	r3, [r3, #10]
 8006da8:	f003 0301 	and.w	r3, r3, #1
 8006dac:	b29a      	uxth	r2, r3
 8006dae:	9b01      	ldr	r3, [sp, #4]
 8006db0:	815a      	strh	r2, [r3, #10]

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006db2:	2301      	movs	r3, #1
 8006db4:	9303      	str	r3, [sp, #12]
 8006db6:	e009      	b.n	8006dcc <usbDisableEndpointsI+0x3c>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8006db8:	9a01      	ldr	r2, [sp, #4]
 8006dba:	9b03      	ldr	r3, [sp, #12]
 8006dbc:	3302      	adds	r3, #2
 8006dbe:	009b      	lsls	r3, r3, #2
 8006dc0:	4413      	add	r3, r2
 8006dc2:	2200      	movs	r2, #0
 8006dc4:	605a      	str	r2, [r3, #4]
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
  usbp->receiving    &= 1U;

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006dc6:	9b03      	ldr	r3, [sp, #12]
 8006dc8:	3301      	adds	r3, #1
 8006dca:	9303      	str	r3, [sp, #12]
 8006dcc:	9b03      	ldr	r3, [sp, #12]
 8006dce:	2b05      	cmp	r3, #5
 8006dd0:	d9f2      	bls.n	8006db8 <usbDisableEndpointsI+0x28>
#endif
    usbp->epc[i] = NULL;
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 8006dd2:	9801      	ldr	r0, [sp, #4]
 8006dd4:	f002 fb24 	bl	8009420 <usb_lld_disable_endpoints>
}
 8006dd8:	b005      	add	sp, #20
 8006dda:	f85d fb04 	ldr.w	pc, [sp], #4
 8006dde:	bf00      	nop

08006de0 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8006de0:	b500      	push	{lr}
 8006de2:	b087      	sub	sp, #28
 8006de4:	9003      	str	r0, [sp, #12]
 8006de6:	9201      	str	r2, [sp, #4]
 8006de8:	9300      	str	r3, [sp, #0]
 8006dea:	460b      	mov	r3, r1
 8006dec:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006df0:	9b03      	ldr	r3, [sp, #12]
 8006df2:	895a      	ldrh	r2, [r3, #10]
 8006df4:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006df8:	2101      	movs	r1, #1
 8006dfa:	fa01 f303 	lsl.w	r3, r1, r3
 8006dfe:	b29b      	uxth	r3, r3
 8006e00:	4313      	orrs	r3, r2
 8006e02:	b29a      	uxth	r2, r3
 8006e04:	9b03      	ldr	r3, [sp, #12]
 8006e06:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8006e08:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e0c:	9a03      	ldr	r2, [sp, #12]
 8006e0e:	3302      	adds	r3, #2
 8006e10:	009b      	lsls	r3, r3, #2
 8006e12:	4413      	add	r3, r2
 8006e14:	685b      	ldr	r3, [r3, #4]
 8006e16:	699b      	ldr	r3, [r3, #24]
 8006e18:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 8006e1a:	9b05      	ldr	r3, [sp, #20]
 8006e1c:	9a01      	ldr	r2, [sp, #4]
 8006e1e:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8006e20:	9b05      	ldr	r3, [sp, #20]
 8006e22:	9a00      	ldr	r2, [sp, #0]
 8006e24:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 8006e26:	9b05      	ldr	r3, [sp, #20]
 8006e28:	2200      	movs	r2, #0
 8006e2a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8006e2c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e30:	9803      	ldr	r0, [sp, #12]
 8006e32:	4619      	mov	r1, r3
 8006e34:	f002 fb5c 	bl	80094f0 <usb_lld_start_out>
}
 8006e38:	b007      	add	sp, #28
 8006e3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006e3e:	bf00      	nop

08006e40 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8006e40:	b500      	push	{lr}
 8006e42:	b087      	sub	sp, #28
 8006e44:	9003      	str	r0, [sp, #12]
 8006e46:	9201      	str	r2, [sp, #4]
 8006e48:	9300      	str	r3, [sp, #0]
 8006e4a:	460b      	mov	r3, r1
 8006e4c:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006e50:	9b03      	ldr	r3, [sp, #12]
 8006e52:	891a      	ldrh	r2, [r3, #8]
 8006e54:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e58:	2101      	movs	r1, #1
 8006e5a:	fa01 f303 	lsl.w	r3, r1, r3
 8006e5e:	b29b      	uxth	r3, r3
 8006e60:	4313      	orrs	r3, r2
 8006e62:	b29a      	uxth	r2, r3
 8006e64:	9b03      	ldr	r3, [sp, #12]
 8006e66:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8006e68:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e6c:	9a03      	ldr	r2, [sp, #12]
 8006e6e:	3302      	adds	r3, #2
 8006e70:	009b      	lsls	r3, r3, #2
 8006e72:	4413      	add	r3, r2
 8006e74:	685b      	ldr	r3, [r3, #4]
 8006e76:	695b      	ldr	r3, [r3, #20]
 8006e78:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 8006e7a:	9b05      	ldr	r3, [sp, #20]
 8006e7c:	9a01      	ldr	r2, [sp, #4]
 8006e7e:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8006e80:	9b05      	ldr	r3, [sp, #20]
 8006e82:	9a00      	ldr	r2, [sp, #0]
 8006e84:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8006e86:	9b05      	ldr	r3, [sp, #20]
 8006e88:	2200      	movs	r2, #0
 8006e8a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8006e8c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e90:	9803      	ldr	r0, [sp, #12]
 8006e92:	4619      	mov	r1, r3
 8006e94:	f002 fbcc 	bl	8009630 <usb_lld_start_in>
}
 8006e98:	b007      	add	sp, #28
 8006e9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006e9e:	bf00      	nop

08006ea0 <usbStallReceiveI>:
 * @retval false        Endpoint stalled.
 * @retval true         Endpoint busy, not stalled.
 *
 * @iclass
 */
bool usbStallReceiveI(USBDriver *usbp, usbep_t ep) {
 8006ea0:	b500      	push	{lr}
 8006ea2:	b083      	sub	sp, #12
 8006ea4:	9001      	str	r0, [sp, #4]
 8006ea6:	460b      	mov	r3, r1
 8006ea8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 8006eac:	9b01      	ldr	r3, [sp, #4]
 8006eae:	895a      	ldrh	r2, [r3, #10]
 8006eb0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006eb4:	2101      	movs	r1, #1
 8006eb6:	fa01 f303 	lsl.w	r3, r1, r3
 8006eba:	b29b      	uxth	r3, r3
 8006ebc:	4013      	ands	r3, r2
 8006ebe:	b29b      	uxth	r3, r3
 8006ec0:	2b00      	cmp	r3, #0
 8006ec2:	d001      	beq.n	8006ec8 <usbStallReceiveI+0x28>
    return true;
 8006ec4:	2301      	movs	r3, #1
 8006ec6:	e006      	b.n	8006ed6 <usbStallReceiveI+0x36>
  }

  usb_lld_stall_out(usbp, ep);
 8006ec8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006ecc:	9801      	ldr	r0, [sp, #4]
 8006ece:	4619      	mov	r1, r3
 8006ed0:	f002 fc5e 	bl	8009790 <usb_lld_stall_out>
  return false;
 8006ed4:	2300      	movs	r3, #0
}
 8006ed6:	4618      	mov	r0, r3
 8006ed8:	b003      	add	sp, #12
 8006eda:	f85d fb04 	ldr.w	pc, [sp], #4
 8006ede:	bf00      	nop

08006ee0 <usbStallTransmitI>:
 * @retval false        Endpoint stalled.
 * @retval true         Endpoint busy, not stalled.
 *
 * @iclass
 */
bool usbStallTransmitI(USBDriver *usbp, usbep_t ep) {
 8006ee0:	b500      	push	{lr}
 8006ee2:	b083      	sub	sp, #12
 8006ee4:	9001      	str	r0, [sp, #4]
 8006ee6:	460b      	mov	r3, r1
 8006ee8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8006eec:	9b01      	ldr	r3, [sp, #4]
 8006eee:	891a      	ldrh	r2, [r3, #8]
 8006ef0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006ef4:	2101      	movs	r1, #1
 8006ef6:	fa01 f303 	lsl.w	r3, r1, r3
 8006efa:	b29b      	uxth	r3, r3
 8006efc:	4013      	ands	r3, r2
 8006efe:	b29b      	uxth	r3, r3
 8006f00:	2b00      	cmp	r3, #0
 8006f02:	d001      	beq.n	8006f08 <usbStallTransmitI+0x28>
    return true;
 8006f04:	2301      	movs	r3, #1
 8006f06:	e006      	b.n	8006f16 <usbStallTransmitI+0x36>
  }

  usb_lld_stall_in(usbp, ep);
 8006f08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006f0c:	9801      	ldr	r0, [sp, #4]
 8006f0e:	4619      	mov	r1, r3
 8006f10:	f002 fc5e 	bl	80097d0 <usb_lld_stall_in>
  return false;
 8006f14:	2300      	movs	r3, #0
}
 8006f16:	4618      	mov	r0, r3
 8006f18:	b003      	add	sp, #12
 8006f1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f1e:	bf00      	nop

08006f20 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8006f20:	b500      	push	{lr}
 8006f22:	b085      	sub	sp, #20
 8006f24:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8006f26:	9b01      	ldr	r3, [sp, #4]
 8006f28:	2202      	movs	r2, #2
 8006f2a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 8006f2c:	9b01      	ldr	r3, [sp, #4]
 8006f2e:	2200      	movs	r2, #0
 8006f30:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
  usbp->address       = 0;
 8006f34:	9b01      	ldr	r3, [sp, #4]
 8006f36:	2200      	movs	r2, #0
 8006f38:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usbp->configuration = 0;
 8006f3c:	9b01      	ldr	r3, [sp, #4]
 8006f3e:	2200      	movs	r2, #0
 8006f40:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
  usbp->transmitting  = 0;
 8006f44:	9b01      	ldr	r3, [sp, #4]
 8006f46:	2200      	movs	r2, #0
 8006f48:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 8006f4a:	9b01      	ldr	r3, [sp, #4]
 8006f4c:	2200      	movs	r2, #0
 8006f4e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006f50:	2300      	movs	r3, #0
 8006f52:	9303      	str	r3, [sp, #12]
 8006f54:	e009      	b.n	8006f6a <_usb_reset+0x4a>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8006f56:	9a01      	ldr	r2, [sp, #4]
 8006f58:	9b03      	ldr	r3, [sp, #12]
 8006f5a:	3302      	adds	r3, #2
 8006f5c:	009b      	lsls	r3, r3, #2
 8006f5e:	4413      	add	r3, r2
 8006f60:	2200      	movs	r2, #0
 8006f62:	605a      	str	r2, [r3, #4]
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006f64:	9b03      	ldr	r3, [sp, #12]
 8006f66:	3301      	adds	r3, #1
 8006f68:	9303      	str	r3, [sp, #12]
 8006f6a:	9b03      	ldr	r3, [sp, #12]
 8006f6c:	2b05      	cmp	r3, #5
 8006f6e:	d9f2      	bls.n	8006f56 <_usb_reset+0x36>
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006f70:	9b01      	ldr	r3, [sp, #4]
 8006f72:	2200      	movs	r2, #0
 8006f74:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8006f78:	9801      	ldr	r0, [sp, #4]
 8006f7a:	f002 f871 	bl	8009060 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8006f7e:	9b01      	ldr	r3, [sp, #4]
 8006f80:	685b      	ldr	r3, [r3, #4]
 8006f82:	681b      	ldr	r3, [r3, #0]
 8006f84:	2b00      	cmp	r3, #0
 8006f86:	d005      	beq.n	8006f94 <_usb_reset+0x74>
 8006f88:	9b01      	ldr	r3, [sp, #4]
 8006f8a:	685b      	ldr	r3, [r3, #4]
 8006f8c:	681b      	ldr	r3, [r3, #0]
 8006f8e:	9801      	ldr	r0, [sp, #4]
 8006f90:	2100      	movs	r1, #0
 8006f92:	4798      	blx	r3
}
 8006f94:	b005      	add	sp, #20
 8006f96:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f9a:	bf00      	nop
 8006f9c:	f3af 8000 	nop.w

08006fa0 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8006fa0:	b500      	push	{lr}
 8006fa2:	b083      	sub	sp, #12
 8006fa4:	9001      	str	r0, [sp, #4]
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8006fa6:	9b01      	ldr	r3, [sp, #4]
 8006fa8:	781a      	ldrb	r2, [r3, #0]
 8006faa:	9b01      	ldr	r3, [sp, #4]
 8006fac:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
 8006fb0:	9b01      	ldr	r3, [sp, #4]
 8006fb2:	2205      	movs	r2, #5
 8006fb4:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8006fb6:	9b01      	ldr	r3, [sp, #4]
 8006fb8:	685b      	ldr	r3, [r3, #4]
 8006fba:	681b      	ldr	r3, [r3, #0]
 8006fbc:	2b00      	cmp	r3, #0
 8006fbe:	d005      	beq.n	8006fcc <_usb_suspend+0x2c>
 8006fc0:	9b01      	ldr	r3, [sp, #4]
 8006fc2:	685b      	ldr	r3, [r3, #4]
 8006fc4:	681b      	ldr	r3, [r3, #0]
 8006fc6:	9801      	ldr	r0, [sp, #4]
 8006fc8:	2104      	movs	r1, #4
 8006fca:	4798      	blx	r3
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8006fcc:	b003      	add	sp, #12
 8006fce:	f85d fb04 	ldr.w	pc, [sp], #4
 8006fd2:	bf00      	nop
 8006fd4:	f3af 8000 	nop.w
 8006fd8:	f3af 8000 	nop.w
 8006fdc:	f3af 8000 	nop.w

08006fe0 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 8006fe0:	b500      	push	{lr}
 8006fe2:	b083      	sub	sp, #12
 8006fe4:	9001      	str	r0, [sp, #4]

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8006fe6:	9b01      	ldr	r3, [sp, #4]
 8006fe8:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
 8006fec:	9b01      	ldr	r3, [sp, #4]
 8006fee:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8006ff0:	9b01      	ldr	r3, [sp, #4]
 8006ff2:	685b      	ldr	r3, [r3, #4]
 8006ff4:	681b      	ldr	r3, [r3, #0]
 8006ff6:	2b00      	cmp	r3, #0
 8006ff8:	d005      	beq.n	8007006 <_usb_wakeup+0x26>
 8006ffa:	9b01      	ldr	r3, [sp, #4]
 8006ffc:	685b      	ldr	r3, [r3, #4]
 8006ffe:	681b      	ldr	r3, [r3, #0]
 8007000:	9801      	ldr	r0, [sp, #4]
 8007002:	2105      	movs	r1, #5
 8007004:	4798      	blx	r3
}
 8007006:	b003      	add	sp, #12
 8007008:	f85d fb04 	ldr.w	pc, [sp], #4
 800700c:	f3af 8000 	nop.w

08007010 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8007010:	b500      	push	{lr}
 8007012:	b085      	sub	sp, #20
 8007014:	9001      	str	r0, [sp, #4]
 8007016:	460b      	mov	r3, r1
 8007018:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800701c:	9b01      	ldr	r3, [sp, #4]
 800701e:	2200      	movs	r2, #0
 8007020:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  usbReadSetup(usbp, ep, usbp->setup);
 8007024:	9b01      	ldr	r3, [sp, #4]
 8007026:	335c      	adds	r3, #92	; 0x5c
 8007028:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800702c:	9801      	ldr	r0, [sp, #4]
 800702e:	4611      	mov	r1, r2
 8007030:	461a      	mov	r2, r3
 8007032:	f002 fa45 	bl	80094c0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8007036:	9b01      	ldr	r3, [sp, #4]
 8007038:	685b      	ldr	r3, [r3, #4]
 800703a:	689b      	ldr	r3, [r3, #8]
 800703c:	2b00      	cmp	r3, #0
 800703e:	d00a      	beq.n	8007056 <_usb_ep0setup+0x46>
      !(usbp->config->requests_hook_cb(usbp))) {
 8007040:	9b01      	ldr	r3, [sp, #4]
 8007042:	685b      	ldr	r3, [r3, #4]
 8007044:	689b      	ldr	r3, [r3, #8]
 8007046:	9801      	ldr	r0, [sp, #4]
 8007048:	4798      	blx	r3
 800704a:	4603      	mov	r3, r0
 800704c:	f083 0301 	eor.w	r3, r3, #1
 8007050:	b2db      	uxtb	r3, r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8007052:	2b00      	cmp	r3, #0
 8007054:	d027      	beq.n	80070a6 <_usb_ep0setup+0x96>
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8007056:	9b01      	ldr	r3, [sp, #4]
 8007058:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800705c:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8007060:	2b00      	cmp	r3, #0
 8007062:	d108      	bne.n	8007076 <_usb_ep0setup+0x66>
        !default_handler(usbp)) {
 8007064:	9801      	ldr	r0, [sp, #4]
 8007066:	f7ff fbf3 	bl	8006850 <default_handler>
 800706a:	4603      	mov	r3, r0
 800706c:	f083 0301 	eor.w	r3, r3, #1
 8007070:	b2db      	uxtb	r3, r3
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8007072:	2b00      	cmp	r3, #0
 8007074:	d017      	beq.n	80070a6 <_usb_ep0setup+0x96>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8007076:	9801      	ldr	r0, [sp, #4]
 8007078:	2100      	movs	r1, #0
 800707a:	f002 fba9 	bl	80097d0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800707e:	9801      	ldr	r0, [sp, #4]
 8007080:	2100      	movs	r1, #0
 8007082:	f002 fb85 	bl	8009790 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8007086:	9b01      	ldr	r3, [sp, #4]
 8007088:	685b      	ldr	r3, [r3, #4]
 800708a:	681b      	ldr	r3, [r3, #0]
 800708c:	2b00      	cmp	r3, #0
 800708e:	d005      	beq.n	800709c <_usb_ep0setup+0x8c>
 8007090:	9b01      	ldr	r3, [sp, #4]
 8007092:	685b      	ldr	r3, [r3, #4]
 8007094:	681b      	ldr	r3, [r3, #0]
 8007096:	9801      	ldr	r0, [sp, #4]
 8007098:	2106      	movs	r1, #6
 800709a:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800709c:	9b01      	ldr	r3, [sp, #4]
 800709e:	2206      	movs	r2, #6
 80070a0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      return;
 80070a4:	e05c      	b.n	8007160 <_usb_ep0setup+0x150>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 80070a6:	9b01      	ldr	r3, [sp, #4]
 80070a8:	3362      	adds	r3, #98	; 0x62
 80070aa:	4618      	mov	r0, r3
 80070ac:	f7ff fb98 	bl	80067e0 <get_hword>
 80070b0:	4603      	mov	r3, r0
 80070b2:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 80070b4:	9b01      	ldr	r3, [sp, #4]
 80070b6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80070b8:	9b03      	ldr	r3, [sp, #12]
 80070ba:	429a      	cmp	r2, r3
 80070bc:	d902      	bls.n	80070c4 <_usb_ep0setup+0xb4>
    usbp->ep0n = max;
 80070be:	9b01      	ldr	r3, [sp, #4]
 80070c0:	9a03      	ldr	r2, [sp, #12]
 80070c2:	655a      	str	r2, [r3, #84]	; 0x54
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80070c4:	9b01      	ldr	r3, [sp, #4]
 80070c6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80070ca:	b2db      	uxtb	r3, r3
 80070cc:	b25b      	sxtb	r3, r3
 80070ce:	2b00      	cmp	r3, #0
 80070d0:	da23      	bge.n	800711a <_usb_ep0setup+0x10a>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 80070d2:	9b01      	ldr	r3, [sp, #4]
 80070d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80070d6:	2b00      	cmp	r3, #0
 80070d8:	d010      	beq.n	80070fc <_usb_ep0setup+0xec>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 80070da:	9b01      	ldr	r3, [sp, #4]
 80070dc:	2201      	movs	r2, #1
 80070de:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 80070e2:	f7ff fb65 	bl	80067b0 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80070e6:	9b01      	ldr	r3, [sp, #4]
 80070e8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80070ea:	9b01      	ldr	r3, [sp, #4]
 80070ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80070ee:	9801      	ldr	r0, [sp, #4]
 80070f0:	2100      	movs	r1, #0
 80070f2:	f7ff fea5 	bl	8006e40 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80070f6:	f7ff fb63 	bl	80067c0 <osalSysUnlockFromISR>
 80070fa:	e031      	b.n	8007160 <_usb_ep0setup+0x150>
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 80070fc:	9b01      	ldr	r3, [sp, #4]
 80070fe:	2203      	movs	r2, #3
 8007100:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8007104:	f7ff fb54 	bl	80067b0 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8007108:	9801      	ldr	r0, [sp, #4]
 800710a:	2100      	movs	r1, #0
 800710c:	2200      	movs	r2, #0
 800710e:	2300      	movs	r3, #0
 8007110:	f7ff fe66 	bl	8006de0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8007114:	f7ff fb54 	bl	80067c0 <osalSysUnlockFromISR>
 8007118:	e022      	b.n	8007160 <_usb_ep0setup+0x150>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 800711a:	9b01      	ldr	r3, [sp, #4]
 800711c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800711e:	2b00      	cmp	r3, #0
 8007120:	d010      	beq.n	8007144 <_usb_ep0setup+0x134>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8007122:	9b01      	ldr	r3, [sp, #4]
 8007124:	2204      	movs	r2, #4
 8007126:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 800712a:	f7ff fb41 	bl	80067b0 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800712e:	9b01      	ldr	r3, [sp, #4]
 8007130:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8007132:	9b01      	ldr	r3, [sp, #4]
 8007134:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007136:	9801      	ldr	r0, [sp, #4]
 8007138:	2100      	movs	r1, #0
 800713a:	f7ff fe51 	bl	8006de0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 800713e:	f7ff fb3f 	bl	80067c0 <osalSysUnlockFromISR>
 8007142:	e00d      	b.n	8007160 <_usb_ep0setup+0x150>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8007144:	9b01      	ldr	r3, [sp, #4]
 8007146:	2205      	movs	r2, #5
 8007148:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 800714c:	f7ff fb30 	bl	80067b0 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8007150:	9801      	ldr	r0, [sp, #4]
 8007152:	2100      	movs	r1, #0
 8007154:	2200      	movs	r2, #0
 8007156:	2300      	movs	r3, #0
 8007158:	f7ff fe72 	bl	8006e40 <usbStartTransmitI>
      osalSysUnlockFromISR();
 800715c:	f7ff fb30 	bl	80067c0 <osalSysUnlockFromISR>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8007160:	b005      	add	sp, #20
 8007162:	f85d fb04 	ldr.w	pc, [sp], #4
 8007166:	bf00      	nop
 8007168:	f3af 8000 	nop.w
 800716c:	f3af 8000 	nop.w

08007170 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8007170:	b500      	push	{lr}
 8007172:	b085      	sub	sp, #20
 8007174:	9001      	str	r0, [sp, #4]
 8007176:	460b      	mov	r3, r1
 8007178:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800717c:	9b01      	ldr	r3, [sp, #4]
 800717e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8007182:	2b06      	cmp	r3, #6
 8007184:	d86b      	bhi.n	800725e <_usb_ep0in+0xee>
 8007186:	a201      	add	r2, pc, #4	; (adr r2, 800718c <_usb_ep0in+0x1c>)
 8007188:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800718c:	0800722f 	.word	0x0800722f
 8007190:	080071a9 	.word	0x080071a9
 8007194:	080071f7 	.word	0x080071f7
 8007198:	0800722f 	.word	0x0800722f
 800719c:	0800722f 	.word	0x0800722f
 80071a0:	08007215 	.word	0x08007215
 80071a4:	0800722f 	.word	0x0800722f
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 80071a8:	9b01      	ldr	r3, [sp, #4]
 80071aa:	3362      	adds	r3, #98	; 0x62
 80071ac:	4618      	mov	r0, r3
 80071ae:	f7ff fb17 	bl	80067e0 <get_hword>
 80071b2:	4603      	mov	r3, r0
 80071b4:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80071b6:	9b01      	ldr	r3, [sp, #4]
 80071b8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80071ba:	9b03      	ldr	r3, [sp, #12]
 80071bc:	429a      	cmp	r2, r3
 80071be:	d21a      	bcs.n	80071f6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80071c0:	9b01      	ldr	r3, [sp, #4]
 80071c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80071c4:	9a01      	ldr	r2, [sp, #4]
 80071c6:	68d2      	ldr	r2, [r2, #12]
 80071c8:	8a12      	ldrh	r2, [r2, #16]
 80071ca:	fbb3 f1f2 	udiv	r1, r3, r2
 80071ce:	fb02 f201 	mul.w	r2, r2, r1
 80071d2:	1a9b      	subs	r3, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80071d4:	2b00      	cmp	r3, #0
 80071d6:	d10e      	bne.n	80071f6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
 80071d8:	f7ff faea 	bl	80067b0 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 80071dc:	9801      	ldr	r0, [sp, #4]
 80071de:	2100      	movs	r1, #0
 80071e0:	2200      	movs	r2, #0
 80071e2:	2300      	movs	r3, #0
 80071e4:	f7ff fe2c 	bl	8006e40 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80071e8:	f7ff faea 	bl	80067c0 <osalSysUnlockFromISR>
      usbp->ep0state = USB_EP0_WAITING_TX0;
 80071ec:	9b01      	ldr	r3, [sp, #4]
 80071ee:	2202      	movs	r2, #2
 80071f0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      return;
 80071f4:	e033      	b.n	800725e <_usb_ep0in+0xee>
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 80071f6:	9b01      	ldr	r3, [sp, #4]
 80071f8:	2203      	movs	r2, #3
 80071fa:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 80071fe:	f7ff fad7 	bl	80067b0 <osalSysLockFromISR>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8007202:	9801      	ldr	r0, [sp, #4]
 8007204:	2100      	movs	r1, #0
 8007206:	2200      	movs	r2, #0
 8007208:	2300      	movs	r3, #0
 800720a:	f7ff fde9 	bl	8006de0 <usbStartReceiveI>
    osalSysUnlockFromISR();
 800720e:	f7ff fad7 	bl	80067c0 <osalSysUnlockFromISR>
#else
    usb_lld_end_setup(usbp, ep);
#endif
    return;
 8007212:	e024      	b.n	800725e <_usb_ep0in+0xee>
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8007214:	9b01      	ldr	r3, [sp, #4]
 8007216:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007218:	2b00      	cmp	r3, #0
 800721a:	d003      	beq.n	8007224 <_usb_ep0in+0xb4>
      usbp->ep0endcb(usbp);
 800721c:	9b01      	ldr	r3, [sp, #4]
 800721e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007220:	9801      	ldr	r0, [sp, #4]
 8007222:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8007224:	9b01      	ldr	r3, [sp, #4]
 8007226:	2200      	movs	r2, #0
 8007228:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 800722c:	e017      	b.n	800725e <_usb_ep0in+0xee>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800722e:	9801      	ldr	r0, [sp, #4]
 8007230:	2100      	movs	r1, #0
 8007232:	f002 facd 	bl	80097d0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8007236:	9801      	ldr	r0, [sp, #4]
 8007238:	2100      	movs	r1, #0
 800723a:	f002 faa9 	bl	8009790 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800723e:	9b01      	ldr	r3, [sp, #4]
 8007240:	685b      	ldr	r3, [r3, #4]
 8007242:	681b      	ldr	r3, [r3, #0]
 8007244:	2b00      	cmp	r3, #0
 8007246:	d005      	beq.n	8007254 <_usb_ep0in+0xe4>
 8007248:	9b01      	ldr	r3, [sp, #4]
 800724a:	685b      	ldr	r3, [r3, #4]
 800724c:	681b      	ldr	r3, [r3, #0]
 800724e:	9801      	ldr	r0, [sp, #4]
 8007250:	2106      	movs	r1, #6
 8007252:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8007254:	9b01      	ldr	r3, [sp, #4]
 8007256:	2206      	movs	r2, #6
 8007258:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 800725c:	bf00      	nop
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800725e:	b005      	add	sp, #20
 8007260:	f85d fb04 	ldr.w	pc, [sp], #4
 8007264:	f3af 8000 	nop.w
 8007268:	f3af 8000 	nop.w
 800726c:	f3af 8000 	nop.w

08007270 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8007270:	b500      	push	{lr}
 8007272:	b083      	sub	sp, #12
 8007274:	9001      	str	r0, [sp, #4]
 8007276:	460b      	mov	r3, r1
 8007278:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 800727c:	9b01      	ldr	r3, [sp, #4]
 800727e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8007282:	2b06      	cmp	r3, #6
 8007284:	d84b      	bhi.n	800731e <_usb_ep0out+0xae>
 8007286:	a201      	add	r2, pc, #4	; (adr r2, 800728c <_usb_ep0out+0x1c>)
 8007288:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800728c:	080072ef 	.word	0x080072ef
 8007290:	080072ef 	.word	0x080072ef
 8007294:	080072ef 	.word	0x080072ef
 8007298:	080072c7 	.word	0x080072c7
 800729c:	080072a9 	.word	0x080072a9
 80072a0:	080072ef 	.word	0x080072ef
 80072a4:	080072ef 	.word	0x080072ef
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 80072a8:	9b01      	ldr	r3, [sp, #4]
 80072aa:	2205      	movs	r2, #5
 80072ac:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 80072b0:	f7ff fa7e 	bl	80067b0 <osalSysLockFromISR>
    usbStartTransmitI(usbp, 0, NULL, 0);
 80072b4:	9801      	ldr	r0, [sp, #4]
 80072b6:	2100      	movs	r1, #0
 80072b8:	2200      	movs	r2, #0
 80072ba:	2300      	movs	r3, #0
 80072bc:	f7ff fdc0 	bl	8006e40 <usbStartTransmitI>
    osalSysUnlockFromISR();
 80072c0:	f7ff fa7e 	bl	80067c0 <osalSysUnlockFromISR>
#else
    usb_lld_end_setup(usbp, ep);
#endif
    return;
 80072c4:	e02b      	b.n	800731e <_usb_ep0out+0xae>
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80072c6:	9b01      	ldr	r3, [sp, #4]
 80072c8:	68db      	ldr	r3, [r3, #12]
 80072ca:	699b      	ldr	r3, [r3, #24]
 80072cc:	685b      	ldr	r3, [r3, #4]
 80072ce:	2b00      	cmp	r3, #0
 80072d0:	d000      	beq.n	80072d4 <_usb_ep0out+0x64>
      break;
 80072d2:	e024      	b.n	800731e <_usb_ep0out+0xae>
    }
#endif
    if (usbp->ep0endcb != NULL) {
 80072d4:	9b01      	ldr	r3, [sp, #4]
 80072d6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80072d8:	2b00      	cmp	r3, #0
 80072da:	d003      	beq.n	80072e4 <_usb_ep0out+0x74>
      usbp->ep0endcb(usbp);
 80072dc:	9b01      	ldr	r3, [sp, #4]
 80072de:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80072e0:	9801      	ldr	r0, [sp, #4]
 80072e2:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80072e4:	9b01      	ldr	r3, [sp, #4]
 80072e6:	2200      	movs	r2, #0
 80072e8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 80072ec:	e017      	b.n	800731e <_usb_ep0out+0xae>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 80072ee:	9801      	ldr	r0, [sp, #4]
 80072f0:	2100      	movs	r1, #0
 80072f2:	f002 fa6d 	bl	80097d0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 80072f6:	9801      	ldr	r0, [sp, #4]
 80072f8:	2100      	movs	r1, #0
 80072fa:	f002 fa49 	bl	8009790 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80072fe:	9b01      	ldr	r3, [sp, #4]
 8007300:	685b      	ldr	r3, [r3, #4]
 8007302:	681b      	ldr	r3, [r3, #0]
 8007304:	2b00      	cmp	r3, #0
 8007306:	d005      	beq.n	8007314 <_usb_ep0out+0xa4>
 8007308:	9b01      	ldr	r3, [sp, #4]
 800730a:	685b      	ldr	r3, [r3, #4]
 800730c:	681b      	ldr	r3, [r3, #0]
 800730e:	9801      	ldr	r0, [sp, #4]
 8007310:	2106      	movs	r1, #6
 8007312:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8007314:	9b01      	ldr	r3, [sp, #4]
 8007316:	2206      	movs	r2, #6
 8007318:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 800731c:	bf00      	nop
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800731e:	b003      	add	sp, #12
 8007320:	f85d fb04 	ldr.w	pc, [sp], #4
 8007324:	f3af 8000 	nop.w
 8007328:	f3af 8000 	nop.w
 800732c:	f3af 8000 	nop.w

08007330 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8007330:	b082      	sub	sp, #8
 8007332:	9001      	str	r0, [sp, #4]
 8007334:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8007336:	4911      	ldr	r1, [pc, #68]	; (800737c <nvicEnableVector+0x4c>)
 8007338:	9b00      	ldr	r3, [sp, #0]
 800733a:	b2db      	uxtb	r3, r3
 800733c:	011b      	lsls	r3, r3, #4
 800733e:	b2da      	uxtb	r2, r3
 8007340:	9b01      	ldr	r3, [sp, #4]
 8007342:	440b      	add	r3, r1
 8007344:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8007348:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800734a:	4b0c      	ldr	r3, [pc, #48]	; (800737c <nvicEnableVector+0x4c>)
 800734c:	9a01      	ldr	r2, [sp, #4]
 800734e:	0952      	lsrs	r2, r2, #5
 8007350:	9901      	ldr	r1, [sp, #4]
 8007352:	f001 011f 	and.w	r1, r1, #31
 8007356:	2001      	movs	r0, #1
 8007358:	fa00 f101 	lsl.w	r1, r0, r1
 800735c:	3260      	adds	r2, #96	; 0x60
 800735e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007362:	4b06      	ldr	r3, [pc, #24]	; (800737c <nvicEnableVector+0x4c>)
 8007364:	9a01      	ldr	r2, [sp, #4]
 8007366:	0952      	lsrs	r2, r2, #5
 8007368:	9901      	ldr	r1, [sp, #4]
 800736a:	f001 011f 	and.w	r1, r1, #31
 800736e:	2001      	movs	r0, #1
 8007370:	fa00 f101 	lsl.w	r1, r0, r1
 8007374:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8007378:	b002      	add	sp, #8
 800737a:	4770      	bx	lr
 800737c:	e000e100 	.word	0xe000e100

08007380 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 8007380:	b082      	sub	sp, #8
 8007382:	9001      	str	r0, [sp, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8007384:	4b0a      	ldr	r3, [pc, #40]	; (80073b0 <nvicDisableVector+0x30>)
 8007386:	9a01      	ldr	r2, [sp, #4]
 8007388:	0952      	lsrs	r2, r2, #5
 800738a:	9901      	ldr	r1, [sp, #4]
 800738c:	f001 011f 	and.w	r1, r1, #31
 8007390:	2001      	movs	r0, #1
 8007392:	fa00 f101 	lsl.w	r1, r0, r1
 8007396:	3220      	adds	r2, #32
 8007398:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800739c:	4a04      	ldr	r2, [pc, #16]	; (80073b0 <nvicDisableVector+0x30>)
 800739e:	9b01      	ldr	r3, [sp, #4]
 80073a0:	4413      	add	r3, r2
 80073a2:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80073a6:	2200      	movs	r2, #0
 80073a8:	701a      	strb	r2, [r3, #0]
#endif
}
 80073aa:	b002      	add	sp, #8
 80073ac:	4770      	bx	lr
 80073ae:	bf00      	nop
 80073b0:	e000e100 	.word	0xe000e100
 80073b4:	f3af 8000 	nop.w
 80073b8:	f3af 8000 	nop.w
 80073bc:	f3af 8000 	nop.w

080073c0 <nvicSetSystemHandlerPriority>:
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 80073c0:	b082      	sub	sp, #8
 80073c2:	9001      	str	r0, [sp, #4]
 80073c4:	9100      	str	r1, [sp, #0]
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 80073c6:	4905      	ldr	r1, [pc, #20]	; (80073dc <nvicSetSystemHandlerPriority+0x1c>)
 80073c8:	9b00      	ldr	r3, [sp, #0]
 80073ca:	b2db      	uxtb	r3, r3
 80073cc:	011b      	lsls	r3, r3, #4
 80073ce:	b2da      	uxtb	r2, r3
 80073d0:	9b01      	ldr	r3, [sp, #4]
 80073d2:	440b      	add	r3, r1
 80073d4:	3318      	adds	r3, #24
 80073d6:	701a      	strb	r2, [r3, #0]
#endif
}
 80073d8:	b002      	add	sp, #8
 80073da:	4770      	bx	lr
 80073dc:	e000ed00 	.word	0xe000ed00

080073e0 <nvicClearPending>:
/**
 * @brief   Clears a pending interrupt source.
 *
 * @param[in] n         the interrupt number
 */
void nvicClearPending(uint32_t n) {
 80073e0:	b082      	sub	sp, #8
 80073e2:	9001      	str	r0, [sp, #4]

  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80073e4:	4b06      	ldr	r3, [pc, #24]	; (8007400 <nvicClearPending+0x20>)
 80073e6:	9a01      	ldr	r2, [sp, #4]
 80073e8:	0952      	lsrs	r2, r2, #5
 80073ea:	9901      	ldr	r1, [sp, #4]
 80073ec:	f001 011f 	and.w	r1, r1, #31
 80073f0:	2001      	movs	r0, #1
 80073f2:	fa00 f101 	lsl.w	r1, r0, r1
 80073f6:	3260      	adds	r2, #96	; 0x60
 80073f8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80073fc:	b002      	add	sp, #8
 80073fe:	4770      	bx	lr
 8007400:	e000e100 	.word	0xe000e100
 8007404:	f3af 8000 	nop.w
 8007408:	f3af 8000 	nop.w
 800740c:	f3af 8000 	nop.w

08007410 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8007410:	4b22      	ldr	r3, [pc, #136]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007412:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007416:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800741a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800741e:	d008      	beq.n	8007432 <hal_lld_backup_domain_init+0x22>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8007420:	4b1e      	ldr	r3, [pc, #120]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007422:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8007426:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    RCC->BDCR = 0;
 800742a:	4b1c      	ldr	r3, [pc, #112]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800742c:	2200      	movs	r2, #0
 800742e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 8007432:	4b1a      	ldr	r3, [pc, #104]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007434:	4a19      	ldr	r2, [pc, #100]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007436:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 800743a:	f042 0219 	orr.w	r2, r2, #25
 800743e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 8007442:	bf00      	nop
 8007444:	4b15      	ldr	r3, [pc, #84]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007446:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800744a:	f003 0302 	and.w	r3, r3, #2
 800744e:	2b00      	cmp	r3, #0
 8007450:	d0f8      	beq.n	8007444 <hal_lld_backup_domain_init+0x34>
#endif

#if STM32_MSIPLL_ENABLED
  /* MSI PLL activation depends on LSE. Reactivating and checking for
     MSI stability.*/
  RCC->CR |= RCC_CR_MSIPLLEN;
 8007452:	4b12      	ldr	r3, [pc, #72]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007454:	4a11      	ldr	r2, [pc, #68]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007456:	6812      	ldr	r2, [r2, #0]
 8007458:	f042 0204 	orr.w	r2, r2, #4
 800745c:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 800745e:	bf00      	nop
 8007460:	4b0e      	ldr	r3, [pc, #56]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007462:	681b      	ldr	r3, [r3, #0]
 8007464:	f003 0302 	and.w	r3, r3, #2
 8007468:	2b00      	cmp	r3, #0
 800746a:	d0f9      	beq.n	8007460 <hal_lld_backup_domain_init+0x50>
#endif

#if HAL_USE_RTC
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 800746c:	4b0b      	ldr	r3, [pc, #44]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800746e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007472:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007476:	2b00      	cmp	r3, #0
 8007478:	d10f      	bne.n	800749a <hal_lld_backup_domain_init+0x8a>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 800747a:	4b08      	ldr	r3, [pc, #32]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800747c:	4a07      	ldr	r2, [pc, #28]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800747e:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8007482:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8007486:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 800748a:	4b04      	ldr	r3, [pc, #16]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800748c:	4a03      	ldr	r2, [pc, #12]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800748e:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8007492:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8007496:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  }
#endif /* HAL_USE_RTC */
}
 800749a:	4770      	bx	lr
 800749c:	40021000 	.word	0x40021000

080074a0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80074a0:	b508      	push	{r3, lr}

  /* Reset of all peripherals.*/
  rccResetAHB1(~0);
 80074a2:	4b28      	ldr	r3, [pc, #160]	; (8007544 <hal_lld_init+0xa4>)
 80074a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80074a6:	4b27      	ldr	r3, [pc, #156]	; (8007544 <hal_lld_init+0xa4>)
 80074a8:	f04f 32ff 	mov.w	r2, #4294967295
 80074ac:	629a      	str	r2, [r3, #40]	; 0x28
 80074ae:	4b25      	ldr	r3, [pc, #148]	; (8007544 <hal_lld_init+0xa4>)
 80074b0:	2200      	movs	r2, #0
 80074b2:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAHB2(~0);
 80074b4:	4b23      	ldr	r3, [pc, #140]	; (8007544 <hal_lld_init+0xa4>)
 80074b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80074b8:	4b22      	ldr	r3, [pc, #136]	; (8007544 <hal_lld_init+0xa4>)
 80074ba:	f04f 32ff 	mov.w	r2, #4294967295
 80074be:	62da      	str	r2, [r3, #44]	; 0x2c
 80074c0:	4b20      	ldr	r3, [pc, #128]	; (8007544 <hal_lld_init+0xa4>)
 80074c2:	2200      	movs	r2, #0
 80074c4:	62da      	str	r2, [r3, #44]	; 0x2c
  rccResetAHB3(~0);
 80074c6:	4b1f      	ldr	r3, [pc, #124]	; (8007544 <hal_lld_init+0xa4>)
 80074c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80074ca:	4b1e      	ldr	r3, [pc, #120]	; (8007544 <hal_lld_init+0xa4>)
 80074cc:	f04f 32ff 	mov.w	r2, #4294967295
 80074d0:	631a      	str	r2, [r3, #48]	; 0x30
 80074d2:	4b1c      	ldr	r3, [pc, #112]	; (8007544 <hal_lld_init+0xa4>)
 80074d4:	2200      	movs	r2, #0
 80074d6:	631a      	str	r2, [r3, #48]	; 0x30
  rccResetAPB1R1(~RCC_APB1RSTR1_PWRRST);
 80074d8:	4b1a      	ldr	r3, [pc, #104]	; (8007544 <hal_lld_init+0xa4>)
 80074da:	4a1a      	ldr	r2, [pc, #104]	; (8007544 <hal_lld_init+0xa4>)
 80074dc:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80074de:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 80074e2:	639a      	str	r2, [r3, #56]	; 0x38
 80074e4:	4b17      	ldr	r3, [pc, #92]	; (8007544 <hal_lld_init+0xa4>)
 80074e6:	2200      	movs	r2, #0
 80074e8:	639a      	str	r2, [r3, #56]	; 0x38
  rccResetAPB1R2(~0);
 80074ea:	4b16      	ldr	r3, [pc, #88]	; (8007544 <hal_lld_init+0xa4>)
 80074ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80074ee:	4b15      	ldr	r3, [pc, #84]	; (8007544 <hal_lld_init+0xa4>)
 80074f0:	f04f 32ff 	mov.w	r2, #4294967295
 80074f4:	63da      	str	r2, [r3, #60]	; 0x3c
 80074f6:	4b13      	ldr	r3, [pc, #76]	; (8007544 <hal_lld_init+0xa4>)
 80074f8:	2200      	movs	r2, #0
 80074fa:	63da      	str	r2, [r3, #60]	; 0x3c
  rccResetAPB2(~0);
 80074fc:	4b11      	ldr	r3, [pc, #68]	; (8007544 <hal_lld_init+0xa4>)
 80074fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007500:	4b10      	ldr	r3, [pc, #64]	; (8007544 <hal_lld_init+0xa4>)
 8007502:	f04f 32ff 	mov.w	r2, #4294967295
 8007506:	641a      	str	r2, [r3, #64]	; 0x40
 8007508:	4b0e      	ldr	r3, [pc, #56]	; (8007544 <hal_lld_init+0xa4>)
 800750a:	2200      	movs	r2, #0
 800750c:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800750e:	4b0d      	ldr	r3, [pc, #52]	; (8007544 <hal_lld_init+0xa4>)
 8007510:	4a0c      	ldr	r2, [pc, #48]	; (8007544 <hal_lld_init+0xa4>)
 8007512:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8007514:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007518:	659a      	str	r2, [r3, #88]	; 0x58

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 800751a:	f7ff ff79 	bl	8007410 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800751e:	f000 fbf7 	bl	8007d10 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR2 = PWR_CR2_PVDE | (STM32_PLS & STM32_PLS_MASK);
#else
  PWR->CR2 = 0;
 8007522:	4b09      	ldr	r3, [pc, #36]	; (8007548 <hal_lld_init+0xa8>)
 8007524:	2200      	movs	r2, #0
 8007526:	605a      	str	r2, [r3, #4]
#endif /* STM32_PVD_ENABLE */

  /* Enabling independent VDDUSB.*/
#if HAL_USE_USB
  PWR->CR2 |= PWR_CR2_USV;
 8007528:	4b07      	ldr	r3, [pc, #28]	; (8007548 <hal_lld_init+0xa8>)
 800752a:	4a07      	ldr	r2, [pc, #28]	; (8007548 <hal_lld_init+0xa8>)
 800752c:	6852      	ldr	r2, [r2, #4]
 800752e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8007532:	605a      	str	r2, [r3, #4]
#endif /* HAL_USE_USB */

  /* Enabling independent VDDIO2 required by GPIOG.*/
#if STM32_HAS_GPIOG
  PWR->CR2 |= PWR_CR2_IOSV;
 8007534:	4b04      	ldr	r3, [pc, #16]	; (8007548 <hal_lld_init+0xa8>)
 8007536:	4a04      	ldr	r2, [pc, #16]	; (8007548 <hal_lld_init+0xa8>)
 8007538:	6852      	ldr	r2, [r2, #4]
 800753a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800753e:	605a      	str	r2, [r3, #4]
#endif /* STM32_HAS_GPIOG */
}
 8007540:	bd08      	pop	{r3, pc}
 8007542:	bf00      	nop
 8007544:	40021000 	.word	0x40021000
 8007548:	40007000 	.word	0x40007000
 800754c:	f3af 8000 	nop.w

08007550 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8007550:	b082      	sub	sp, #8

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR1 |= RCC_APB1ENR1_PWREN;
 8007552:	4b5e      	ldr	r3, [pc, #376]	; (80076cc <stm32_clock_init+0x17c>)
 8007554:	4a5d      	ldr	r2, [pc, #372]	; (80076cc <stm32_clock_init+0x17c>)
 8007556:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8007558:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800755c:	659a      	str	r2, [r3, #88]	; 0x58
  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fall back clock when PLL the fails.
     Trim fields are not altered from reset values.*/

  /* MSIRANGE can be set only when MSI is OFF or READY.*/
  RCC->CR = RCC_CR_MSION;
 800755e:	4b5b      	ldr	r3, [pc, #364]	; (80076cc <stm32_clock_init+0x17c>)
 8007560:	2201      	movs	r2, #1
 8007562:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8007564:	bf00      	nop
 8007566:	4b59      	ldr	r3, [pc, #356]	; (80076cc <stm32_clock_init+0x17c>)
 8007568:	681b      	ldr	r3, [r3, #0]
 800756a:	f003 0302 	and.w	r3, r3, #2
 800756e:	2b00      	cmp	r3, #0
 8007570:	d0f9      	beq.n	8007566 <stm32_clock_init+0x16>
    ;                                       /* Wait until MSI is stable.    */

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0;
 8007572:	4b56      	ldr	r3, [pc, #344]	; (80076cc <stm32_clock_init+0x17c>)
 8007574:	2200      	movs	r2, #0
 8007576:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8007578:	bf00      	nop
 800757a:	4b54      	ldr	r3, [pc, #336]	; (80076cc <stm32_clock_init+0x17c>)
 800757c:	689b      	ldr	r3, [r3, #8]
 800757e:	f003 030c 	and.w	r3, r3, #12
 8007582:	2b00      	cmp	r3, #0
 8007584:	d1f9      	bne.n	800757a <stm32_clock_init+0x2a>
    ;                                       /* Wait until MSI is selected.  */

  /* Core voltage setup.*/
  PWR->CR1 = STM32_VOS;
 8007586:	4b52      	ldr	r3, [pc, #328]	; (80076d0 <stm32_clock_init+0x180>)
 8007588:	f44f 7200 	mov.w	r2, #512	; 0x200
 800758c:	601a      	str	r2, [r3, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 800758e:	bf00      	nop
 8007590:	4b4f      	ldr	r3, [pc, #316]	; (80076d0 <stm32_clock_init+0x180>)
 8007592:	695b      	ldr	r3, [r3, #20]
 8007594:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8007598:	2b00      	cmp	r3, #0
 800759a:	d1f9      	bne.n	8007590 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSE is stable.    */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800759c:	4b4b      	ldr	r3, [pc, #300]	; (80076cc <stm32_clock_init+0x17c>)
 800759e:	4a4b      	ldr	r2, [pc, #300]	; (80076cc <stm32_clock_init+0x17c>)
 80075a0:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 80075a4:	f042 0201 	orr.w	r2, r2, #1
 80075a8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80075ac:	bf00      	nop
 80075ae:	4b47      	ldr	r3, [pc, #284]	; (80076cc <stm32_clock_init+0x17c>)
 80075b0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80075b4:	f003 0302 	and.w	r3, r3, #2
 80075b8:	2b00      	cmp	r3, #0
 80075ba:	d0f8      	beq.n	80075ae <stm32_clock_init+0x5e>
    ;                                       /* Wait until LSI is stable.    */
#endif

  /* Backup domain access enabled and left open.*/
  PWR->CR1 |= PWR_CR1_DBP;
 80075bc:	4b44      	ldr	r3, [pc, #272]	; (80076d0 <stm32_clock_init+0x180>)
 80075be:	4a44      	ldr	r2, [pc, #272]	; (80076d0 <stm32_clock_init+0x180>)
 80075c0:	6812      	ldr	r2, [r2, #0]
 80075c2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80075c6:	601a      	str	r2, [r3, #0]
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 80075c8:	4b40      	ldr	r3, [pc, #256]	; (80076cc <stm32_clock_init+0x17c>)
 80075ca:	4a40      	ldr	r2, [pc, #256]	; (80076cc <stm32_clock_init+0x17c>)
 80075cc:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 80075d0:	f042 0219 	orr.w	r2, r2, #25
 80075d4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 80075d8:	bf00      	nop
 80075da:	4b3c      	ldr	r3, [pc, #240]	; (80076cc <stm32_clock_init+0x17c>)
 80075dc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80075e0:	f003 0302 	and.w	r3, r3, #2
 80075e4:	2b00      	cmp	r3, #0
 80075e6:	d0f8      	beq.n	80075da <stm32_clock_init+0x8a>
    ;                                       /* Wait until LSE is stable.    */
#endif

  /* Flash setup for selected MSI speed setting.*/
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 80075e8:	4b3a      	ldr	r3, [pc, #232]	; (80076d4 <stm32_clock_init+0x184>)
 80075ea:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 80075ee:	601a      	str	r2, [r3, #0]
               STM32_MSI_FLASHBITS;

  /* Changing MSIRANGE to configured value.*/
  RCC->CR |= STM32_MSIRANGE;
 80075f0:	4b36      	ldr	r3, [pc, #216]	; (80076cc <stm32_clock_init+0x17c>)
 80075f2:	4a36      	ldr	r2, [pc, #216]	; (80076cc <stm32_clock_init+0x17c>)
 80075f4:	6812      	ldr	r2, [r2, #0]
 80075f6:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 80075fa:	601a      	str	r2, [r3, #0]

  /* Switching from MSISRANGE to MSIRANGE.*/
  RCC->CR |= RCC_CR_MSIRGSEL;
 80075fc:	4b33      	ldr	r3, [pc, #204]	; (80076cc <stm32_clock_init+0x17c>)
 80075fe:	4a33      	ldr	r2, [pc, #204]	; (80076cc <stm32_clock_init+0x17c>)
 8007600:	6812      	ldr	r2, [r2, #0]
 8007602:	f042 0208 	orr.w	r2, r2, #8
 8007606:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8007608:	bf00      	nop
 800760a:	4b30      	ldr	r3, [pc, #192]	; (80076cc <stm32_clock_init+0x17c>)
 800760c:	681b      	ldr	r3, [r3, #0]
 800760e:	f003 0302 	and.w	r3, r3, #2
 8007612:	2b00      	cmp	r3, #0
 8007614:	d0f9      	beq.n	800760a <stm32_clock_init+0xba>
    ;

  /* MSI is configured SYSCLK source so wait for it to be stable as well.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8007616:	bf00      	nop
 8007618:	4b2c      	ldr	r3, [pc, #176]	; (80076cc <stm32_clock_init+0x17c>)
 800761a:	689b      	ldr	r3, [r3, #8]
 800761c:	f003 030c 	and.w	r3, r3, #12
 8007620:	2b00      	cmp	r3, #0
 8007622:	d1f9      	bne.n	8007618 <stm32_clock_init+0xc8>
    ;

#if STM32_MSIPLL_ENABLED
  /* MSI PLL (to LSE) activation */
  RCC->CR |= RCC_CR_MSIPLLEN;
 8007624:	4b29      	ldr	r3, [pc, #164]	; (80076cc <stm32_clock_init+0x17c>)
 8007626:	4a29      	ldr	r2, [pc, #164]	; (80076cc <stm32_clock_init+0x17c>)
 8007628:	6812      	ldr	r2, [r2, #0]
 800762a:	f042 0204 	orr.w	r2, r2, #4
 800762e:	601a      	str	r2, [r3, #0]
#endif

  /* Updating MSISRANGE value. MSISRANGE can be set only when MSIRGSEL is high.
     This range is used exiting the Standby mode until MSIRGSEL is set.*/
  RCC->CSR |= STM32_MSISRANGE;
 8007630:	4b26      	ldr	r3, [pc, #152]	; (80076cc <stm32_clock_init+0x17c>)
 8007632:	4a26      	ldr	r2, [pc, #152]	; (80076cc <stm32_clock_init+0x17c>)
 8007634:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 8007638:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
 800763c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

#if STM32_ACTIVATE_PLL || STM32_ACTIVATE_PLLSAI1 || STM32_ACTIVATE_PLLSAI2
  /* PLLM and PLLSRC are common to all PLLs.*/
  RCC->PLLCFGR = STM32_PLLR   | STM32_PLLREN |
 8007640:	4b22      	ldr	r3, [pc, #136]	; (80076cc <stm32_clock_init+0x17c>)
 8007642:	4a25      	ldr	r2, [pc, #148]	; (80076d8 <stm32_clock_init+0x188>)
 8007644:	60da      	str	r2, [r3, #12]
                 STM32_PLLSRC;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR |= RCC_CR_PLLON;
 8007646:	4b21      	ldr	r3, [pc, #132]	; (80076cc <stm32_clock_init+0x17c>)
 8007648:	4a20      	ldr	r2, [pc, #128]	; (80076cc <stm32_clock_init+0x17c>)
 800764a:	6812      	ldr	r2, [r2, #0]
 800764c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8007650:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLRDY) == 0)
 8007652:	bf00      	nop
 8007654:	4b1d      	ldr	r3, [pc, #116]	; (80076cc <stm32_clock_init+0x17c>)
 8007656:	681b      	ldr	r3, [r3, #0]
 8007658:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800765c:	2b00      	cmp	r3, #0
 800765e:	d0f9      	beq.n	8007654 <stm32_clock_init+0x104>
    ;
#endif

#if STM32_ACTIVATE_PLLSAI1
  /* PLLSAI1 activation.*/
  RCC->PLLSAI1CFGR = STM32_PLLSAI1R | STM32_PLLSAI1REN |
 8007660:	4b1a      	ldr	r3, [pc, #104]	; (80076cc <stm32_clock_init+0x17c>)
 8007662:	4a1e      	ldr	r2, [pc, #120]	; (80076dc <stm32_clock_init+0x18c>)
 8007664:	611a      	str	r2, [r3, #16]
                     STM32_PLLSAI1Q | STM32_PLLSAI1QEN |
                     STM32_PLLSAI1P | STM32_PLLSAI1PEN |
                     STM32_PLLSAI1N;
  RCC->CR |= RCC_CR_PLLSAI1ON;
 8007666:	4b19      	ldr	r3, [pc, #100]	; (80076cc <stm32_clock_init+0x17c>)
 8007668:	4a18      	ldr	r2, [pc, #96]	; (80076cc <stm32_clock_init+0x17c>)
 800766a:	6812      	ldr	r2, [r2, #0]
 800766c:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8007670:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLSAI1RDY) == 0)
 8007672:	bf00      	nop
 8007674:	4b15      	ldr	r3, [pc, #84]	; (80076cc <stm32_clock_init+0x17c>)
 8007676:	681b      	ldr	r3, [r3, #0]
 8007678:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800767c:	2b00      	cmp	r3, #0
 800767e:	d0f9      	beq.n	8007674 <stm32_clock_init+0x124>
  while ((RCC->CR & RCC_CR_PLLSAI2RDY) == 0)
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 8007680:	4b12      	ldr	r3, [pc, #72]	; (80076cc <stm32_clock_init+0x17c>)
 8007682:	2200      	movs	r2, #0
 8007684:	609a      	str	r2, [r3, #8]
              STM32_PPRE2  | STM32_PPRE1  | STM32_HPRE;

  /* CCIPR register initialization, note, must take care of the _OFF
     pseudo settings.*/
  {
    uint32_t ccipr = STM32_DFSDMSEL  | STM32_SWPMI1SEL | STM32_ADCSEL    |
 8007686:	4b16      	ldr	r3, [pc, #88]	; (80076e0 <stm32_clock_init+0x190>)
 8007688:	9301      	str	r3, [sp, #4]
    ccipr |= STM32_SAI2SEL;
#endif
#if STM32_SAI1SEL != STM32_SAI1SEL_OFF
    ccipr |= STM32_SAI1SEL;
#endif
    RCC->CCIPR = ccipr;
 800768a:	4b10      	ldr	r3, [pc, #64]	; (80076cc <stm32_clock_init+0x17c>)
 800768c:	9a01      	ldr	r2, [sp, #4]
 800768e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  }

  /* Set flash WS's for SYSCLK source */
  if (STM32_FLASHBITS > STM32_MSI_FLASHBITS)
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS;
 8007692:	4b10      	ldr	r3, [pc, #64]	; (80076d4 <stm32_clock_init+0x184>)
 8007694:	4a0f      	ldr	r2, [pc, #60]	; (80076d4 <stm32_clock_init+0x184>)
 8007696:	6812      	ldr	r2, [r2, #0]
 8007698:	f022 0207 	bic.w	r2, r2, #7
 800769c:	f042 0204 	orr.w	r2, r2, #4
 80076a0:	601a      	str	r2, [r3, #0]

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80076a2:	4b0a      	ldr	r3, [pc, #40]	; (80076cc <stm32_clock_init+0x17c>)
 80076a4:	4a09      	ldr	r2, [pc, #36]	; (80076cc <stm32_clock_init+0x17c>)
 80076a6:	6892      	ldr	r2, [r2, #8]
 80076a8:	f042 0203 	orr.w	r2, r2, #3
 80076ac:	609a      	str	r2, [r3, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80076ae:	bf00      	nop
 80076b0:	4b06      	ldr	r3, [pc, #24]	; (80076cc <stm32_clock_init+0x17c>)
 80076b2:	689b      	ldr	r3, [r3, #8]
 80076b4:	f003 030c 	and.w	r3, r3, #12
 80076b8:	2b0c      	cmp	r3, #12
 80076ba:	d1f9      	bne.n	80076b0 <stm32_clock_init+0x160>

#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80076bc:	4b03      	ldr	r3, [pc, #12]	; (80076cc <stm32_clock_init+0x17c>)
 80076be:	4a03      	ldr	r2, [pc, #12]	; (80076cc <stm32_clock_init+0x17c>)
 80076c0:	6e12      	ldr	r2, [r2, #96]	; 0x60
 80076c2:	f042 0201 	orr.w	r2, r2, #1
 80076c6:	661a      	str	r2, [r3, #96]	; 0x60
}
 80076c8:	b002      	add	sp, #8
 80076ca:	4770      	bx	lr
 80076cc:	40021000 	.word	0x40021000
 80076d0:	40007000 	.word	0x40007000
 80076d4:	40022000 	.word	0x40022000
 80076d8:	03405001 	.word	0x03405001
 80076dc:	04504800 	.word	0x04504800
 80076e0:	34015555 	.word	0x34015555
 80076e4:	f3af 8000 	nop.w
 80076e8:	f3af 8000 	nop.w
 80076ec:	f3af 8000 	nop.w

080076f0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80076f0:	b500      	push	{lr}
 80076f2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 80076f4:	2300      	movs	r3, #0
 80076f6:	9301      	str	r3, [sp, #4]
 80076f8:	4b14      	ldr	r3, [pc, #80]	; (800774c <Vector6C+0x5c>)
 80076fa:	681a      	ldr	r2, [r3, #0]
 80076fc:	2300      	movs	r3, #0
 80076fe:	fa22 f303 	lsr.w	r3, r2, r3
 8007702:	f003 030f 	and.w	r3, r3, #15
 8007706:	9300      	str	r3, [sp, #0]
 8007708:	9b00      	ldr	r3, [sp, #0]
 800770a:	f003 030f 	and.w	r3, r3, #15
 800770e:	2b00      	cmp	r3, #0
 8007710:	d017      	beq.n	8007742 <Vector6C+0x52>
 8007712:	4b0e      	ldr	r3, [pc, #56]	; (800774c <Vector6C+0x5c>)
 8007714:	2200      	movs	r2, #0
 8007716:	9900      	ldr	r1, [sp, #0]
 8007718:	fa01 f202 	lsl.w	r2, r1, r2
 800771c:	605a      	str	r2, [r3, #4]
 800771e:	4b0c      	ldr	r3, [pc, #48]	; (8007750 <Vector6C+0x60>)
 8007720:	9a01      	ldr	r2, [sp, #4]
 8007722:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007726:	2b00      	cmp	r3, #0
 8007728:	d00b      	beq.n	8007742 <Vector6C+0x52>
 800772a:	4b09      	ldr	r3, [pc, #36]	; (8007750 <Vector6C+0x60>)
 800772c:	9a01      	ldr	r2, [sp, #4]
 800772e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007732:	4907      	ldr	r1, [pc, #28]	; (8007750 <Vector6C+0x60>)
 8007734:	9b01      	ldr	r3, [sp, #4]
 8007736:	00db      	lsls	r3, r3, #3
 8007738:	440b      	add	r3, r1
 800773a:	685b      	ldr	r3, [r3, #4]
 800773c:	4618      	mov	r0, r3
 800773e:	9900      	ldr	r1, [sp, #0]
 8007740:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007742:	f7fc fa05 	bl	8003b50 <_port_irq_epilogue>
}
 8007746:	b003      	add	sp, #12
 8007748:	f85d fb04 	ldr.w	pc, [sp], #4
 800774c:	40020000 	.word	0x40020000
 8007750:	20003af8 	.word	0x20003af8
 8007754:	f3af 8000 	nop.w
 8007758:	f3af 8000 	nop.w
 800775c:	f3af 8000 	nop.w

08007760 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8007760:	b500      	push	{lr}
 8007762:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8007764:	2301      	movs	r3, #1
 8007766:	9301      	str	r3, [sp, #4]
 8007768:	4b14      	ldr	r3, [pc, #80]	; (80077bc <Vector70+0x5c>)
 800776a:	681a      	ldr	r2, [r3, #0]
 800776c:	2304      	movs	r3, #4
 800776e:	fa22 f303 	lsr.w	r3, r2, r3
 8007772:	f003 030f 	and.w	r3, r3, #15
 8007776:	9300      	str	r3, [sp, #0]
 8007778:	9b00      	ldr	r3, [sp, #0]
 800777a:	f003 030f 	and.w	r3, r3, #15
 800777e:	2b00      	cmp	r3, #0
 8007780:	d017      	beq.n	80077b2 <Vector70+0x52>
 8007782:	4b0e      	ldr	r3, [pc, #56]	; (80077bc <Vector70+0x5c>)
 8007784:	2204      	movs	r2, #4
 8007786:	9900      	ldr	r1, [sp, #0]
 8007788:	fa01 f202 	lsl.w	r2, r1, r2
 800778c:	605a      	str	r2, [r3, #4]
 800778e:	4b0c      	ldr	r3, [pc, #48]	; (80077c0 <Vector70+0x60>)
 8007790:	9a01      	ldr	r2, [sp, #4]
 8007792:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007796:	2b00      	cmp	r3, #0
 8007798:	d00b      	beq.n	80077b2 <Vector70+0x52>
 800779a:	4b09      	ldr	r3, [pc, #36]	; (80077c0 <Vector70+0x60>)
 800779c:	9a01      	ldr	r2, [sp, #4]
 800779e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80077a2:	4907      	ldr	r1, [pc, #28]	; (80077c0 <Vector70+0x60>)
 80077a4:	9b01      	ldr	r3, [sp, #4]
 80077a6:	00db      	lsls	r3, r3, #3
 80077a8:	440b      	add	r3, r1
 80077aa:	685b      	ldr	r3, [r3, #4]
 80077ac:	4618      	mov	r0, r3
 80077ae:	9900      	ldr	r1, [sp, #0]
 80077b0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80077b2:	f7fc f9cd 	bl	8003b50 <_port_irq_epilogue>
}
 80077b6:	b003      	add	sp, #12
 80077b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80077bc:	40020000 	.word	0x40020000
 80077c0:	20003af8 	.word	0x20003af8
 80077c4:	f3af 8000 	nop.w
 80077c8:	f3af 8000 	nop.w
 80077cc:	f3af 8000 	nop.w

080077d0 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80077d0:	b500      	push	{lr}
 80077d2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80077d4:	2302      	movs	r3, #2
 80077d6:	9301      	str	r3, [sp, #4]
 80077d8:	4b14      	ldr	r3, [pc, #80]	; (800782c <Vector74+0x5c>)
 80077da:	681a      	ldr	r2, [r3, #0]
 80077dc:	2308      	movs	r3, #8
 80077de:	fa22 f303 	lsr.w	r3, r2, r3
 80077e2:	f003 030f 	and.w	r3, r3, #15
 80077e6:	9300      	str	r3, [sp, #0]
 80077e8:	9b00      	ldr	r3, [sp, #0]
 80077ea:	f003 030f 	and.w	r3, r3, #15
 80077ee:	2b00      	cmp	r3, #0
 80077f0:	d017      	beq.n	8007822 <Vector74+0x52>
 80077f2:	4b0e      	ldr	r3, [pc, #56]	; (800782c <Vector74+0x5c>)
 80077f4:	2208      	movs	r2, #8
 80077f6:	9900      	ldr	r1, [sp, #0]
 80077f8:	fa01 f202 	lsl.w	r2, r1, r2
 80077fc:	605a      	str	r2, [r3, #4]
 80077fe:	4b0c      	ldr	r3, [pc, #48]	; (8007830 <Vector74+0x60>)
 8007800:	9a01      	ldr	r2, [sp, #4]
 8007802:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007806:	2b00      	cmp	r3, #0
 8007808:	d00b      	beq.n	8007822 <Vector74+0x52>
 800780a:	4b09      	ldr	r3, [pc, #36]	; (8007830 <Vector74+0x60>)
 800780c:	9a01      	ldr	r2, [sp, #4]
 800780e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007812:	4907      	ldr	r1, [pc, #28]	; (8007830 <Vector74+0x60>)
 8007814:	9b01      	ldr	r3, [sp, #4]
 8007816:	00db      	lsls	r3, r3, #3
 8007818:	440b      	add	r3, r1
 800781a:	685b      	ldr	r3, [r3, #4]
 800781c:	4618      	mov	r0, r3
 800781e:	9900      	ldr	r1, [sp, #0]
 8007820:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007822:	f7fc f995 	bl	8003b50 <_port_irq_epilogue>
}
 8007826:	b003      	add	sp, #12
 8007828:	f85d fb04 	ldr.w	pc, [sp], #4
 800782c:	40020000 	.word	0x40020000
 8007830:	20003af8 	.word	0x20003af8
 8007834:	f3af 8000 	nop.w
 8007838:	f3af 8000 	nop.w
 800783c:	f3af 8000 	nop.w

08007840 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8007840:	b500      	push	{lr}
 8007842:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8007844:	2303      	movs	r3, #3
 8007846:	9301      	str	r3, [sp, #4]
 8007848:	4b14      	ldr	r3, [pc, #80]	; (800789c <Vector78+0x5c>)
 800784a:	681a      	ldr	r2, [r3, #0]
 800784c:	230c      	movs	r3, #12
 800784e:	fa22 f303 	lsr.w	r3, r2, r3
 8007852:	f003 030f 	and.w	r3, r3, #15
 8007856:	9300      	str	r3, [sp, #0]
 8007858:	9b00      	ldr	r3, [sp, #0]
 800785a:	f003 030f 	and.w	r3, r3, #15
 800785e:	2b00      	cmp	r3, #0
 8007860:	d017      	beq.n	8007892 <Vector78+0x52>
 8007862:	4b0e      	ldr	r3, [pc, #56]	; (800789c <Vector78+0x5c>)
 8007864:	220c      	movs	r2, #12
 8007866:	9900      	ldr	r1, [sp, #0]
 8007868:	fa01 f202 	lsl.w	r2, r1, r2
 800786c:	605a      	str	r2, [r3, #4]
 800786e:	4b0c      	ldr	r3, [pc, #48]	; (80078a0 <Vector78+0x60>)
 8007870:	9a01      	ldr	r2, [sp, #4]
 8007872:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007876:	2b00      	cmp	r3, #0
 8007878:	d00b      	beq.n	8007892 <Vector78+0x52>
 800787a:	4b09      	ldr	r3, [pc, #36]	; (80078a0 <Vector78+0x60>)
 800787c:	9a01      	ldr	r2, [sp, #4]
 800787e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007882:	4907      	ldr	r1, [pc, #28]	; (80078a0 <Vector78+0x60>)
 8007884:	9b01      	ldr	r3, [sp, #4]
 8007886:	00db      	lsls	r3, r3, #3
 8007888:	440b      	add	r3, r1
 800788a:	685b      	ldr	r3, [r3, #4]
 800788c:	4618      	mov	r0, r3
 800788e:	9900      	ldr	r1, [sp, #0]
 8007890:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007892:	f7fc f95d 	bl	8003b50 <_port_irq_epilogue>
}
 8007896:	b003      	add	sp, #12
 8007898:	f85d fb04 	ldr.w	pc, [sp], #4
 800789c:	40020000 	.word	0x40020000
 80078a0:	20003af8 	.word	0x20003af8
 80078a4:	f3af 8000 	nop.w
 80078a8:	f3af 8000 	nop.w
 80078ac:	f3af 8000 	nop.w

080078b0 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80078b0:	b500      	push	{lr}
 80078b2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80078b4:	2304      	movs	r3, #4
 80078b6:	9301      	str	r3, [sp, #4]
 80078b8:	4b14      	ldr	r3, [pc, #80]	; (800790c <Vector7C+0x5c>)
 80078ba:	681a      	ldr	r2, [r3, #0]
 80078bc:	2310      	movs	r3, #16
 80078be:	fa22 f303 	lsr.w	r3, r2, r3
 80078c2:	f003 030f 	and.w	r3, r3, #15
 80078c6:	9300      	str	r3, [sp, #0]
 80078c8:	9b00      	ldr	r3, [sp, #0]
 80078ca:	f003 030f 	and.w	r3, r3, #15
 80078ce:	2b00      	cmp	r3, #0
 80078d0:	d017      	beq.n	8007902 <Vector7C+0x52>
 80078d2:	4b0e      	ldr	r3, [pc, #56]	; (800790c <Vector7C+0x5c>)
 80078d4:	2210      	movs	r2, #16
 80078d6:	9900      	ldr	r1, [sp, #0]
 80078d8:	fa01 f202 	lsl.w	r2, r1, r2
 80078dc:	605a      	str	r2, [r3, #4]
 80078de:	4b0c      	ldr	r3, [pc, #48]	; (8007910 <Vector7C+0x60>)
 80078e0:	9a01      	ldr	r2, [sp, #4]
 80078e2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80078e6:	2b00      	cmp	r3, #0
 80078e8:	d00b      	beq.n	8007902 <Vector7C+0x52>
 80078ea:	4b09      	ldr	r3, [pc, #36]	; (8007910 <Vector7C+0x60>)
 80078ec:	9a01      	ldr	r2, [sp, #4]
 80078ee:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80078f2:	4907      	ldr	r1, [pc, #28]	; (8007910 <Vector7C+0x60>)
 80078f4:	9b01      	ldr	r3, [sp, #4]
 80078f6:	00db      	lsls	r3, r3, #3
 80078f8:	440b      	add	r3, r1
 80078fa:	685b      	ldr	r3, [r3, #4]
 80078fc:	4618      	mov	r0, r3
 80078fe:	9900      	ldr	r1, [sp, #0]
 8007900:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007902:	f7fc f925 	bl	8003b50 <_port_irq_epilogue>
}
 8007906:	b003      	add	sp, #12
 8007908:	f85d fb04 	ldr.w	pc, [sp], #4
 800790c:	40020000 	.word	0x40020000
 8007910:	20003af8 	.word	0x20003af8
 8007914:	f3af 8000 	nop.w
 8007918:	f3af 8000 	nop.w
 800791c:	f3af 8000 	nop.w

08007920 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8007920:	b500      	push	{lr}
 8007922:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8007924:	2305      	movs	r3, #5
 8007926:	9301      	str	r3, [sp, #4]
 8007928:	4b14      	ldr	r3, [pc, #80]	; (800797c <Vector80+0x5c>)
 800792a:	681a      	ldr	r2, [r3, #0]
 800792c:	2314      	movs	r3, #20
 800792e:	fa22 f303 	lsr.w	r3, r2, r3
 8007932:	f003 030f 	and.w	r3, r3, #15
 8007936:	9300      	str	r3, [sp, #0]
 8007938:	9b00      	ldr	r3, [sp, #0]
 800793a:	f003 030f 	and.w	r3, r3, #15
 800793e:	2b00      	cmp	r3, #0
 8007940:	d017      	beq.n	8007972 <Vector80+0x52>
 8007942:	4b0e      	ldr	r3, [pc, #56]	; (800797c <Vector80+0x5c>)
 8007944:	2214      	movs	r2, #20
 8007946:	9900      	ldr	r1, [sp, #0]
 8007948:	fa01 f202 	lsl.w	r2, r1, r2
 800794c:	605a      	str	r2, [r3, #4]
 800794e:	4b0c      	ldr	r3, [pc, #48]	; (8007980 <Vector80+0x60>)
 8007950:	9a01      	ldr	r2, [sp, #4]
 8007952:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007956:	2b00      	cmp	r3, #0
 8007958:	d00b      	beq.n	8007972 <Vector80+0x52>
 800795a:	4b09      	ldr	r3, [pc, #36]	; (8007980 <Vector80+0x60>)
 800795c:	9a01      	ldr	r2, [sp, #4]
 800795e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007962:	4907      	ldr	r1, [pc, #28]	; (8007980 <Vector80+0x60>)
 8007964:	9b01      	ldr	r3, [sp, #4]
 8007966:	00db      	lsls	r3, r3, #3
 8007968:	440b      	add	r3, r1
 800796a:	685b      	ldr	r3, [r3, #4]
 800796c:	4618      	mov	r0, r3
 800796e:	9900      	ldr	r1, [sp, #0]
 8007970:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007972:	f7fc f8ed 	bl	8003b50 <_port_irq_epilogue>
}
 8007976:	b003      	add	sp, #12
 8007978:	f85d fb04 	ldr.w	pc, [sp], #4
 800797c:	40020000 	.word	0x40020000
 8007980:	20003af8 	.word	0x20003af8
 8007984:	f3af 8000 	nop.w
 8007988:	f3af 8000 	nop.w
 800798c:	f3af 8000 	nop.w

08007990 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8007990:	b500      	push	{lr}
 8007992:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8007994:	2306      	movs	r3, #6
 8007996:	9301      	str	r3, [sp, #4]
 8007998:	4b14      	ldr	r3, [pc, #80]	; (80079ec <Vector84+0x5c>)
 800799a:	681a      	ldr	r2, [r3, #0]
 800799c:	2318      	movs	r3, #24
 800799e:	fa22 f303 	lsr.w	r3, r2, r3
 80079a2:	f003 030f 	and.w	r3, r3, #15
 80079a6:	9300      	str	r3, [sp, #0]
 80079a8:	9b00      	ldr	r3, [sp, #0]
 80079aa:	f003 030f 	and.w	r3, r3, #15
 80079ae:	2b00      	cmp	r3, #0
 80079b0:	d017      	beq.n	80079e2 <Vector84+0x52>
 80079b2:	4b0e      	ldr	r3, [pc, #56]	; (80079ec <Vector84+0x5c>)
 80079b4:	2218      	movs	r2, #24
 80079b6:	9900      	ldr	r1, [sp, #0]
 80079b8:	fa01 f202 	lsl.w	r2, r1, r2
 80079bc:	605a      	str	r2, [r3, #4]
 80079be:	4b0c      	ldr	r3, [pc, #48]	; (80079f0 <Vector84+0x60>)
 80079c0:	9a01      	ldr	r2, [sp, #4]
 80079c2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80079c6:	2b00      	cmp	r3, #0
 80079c8:	d00b      	beq.n	80079e2 <Vector84+0x52>
 80079ca:	4b09      	ldr	r3, [pc, #36]	; (80079f0 <Vector84+0x60>)
 80079cc:	9a01      	ldr	r2, [sp, #4]
 80079ce:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80079d2:	4907      	ldr	r1, [pc, #28]	; (80079f0 <Vector84+0x60>)
 80079d4:	9b01      	ldr	r3, [sp, #4]
 80079d6:	00db      	lsls	r3, r3, #3
 80079d8:	440b      	add	r3, r1
 80079da:	685b      	ldr	r3, [r3, #4]
 80079dc:	4618      	mov	r0, r3
 80079de:	9900      	ldr	r1, [sp, #0]
 80079e0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80079e2:	f7fc f8b5 	bl	8003b50 <_port_irq_epilogue>
}
 80079e6:	b003      	add	sp, #12
 80079e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80079ec:	40020000 	.word	0x40020000
 80079f0:	20003af8 	.word	0x20003af8
 80079f4:	f3af 8000 	nop.w
 80079f8:	f3af 8000 	nop.w
 80079fc:	f3af 8000 	nop.w

08007a00 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8007a00:	b500      	push	{lr}
 8007a02:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8007a04:	2307      	movs	r3, #7
 8007a06:	9301      	str	r3, [sp, #4]
 8007a08:	4b14      	ldr	r3, [pc, #80]	; (8007a5c <Vector120+0x5c>)
 8007a0a:	681a      	ldr	r2, [r3, #0]
 8007a0c:	2300      	movs	r3, #0
 8007a0e:	fa22 f303 	lsr.w	r3, r2, r3
 8007a12:	f003 030f 	and.w	r3, r3, #15
 8007a16:	9300      	str	r3, [sp, #0]
 8007a18:	9b00      	ldr	r3, [sp, #0]
 8007a1a:	f003 030f 	and.w	r3, r3, #15
 8007a1e:	2b00      	cmp	r3, #0
 8007a20:	d017      	beq.n	8007a52 <Vector120+0x52>
 8007a22:	4b0e      	ldr	r3, [pc, #56]	; (8007a5c <Vector120+0x5c>)
 8007a24:	2200      	movs	r2, #0
 8007a26:	9900      	ldr	r1, [sp, #0]
 8007a28:	fa01 f202 	lsl.w	r2, r1, r2
 8007a2c:	605a      	str	r2, [r3, #4]
 8007a2e:	4b0c      	ldr	r3, [pc, #48]	; (8007a60 <Vector120+0x60>)
 8007a30:	9a01      	ldr	r2, [sp, #4]
 8007a32:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007a36:	2b00      	cmp	r3, #0
 8007a38:	d00b      	beq.n	8007a52 <Vector120+0x52>
 8007a3a:	4b09      	ldr	r3, [pc, #36]	; (8007a60 <Vector120+0x60>)
 8007a3c:	9a01      	ldr	r2, [sp, #4]
 8007a3e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007a42:	4907      	ldr	r1, [pc, #28]	; (8007a60 <Vector120+0x60>)
 8007a44:	9b01      	ldr	r3, [sp, #4]
 8007a46:	00db      	lsls	r3, r3, #3
 8007a48:	440b      	add	r3, r1
 8007a4a:	685b      	ldr	r3, [r3, #4]
 8007a4c:	4618      	mov	r0, r3
 8007a4e:	9900      	ldr	r1, [sp, #0]
 8007a50:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007a52:	f7fc f87d 	bl	8003b50 <_port_irq_epilogue>
}
 8007a56:	b003      	add	sp, #12
 8007a58:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a5c:	40020400 	.word	0x40020400
 8007a60:	20003af8 	.word	0x20003af8
 8007a64:	f3af 8000 	nop.w
 8007a68:	f3af 8000 	nop.w
 8007a6c:	f3af 8000 	nop.w

08007a70 <Vector124>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8007a70:	b500      	push	{lr}
 8007a72:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8007a74:	2308      	movs	r3, #8
 8007a76:	9301      	str	r3, [sp, #4]
 8007a78:	4b14      	ldr	r3, [pc, #80]	; (8007acc <Vector124+0x5c>)
 8007a7a:	681a      	ldr	r2, [r3, #0]
 8007a7c:	2304      	movs	r3, #4
 8007a7e:	fa22 f303 	lsr.w	r3, r2, r3
 8007a82:	f003 030f 	and.w	r3, r3, #15
 8007a86:	9300      	str	r3, [sp, #0]
 8007a88:	9b00      	ldr	r3, [sp, #0]
 8007a8a:	f003 030f 	and.w	r3, r3, #15
 8007a8e:	2b00      	cmp	r3, #0
 8007a90:	d017      	beq.n	8007ac2 <Vector124+0x52>
 8007a92:	4b0e      	ldr	r3, [pc, #56]	; (8007acc <Vector124+0x5c>)
 8007a94:	2204      	movs	r2, #4
 8007a96:	9900      	ldr	r1, [sp, #0]
 8007a98:	fa01 f202 	lsl.w	r2, r1, r2
 8007a9c:	605a      	str	r2, [r3, #4]
 8007a9e:	4b0c      	ldr	r3, [pc, #48]	; (8007ad0 <Vector124+0x60>)
 8007aa0:	9a01      	ldr	r2, [sp, #4]
 8007aa2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007aa6:	2b00      	cmp	r3, #0
 8007aa8:	d00b      	beq.n	8007ac2 <Vector124+0x52>
 8007aaa:	4b09      	ldr	r3, [pc, #36]	; (8007ad0 <Vector124+0x60>)
 8007aac:	9a01      	ldr	r2, [sp, #4]
 8007aae:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007ab2:	4907      	ldr	r1, [pc, #28]	; (8007ad0 <Vector124+0x60>)
 8007ab4:	9b01      	ldr	r3, [sp, #4]
 8007ab6:	00db      	lsls	r3, r3, #3
 8007ab8:	440b      	add	r3, r1
 8007aba:	685b      	ldr	r3, [r3, #4]
 8007abc:	4618      	mov	r0, r3
 8007abe:	9900      	ldr	r1, [sp, #0]
 8007ac0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007ac2:	f7fc f845 	bl	8003b50 <_port_irq_epilogue>
}
 8007ac6:	b003      	add	sp, #12
 8007ac8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007acc:	40020400 	.word	0x40020400
 8007ad0:	20003af8 	.word	0x20003af8
 8007ad4:	f3af 8000 	nop.w
 8007ad8:	f3af 8000 	nop.w
 8007adc:	f3af 8000 	nop.w

08007ae0 <Vector128>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8007ae0:	b500      	push	{lr}
 8007ae2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8007ae4:	2309      	movs	r3, #9
 8007ae6:	9301      	str	r3, [sp, #4]
 8007ae8:	4b14      	ldr	r3, [pc, #80]	; (8007b3c <Vector128+0x5c>)
 8007aea:	681a      	ldr	r2, [r3, #0]
 8007aec:	2308      	movs	r3, #8
 8007aee:	fa22 f303 	lsr.w	r3, r2, r3
 8007af2:	f003 030f 	and.w	r3, r3, #15
 8007af6:	9300      	str	r3, [sp, #0]
 8007af8:	9b00      	ldr	r3, [sp, #0]
 8007afa:	f003 030f 	and.w	r3, r3, #15
 8007afe:	2b00      	cmp	r3, #0
 8007b00:	d017      	beq.n	8007b32 <Vector128+0x52>
 8007b02:	4b0e      	ldr	r3, [pc, #56]	; (8007b3c <Vector128+0x5c>)
 8007b04:	2208      	movs	r2, #8
 8007b06:	9900      	ldr	r1, [sp, #0]
 8007b08:	fa01 f202 	lsl.w	r2, r1, r2
 8007b0c:	605a      	str	r2, [r3, #4]
 8007b0e:	4b0c      	ldr	r3, [pc, #48]	; (8007b40 <Vector128+0x60>)
 8007b10:	9a01      	ldr	r2, [sp, #4]
 8007b12:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007b16:	2b00      	cmp	r3, #0
 8007b18:	d00b      	beq.n	8007b32 <Vector128+0x52>
 8007b1a:	4b09      	ldr	r3, [pc, #36]	; (8007b40 <Vector128+0x60>)
 8007b1c:	9a01      	ldr	r2, [sp, #4]
 8007b1e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007b22:	4907      	ldr	r1, [pc, #28]	; (8007b40 <Vector128+0x60>)
 8007b24:	9b01      	ldr	r3, [sp, #4]
 8007b26:	00db      	lsls	r3, r3, #3
 8007b28:	440b      	add	r3, r1
 8007b2a:	685b      	ldr	r3, [r3, #4]
 8007b2c:	4618      	mov	r0, r3
 8007b2e:	9900      	ldr	r1, [sp, #0]
 8007b30:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007b32:	f7fc f80d 	bl	8003b50 <_port_irq_epilogue>
}
 8007b36:	b003      	add	sp, #12
 8007b38:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b3c:	40020400 	.word	0x40020400
 8007b40:	20003af8 	.word	0x20003af8
 8007b44:	f3af 8000 	nop.w
 8007b48:	f3af 8000 	nop.w
 8007b4c:	f3af 8000 	nop.w

08007b50 <Vector12C>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8007b50:	b500      	push	{lr}
 8007b52:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8007b54:	230a      	movs	r3, #10
 8007b56:	9301      	str	r3, [sp, #4]
 8007b58:	4b14      	ldr	r3, [pc, #80]	; (8007bac <Vector12C+0x5c>)
 8007b5a:	681a      	ldr	r2, [r3, #0]
 8007b5c:	230c      	movs	r3, #12
 8007b5e:	fa22 f303 	lsr.w	r3, r2, r3
 8007b62:	f003 030f 	and.w	r3, r3, #15
 8007b66:	9300      	str	r3, [sp, #0]
 8007b68:	9b00      	ldr	r3, [sp, #0]
 8007b6a:	f003 030f 	and.w	r3, r3, #15
 8007b6e:	2b00      	cmp	r3, #0
 8007b70:	d017      	beq.n	8007ba2 <Vector12C+0x52>
 8007b72:	4b0e      	ldr	r3, [pc, #56]	; (8007bac <Vector12C+0x5c>)
 8007b74:	220c      	movs	r2, #12
 8007b76:	9900      	ldr	r1, [sp, #0]
 8007b78:	fa01 f202 	lsl.w	r2, r1, r2
 8007b7c:	605a      	str	r2, [r3, #4]
 8007b7e:	4b0c      	ldr	r3, [pc, #48]	; (8007bb0 <Vector12C+0x60>)
 8007b80:	9a01      	ldr	r2, [sp, #4]
 8007b82:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007b86:	2b00      	cmp	r3, #0
 8007b88:	d00b      	beq.n	8007ba2 <Vector12C+0x52>
 8007b8a:	4b09      	ldr	r3, [pc, #36]	; (8007bb0 <Vector12C+0x60>)
 8007b8c:	9a01      	ldr	r2, [sp, #4]
 8007b8e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007b92:	4907      	ldr	r1, [pc, #28]	; (8007bb0 <Vector12C+0x60>)
 8007b94:	9b01      	ldr	r3, [sp, #4]
 8007b96:	00db      	lsls	r3, r3, #3
 8007b98:	440b      	add	r3, r1
 8007b9a:	685b      	ldr	r3, [r3, #4]
 8007b9c:	4618      	mov	r0, r3
 8007b9e:	9900      	ldr	r1, [sp, #0]
 8007ba0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007ba2:	f7fb ffd5 	bl	8003b50 <_port_irq_epilogue>
}
 8007ba6:	b003      	add	sp, #12
 8007ba8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007bac:	40020400 	.word	0x40020400
 8007bb0:	20003af8 	.word	0x20003af8
 8007bb4:	f3af 8000 	nop.w
 8007bb8:	f3af 8000 	nop.w
 8007bbc:	f3af 8000 	nop.w

08007bc0 <Vector130>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8007bc0:	b500      	push	{lr}
 8007bc2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8007bc4:	230b      	movs	r3, #11
 8007bc6:	9301      	str	r3, [sp, #4]
 8007bc8:	4b14      	ldr	r3, [pc, #80]	; (8007c1c <Vector130+0x5c>)
 8007bca:	681a      	ldr	r2, [r3, #0]
 8007bcc:	2310      	movs	r3, #16
 8007bce:	fa22 f303 	lsr.w	r3, r2, r3
 8007bd2:	f003 030f 	and.w	r3, r3, #15
 8007bd6:	9300      	str	r3, [sp, #0]
 8007bd8:	9b00      	ldr	r3, [sp, #0]
 8007bda:	f003 030f 	and.w	r3, r3, #15
 8007bde:	2b00      	cmp	r3, #0
 8007be0:	d017      	beq.n	8007c12 <Vector130+0x52>
 8007be2:	4b0e      	ldr	r3, [pc, #56]	; (8007c1c <Vector130+0x5c>)
 8007be4:	2210      	movs	r2, #16
 8007be6:	9900      	ldr	r1, [sp, #0]
 8007be8:	fa01 f202 	lsl.w	r2, r1, r2
 8007bec:	605a      	str	r2, [r3, #4]
 8007bee:	4b0c      	ldr	r3, [pc, #48]	; (8007c20 <Vector130+0x60>)
 8007bf0:	9a01      	ldr	r2, [sp, #4]
 8007bf2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007bf6:	2b00      	cmp	r3, #0
 8007bf8:	d00b      	beq.n	8007c12 <Vector130+0x52>
 8007bfa:	4b09      	ldr	r3, [pc, #36]	; (8007c20 <Vector130+0x60>)
 8007bfc:	9a01      	ldr	r2, [sp, #4]
 8007bfe:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007c02:	4907      	ldr	r1, [pc, #28]	; (8007c20 <Vector130+0x60>)
 8007c04:	9b01      	ldr	r3, [sp, #4]
 8007c06:	00db      	lsls	r3, r3, #3
 8007c08:	440b      	add	r3, r1
 8007c0a:	685b      	ldr	r3, [r3, #4]
 8007c0c:	4618      	mov	r0, r3
 8007c0e:	9900      	ldr	r1, [sp, #0]
 8007c10:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007c12:	f7fb ff9d 	bl	8003b50 <_port_irq_epilogue>
}
 8007c16:	b003      	add	sp, #12
 8007c18:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c1c:	40020400 	.word	0x40020400
 8007c20:	20003af8 	.word	0x20003af8
 8007c24:	f3af 8000 	nop.w
 8007c28:	f3af 8000 	nop.w
 8007c2c:	f3af 8000 	nop.w

08007c30 <Vector150>:
/**
 * @brief   DMA2 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8007c30:	b500      	push	{lr}
 8007c32:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM6);
 8007c34:	230c      	movs	r3, #12
 8007c36:	9301      	str	r3, [sp, #4]
 8007c38:	4b14      	ldr	r3, [pc, #80]	; (8007c8c <Vector150+0x5c>)
 8007c3a:	681a      	ldr	r2, [r3, #0]
 8007c3c:	2314      	movs	r3, #20
 8007c3e:	fa22 f303 	lsr.w	r3, r2, r3
 8007c42:	f003 030f 	and.w	r3, r3, #15
 8007c46:	9300      	str	r3, [sp, #0]
 8007c48:	9b00      	ldr	r3, [sp, #0]
 8007c4a:	f003 030f 	and.w	r3, r3, #15
 8007c4e:	2b00      	cmp	r3, #0
 8007c50:	d017      	beq.n	8007c82 <Vector150+0x52>
 8007c52:	4b0e      	ldr	r3, [pc, #56]	; (8007c8c <Vector150+0x5c>)
 8007c54:	2214      	movs	r2, #20
 8007c56:	9900      	ldr	r1, [sp, #0]
 8007c58:	fa01 f202 	lsl.w	r2, r1, r2
 8007c5c:	605a      	str	r2, [r3, #4]
 8007c5e:	4b0c      	ldr	r3, [pc, #48]	; (8007c90 <Vector150+0x60>)
 8007c60:	9a01      	ldr	r2, [sp, #4]
 8007c62:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007c66:	2b00      	cmp	r3, #0
 8007c68:	d00b      	beq.n	8007c82 <Vector150+0x52>
 8007c6a:	4b09      	ldr	r3, [pc, #36]	; (8007c90 <Vector150+0x60>)
 8007c6c:	9a01      	ldr	r2, [sp, #4]
 8007c6e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007c72:	4907      	ldr	r1, [pc, #28]	; (8007c90 <Vector150+0x60>)
 8007c74:	9b01      	ldr	r3, [sp, #4]
 8007c76:	00db      	lsls	r3, r3, #3
 8007c78:	440b      	add	r3, r1
 8007c7a:	685b      	ldr	r3, [r3, #4]
 8007c7c:	4618      	mov	r0, r3
 8007c7e:	9900      	ldr	r1, [sp, #0]
 8007c80:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007c82:	f7fb ff65 	bl	8003b50 <_port_irq_epilogue>
}
 8007c86:	b003      	add	sp, #12
 8007c88:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c8c:	40020400 	.word	0x40020400
 8007c90:	20003af8 	.word	0x20003af8
 8007c94:	f3af 8000 	nop.w
 8007c98:	f3af 8000 	nop.w
 8007c9c:	f3af 8000 	nop.w

08007ca0 <Vector154>:
/**
 * @brief   DMA2 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8007ca0:	b500      	push	{lr}
 8007ca2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM7);
 8007ca4:	230d      	movs	r3, #13
 8007ca6:	9301      	str	r3, [sp, #4]
 8007ca8:	4b14      	ldr	r3, [pc, #80]	; (8007cfc <Vector154+0x5c>)
 8007caa:	681a      	ldr	r2, [r3, #0]
 8007cac:	2318      	movs	r3, #24
 8007cae:	fa22 f303 	lsr.w	r3, r2, r3
 8007cb2:	f003 030f 	and.w	r3, r3, #15
 8007cb6:	9300      	str	r3, [sp, #0]
 8007cb8:	9b00      	ldr	r3, [sp, #0]
 8007cba:	f003 030f 	and.w	r3, r3, #15
 8007cbe:	2b00      	cmp	r3, #0
 8007cc0:	d017      	beq.n	8007cf2 <Vector154+0x52>
 8007cc2:	4b0e      	ldr	r3, [pc, #56]	; (8007cfc <Vector154+0x5c>)
 8007cc4:	2218      	movs	r2, #24
 8007cc6:	9900      	ldr	r1, [sp, #0]
 8007cc8:	fa01 f202 	lsl.w	r2, r1, r2
 8007ccc:	605a      	str	r2, [r3, #4]
 8007cce:	4b0c      	ldr	r3, [pc, #48]	; (8007d00 <Vector154+0x60>)
 8007cd0:	9a01      	ldr	r2, [sp, #4]
 8007cd2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007cd6:	2b00      	cmp	r3, #0
 8007cd8:	d00b      	beq.n	8007cf2 <Vector154+0x52>
 8007cda:	4b09      	ldr	r3, [pc, #36]	; (8007d00 <Vector154+0x60>)
 8007cdc:	9a01      	ldr	r2, [sp, #4]
 8007cde:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007ce2:	4907      	ldr	r1, [pc, #28]	; (8007d00 <Vector154+0x60>)
 8007ce4:	9b01      	ldr	r3, [sp, #4]
 8007ce6:	00db      	lsls	r3, r3, #3
 8007ce8:	440b      	add	r3, r1
 8007cea:	685b      	ldr	r3, [r3, #4]
 8007cec:	4618      	mov	r0, r3
 8007cee:	9900      	ldr	r1, [sp, #0]
 8007cf0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007cf2:	f7fb ff2d 	bl	8003b50 <_port_irq_epilogue>
}
 8007cf6:	b003      	add	sp, #12
 8007cf8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007cfc:	40020400 	.word	0x40020400
 8007d00:	20003af8 	.word	0x20003af8
 8007d04:	f3af 8000 	nop.w
 8007d08:	f3af 8000 	nop.w
 8007d0c:	f3af 8000 	nop.w

08007d10 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8007d10:	b082      	sub	sp, #8
  int i;

  dma_streams_mask = 0U;
 8007d12:	4b12      	ldr	r3, [pc, #72]	; (8007d5c <dmaInit+0x4c>)
 8007d14:	2200      	movs	r2, #0
 8007d16:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8007d18:	2300      	movs	r3, #0
 8007d1a:	9301      	str	r3, [sp, #4]
 8007d1c:	e011      	b.n	8007d42 <dmaInit+0x32>
    _stm32_dma_streams[i].channel->CCR = 0U;
 8007d1e:	4910      	ldr	r1, [pc, #64]	; (8007d60 <dmaInit+0x50>)
 8007d20:	9a01      	ldr	r2, [sp, #4]
 8007d22:	4613      	mov	r3, r2
 8007d24:	009b      	lsls	r3, r3, #2
 8007d26:	4413      	add	r3, r2
 8007d28:	009b      	lsls	r3, r3, #2
 8007d2a:	440b      	add	r3, r1
 8007d2c:	685b      	ldr	r3, [r3, #4]
 8007d2e:	2200      	movs	r2, #0
 8007d30:	601a      	str	r2, [r3, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8007d32:	4b0c      	ldr	r3, [pc, #48]	; (8007d64 <dmaInit+0x54>)
 8007d34:	9a01      	ldr	r2, [sp, #4]
 8007d36:	2100      	movs	r1, #0
 8007d38:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8007d3c:	9b01      	ldr	r3, [sp, #4]
 8007d3e:	3301      	adds	r3, #1
 8007d40:	9301      	str	r3, [sp, #4]
 8007d42:	9b01      	ldr	r3, [sp, #4]
 8007d44:	2b0d      	cmp	r3, #13
 8007d46:	ddea      	ble.n	8007d1e <dmaInit+0xe>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8007d48:	4b07      	ldr	r3, [pc, #28]	; (8007d68 <dmaInit+0x58>)
 8007d4a:	f04f 32ff 	mov.w	r2, #4294967295
 8007d4e:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8007d50:	4b06      	ldr	r3, [pc, #24]	; (8007d6c <dmaInit+0x5c>)
 8007d52:	f04f 32ff 	mov.w	r2, #4294967295
 8007d56:	605a      	str	r2, [r3, #4]
#endif
}
 8007d58:	b002      	add	sp, #8
 8007d5a:	4770      	bx	lr
 8007d5c:	20001248 	.word	0x20001248
 8007d60:	0801aac0 	.word	0x0801aac0
 8007d64:	20003af8 	.word	0x20003af8
 8007d68:	40020000 	.word	0x40020000
 8007d6c:	40020400 	.word	0x40020400

08007d70 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8007d70:	b500      	push	{lr}
 8007d72:	b085      	sub	sp, #20
 8007d74:	9003      	str	r0, [sp, #12]
 8007d76:	9102      	str	r1, [sp, #8]
 8007d78:	9201      	str	r2, [sp, #4]
 8007d7a:	9300      	str	r3, [sp, #0]

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8007d7c:	9b03      	ldr	r3, [sp, #12]
 8007d7e:	7c5b      	ldrb	r3, [r3, #17]
 8007d80:	2201      	movs	r2, #1
 8007d82:	409a      	lsls	r2, r3
 8007d84:	4b2f      	ldr	r3, [pc, #188]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007d86:	681b      	ldr	r3, [r3, #0]
 8007d88:	4013      	ands	r3, r2
 8007d8a:	2b00      	cmp	r3, #0
 8007d8c:	d001      	beq.n	8007d92 <dmaStreamAllocate+0x22>
    return true;
 8007d8e:	2301      	movs	r3, #1
 8007d90:	e053      	b.n	8007e3a <dmaStreamAllocate+0xca>

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8007d92:	9b03      	ldr	r3, [sp, #12]
 8007d94:	7c5b      	ldrb	r3, [r3, #17]
 8007d96:	461a      	mov	r2, r3
 8007d98:	4b2b      	ldr	r3, [pc, #172]	; (8007e48 <dmaStreamAllocate+0xd8>)
 8007d9a:	9901      	ldr	r1, [sp, #4]
 8007d9c:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8007da0:	9b03      	ldr	r3, [sp, #12]
 8007da2:	7c5b      	ldrb	r3, [r3, #17]
 8007da4:	4a28      	ldr	r2, [pc, #160]	; (8007e48 <dmaStreamAllocate+0xd8>)
 8007da6:	00db      	lsls	r3, r3, #3
 8007da8:	4413      	add	r3, r2
 8007daa:	9a00      	ldr	r2, [sp, #0]
 8007dac:	605a      	str	r2, [r3, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8007dae:	4b25      	ldr	r3, [pc, #148]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007db0:	681b      	ldr	r3, [r3, #0]
 8007db2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007db6:	2b00      	cmp	r3, #0
 8007db8:	d105      	bne.n	8007dc6 <dmaStreamAllocate+0x56>
    rccEnableDMA1(false);
 8007dba:	4b24      	ldr	r3, [pc, #144]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dbc:	4a23      	ldr	r2, [pc, #140]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dbe:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007dc0:	f042 0201 	orr.w	r2, r2, #1
 8007dc4:	649a      	str	r2, [r3, #72]	; 0x48
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8007dc6:	4b1f      	ldr	r3, [pc, #124]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007dc8:	681b      	ldr	r3, [r3, #0]
 8007dca:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
 8007dce:	2b00      	cmp	r3, #0
 8007dd0:	d105      	bne.n	8007dde <dmaStreamAllocate+0x6e>
    rccEnableDMA2(false);
 8007dd2:	4b1e      	ldr	r3, [pc, #120]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dd4:	4a1d      	ldr	r2, [pc, #116]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dd6:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007dd8:	f042 0202 	orr.w	r2, r2, #2
 8007ddc:	649a      	str	r2, [r3, #72]	; 0x48
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8007dde:	9b03      	ldr	r3, [sp, #12]
 8007de0:	685b      	ldr	r3, [r3, #4]
 8007de2:	9a03      	ldr	r2, [sp, #12]
 8007de4:	6852      	ldr	r2, [r2, #4]
 8007de6:	6812      	ldr	r2, [r2, #0]
 8007de8:	f022 020f 	bic.w	r2, r2, #15
 8007dec:	601a      	str	r2, [r3, #0]
 8007dee:	9b03      	ldr	r3, [sp, #12]
 8007df0:	681b      	ldr	r3, [r3, #0]
 8007df2:	9a03      	ldr	r2, [sp, #12]
 8007df4:	7c12      	ldrb	r2, [r2, #16]
 8007df6:	210f      	movs	r1, #15
 8007df8:	fa01 f202 	lsl.w	r2, r1, r2
 8007dfc:	605a      	str	r2, [r3, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8007dfe:	9b03      	ldr	r3, [sp, #12]
 8007e00:	685b      	ldr	r3, [r3, #4]
 8007e02:	2200      	movs	r2, #0
 8007e04:	601a      	str	r2, [r3, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8007e06:	9b03      	ldr	r3, [sp, #12]
 8007e08:	689a      	ldr	r2, [r3, #8]
 8007e0a:	4b0e      	ldr	r3, [pc, #56]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007e0c:	681b      	ldr	r3, [r3, #0]
 8007e0e:	4013      	ands	r3, r2
 8007e10:	2b00      	cmp	r3, #0
 8007e12:	d108      	bne.n	8007e26 <dmaStreamAllocate+0xb6>
 8007e14:	9b01      	ldr	r3, [sp, #4]
 8007e16:	2b00      	cmp	r3, #0
 8007e18:	d005      	beq.n	8007e26 <dmaStreamAllocate+0xb6>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8007e1a:	9b03      	ldr	r3, [sp, #12]
 8007e1c:	7c9b      	ldrb	r3, [r3, #18]
 8007e1e:	4618      	mov	r0, r3
 8007e20:	9902      	ldr	r1, [sp, #8]
 8007e22:	f7ff fa85 	bl	8007330 <nvicEnableVector>
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8007e26:	9b03      	ldr	r3, [sp, #12]
 8007e28:	7c5b      	ldrb	r3, [r3, #17]
 8007e2a:	2201      	movs	r2, #1
 8007e2c:	409a      	lsls	r2, r3
 8007e2e:	4b05      	ldr	r3, [pc, #20]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007e30:	681b      	ldr	r3, [r3, #0]
 8007e32:	431a      	orrs	r2, r3
 8007e34:	4b03      	ldr	r3, [pc, #12]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007e36:	601a      	str	r2, [r3, #0]

  return false;
 8007e38:	2300      	movs	r3, #0
}
 8007e3a:	4618      	mov	r0, r3
 8007e3c:	b005      	add	sp, #20
 8007e3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007e42:	bf00      	nop
 8007e44:	20001248 	.word	0x20001248
 8007e48:	20003af8 	.word	0x20003af8
 8007e4c:	40021000 	.word	0x40021000

08007e50 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8007e50:	b500      	push	{lr}
 8007e52:	b083      	sub	sp, #12
 8007e54:	9001      	str	r0, [sp, #4]
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8007e56:	9b01      	ldr	r3, [sp, #4]
 8007e58:	7c5b      	ldrb	r3, [r3, #17]
 8007e5a:	2201      	movs	r2, #1
 8007e5c:	fa02 f303 	lsl.w	r3, r2, r3
 8007e60:	43da      	mvns	r2, r3
 8007e62:	4b1d      	ldr	r3, [pc, #116]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007e64:	681b      	ldr	r3, [r3, #0]
 8007e66:	401a      	ands	r2, r3
 8007e68:	4b1b      	ldr	r3, [pc, #108]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007e6a:	601a      	str	r2, [r3, #0]

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8007e6c:	9b01      	ldr	r3, [sp, #4]
 8007e6e:	689a      	ldr	r2, [r3, #8]
 8007e70:	4b19      	ldr	r3, [pc, #100]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007e72:	681b      	ldr	r3, [r3, #0]
 8007e74:	4013      	ands	r3, r2
 8007e76:	2b00      	cmp	r3, #0
 8007e78:	d104      	bne.n	8007e84 <dmaStreamRelease+0x34>
    nvicDisableVector(dmastp->vector);
 8007e7a:	9b01      	ldr	r3, [sp, #4]
 8007e7c:	7c9b      	ldrb	r3, [r3, #18]
 8007e7e:	4618      	mov	r0, r3
 8007e80:	f7ff fa7e 	bl	8007380 <nvicDisableVector>
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8007e84:	9b01      	ldr	r3, [sp, #4]
 8007e86:	7c5b      	ldrb	r3, [r3, #17]
 8007e88:	461a      	mov	r2, r3
 8007e8a:	4b14      	ldr	r3, [pc, #80]	; (8007edc <dmaStreamRelease+0x8c>)
 8007e8c:	2100      	movs	r1, #0
 8007e8e:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8007e92:	9b01      	ldr	r3, [sp, #4]
 8007e94:	7c5b      	ldrb	r3, [r3, #17]
 8007e96:	4a11      	ldr	r2, [pc, #68]	; (8007edc <dmaStreamRelease+0x8c>)
 8007e98:	00db      	lsls	r3, r3, #3
 8007e9a:	4413      	add	r3, r2
 8007e9c:	2200      	movs	r2, #0
 8007e9e:	605a      	str	r2, [r3, #4]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8007ea0:	4b0d      	ldr	r3, [pc, #52]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007ea2:	681b      	ldr	r3, [r3, #0]
 8007ea4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007ea8:	2b00      	cmp	r3, #0
 8007eaa:	d105      	bne.n	8007eb8 <dmaStreamRelease+0x68>
    rccDisableDMA1(false);
 8007eac:	4b0c      	ldr	r3, [pc, #48]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007eae:	4a0c      	ldr	r2, [pc, #48]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007eb0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007eb2:	f022 0201 	bic.w	r2, r2, #1
 8007eb6:	649a      	str	r2, [r3, #72]	; 0x48
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8007eb8:	4b07      	ldr	r3, [pc, #28]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007eba:	681b      	ldr	r3, [r3, #0]
 8007ebc:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
 8007ec0:	2b00      	cmp	r3, #0
 8007ec2:	d105      	bne.n	8007ed0 <dmaStreamRelease+0x80>
    rccDisableDMA2(false);
 8007ec4:	4b06      	ldr	r3, [pc, #24]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007ec6:	4a06      	ldr	r2, [pc, #24]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007ec8:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007eca:	f022 0202 	bic.w	r2, r2, #2
 8007ece:	649a      	str	r2, [r3, #72]	; 0x48
  }
#endif
}
 8007ed0:	b003      	add	sp, #12
 8007ed2:	f85d fb04 	ldr.w	pc, [sp], #4
 8007ed6:	bf00      	nop
 8007ed8:	20001248 	.word	0x20001248
 8007edc:	20003af8 	.word	0x20003af8
 8007ee0:	40021000 	.word	0x40021000
 8007ee4:	f3af 8000 	nop.w
 8007ee8:	f3af 8000 	nop.w
 8007eec:	f3af 8000 	nop.w

08007ef0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007ef0:	b082      	sub	sp, #8
 8007ef2:	2320      	movs	r3, #32
 8007ef4:	9301      	str	r3, [sp, #4]
 8007ef6:	9b01      	ldr	r3, [sp, #4]
 8007ef8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007efc:	b002      	add	sp, #8
 8007efe:	4770      	bx	lr

08007f00 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007f00:	b082      	sub	sp, #8
 8007f02:	2300      	movs	r3, #0
 8007f04:	9301      	str	r3, [sp, #4]
 8007f06:	9b01      	ldr	r3, [sp, #4]
 8007f08:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007f0c:	b002      	add	sp, #8
 8007f0e:	4770      	bx	lr

08007f10 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8007f10:	b508      	push	{r3, lr}

  port_lock();
 8007f12:	f7ff ffed 	bl	8007ef0 <port_lock>
}
 8007f16:	bd08      	pop	{r3, pc}
 8007f18:	f3af 8000 	nop.w
 8007f1c:	f3af 8000 	nop.w

08007f20 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8007f20:	b508      	push	{r3, lr}

  port_unlock();
 8007f22:	f7ff ffed 	bl	8007f00 <port_unlock>
}
 8007f26:	bd08      	pop	{r3, pc}
 8007f28:	f3af 8000 	nop.w
 8007f2c:	f3af 8000 	nop.w

08007f30 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8007f30:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8007f32:	f7ff ffed 	bl	8007f10 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8007f36:	bd08      	pop	{r3, pc}
 8007f38:	f3af 8000 	nop.w
 8007f3c:	f3af 8000 	nop.w

08007f40 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8007f40:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8007f42:	f7ff ffed 	bl	8007f20 <port_unlock_from_isr>
}
 8007f46:	bd08      	pop	{r3, pc}
 8007f48:	f3af 8000 	nop.w
 8007f4c:	f3af 8000 	nop.w

08007f50 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8007f50:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8007f52:	f7ff ffed 	bl	8007f30 <chSysLockFromISR>
}
 8007f56:	bd08      	pop	{r3, pc}
 8007f58:	f3af 8000 	nop.w
 8007f5c:	f3af 8000 	nop.w

08007f60 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8007f60:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8007f62:	f7ff ffed 	bl	8007f40 <chSysUnlockFromISR>
}
 8007f66:	bd08      	pop	{r3, pc}
 8007f68:	f3af 8000 	nop.w
 8007f6c:	f3af 8000 	nop.w

08007f70 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8007f70:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8007f72:	f7f8 fc6d 	bl	8000850 <chSysTimerHandlerI>
}
 8007f76:	bd08      	pop	{r3, pc}
 8007f78:	f3af 8000 	nop.w
 8007f7c:	f3af 8000 	nop.w

08007f80 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 8007f80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 8007f82:	f7ff ffe5 	bl	8007f50 <osalSysLockFromISR>
  osalOsTimerHandlerI();
 8007f86:	f7ff fff3 	bl	8007f70 <osalOsTimerHandlerI>
  osalSysUnlockFromISR();
 8007f8a:	f7ff ffe9 	bl	8007f60 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 8007f8e:	f7fb fddf 	bl	8003b50 <_port_irq_epilogue>
}
 8007f92:	bd08      	pop	{r3, pc}
 8007f94:	f3af 8000 	nop.w
 8007f98:	f3af 8000 	nop.w
 8007f9c:	f3af 8000 	nop.w

08007fa0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8007fa0:	b508      	push	{r3, lr}
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8007fa2:	4b07      	ldr	r3, [pc, #28]	; (8007fc0 <st_lld_init+0x20>)
 8007fa4:	f240 321f 	movw	r2, #799	; 0x31f
 8007fa8:	605a      	str	r2, [r3, #4]
  SysTick->VAL = 0;
 8007faa:	4b05      	ldr	r3, [pc, #20]	; (8007fc0 <st_lld_init+0x20>)
 8007fac:	2200      	movs	r2, #0
 8007fae:	609a      	str	r2, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8007fb0:	4b03      	ldr	r3, [pc, #12]	; (8007fc0 <st_lld_init+0x20>)
 8007fb2:	2207      	movs	r2, #7
 8007fb4:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 8007fb6:	200b      	movs	r0, #11
 8007fb8:	2108      	movs	r1, #8
 8007fba:	f7ff fa01 	bl	80073c0 <nvicSetSystemHandlerPriority>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8007fbe:	bd08      	pop	{r3, pc}
 8007fc0:	e000e010 	.word	0xe000e010
 8007fc4:	f3af 8000 	nop.w
 8007fc8:	f3af 8000 	nop.w
 8007fcc:	f3af 8000 	nop.w

08007fd0 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8007fd0:	b082      	sub	sp, #8
 8007fd2:	9001      	str	r0, [sp, #4]
 8007fd4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8007fd6:	9b00      	ldr	r3, [sp, #0]
 8007fd8:	685a      	ldr	r2, [r3, #4]
 8007fda:	9b01      	ldr	r3, [sp, #4]
 8007fdc:	605a      	str	r2, [r3, #4]
  gpiop->ASCR    = config->ascr;
 8007fde:	9b00      	ldr	r3, [sp, #0]
 8007fe0:	69da      	ldr	r2, [r3, #28]
 8007fe2:	9b01      	ldr	r3, [sp, #4]
 8007fe4:	62da      	str	r2, [r3, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 8007fe6:	9b00      	ldr	r3, [sp, #0]
 8007fe8:	689a      	ldr	r2, [r3, #8]
 8007fea:	9b01      	ldr	r3, [sp, #4]
 8007fec:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8007fee:	9b00      	ldr	r3, [sp, #0]
 8007ff0:	68da      	ldr	r2, [r3, #12]
 8007ff2:	9b01      	ldr	r3, [sp, #4]
 8007ff4:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8007ff6:	9b00      	ldr	r3, [sp, #0]
 8007ff8:	691a      	ldr	r2, [r3, #16]
 8007ffa:	9b01      	ldr	r3, [sp, #4]
 8007ffc:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8007ffe:	9b00      	ldr	r3, [sp, #0]
 8008000:	695a      	ldr	r2, [r3, #20]
 8008002:	9b01      	ldr	r3, [sp, #4]
 8008004:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8008006:	9b00      	ldr	r3, [sp, #0]
 8008008:	699a      	ldr	r2, [r3, #24]
 800800a:	9b01      	ldr	r3, [sp, #4]
 800800c:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800800e:	9b00      	ldr	r3, [sp, #0]
 8008010:	681a      	ldr	r2, [r3, #0]
 8008012:	9b01      	ldr	r3, [sp, #4]
 8008014:	601a      	str	r2, [r3, #0]
  gpiop->LOCKR   = config->lockr;
 8008016:	9b00      	ldr	r3, [sp, #0]
 8008018:	6a1a      	ldr	r2, [r3, #32]
 800801a:	9b01      	ldr	r3, [sp, #4]
 800801c:	61da      	str	r2, [r3, #28]
}
 800801e:	b002      	add	sp, #8
 8008020:	4770      	bx	lr
 8008022:	bf00      	nop
 8008024:	f3af 8000 	nop.w
 8008028:	f3af 8000 	nop.w
 800802c:	f3af 8000 	nop.w

08008030 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8008030:	b500      	push	{lr}
 8008032:	b083      	sub	sp, #12
 8008034:	9001      	str	r0, [sp, #4]

  /*
   * Enables the GPIO related clocks.
   */
#if defined(STM32L4XX)
  RCC->AHB2ENR   |= AHB1_EN_MASK;
 8008036:	4b1c      	ldr	r3, [pc, #112]	; (80080a8 <_pal_lld_init+0x78>)
 8008038:	4a1b      	ldr	r2, [pc, #108]	; (80080a8 <_pal_lld_init+0x78>)
 800803a:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 800803c:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 8008040:	64da      	str	r2, [r3, #76]	; 0x4c

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8008042:	9b01      	ldr	r3, [sp, #4]
 8008044:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8008048:	4619      	mov	r1, r3
 800804a:	f7ff ffc1 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 800804e:	9b01      	ldr	r3, [sp, #4]
 8008050:	3324      	adds	r3, #36	; 0x24
 8008052:	4816      	ldr	r0, [pc, #88]	; (80080ac <_pal_lld_init+0x7c>)
 8008054:	4619      	mov	r1, r3
 8008056:	f7ff ffbb 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 800805a:	9b01      	ldr	r3, [sp, #4]
 800805c:	3348      	adds	r3, #72	; 0x48
 800805e:	4814      	ldr	r0, [pc, #80]	; (80080b0 <_pal_lld_init+0x80>)
 8008060:	4619      	mov	r1, r3
 8008062:	f7ff ffb5 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 8008066:	9b01      	ldr	r3, [sp, #4]
 8008068:	336c      	adds	r3, #108	; 0x6c
 800806a:	4812      	ldr	r0, [pc, #72]	; (80080b4 <_pal_lld_init+0x84>)
 800806c:	4619      	mov	r1, r3
 800806e:	f7ff ffaf 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 8008072:	9b01      	ldr	r3, [sp, #4]
 8008074:	3390      	adds	r3, #144	; 0x90
 8008076:	4810      	ldr	r0, [pc, #64]	; (80080b8 <_pal_lld_init+0x88>)
 8008078:	4619      	mov	r1, r3
 800807a:	f7ff ffa9 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 800807e:	9b01      	ldr	r3, [sp, #4]
 8008080:	33b4      	adds	r3, #180	; 0xb4
 8008082:	480e      	ldr	r0, [pc, #56]	; (80080bc <_pal_lld_init+0x8c>)
 8008084:	4619      	mov	r1, r3
 8008086:	f7ff ffa3 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 800808a:	9b01      	ldr	r3, [sp, #4]
 800808c:	33d8      	adds	r3, #216	; 0xd8
 800808e:	480c      	ldr	r0, [pc, #48]	; (80080c0 <_pal_lld_init+0x90>)
 8008090:	4619      	mov	r1, r3
 8008092:	f7ff ff9d 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8008096:	9b01      	ldr	r3, [sp, #4]
 8008098:	33fc      	adds	r3, #252	; 0xfc
 800809a:	480a      	ldr	r0, [pc, #40]	; (80080c4 <_pal_lld_init+0x94>)
 800809c:	4619      	mov	r1, r3
 800809e:	f7ff ff97 	bl	8007fd0 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 80080a2:	b003      	add	sp, #12
 80080a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80080a8:	40021000 	.word	0x40021000
 80080ac:	48000400 	.word	0x48000400
 80080b0:	48000800 	.word	0x48000800
 80080b4:	48000c00 	.word	0x48000c00
 80080b8:	48001000 	.word	0x48001000
 80080bc:	48001400 	.word	0x48001400
 80080c0:	48001800 	.word	0x48001800
 80080c4:	48001c00 	.word	0x48001c00
 80080c8:	f3af 8000 	nop.w
 80080cc:	f3af 8000 	nop.w

080080d0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80080d0:	b090      	sub	sp, #64	; 0x40
 80080d2:	9003      	str	r0, [sp, #12]
 80080d4:	9102      	str	r1, [sp, #8]
 80080d6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80080d8:	9b01      	ldr	r3, [sp, #4]
 80080da:	f003 0303 	and.w	r3, r3, #3
 80080de:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80080e0:	9b01      	ldr	r3, [sp, #4]
 80080e2:	f003 0304 	and.w	r3, r3, #4
 80080e6:	089b      	lsrs	r3, r3, #2
 80080e8:	930e      	str	r3, [sp, #56]	; 0x38
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80080ea:	9b01      	ldr	r3, [sp, #4]
 80080ec:	f003 0318 	and.w	r3, r3, #24
 80080f0:	08db      	lsrs	r3, r3, #3
 80080f2:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 80080f4:	9b01      	ldr	r3, [sp, #4]
 80080f6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80080fa:	095b      	lsrs	r3, r3, #5
 80080fc:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80080fe:	9b01      	ldr	r3, [sp, #4]
 8008100:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 8008104:	09db      	lsrs	r3, r3, #7
 8008106:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t ascr    = (mode & PAL_STM32_ASCR_MASK) >> 11;
 8008108:	9b01      	ldr	r3, [sp, #4]
 800810a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800810e:	0adb      	lsrs	r3, r3, #11
 8008110:	9309      	str	r3, [sp, #36]	; 0x24
  uint32_t lockr   = (mode & PAL_STM32_LOCKR_MASK) >> 12;
 8008112:	9b01      	ldr	r3, [sp, #4]
 8008114:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8008118:	0b1b      	lsrs	r3, r3, #12
 800811a:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 800811c:	2300      	movs	r3, #0
 800811e:	930b      	str	r3, [sp, #44]	; 0x2c
  while (true) {
    if ((mask & 1) != 0) {
 8008120:	9b02      	ldr	r3, [sp, #8]
 8008122:	f003 0301 	and.w	r3, r3, #1
 8008126:	2b00      	cmp	r3, #0
 8008128:	f000 808a 	beq.w	8008240 <_pal_lld_setgroupmode+0x170>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800812c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800812e:	f003 0307 	and.w	r3, r3, #7
 8008132:	009b      	lsls	r3, r3, #2
 8008134:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008136:	fa02 f303 	lsl.w	r3, r2, r3
 800813a:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 800813c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800813e:	2201      	movs	r2, #1
 8008140:	fa02 f303 	lsl.w	r3, r2, r3
 8008144:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8008146:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008148:	005b      	lsls	r3, r3, #1
 800814a:	2203      	movs	r2, #3
 800814c:	fa02 f303 	lsl.w	r3, r2, r3
 8008150:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8008152:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008154:	f003 0307 	and.w	r3, r3, #7
 8008158:	009b      	lsls	r3, r3, #2
 800815a:	220f      	movs	r2, #15
 800815c:	fa02 f303 	lsl.w	r3, r2, r3
 8008160:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8008162:	9b03      	ldr	r3, [sp, #12]
 8008164:	685a      	ldr	r2, [r3, #4]
 8008166:	9b06      	ldr	r3, [sp, #24]
 8008168:	43db      	mvns	r3, r3
 800816a:	401a      	ands	r2, r3
 800816c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800816e:	431a      	orrs	r2, r3
 8008170:	9b03      	ldr	r3, [sp, #12]
 8008172:	605a      	str	r2, [r3, #4]
      port->ASCR    = (port->ASCR & ~m1) | ascr;
 8008174:	9b03      	ldr	r3, [sp, #12]
 8008176:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008178:	9b06      	ldr	r3, [sp, #24]
 800817a:	43db      	mvns	r3, r3
 800817c:	401a      	ands	r2, r3
 800817e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008180:	431a      	orrs	r2, r3
 8008182:	9b03      	ldr	r3, [sp, #12]
 8008184:	62da      	str	r2, [r3, #44]	; 0x2c
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8008186:	9b03      	ldr	r3, [sp, #12]
 8008188:	689a      	ldr	r2, [r3, #8]
 800818a:	9b05      	ldr	r3, [sp, #20]
 800818c:	43db      	mvns	r3, r3
 800818e:	401a      	ands	r2, r3
 8008190:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008192:	431a      	orrs	r2, r3
 8008194:	9b03      	ldr	r3, [sp, #12]
 8008196:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8008198:	9b03      	ldr	r3, [sp, #12]
 800819a:	68da      	ldr	r2, [r3, #12]
 800819c:	9b05      	ldr	r3, [sp, #20]
 800819e:	43db      	mvns	r3, r3
 80081a0:	401a      	ands	r2, r3
 80081a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80081a4:	431a      	orrs	r2, r3
 80081a6:	9b03      	ldr	r3, [sp, #12]
 80081a8:	60da      	str	r2, [r3, #12]
       if (moder == PAL_STM32_MODE_ALTERNATE) {
 80081aa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80081ac:	2b02      	cmp	r3, #2
 80081ae:	d11f      	bne.n	80081f0 <_pal_lld_setgroupmode+0x120>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80081b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80081b2:	2b07      	cmp	r3, #7
 80081b4:	d809      	bhi.n	80081ca <_pal_lld_setgroupmode+0xfa>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80081b6:	9b03      	ldr	r3, [sp, #12]
 80081b8:	6a1a      	ldr	r2, [r3, #32]
 80081ba:	9b04      	ldr	r3, [sp, #16]
 80081bc:	43db      	mvns	r3, r3
 80081be:	401a      	ands	r2, r3
 80081c0:	9b07      	ldr	r3, [sp, #28]
 80081c2:	431a      	orrs	r2, r3
 80081c4:	9b03      	ldr	r3, [sp, #12]
 80081c6:	621a      	str	r2, [r3, #32]
 80081c8:	e008      	b.n	80081dc <_pal_lld_setgroupmode+0x10c>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80081ca:	9b03      	ldr	r3, [sp, #12]
 80081cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80081ce:	9b04      	ldr	r3, [sp, #16]
 80081d0:	43db      	mvns	r3, r3
 80081d2:	401a      	ands	r2, r3
 80081d4:	9b07      	ldr	r3, [sp, #28]
 80081d6:	431a      	orrs	r2, r3
 80081d8:	9b03      	ldr	r3, [sp, #12]
 80081da:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 80081dc:	9b03      	ldr	r3, [sp, #12]
 80081de:	681a      	ldr	r2, [r3, #0]
 80081e0:	9b05      	ldr	r3, [sp, #20]
 80081e2:	43db      	mvns	r3, r3
 80081e4:	401a      	ands	r2, r3
 80081e6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80081e8:	431a      	orrs	r2, r3
 80081ea:	9b03      	ldr	r3, [sp, #12]
 80081ec:	601a      	str	r2, [r3, #0]
 80081ee:	e01e      	b.n	800822e <_pal_lld_setgroupmode+0x15e>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80081f0:	9b03      	ldr	r3, [sp, #12]
 80081f2:	681a      	ldr	r2, [r3, #0]
 80081f4:	9b05      	ldr	r3, [sp, #20]
 80081f6:	43db      	mvns	r3, r3
 80081f8:	401a      	ands	r2, r3
 80081fa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80081fc:	431a      	orrs	r2, r3
 80081fe:	9b03      	ldr	r3, [sp, #12]
 8008200:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8008202:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008204:	2b07      	cmp	r3, #7
 8008206:	d809      	bhi.n	800821c <_pal_lld_setgroupmode+0x14c>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8008208:	9b03      	ldr	r3, [sp, #12]
 800820a:	6a1a      	ldr	r2, [r3, #32]
 800820c:	9b04      	ldr	r3, [sp, #16]
 800820e:	43db      	mvns	r3, r3
 8008210:	401a      	ands	r2, r3
 8008212:	9b07      	ldr	r3, [sp, #28]
 8008214:	431a      	orrs	r2, r3
 8008216:	9b03      	ldr	r3, [sp, #12]
 8008218:	621a      	str	r2, [r3, #32]
 800821a:	e008      	b.n	800822e <_pal_lld_setgroupmode+0x15e>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800821c:	9b03      	ldr	r3, [sp, #12]
 800821e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008220:	9b04      	ldr	r3, [sp, #16]
 8008222:	43db      	mvns	r3, r3
 8008224:	401a      	ands	r2, r3
 8008226:	9b07      	ldr	r3, [sp, #28]
 8008228:	431a      	orrs	r2, r3
 800822a:	9b03      	ldr	r3, [sp, #12]
 800822c:	625a      	str	r2, [r3, #36]	; 0x24
      }
      port->LOCKR   = (port->LOCKR & ~m1) | lockr;
 800822e:	9b03      	ldr	r3, [sp, #12]
 8008230:	69da      	ldr	r2, [r3, #28]
 8008232:	9b06      	ldr	r3, [sp, #24]
 8008234:	43db      	mvns	r3, r3
 8008236:	401a      	ands	r2, r3
 8008238:	9b08      	ldr	r3, [sp, #32]
 800823a:	431a      	orrs	r2, r3
 800823c:	9b03      	ldr	r3, [sp, #12]
 800823e:	61da      	str	r2, [r3, #28]
    }
    mask >>= 1;
 8008240:	9b02      	ldr	r3, [sp, #8]
 8008242:	085b      	lsrs	r3, r3, #1
 8008244:	9302      	str	r3, [sp, #8]
    if (!mask)
 8008246:	9b02      	ldr	r3, [sp, #8]
 8008248:	2b00      	cmp	r3, #0
 800824a:	d100      	bne.n	800824e <_pal_lld_setgroupmode+0x17e>
      return;
 800824c:	e00f      	b.n	800826e <_pal_lld_setgroupmode+0x19e>
    otyper <<= 1;
 800824e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008250:	005b      	lsls	r3, r3, #1
 8008252:	930e      	str	r3, [sp, #56]	; 0x38
    ospeedr <<= 2;
 8008254:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008256:	009b      	lsls	r3, r3, #2
 8008258:	930d      	str	r3, [sp, #52]	; 0x34
    pupdr <<= 2;
 800825a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800825c:	009b      	lsls	r3, r3, #2
 800825e:	930c      	str	r3, [sp, #48]	; 0x30
    moder <<= 2;
 8008260:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008262:	009b      	lsls	r3, r3, #2
 8008264:	930f      	str	r3, [sp, #60]	; 0x3c
    bit++;
 8008266:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008268:	3301      	adds	r3, #1
 800826a:	930b      	str	r3, [sp, #44]	; 0x2c
  }
 800826c:	e758      	b.n	8008120 <_pal_lld_setgroupmode+0x50>
}
 800826e:	b010      	add	sp, #64	; 0x40
 8008270:	4770      	bx	lr
 8008272:	bf00      	nop
 8008274:	f3af 8000 	nop.w
 8008278:	f3af 8000 	nop.w
 800827c:	f3af 8000 	nop.w

08008280 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008280:	b082      	sub	sp, #8
 8008282:	2320      	movs	r3, #32
 8008284:	9301      	str	r3, [sp, #4]
 8008286:	9b01      	ldr	r3, [sp, #4]
 8008288:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800828c:	b002      	add	sp, #8
 800828e:	4770      	bx	lr

08008290 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008290:	b082      	sub	sp, #8
 8008292:	2300      	movs	r3, #0
 8008294:	9301      	str	r3, [sp, #4]
 8008296:	9b01      	ldr	r3, [sp, #4]
 8008298:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800829c:	b002      	add	sp, #8
 800829e:	4770      	bx	lr

080082a0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80082a0:	b508      	push	{r3, lr}

  port_lock();
 80082a2:	f7ff ffed 	bl	8008280 <port_lock>
}
 80082a6:	bd08      	pop	{r3, pc}
 80082a8:	f3af 8000 	nop.w
 80082ac:	f3af 8000 	nop.w

080082b0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80082b0:	b508      	push	{r3, lr}

  port_unlock();
 80082b2:	f7ff ffed 	bl	8008290 <port_unlock>
}
 80082b6:	bd08      	pop	{r3, pc}
 80082b8:	f3af 8000 	nop.w
 80082bc:	f3af 8000 	nop.w

080082c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80082c0:	b508      	push	{r3, lr}

  port_lock();
 80082c2:	f7ff ffdd 	bl	8008280 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80082c6:	bd08      	pop	{r3, pc}
 80082c8:	f3af 8000 	nop.w
 80082cc:	f3af 8000 	nop.w

080082d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80082d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80082d2:	f7ff ffdd 	bl	8008290 <port_unlock>
}
 80082d6:	bd08      	pop	{r3, pc}
 80082d8:	f3af 8000 	nop.w
 80082dc:	f3af 8000 	nop.w

080082e0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80082e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80082e2:	f7ff ffdd 	bl	80082a0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80082e6:	bd08      	pop	{r3, pc}
 80082e8:	f3af 8000 	nop.w
 80082ec:	f3af 8000 	nop.w

080082f0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80082f0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80082f2:	f7ff ffdd 	bl	80082b0 <port_unlock_from_isr>
}
 80082f6:	bd08      	pop	{r3, pc}
 80082f8:	f3af 8000 	nop.w
 80082fc:	f3af 8000 	nop.w

08008300 <chThdStartI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 8008300:	b500      	push	{lr}
 8008302:	b083      	sub	sp, #12
 8008304:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8008306:	9801      	ldr	r0, [sp, #4]
 8008308:	f7f8 fc4a 	bl	8000ba0 <chSchReadyI>
 800830c:	4603      	mov	r3, r0
}
 800830e:	4618      	mov	r0, r3
 8008310:	b003      	add	sp, #12
 8008312:	f85d fb04 	ldr.w	pc, [sp], #4
 8008316:	bf00      	nop
 8008318:	f3af 8000 	nop.w
 800831c:	f3af 8000 	nop.w

08008320 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8008320:	b082      	sub	sp, #8
 8008322:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8008324:	4b02      	ldr	r3, [pc, #8]	; (8008330 <chRegSetThreadName+0x10>)
 8008326:	699b      	ldr	r3, [r3, #24]
 8008328:	9a01      	ldr	r2, [sp, #4]
 800832a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800832c:	b002      	add	sp, #8
 800832e:	4770      	bx	lr
 8008330:	200039a8 	.word	0x200039a8
 8008334:	f3af 8000 	nop.w
 8008338:	f3af 8000 	nop.w
 800833c:	f3af 8000 	nop.w

08008340 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8008340:	b508      	push	{r3, lr}

  chSysLock();
 8008342:	f7ff ffbd 	bl	80082c0 <chSysLock>
}
 8008346:	bd08      	pop	{r3, pc}
 8008348:	f3af 8000 	nop.w
 800834c:	f3af 8000 	nop.w

08008350 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8008350:	b508      	push	{r3, lr}

  chSysUnlock();
 8008352:	f7ff ffbd 	bl	80082d0 <chSysUnlock>
}
 8008356:	bd08      	pop	{r3, pc}
 8008358:	f3af 8000 	nop.w
 800835c:	f3af 8000 	nop.w

08008360 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8008360:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8008362:	f7ff ffbd 	bl	80082e0 <chSysLockFromISR>
}
 8008366:	bd08      	pop	{r3, pc}
 8008368:	f3af 8000 	nop.w
 800836c:	f3af 8000 	nop.w

08008370 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8008370:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8008372:	f7ff ffbd 	bl	80082f0 <chSysUnlockFromISR>
}
 8008376:	bd08      	pop	{r3, pc}
 8008378:	f3af 8000 	nop.w
 800837c:	f3af 8000 	nop.w

08008380 <osalSysPolledDelayX>:
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8008380:	b500      	push	{lr}
 8008382:	b083      	sub	sp, #12
 8008384:	9001      	str	r0, [sp, #4]

  chSysPolledDelayX(cycles);
 8008386:	9801      	ldr	r0, [sp, #4]
 8008388:	f7f8 faca 	bl	8000920 <chSysPolledDelayX>
}
 800838c:	b003      	add	sp, #12
 800838e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008392:	bf00      	nop
 8008394:	f3af 8000 	nop.w
 8008398:	f3af 8000 	nop.w
 800839c:	f3af 8000 	nop.w

080083a0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 80083a0:	b500      	push	{lr}
 80083a2:	b083      	sub	sp, #12
 80083a4:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 80083a6:	9801      	ldr	r0, [sp, #4]
 80083a8:	f7f9 f852 	bl	8001450 <chThdSuspendS>
 80083ac:	4603      	mov	r3, r0
}
 80083ae:	4618      	mov	r0, r3
 80083b0:	b003      	add	sp, #12
 80083b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80083b6:	bf00      	nop
 80083b8:	f3af 8000 	nop.w
 80083bc:	f3af 8000 	nop.w

080083c0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80083c0:	b500      	push	{lr}
 80083c2:	b083      	sub	sp, #12
 80083c4:	9001      	str	r0, [sp, #4]
 80083c6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 80083c8:	9801      	ldr	r0, [sp, #4]
 80083ca:	9900      	ldr	r1, [sp, #0]
 80083cc:	f7f9 f878 	bl	80014c0 <chThdResumeI>
}
 80083d0:	b003      	add	sp, #12
 80083d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80083d6:	bf00      	nop
 80083d8:	f3af 8000 	nop.w
 80083dc:	f3af 8000 	nop.w

080083e0 <otg_core_reset>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 80083e0:	b500      	push	{lr}
 80083e2:	b085      	sub	sp, #20
 80083e4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80083e6:	9b01      	ldr	r3, [sp, #4]
 80083e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80083ea:	9303      	str	r3, [sp, #12]

  osalSysPolledDelayX(32);
 80083ec:	2020      	movs	r0, #32
 80083ee:	f7ff ffc7 	bl	8008380 <osalSysPolledDelayX>

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 80083f2:	9b03      	ldr	r3, [sp, #12]
 80083f4:	2201      	movs	r2, #1
 80083f6:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 80083f8:	bf00      	nop
 80083fa:	9b03      	ldr	r3, [sp, #12]
 80083fc:	691b      	ldr	r3, [r3, #16]
 80083fe:	f003 0301 	and.w	r3, r3, #1
 8008402:	2b00      	cmp	r3, #0
 8008404:	d1f9      	bne.n	80083fa <otg_core_reset+0x1a>
    ;

  osalSysPolledDelayX(18);
 8008406:	2012      	movs	r0, #18
 8008408:	f7ff ffba 	bl	8008380 <osalSysPolledDelayX>

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800840c:	bf00      	nop
 800840e:	9b03      	ldr	r3, [sp, #12]
 8008410:	691b      	ldr	r3, [r3, #16]
 8008412:	2b00      	cmp	r3, #0
 8008414:	dafb      	bge.n	800840e <otg_core_reset+0x2e>
    ;
}
 8008416:	b005      	add	sp, #20
 8008418:	f85d fb04 	ldr.w	pc, [sp], #4
 800841c:	f3af 8000 	nop.w

08008420 <otg_disable_ep>:

static void otg_disable_ep(USBDriver *usbp) {
 8008420:	b084      	sub	sp, #16
 8008422:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008424:	9b01      	ldr	r3, [sp, #4]
 8008426:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008428:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800842a:	2300      	movs	r3, #0
 800842c:	9303      	str	r3, [sp, #12]
 800842e:	e032      	b.n	8008496 <otg_disable_ep+0x76>
    otgp->ie[i].DIEPCTL = 0;
 8008430:	9a02      	ldr	r2, [sp, #8]
 8008432:	9b03      	ldr	r3, [sp, #12]
 8008434:	3348      	adds	r3, #72	; 0x48
 8008436:	015b      	lsls	r3, r3, #5
 8008438:	4413      	add	r3, r2
 800843a:	2200      	movs	r2, #0
 800843c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 800843e:	9a02      	ldr	r2, [sp, #8]
 8008440:	9b03      	ldr	r3, [sp, #12]
 8008442:	015b      	lsls	r3, r3, #5
 8008444:	4413      	add	r3, r2
 8008446:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800844a:	2200      	movs	r2, #0
 800844c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800844e:	9a02      	ldr	r2, [sp, #8]
 8008450:	9b03      	ldr	r3, [sp, #12]
 8008452:	015b      	lsls	r3, r3, #5
 8008454:	4413      	add	r3, r2
 8008456:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800845a:	f04f 32ff 	mov.w	r2, #4294967295
 800845e:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 8008460:	9a02      	ldr	r2, [sp, #8]
 8008462:	9b03      	ldr	r3, [sp, #12]
 8008464:	3358      	adds	r3, #88	; 0x58
 8008466:	015b      	lsls	r3, r3, #5
 8008468:	4413      	add	r3, r2
 800846a:	2200      	movs	r2, #0
 800846c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 800846e:	9a02      	ldr	r2, [sp, #8]
 8008470:	9b03      	ldr	r3, [sp, #12]
 8008472:	015b      	lsls	r3, r3, #5
 8008474:	4413      	add	r3, r2
 8008476:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800847a:	2200      	movs	r2, #0
 800847c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800847e:	9a02      	ldr	r2, [sp, #8]
 8008480:	9b03      	ldr	r3, [sp, #12]
 8008482:	015b      	lsls	r3, r3, #5
 8008484:	4413      	add	r3, r2
 8008486:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800848a:	f04f 32ff 	mov.w	r2, #4294967295
 800848e:	601a      	str	r2, [r3, #0]

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008490:	9b03      	ldr	r3, [sp, #12]
 8008492:	3301      	adds	r3, #1
 8008494:	9303      	str	r3, [sp, #12]
 8008496:	9b01      	ldr	r3, [sp, #4]
 8008498:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800849a:	689a      	ldr	r2, [r3, #8]
 800849c:	9b03      	ldr	r3, [sp, #12]
 800849e:	429a      	cmp	r2, r3
 80084a0:	d2c6      	bcs.n	8008430 <otg_disable_ep+0x10>

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80084a2:	9b02      	ldr	r3, [sp, #8]
 80084a4:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 80084a8:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 80084ac:	b004      	add	sp, #16
 80084ae:	4770      	bx	lr

080084b0 <otg_rxfifo_flush>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 80084b0:	b500      	push	{lr}
 80084b2:	b085      	sub	sp, #20
 80084b4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80084b6:	9b01      	ldr	r3, [sp, #4]
 80084b8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80084ba:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80084bc:	9b03      	ldr	r3, [sp, #12]
 80084be:	2210      	movs	r2, #16
 80084c0:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80084c2:	bf00      	nop
 80084c4:	9b03      	ldr	r3, [sp, #12]
 80084c6:	691b      	ldr	r3, [r3, #16]
 80084c8:	f003 0310 	and.w	r3, r3, #16
 80084cc:	2b00      	cmp	r3, #0
 80084ce:	d1f9      	bne.n	80084c4 <otg_rxfifo_flush+0x14>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 80084d0:	2012      	movs	r0, #18
 80084d2:	f7ff ff55 	bl	8008380 <osalSysPolledDelayX>
}
 80084d6:	b005      	add	sp, #20
 80084d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80084dc:	f3af 8000 	nop.w

080084e0 <otg_txfifo_flush>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 80084e0:	b500      	push	{lr}
 80084e2:	b085      	sub	sp, #20
 80084e4:	9001      	str	r0, [sp, #4]
 80084e6:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 80084e8:	9b01      	ldr	r3, [sp, #4]
 80084ea:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80084ec:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80084ee:	9b00      	ldr	r3, [sp, #0]
 80084f0:	019b      	lsls	r3, r3, #6
 80084f2:	f043 0220 	orr.w	r2, r3, #32
 80084f6:	9b03      	ldr	r3, [sp, #12]
 80084f8:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80084fa:	bf00      	nop
 80084fc:	9b03      	ldr	r3, [sp, #12]
 80084fe:	691b      	ldr	r3, [r3, #16]
 8008500:	f003 0320 	and.w	r3, r3, #32
 8008504:	2b00      	cmp	r3, #0
 8008506:	d1f9      	bne.n	80084fc <otg_txfifo_flush+0x1c>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 8008508:	2012      	movs	r0, #18
 800850a:	f7ff ff39 	bl	8008380 <osalSysPolledDelayX>
}
 800850e:	b005      	add	sp, #20
 8008510:	f85d fb04 	ldr.w	pc, [sp], #4
 8008514:	f3af 8000 	nop.w
 8008518:	f3af 8000 	nop.w
 800851c:	f3af 8000 	nop.w

08008520 <otg_ram_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 8008520:	b082      	sub	sp, #8
 8008522:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8008524:	9b01      	ldr	r3, [sp, #4]
 8008526:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008528:	681a      	ldr	r2, [r3, #0]
 800852a:	9b01      	ldr	r3, [sp, #4]
 800852c:	675a      	str	r2, [r3, #116]	; 0x74
}
 800852e:	b002      	add	sp, #8
 8008530:	4770      	bx	lr
 8008532:	bf00      	nop
 8008534:	f3af 8000 	nop.w
 8008538:	f3af 8000 	nop.w
 800853c:	f3af 8000 	nop.w

08008540 <otg_ram_alloc>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 8008540:	b084      	sub	sp, #16
 8008542:	9001      	str	r0, [sp, #4]
 8008544:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 8008546:	9b01      	ldr	r3, [sp, #4]
 8008548:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800854a:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 800854c:	9b01      	ldr	r3, [sp, #4]
 800854e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8008550:	9b00      	ldr	r3, [sp, #0]
 8008552:	441a      	add	r2, r3
 8008554:	9b01      	ldr	r3, [sp, #4]
 8008556:	675a      	str	r2, [r3, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
                "OTG FIFO memory overflow");
  return next;
 8008558:	9b03      	ldr	r3, [sp, #12]
}
 800855a:	4618      	mov	r0, r3
 800855c:	b004      	add	sp, #16
 800855e:	4770      	bx	lr

08008560 <otg_fifo_write_from_buffer>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 8008560:	b084      	sub	sp, #16
 8008562:	9003      	str	r0, [sp, #12]
 8008564:	9102      	str	r1, [sp, #8]
 8008566:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");

  while (true) {
    *fifop = *((uint32_t *)buf);
 8008568:	9b02      	ldr	r3, [sp, #8]
 800856a:	681a      	ldr	r2, [r3, #0]
 800856c:	9b03      	ldr	r3, [sp, #12]
 800856e:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 8008570:	9b01      	ldr	r3, [sp, #4]
 8008572:	2b04      	cmp	r3, #4
 8008574:	d800      	bhi.n	8008578 <otg_fifo_write_from_buffer+0x18>
      break;
 8008576:	e006      	b.n	8008586 <otg_fifo_write_from_buffer+0x26>
    }
    n -= 4;
 8008578:	9b01      	ldr	r3, [sp, #4]
 800857a:	3b04      	subs	r3, #4
 800857c:	9301      	str	r3, [sp, #4]
    buf += 4;
 800857e:	9b02      	ldr	r3, [sp, #8]
 8008580:	3304      	adds	r3, #4
 8008582:	9302      	str	r3, [sp, #8]
  }
 8008584:	e7f0      	b.n	8008568 <otg_fifo_write_from_buffer+0x8>
}
 8008586:	b004      	add	sp, #16
 8008588:	4770      	bx	lr
 800858a:	bf00      	nop
 800858c:	f3af 8000 	nop.w

08008590 <otg_fifo_read_to_buffer>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 8008590:	b086      	sub	sp, #24
 8008592:	9003      	str	r0, [sp, #12]
 8008594:	9102      	str	r1, [sp, #8]
 8008596:	9201      	str	r2, [sp, #4]
 8008598:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 800859a:	2300      	movs	r3, #0
 800859c:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 800859e:	2300      	movs	r3, #0
 80085a0:	9304      	str	r3, [sp, #16]

  while (i < n) {
 80085a2:	e017      	b.n	80085d4 <otg_fifo_read_to_buffer+0x44>
    if ((i & 3) == 0){
 80085a4:	9b04      	ldr	r3, [sp, #16]
 80085a6:	f003 0303 	and.w	r3, r3, #3
 80085aa:	2b00      	cmp	r3, #0
 80085ac:	d102      	bne.n	80085b4 <otg_fifo_read_to_buffer+0x24>
      w = *fifop;
 80085ae:	9b03      	ldr	r3, [sp, #12]
 80085b0:	681b      	ldr	r3, [r3, #0]
 80085b2:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 80085b4:	9a04      	ldr	r2, [sp, #16]
 80085b6:	9b00      	ldr	r3, [sp, #0]
 80085b8:	429a      	cmp	r2, r3
 80085ba:	d208      	bcs.n	80085ce <otg_fifo_read_to_buffer+0x3e>
      *buf++ = (uint8_t)w;
 80085bc:	9b02      	ldr	r3, [sp, #8]
 80085be:	1c5a      	adds	r2, r3, #1
 80085c0:	9202      	str	r2, [sp, #8]
 80085c2:	9a05      	ldr	r2, [sp, #20]
 80085c4:	b2d2      	uxtb	r2, r2
 80085c6:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 80085c8:	9b05      	ldr	r3, [sp, #20]
 80085ca:	0a1b      	lsrs	r3, r3, #8
 80085cc:	9305      	str	r3, [sp, #20]
    }
    i++;
 80085ce:	9b04      	ldr	r3, [sp, #16]
 80085d0:	3301      	adds	r3, #1
 80085d2:	9304      	str	r3, [sp, #16]
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80085d4:	9a04      	ldr	r2, [sp, #16]
 80085d6:	9b01      	ldr	r3, [sp, #4]
 80085d8:	429a      	cmp	r2, r3
 80085da:	d3e3      	bcc.n	80085a4 <otg_fifo_read_to_buffer+0x14>
      *buf++ = (uint8_t)w;
      w >>= 8;
    }
    i++;
  }
}
 80085dc:	b006      	add	sp, #24
 80085de:	4770      	bx	lr

080085e0 <otg_rxfifo_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 80085e0:	b510      	push	{r4, lr}
 80085e2:	b086      	sub	sp, #24
 80085e4:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 80085e6:	9b01      	ldr	r3, [sp, #4]
 80085e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80085ea:	6a1b      	ldr	r3, [r3, #32]
 80085ec:	9305      	str	r3, [sp, #20]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 80085ee:	9b05      	ldr	r3, [sp, #20]
 80085f0:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 80085f4:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80085f8:	d074      	beq.n	80086e4 <otg_rxfifo_handler+0x104>
 80085fa:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 80085fe:	d003      	beq.n	8008608 <otg_rxfifo_handler+0x28>
 8008600:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008604:	d01c      	beq.n	8008640 <otg_rxfifo_handler+0x60>
 8008606:	e06e      	b.n	80086e6 <otg_rxfifo_handler+0x106>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8008608:	9a05      	ldr	r2, [sp, #20]
 800860a:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800860e:	4013      	ands	r3, r2
 8008610:	091b      	lsrs	r3, r3, #4
 8008612:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8008614:	9b05      	ldr	r3, [sp, #20]
 8008616:	f003 030f 	and.w	r3, r3, #15
 800861a:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800861c:	9b01      	ldr	r3, [sp, #4]
 800861e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008620:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8008624:	9901      	ldr	r1, [sp, #4]
 8008626:	9b03      	ldr	r3, [sp, #12]
 8008628:	3302      	adds	r3, #2
 800862a:	009b      	lsls	r3, r3, #2
 800862c:	440b      	add	r3, r1
 800862e:	685b      	ldr	r3, [r3, #4]
 8008630:	6a1b      	ldr	r3, [r3, #32]
 8008632:	4610      	mov	r0, r2
 8008634:	4619      	mov	r1, r3
 8008636:	9a04      	ldr	r2, [sp, #16]
 8008638:	2308      	movs	r3, #8
 800863a:	f7ff ffa9 	bl	8008590 <otg_fifo_read_to_buffer>
                            cnt, 8);
    break;
 800863e:	e052      	b.n	80086e6 <otg_rxfifo_handler+0x106>
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8008640:	9a05      	ldr	r2, [sp, #20]
 8008642:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8008646:	4013      	ands	r3, r2
 8008648:	091b      	lsrs	r3, r3, #4
 800864a:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800864c:	9b05      	ldr	r3, [sp, #20]
 800864e:	f003 030f 	and.w	r3, r3, #15
 8008652:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8008654:	9b01      	ldr	r3, [sp, #4]
 8008656:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008658:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 800865c:	9a01      	ldr	r2, [sp, #4]
 800865e:	9b03      	ldr	r3, [sp, #12]
 8008660:	3302      	adds	r3, #2
 8008662:	009b      	lsls	r3, r3, #2
 8008664:	4413      	add	r3, r2
 8008666:	685b      	ldr	r3, [r3, #4]
 8008668:	699b      	ldr	r3, [r3, #24]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800866a:	689a      	ldr	r2, [r3, #8]
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 800866c:	9801      	ldr	r0, [sp, #4]
 800866e:	9b03      	ldr	r3, [sp, #12]
 8008670:	3302      	adds	r3, #2
 8008672:	009b      	lsls	r3, r3, #2
 8008674:	4403      	add	r3, r0
 8008676:	685b      	ldr	r3, [r3, #4]
 8008678:	699b      	ldr	r3, [r3, #24]
 800867a:	6818      	ldr	r0, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 800867c:	9c01      	ldr	r4, [sp, #4]
 800867e:	9b03      	ldr	r3, [sp, #12]
 8008680:	3302      	adds	r3, #2
 8008682:	009b      	lsls	r3, r3, #2
 8008684:	4423      	add	r3, r4
 8008686:	685b      	ldr	r3, [r3, #4]
 8008688:	699b      	ldr	r3, [r3, #24]
 800868a:	685b      	ldr	r3, [r3, #4]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800868c:	1ac3      	subs	r3, r0, r3
 800868e:	4608      	mov	r0, r1
 8008690:	4611      	mov	r1, r2
 8008692:	9a04      	ldr	r2, [sp, #16]
 8008694:	f7ff ff7c 	bl	8008590 <otg_fifo_read_to_buffer>
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8008698:	9a01      	ldr	r2, [sp, #4]
 800869a:	9b03      	ldr	r3, [sp, #12]
 800869c:	3302      	adds	r3, #2
 800869e:	009b      	lsls	r3, r3, #2
 80086a0:	4413      	add	r3, r2
 80086a2:	685b      	ldr	r3, [r3, #4]
 80086a4:	699a      	ldr	r2, [r3, #24]
 80086a6:	9901      	ldr	r1, [sp, #4]
 80086a8:	9b03      	ldr	r3, [sp, #12]
 80086aa:	3302      	adds	r3, #2
 80086ac:	009b      	lsls	r3, r3, #2
 80086ae:	440b      	add	r3, r1
 80086b0:	685b      	ldr	r3, [r3, #4]
 80086b2:	699b      	ldr	r3, [r3, #24]
 80086b4:	6899      	ldr	r1, [r3, #8]
 80086b6:	9b04      	ldr	r3, [sp, #16]
 80086b8:	440b      	add	r3, r1
 80086ba:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80086bc:	9a01      	ldr	r2, [sp, #4]
 80086be:	9b03      	ldr	r3, [sp, #12]
 80086c0:	3302      	adds	r3, #2
 80086c2:	009b      	lsls	r3, r3, #2
 80086c4:	4413      	add	r3, r2
 80086c6:	685b      	ldr	r3, [r3, #4]
 80086c8:	699a      	ldr	r2, [r3, #24]
 80086ca:	9901      	ldr	r1, [sp, #4]
 80086cc:	9b03      	ldr	r3, [sp, #12]
 80086ce:	3302      	adds	r3, #2
 80086d0:	009b      	lsls	r3, r3, #2
 80086d2:	440b      	add	r3, r1
 80086d4:	685b      	ldr	r3, [r3, #4]
 80086d6:	699b      	ldr	r3, [r3, #24]
 80086d8:	6859      	ldr	r1, [r3, #4]
 80086da:	9b04      	ldr	r3, [sp, #16]
 80086dc:	440b      	add	r3, r1
 80086de:	6053      	str	r3, [r2, #4]
    break;
 80086e0:	bf00      	nop
 80086e2:	e000      	b.n	80086e6 <otg_rxfifo_handler+0x106>
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  case GRXSTSP_SETUP_COMP:
    break;
 80086e4:	bf00      	nop
  case GRXSTSP_OUT_GLOBAL_NAK:
  case GRXSTSP_OUT_COMP:
  default:
    ;
  }
}
 80086e6:	b006      	add	sp, #24
 80086e8:	bd10      	pop	{r4, pc}
 80086ea:	bf00      	nop
 80086ec:	f3af 8000 	nop.w

080086f0 <otg_txfifo_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 80086f0:	b500      	push	{lr}
 80086f2:	b085      	sub	sp, #20
 80086f4:	9001      	str	r0, [sp, #4]
 80086f6:	460b      	mov	r3, r1
 80086f8:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80086fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008700:	9a01      	ldr	r2, [sp, #4]
 8008702:	3302      	adds	r3, #2
 8008704:	009b      	lsls	r3, r3, #2
 8008706:	4413      	add	r3, r2
 8008708:	685b      	ldr	r3, [r3, #4]
 800870a:	695b      	ldr	r3, [r3, #20]
 800870c:	685a      	ldr	r2, [r3, #4]
 800870e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008712:	9901      	ldr	r1, [sp, #4]
 8008714:	3302      	adds	r3, #2
 8008716:	009b      	lsls	r3, r3, #2
 8008718:	440b      	add	r3, r1
 800871a:	685b      	ldr	r3, [r3, #4]
 800871c:	695b      	ldr	r3, [r3, #20]
 800871e:	681b      	ldr	r3, [r3, #0]
 8008720:	429a      	cmp	r2, r3
 8008722:	d301      	bcc.n	8008728 <otg_txfifo_handler+0x38>
      return true;
 8008724:	2301      	movs	r3, #1
 8008726:	e076      	b.n	8008816 <otg_txfifo_handler+0x126>

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8008728:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800872c:	9a01      	ldr	r2, [sp, #4]
 800872e:	3302      	adds	r3, #2
 8008730:	009b      	lsls	r3, r3, #2
 8008732:	4413      	add	r3, r2
 8008734:	685b      	ldr	r3, [r3, #4]
 8008736:	695b      	ldr	r3, [r3, #20]
 8008738:	681a      	ldr	r2, [r3, #0]
 800873a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800873e:	9901      	ldr	r1, [sp, #4]
 8008740:	3302      	adds	r3, #2
 8008742:	009b      	lsls	r3, r3, #2
 8008744:	440b      	add	r3, r1
 8008746:	685b      	ldr	r3, [r3, #4]
 8008748:	695b      	ldr	r3, [r3, #20]
 800874a:	685b      	ldr	r3, [r3, #4]
 800874c:	1ad3      	subs	r3, r2, r3
 800874e:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 8008750:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008754:	9a01      	ldr	r2, [sp, #4]
 8008756:	3302      	adds	r3, #2
 8008758:	009b      	lsls	r3, r3, #2
 800875a:	4413      	add	r3, r2
 800875c:	685b      	ldr	r3, [r3, #4]
 800875e:	8a1b      	ldrh	r3, [r3, #16]
 8008760:	461a      	mov	r2, r3
 8008762:	9b03      	ldr	r3, [sp, #12]
 8008764:	429a      	cmp	r2, r3
 8008766:	d208      	bcs.n	800877a <otg_txfifo_handler+0x8a>
      n = usbp->epc[ep]->in_maxsize;
 8008768:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800876c:	9a01      	ldr	r2, [sp, #4]
 800876e:	3302      	adds	r3, #2
 8008770:	009b      	lsls	r3, r3, #2
 8008772:	4413      	add	r3, r2
 8008774:	685b      	ldr	r3, [r3, #4]
 8008776:	8a1b      	ldrh	r3, [r3, #16]
 8008778:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800877a:	9b01      	ldr	r3, [sp, #4]
 800877c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800877e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008782:	015b      	lsls	r3, r3, #5
 8008784:	4413      	add	r3, r2
 8008786:	f603 1318 	addw	r3, r3, #2328	; 0x918
 800878a:	681b      	ldr	r3, [r3, #0]
 800878c:	b29b      	uxth	r3, r3
 800878e:	009a      	lsls	r2, r3, #2
 8008790:	9b03      	ldr	r3, [sp, #12]
 8008792:	429a      	cmp	r2, r3
 8008794:	d201      	bcs.n	800879a <otg_txfifo_handler+0xaa>
      return false;
 8008796:	2300      	movs	r3, #0
 8008798:	e03d      	b.n	8008816 <otg_txfifo_handler+0x126>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800879a:	9b01      	ldr	r3, [sp, #4]
 800879c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800879e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087a2:	3301      	adds	r3, #1
 80087a4:	031b      	lsls	r3, r3, #12
 80087a6:	441a      	add	r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 80087a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087ac:	9901      	ldr	r1, [sp, #4]
 80087ae:	3302      	adds	r3, #2
 80087b0:	009b      	lsls	r3, r3, #2
 80087b2:	440b      	add	r3, r1
 80087b4:	685b      	ldr	r3, [r3, #4]
 80087b6:	695b      	ldr	r3, [r3, #20]
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80087b8:	689b      	ldr	r3, [r3, #8]
 80087ba:	4610      	mov	r0, r2
 80087bc:	4619      	mov	r1, r3
 80087be:	9a03      	ldr	r2, [sp, #12]
 80087c0:	f7ff fece 	bl	8008560 <otg_fifo_write_from_buffer>
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 80087c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087c8:	9a01      	ldr	r2, [sp, #4]
 80087ca:	3302      	adds	r3, #2
 80087cc:	009b      	lsls	r3, r3, #2
 80087ce:	4413      	add	r3, r2
 80087d0:	685b      	ldr	r3, [r3, #4]
 80087d2:	695a      	ldr	r2, [r3, #20]
 80087d4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087d8:	9901      	ldr	r1, [sp, #4]
 80087da:	3302      	adds	r3, #2
 80087dc:	009b      	lsls	r3, r3, #2
 80087de:	440b      	add	r3, r1
 80087e0:	685b      	ldr	r3, [r3, #4]
 80087e2:	695b      	ldr	r3, [r3, #20]
 80087e4:	6899      	ldr	r1, [r3, #8]
 80087e6:	9b03      	ldr	r3, [sp, #12]
 80087e8:	440b      	add	r3, r1
 80087ea:	6093      	str	r3, [r2, #8]
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 80087ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087f0:	9a01      	ldr	r2, [sp, #4]
 80087f2:	3302      	adds	r3, #2
 80087f4:	009b      	lsls	r3, r3, #2
 80087f6:	4413      	add	r3, r2
 80087f8:	685b      	ldr	r3, [r3, #4]
 80087fa:	695a      	ldr	r2, [r3, #20]
 80087fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008800:	9901      	ldr	r1, [sp, #4]
 8008802:	3302      	adds	r3, #2
 8008804:	009b      	lsls	r3, r3, #2
 8008806:	440b      	add	r3, r1
 8008808:	685b      	ldr	r3, [r3, #4]
 800880a:	695b      	ldr	r3, [r3, #20]
 800880c:	6859      	ldr	r1, [r3, #4]
 800880e:	9b03      	ldr	r3, [sp, #12]
 8008810:	440b      	add	r3, r1
 8008812:	6053      	str	r3, [r2, #4]
  }
 8008814:	e772      	b.n	80086fc <otg_txfifo_handler+0xc>
}
 8008816:	4618      	mov	r0, r3
 8008818:	b005      	add	sp, #20
 800881a:	f85d fb04 	ldr.w	pc, [sp], #4
 800881e:	bf00      	nop

08008820 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8008820:	b500      	push	{lr}
 8008822:	b087      	sub	sp, #28
 8008824:	9001      	str	r0, [sp, #4]
 8008826:	460b      	mov	r3, r1
 8008828:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800882c:	9b01      	ldr	r3, [sp, #4]
 800882e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008830:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8008832:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008836:	9a05      	ldr	r2, [sp, #20]
 8008838:	015b      	lsls	r3, r3, #5
 800883a:	4413      	add	r3, r2
 800883c:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8008840:	681b      	ldr	r3, [r3, #0]
 8008842:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 8008844:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008848:	9a05      	ldr	r2, [sp, #20]
 800884a:	015b      	lsls	r3, r3, #5
 800884c:	4413      	add	r3, r2
 800884e:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8008852:	9a04      	ldr	r2, [sp, #16]
 8008854:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8008856:	9b04      	ldr	r3, [sp, #16]
 8008858:	f003 0301 	and.w	r3, r3, #1
 800885c:	2b00      	cmp	r3, #0
 800885e:	d051      	beq.n	8008904 <otg_epin_handler+0xe4>
 8008860:	9b05      	ldr	r3, [sp, #20]
 8008862:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8008866:	f003 0301 	and.w	r3, r3, #1
 800886a:	2b00      	cmp	r3, #0
 800886c:	d04a      	beq.n	8008904 <otg_epin_handler+0xe4>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800886e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008872:	9a01      	ldr	r2, [sp, #4]
 8008874:	3302      	adds	r3, #2
 8008876:	009b      	lsls	r3, r3, #2
 8008878:	4413      	add	r3, r2
 800887a:	685b      	ldr	r3, [r3, #4]
 800887c:	695b      	ldr	r3, [r3, #20]
 800887e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 8008880:	9b03      	ldr	r3, [sp, #12]
 8008882:	681a      	ldr	r2, [r3, #0]
 8008884:	9b03      	ldr	r3, [sp, #12]
 8008886:	68db      	ldr	r3, [r3, #12]
 8008888:	429a      	cmp	r2, r3
 800888a:	d214      	bcs.n	80088b6 <otg_epin_handler+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800888c:	9b03      	ldr	r3, [sp, #12]
 800888e:	68da      	ldr	r2, [r3, #12]
 8008890:	9b03      	ldr	r3, [sp, #12]
 8008892:	681b      	ldr	r3, [r3, #0]
 8008894:	1ad2      	subs	r2, r2, r3
 8008896:	9b03      	ldr	r3, [sp, #12]
 8008898:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 800889a:	9b03      	ldr	r3, [sp, #12]
 800889c:	2200      	movs	r2, #0
 800889e:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 80088a0:	f7ff fd5e 	bl	8008360 <osalSysLockFromISR>
      usb_lld_start_in(usbp, ep);
 80088a4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088a8:	9801      	ldr	r0, [sp, #4]
 80088aa:	4619      	mov	r1, r3
 80088ac:	f000 fec0 	bl	8009630 <usb_lld_start_in>
      osalSysUnlockFromISR();
 80088b0:	f7ff fd5e 	bl	8008370 <osalSysUnlockFromISR>
 80088b4:	e026      	b.n	8008904 <otg_epin_handler+0xe4>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 80088b6:	9b01      	ldr	r3, [sp, #4]
 80088b8:	891b      	ldrh	r3, [r3, #8]
 80088ba:	b29a      	uxth	r2, r3
 80088bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088c0:	2101      	movs	r1, #1
 80088c2:	fa01 f303 	lsl.w	r3, r1, r3
 80088c6:	b29b      	uxth	r3, r3
 80088c8:	43db      	mvns	r3, r3
 80088ca:	b29b      	uxth	r3, r3
 80088cc:	4013      	ands	r3, r2
 80088ce:	b29b      	uxth	r3, r3
 80088d0:	b29a      	uxth	r2, r3
 80088d2:	9b01      	ldr	r3, [sp, #4]
 80088d4:	811a      	strh	r2, [r3, #8]
 80088d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088da:	9a01      	ldr	r2, [sp, #4]
 80088dc:	3302      	adds	r3, #2
 80088de:	009b      	lsls	r3, r3, #2
 80088e0:	4413      	add	r3, r2
 80088e2:	685b      	ldr	r3, [r3, #4]
 80088e4:	689b      	ldr	r3, [r3, #8]
 80088e6:	2b00      	cmp	r3, #0
 80088e8:	d00c      	beq.n	8008904 <otg_epin_handler+0xe4>
 80088ea:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088ee:	9a01      	ldr	r2, [sp, #4]
 80088f0:	3302      	adds	r3, #2
 80088f2:	009b      	lsls	r3, r3, #2
 80088f4:	4413      	add	r3, r2
 80088f6:	685b      	ldr	r3, [r3, #4]
 80088f8:	689b      	ldr	r3, [r3, #8]
 80088fa:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80088fe:	9801      	ldr	r0, [sp, #4]
 8008900:	4611      	mov	r1, r2
 8008902:	4798      	blx	r3
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8008904:	9b04      	ldr	r3, [sp, #16]
 8008906:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800890a:	2b00      	cmp	r3, #0
 800890c:	d02b      	beq.n	8008966 <otg_epin_handler+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800890e:	9b05      	ldr	r3, [sp, #20]
 8008910:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008914:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008918:	2101      	movs	r1, #1
 800891a:	fa01 f303 	lsl.w	r3, r1, r3
 800891e:	4013      	ands	r3, r2
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8008920:	2b00      	cmp	r3, #0
 8008922:	d020      	beq.n	8008966 <otg_epin_handler+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
 8008924:	f7ff fd1c 	bl	8008360 <osalSysLockFromISR>
    usbp->txpending |= (1 << ep);
 8008928:	9b01      	ldr	r3, [sp, #4]
 800892a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800892c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008930:	2101      	movs	r1, #1
 8008932:	fa01 f303 	lsl.w	r3, r1, r3
 8008936:	431a      	orrs	r2, r3
 8008938:	9b01      	ldr	r3, [sp, #4]
 800893a:	679a      	str	r2, [r3, #120]	; 0x78
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800893c:	9b05      	ldr	r3, [sp, #20]
 800893e:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008942:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008946:	2101      	movs	r1, #1
 8008948:	fa01 f303 	lsl.w	r3, r1, r3
 800894c:	43db      	mvns	r3, r3
 800894e:	401a      	ands	r2, r3
 8008950:	9b05      	ldr	r3, [sp, #20]
 8008952:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8008956:	9b01      	ldr	r3, [sp, #4]
 8008958:	337c      	adds	r3, #124	; 0x7c
 800895a:	4618      	mov	r0, r3
 800895c:	2100      	movs	r1, #0
 800895e:	f7ff fd2f 	bl	80083c0 <osalThreadResumeI>
    osalSysUnlockFromISR();
 8008962:	f7ff fd05 	bl	8008370 <osalSysUnlockFromISR>
  }
}
 8008966:	b007      	add	sp, #28
 8008968:	f85d fb04 	ldr.w	pc, [sp], #4
 800896c:	f3af 8000 	nop.w

08008970 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8008970:	b500      	push	{lr}
 8008972:	b087      	sub	sp, #28
 8008974:	9001      	str	r0, [sp, #4]
 8008976:	460b      	mov	r3, r1
 8008978:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800897c:	9b01      	ldr	r3, [sp, #4]
 800897e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008980:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8008982:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008986:	9a05      	ldr	r2, [sp, #20]
 8008988:	015b      	lsls	r3, r3, #5
 800898a:	4413      	add	r3, r2
 800898c:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8008990:	681b      	ldr	r3, [r3, #0]
 8008992:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8008994:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008998:	9a05      	ldr	r2, [sp, #20]
 800899a:	015b      	lsls	r3, r3, #5
 800899c:	4413      	add	r3, r2
 800899e:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80089a2:	9a04      	ldr	r2, [sp, #16]
 80089a4:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 80089a6:	9b04      	ldr	r3, [sp, #16]
 80089a8:	f003 0308 	and.w	r3, r3, #8
 80089ac:	2b00      	cmp	r3, #0
 80089ae:	d013      	beq.n	80089d8 <otg_epout_handler+0x68>
 80089b0:	9b05      	ldr	r3, [sp, #20]
 80089b2:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80089b6:	f003 0308 	and.w	r3, r3, #8
 80089ba:	2b00      	cmp	r3, #0
 80089bc:	d00c      	beq.n	80089d8 <otg_epout_handler+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 80089be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80089c2:	9a01      	ldr	r2, [sp, #4]
 80089c4:	3302      	adds	r3, #2
 80089c6:	009b      	lsls	r3, r3, #2
 80089c8:	4413      	add	r3, r2
 80089ca:	685b      	ldr	r3, [r3, #4]
 80089cc:	685b      	ldr	r3, [r3, #4]
 80089ce:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80089d2:	9801      	ldr	r0, [sp, #4]
 80089d4:	4611      	mov	r1, r2
 80089d6:	4798      	blx	r3
  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 80089d8:	9b04      	ldr	r3, [sp, #16]
 80089da:	f003 0301 	and.w	r3, r3, #1
 80089de:	2b00      	cmp	r3, #0
 80089e0:	d06c      	beq.n	8008abc <otg_epout_handler+0x14c>
 80089e2:	9b05      	ldr	r3, [sp, #20]
 80089e4:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80089e8:	f003 0301 	and.w	r3, r3, #1
 80089ec:	2b00      	cmp	r3, #0
 80089ee:	d065      	beq.n	8008abc <otg_epout_handler+0x14c>
    USBOutEndpointState *osp;

    /* Receive transfer complete, checking if it is a SETUP transfer on EP0,
       that it must be ignored, the STUPM handler will take care of it.*/
    if ((ep == 0) && (usbp->ep0state == USB_EP0_WAITING_SETUP))
 80089f0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80089f4:	2b00      	cmp	r3, #0
 80089f6:	d105      	bne.n	8008a04 <otg_epout_handler+0x94>
 80089f8:	9b01      	ldr	r3, [sp, #4]
 80089fa:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 80089fe:	2b00      	cmp	r3, #0
 8008a00:	d100      	bne.n	8008a04 <otg_epout_handler+0x94>
      return;
 8008a02:	e05b      	b.n	8008abc <otg_epout_handler+0x14c>

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 8008a04:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a08:	9a01      	ldr	r2, [sp, #4]
 8008a0a:	3302      	adds	r3, #2
 8008a0c:	009b      	lsls	r3, r3, #2
 8008a0e:	4413      	add	r3, r2
 8008a10:	685b      	ldr	r3, [r3, #4]
 8008a12:	699b      	ldr	r3, [r3, #24]
 8008a14:	9303      	str	r3, [sp, #12]

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8008a16:	9b03      	ldr	r3, [sp, #12]
 8008a18:	685a      	ldr	r2, [r3, #4]
 8008a1a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a1e:	9901      	ldr	r1, [sp, #4]
 8008a20:	3302      	adds	r3, #2
 8008a22:	009b      	lsls	r3, r3, #2
 8008a24:	440b      	add	r3, r1
 8008a26:	685b      	ldr	r3, [r3, #4]
 8008a28:	8a5b      	ldrh	r3, [r3, #18]
 8008a2a:	fbb2 f1f3 	udiv	r1, r2, r3
 8008a2e:	fb03 f301 	mul.w	r3, r3, r1
 8008a32:	1ad3      	subs	r3, r2, r3
 8008a34:	2b00      	cmp	r3, #0
 8008a36:	d11a      	bne.n	8008a6e <otg_epout_handler+0xfe>
        (osp->rxsize < osp->totsize)) {
 8008a38:	9b03      	ldr	r3, [sp, #12]
 8008a3a:	681a      	ldr	r2, [r3, #0]
 8008a3c:	9b03      	ldr	r3, [sp, #12]
 8008a3e:	68db      	ldr	r3, [r3, #12]

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8008a40:	429a      	cmp	r2, r3
 8008a42:	d214      	bcs.n	8008a6e <otg_epout_handler+0xfe>
        (osp->rxsize < osp->totsize)) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8008a44:	9b03      	ldr	r3, [sp, #12]
 8008a46:	68da      	ldr	r2, [r3, #12]
 8008a48:	9b03      	ldr	r3, [sp, #12]
 8008a4a:	681b      	ldr	r3, [r3, #0]
 8008a4c:	1ad2      	subs	r2, r2, r3
 8008a4e:	9b03      	ldr	r3, [sp, #12]
 8008a50:	601a      	str	r2, [r3, #0]
      osp->rxcnt  = 0;
 8008a52:	9b03      	ldr	r3, [sp, #12]
 8008a54:	2200      	movs	r2, #0
 8008a56:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8008a58:	f7ff fc82 	bl	8008360 <osalSysLockFromISR>
      usb_lld_start_out(usbp, ep);
 8008a5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a60:	9801      	ldr	r0, [sp, #4]
 8008a62:	4619      	mov	r1, r3
 8008a64:	f000 fd44 	bl	80094f0 <usb_lld_start_out>
      osalSysUnlockFromISR();
 8008a68:	f7ff fc82 	bl	8008370 <osalSysUnlockFromISR>
 8008a6c:	e026      	b.n	8008abc <otg_epout_handler+0x14c>
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 8008a6e:	9b01      	ldr	r3, [sp, #4]
 8008a70:	895b      	ldrh	r3, [r3, #10]
 8008a72:	b29a      	uxth	r2, r3
 8008a74:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a78:	2101      	movs	r1, #1
 8008a7a:	fa01 f303 	lsl.w	r3, r1, r3
 8008a7e:	b29b      	uxth	r3, r3
 8008a80:	43db      	mvns	r3, r3
 8008a82:	b29b      	uxth	r3, r3
 8008a84:	4013      	ands	r3, r2
 8008a86:	b29b      	uxth	r3, r3
 8008a88:	b29a      	uxth	r2, r3
 8008a8a:	9b01      	ldr	r3, [sp, #4]
 8008a8c:	815a      	strh	r2, [r3, #10]
 8008a8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a92:	9a01      	ldr	r2, [sp, #4]
 8008a94:	3302      	adds	r3, #2
 8008a96:	009b      	lsls	r3, r3, #2
 8008a98:	4413      	add	r3, r2
 8008a9a:	685b      	ldr	r3, [r3, #4]
 8008a9c:	68db      	ldr	r3, [r3, #12]
 8008a9e:	2b00      	cmp	r3, #0
 8008aa0:	d00c      	beq.n	8008abc <otg_epout_handler+0x14c>
 8008aa2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008aa6:	9a01      	ldr	r2, [sp, #4]
 8008aa8:	3302      	adds	r3, #2
 8008aaa:	009b      	lsls	r3, r3, #2
 8008aac:	4413      	add	r3, r2
 8008aae:	685b      	ldr	r3, [r3, #4]
 8008ab0:	68db      	ldr	r3, [r3, #12]
 8008ab2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8008ab6:	9801      	ldr	r0, [sp, #4]
 8008ab8:	4611      	mov	r1, r2
 8008aba:	4798      	blx	r3
    }
  }
}
 8008abc:	b007      	add	sp, #28
 8008abe:	f85d fb04 	ldr.w	pc, [sp], #4
 8008ac2:	bf00      	nop
 8008ac4:	f3af 8000 	nop.w
 8008ac8:	f3af 8000 	nop.w
 8008acc:	f3af 8000 	nop.w

08008ad0 <otg_isoc_in_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 8008ad0:	b500      	push	{lr}
 8008ad2:	b085      	sub	sp, #20
 8008ad4:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8008ad6:	9b01      	ldr	r3, [sp, #4]
 8008ad8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008ada:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008adc:	2300      	movs	r3, #0
 8008ade:	f88d 300f 	strb.w	r3, [sp, #15]
 8008ae2:	e081      	b.n	8008be8 <otg_isoc_in_failed_handler+0x118>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8008ae4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008ae8:	9a02      	ldr	r2, [sp, #8]
 8008aea:	3348      	adds	r3, #72	; 0x48
 8008aec:	015b      	lsls	r3, r3, #5
 8008aee:	4413      	add	r3, r2
 8008af0:	681b      	ldr	r3, [r3, #0]
 8008af2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8008af6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008afa:	d170      	bne.n	8008bde <otg_isoc_in_failed_handler+0x10e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8008afc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b00:	9a02      	ldr	r2, [sp, #8]
 8008b02:	3348      	adds	r3, #72	; 0x48
 8008b04:	015b      	lsls	r3, r3, #5
 8008b06:	4413      	add	r3, r2
 8008b08:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8008b0a:	2b00      	cmp	r3, #0
 8008b0c:	da67      	bge.n	8008bde <otg_isoc_in_failed_handler+0x10e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8008b0e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b12:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008b16:	9902      	ldr	r1, [sp, #8]
 8008b18:	3248      	adds	r2, #72	; 0x48
 8008b1a:	0152      	lsls	r2, r2, #5
 8008b1c:	440a      	add	r2, r1
 8008b1e:	6812      	ldr	r2, [r2, #0]
 8008b20:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8008b24:	9902      	ldr	r1, [sp, #8]
 8008b26:	3348      	adds	r3, #72	; 0x48
 8008b28:	015b      	lsls	r3, r3, #5
 8008b2a:	440b      	add	r3, r1
 8008b2c:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8008b2e:	bf00      	nop
 8008b30:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b34:	9a02      	ldr	r2, [sp, #8]
 8008b36:	3348      	adds	r3, #72	; 0x48
 8008b38:	015b      	lsls	r3, r3, #5
 8008b3a:	4413      	add	r3, r2
 8008b3c:	681b      	ldr	r3, [r3, #0]
 8008b3e:	2b00      	cmp	r3, #0
 8008b40:	dbf6      	blt.n	8008b30 <otg_isoc_in_failed_handler+0x60>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 8008b42:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b46:	9801      	ldr	r0, [sp, #4]
 8008b48:	4619      	mov	r1, r3
 8008b4a:	f7ff fcc9 	bl	80084e0 <otg_txfifo_flush>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 8008b4e:	9b01      	ldr	r3, [sp, #4]
 8008b50:	891b      	ldrh	r3, [r3, #8]
 8008b52:	b29a      	uxth	r2, r3
 8008b54:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b58:	2101      	movs	r1, #1
 8008b5a:	fa01 f303 	lsl.w	r3, r1, r3
 8008b5e:	b29b      	uxth	r3, r3
 8008b60:	43db      	mvns	r3, r3
 8008b62:	b29b      	uxth	r3, r3
 8008b64:	4013      	ands	r3, r2
 8008b66:	b29b      	uxth	r3, r3
 8008b68:	b29a      	uxth	r2, r3
 8008b6a:	9b01      	ldr	r3, [sp, #4]
 8008b6c:	811a      	strh	r2, [r3, #8]
 8008b6e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b72:	9a01      	ldr	r2, [sp, #4]
 8008b74:	3302      	adds	r3, #2
 8008b76:	009b      	lsls	r3, r3, #2
 8008b78:	4413      	add	r3, r2
 8008b7a:	685b      	ldr	r3, [r3, #4]
 8008b7c:	689b      	ldr	r3, [r3, #8]
 8008b7e:	2b00      	cmp	r3, #0
 8008b80:	d00c      	beq.n	8008b9c <otg_isoc_in_failed_handler+0xcc>
 8008b82:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b86:	9a01      	ldr	r2, [sp, #4]
 8008b88:	3302      	adds	r3, #2
 8008b8a:	009b      	lsls	r3, r3, #2
 8008b8c:	4413      	add	r3, r2
 8008b8e:	685b      	ldr	r3, [r3, #4]
 8008b90:	689b      	ldr	r3, [r3, #8]
 8008b92:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008b96:	9801      	ldr	r0, [sp, #4]
 8008b98:	4611      	mov	r1, r2
 8008b9a:	4798      	blx	r3

      /* Pump out data for next frame */
      osalSysLockFromISR();
 8008b9c:	f7ff fbe0 	bl	8008360 <osalSysLockFromISR>
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8008ba0:	9b02      	ldr	r3, [sp, #8]
 8008ba2:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008ba6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008baa:	2101      	movs	r1, #1
 8008bac:	fa01 f303 	lsl.w	r3, r1, r3
 8008bb0:	43db      	mvns	r3, r3
 8008bb2:	401a      	ands	r2, r3
 8008bb4:	9b02      	ldr	r3, [sp, #8]
 8008bb6:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 8008bba:	9b01      	ldr	r3, [sp, #4]
 8008bbc:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8008bbe:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008bc2:	2101      	movs	r1, #1
 8008bc4:	fa01 f303 	lsl.w	r3, r1, r3
 8008bc8:	431a      	orrs	r2, r3
 8008bca:	9b01      	ldr	r3, [sp, #4]
 8008bcc:	679a      	str	r2, [r3, #120]	; 0x78
      osalThreadResumeI(&usbp->wait, MSG_OK);
 8008bce:	9b01      	ldr	r3, [sp, #4]
 8008bd0:	337c      	adds	r3, #124	; 0x7c
 8008bd2:	4618      	mov	r0, r3
 8008bd4:	2100      	movs	r1, #0
 8008bd6:	f7ff fbf3 	bl	80083c0 <osalThreadResumeI>
      osalSysUnlockFromISR();
 8008bda:	f7ff fbc9 	bl	8008370 <osalSysUnlockFromISR>
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008bde:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008be2:	3301      	adds	r3, #1
 8008be4:	f88d 300f 	strb.w	r3, [sp, #15]
 8008be8:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008bec:	9b01      	ldr	r3, [sp, #4]
 8008bee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008bf0:	689b      	ldr	r3, [r3, #8]
 8008bf2:	429a      	cmp	r2, r3
 8008bf4:	f67f af76 	bls.w	8008ae4 <otg_isoc_in_failed_handler+0x14>
      usbp->txpending |= (1 << ep);
      osalThreadResumeI(&usbp->wait, MSG_OK);
      osalSysUnlockFromISR();
    }
  }
}
 8008bf8:	b005      	add	sp, #20
 8008bfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8008bfe:	bf00      	nop

08008c00 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8008c00:	b500      	push	{lr}
 8008c02:	b085      	sub	sp, #20
 8008c04:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8008c06:	9b01      	ldr	r3, [sp, #4]
 8008c08:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008c0a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008c0c:	2300      	movs	r3, #0
 8008c0e:	f88d 300f 	strb.w	r3, [sp, #15]
 8008c12:	e040      	b.n	8008c96 <otg_isoc_out_failed_handler+0x96>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8008c14:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c18:	9a02      	ldr	r2, [sp, #8]
 8008c1a:	3358      	adds	r3, #88	; 0x58
 8008c1c:	015b      	lsls	r3, r3, #5
 8008c1e:	4413      	add	r3, r2
 8008c20:	681b      	ldr	r3, [r3, #0]
 8008c22:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8008c26:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008c2a:	d12f      	bne.n	8008c8c <otg_isoc_out_failed_handler+0x8c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8008c2c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c30:	9a02      	ldr	r2, [sp, #8]
 8008c32:	3358      	adds	r3, #88	; 0x58
 8008c34:	015b      	lsls	r3, r3, #5
 8008c36:	4413      	add	r3, r2
 8008c38:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8008c3a:	2b00      	cmp	r3, #0
 8008c3c:	da26      	bge.n	8008c8c <otg_isoc_out_failed_handler+0x8c>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8008c3e:	9b01      	ldr	r3, [sp, #4]
 8008c40:	895b      	ldrh	r3, [r3, #10]
 8008c42:	b29a      	uxth	r2, r3
 8008c44:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c48:	2101      	movs	r1, #1
 8008c4a:	fa01 f303 	lsl.w	r3, r1, r3
 8008c4e:	b29b      	uxth	r3, r3
 8008c50:	43db      	mvns	r3, r3
 8008c52:	b29b      	uxth	r3, r3
 8008c54:	4013      	ands	r3, r2
 8008c56:	b29b      	uxth	r3, r3
 8008c58:	b29a      	uxth	r2, r3
 8008c5a:	9b01      	ldr	r3, [sp, #4]
 8008c5c:	815a      	strh	r2, [r3, #10]
 8008c5e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c62:	9a01      	ldr	r2, [sp, #4]
 8008c64:	3302      	adds	r3, #2
 8008c66:	009b      	lsls	r3, r3, #2
 8008c68:	4413      	add	r3, r2
 8008c6a:	685b      	ldr	r3, [r3, #4]
 8008c6c:	68db      	ldr	r3, [r3, #12]
 8008c6e:	2b00      	cmp	r3, #0
 8008c70:	d00c      	beq.n	8008c8c <otg_isoc_out_failed_handler+0x8c>
 8008c72:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c76:	9a01      	ldr	r2, [sp, #4]
 8008c78:	3302      	adds	r3, #2
 8008c7a:	009b      	lsls	r3, r3, #2
 8008c7c:	4413      	add	r3, r2
 8008c7e:	685b      	ldr	r3, [r3, #4]
 8008c80:	68db      	ldr	r3, [r3, #12]
 8008c82:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008c86:	9801      	ldr	r0, [sp, #4]
 8008c88:	4611      	mov	r1, r2
 8008c8a:	4798      	blx	r3
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008c8c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c90:	3301      	adds	r3, #1
 8008c92:	f88d 300f 	strb.w	r3, [sp, #15]
 8008c96:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008c9a:	9b01      	ldr	r3, [sp, #4]
 8008c9c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008c9e:	689b      	ldr	r3, [r3, #8]
 8008ca0:	429a      	cmp	r2, r3
 8008ca2:	d9b7      	bls.n	8008c14 <otg_isoc_out_failed_handler+0x14>
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
    }
  }
}
 8008ca4:	b005      	add	sp, #20
 8008ca6:	f85d fb04 	ldr.w	pc, [sp], #4
 8008caa:	bf00      	nop
 8008cac:	f3af 8000 	nop.w

08008cb0 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8008cb0:	b500      	push	{lr}
 8008cb2:	b087      	sub	sp, #28
 8008cb4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008cb6:	9b01      	ldr	r3, [sp, #4]
 8008cb8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008cba:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8008cbc:	9b05      	ldr	r3, [sp, #20]
 8008cbe:	695b      	ldr	r3, [r3, #20]
 8008cc0:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 8008cc2:	9b05      	ldr	r3, [sp, #20]
 8008cc4:	699b      	ldr	r3, [r3, #24]
 8008cc6:	9a04      	ldr	r2, [sp, #16]
 8008cc8:	4013      	ands	r3, r2
 8008cca:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 8008ccc:	9b05      	ldr	r3, [sp, #20]
 8008cce:	9a04      	ldr	r2, [sp, #16]
 8008cd0:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8008cd2:	9b04      	ldr	r3, [sp, #16]
 8008cd4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8008cd8:	2b00      	cmp	r3, #0
 8008cda:	d006      	beq.n	8008cea <usb_lld_serve_interrupt+0x3a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8008cdc:	9b01      	ldr	r3, [sp, #4]
 8008cde:	2200      	movs	r2, #0
 8008ce0:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default reset action.*/
    _usb_reset(usbp);
 8008ce2:	9801      	ldr	r0, [sp, #4]
 8008ce4:	f7fe f91c 	bl	8006f20 <_usb_reset>

    /* Preventing execution of more handlers, the core has been reset.*/
    return;
 8008ce8:	e0ce      	b.n	8008e88 <usb_lld_serve_interrupt+0x1d8>
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 8008cea:	9b04      	ldr	r3, [sp, #16]
 8008cec:	2b00      	cmp	r3, #0
 8008cee:	da19      	bge.n	8008d24 <usb_lld_serve_interrupt+0x74>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8008cf0:	9b05      	ldr	r3, [sp, #20]
 8008cf2:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8008cf6:	f003 0303 	and.w	r3, r3, #3
 8008cfa:	2b00      	cmp	r3, #0
 8008cfc:	d007      	beq.n	8008d0e <usb_lld_serve_interrupt+0x5e>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8008cfe:	9b05      	ldr	r3, [sp, #20]
 8008d00:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8008d04:	f023 0203 	bic.w	r2, r3, #3
 8008d08:	9b05      	ldr	r3, [sp, #20]
 8008d0a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 8008d0e:	9b05      	ldr	r3, [sp, #20]
 8008d10:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8008d14:	f043 0201 	orr.w	r2, r3, #1
 8008d18:	9b05      	ldr	r3, [sp, #20]
 8008d1a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 8008d1e:	9801      	ldr	r0, [sp, #4]
 8008d20:	f7fe f95e 	bl	8006fe0 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8008d24:	9b04      	ldr	r3, [sp, #16]
 8008d26:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8008d2a:	2b00      	cmp	r3, #0
 8008d2c:	d005      	beq.n	8008d3a <usb_lld_serve_interrupt+0x8a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8008d2e:	9b01      	ldr	r3, [sp, #4]
 8008d30:	2200      	movs	r2, #0
 8008d32:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default suspend action.*/
    _usb_suspend(usbp);
 8008d34:	9801      	ldr	r0, [sp, #4]
 8008d36:	f7fe f933 	bl	8006fa0 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8008d3a:	9b04      	ldr	r3, [sp, #16]
 8008d3c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8008d40:	2b00      	cmp	r3, #0
 8008d42:	d017      	beq.n	8008d74 <usb_lld_serve_interrupt+0xc4>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8008d44:	9b05      	ldr	r3, [sp, #20]
 8008d46:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8008d4a:	f003 0306 	and.w	r3, r3, #6
 8008d4e:	2b00      	cmp	r3, #0
 8008d50:	d108      	bne.n	8008d64 <usb_lld_serve_interrupt+0xb4>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8008d52:	9b05      	ldr	r3, [sp, #20]
 8008d54:	68db      	ldr	r3, [r3, #12]
 8008d56:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8008d5a:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 8008d5e:	9b05      	ldr	r3, [sp, #20]
 8008d60:	60da      	str	r2, [r3, #12]
 8008d62:	e007      	b.n	8008d74 <usb_lld_serve_interrupt+0xc4>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8008d64:	9b05      	ldr	r3, [sp, #20]
 8008d66:	68db      	ldr	r3, [r3, #12]
 8008d68:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8008d6c:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 8008d70:	9b05      	ldr	r3, [sp, #20]
 8008d72:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8008d74:	9b04      	ldr	r3, [sp, #16]
 8008d76:	f003 0308 	and.w	r3, r3, #8
 8008d7a:	2b00      	cmp	r3, #0
 8008d7c:	d009      	beq.n	8008d92 <usb_lld_serve_interrupt+0xe2>
    _usb_isr_invoke_sof_cb(usbp);
 8008d7e:	9b01      	ldr	r3, [sp, #4]
 8008d80:	685b      	ldr	r3, [r3, #4]
 8008d82:	68db      	ldr	r3, [r3, #12]
 8008d84:	2b00      	cmp	r3, #0
 8008d86:	d004      	beq.n	8008d92 <usb_lld_serve_interrupt+0xe2>
 8008d88:	9b01      	ldr	r3, [sp, #4]
 8008d8a:	685b      	ldr	r3, [r3, #4]
 8008d8c:	68db      	ldr	r3, [r3, #12]
 8008d8e:	9801      	ldr	r0, [sp, #4]
 8008d90:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8008d92:	9b04      	ldr	r3, [sp, #16]
 8008d94:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8008d98:	2b00      	cmp	r3, #0
 8008d9a:	d002      	beq.n	8008da2 <usb_lld_serve_interrupt+0xf2>
    otg_isoc_in_failed_handler(usbp);
 8008d9c:	9801      	ldr	r0, [sp, #4]
 8008d9e:	f7ff fe97 	bl	8008ad0 <otg_isoc_in_failed_handler>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8008da2:	9b04      	ldr	r3, [sp, #16]
 8008da4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8008da8:	2b00      	cmp	r3, #0
 8008daa:	d002      	beq.n	8008db2 <usb_lld_serve_interrupt+0x102>
    otg_isoc_out_failed_handler(usbp);
 8008dac:	9801      	ldr	r0, [sp, #4]
 8008dae:	f7ff ff27 	bl	8008c00 <otg_isoc_out_failed_handler>
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 8008db2:	9b04      	ldr	r3, [sp, #16]
 8008db4:	f003 0310 	and.w	r3, r3, #16
 8008db8:	2b00      	cmp	r3, #0
 8008dba:	d00f      	beq.n	8008ddc <usb_lld_serve_interrupt+0x12c>
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
 8008dbc:	f7ff fad0 	bl	8008360 <osalSysLockFromISR>
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8008dc0:	9b05      	ldr	r3, [sp, #20]
 8008dc2:	699b      	ldr	r3, [r3, #24]
 8008dc4:	f023 0210 	bic.w	r2, r3, #16
 8008dc8:	9b05      	ldr	r3, [sp, #20]
 8008dca:	619a      	str	r2, [r3, #24]
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8008dcc:	9b01      	ldr	r3, [sp, #4]
 8008dce:	337c      	adds	r3, #124	; 0x7c
 8008dd0:	4618      	mov	r0, r3
 8008dd2:	2100      	movs	r1, #0
 8008dd4:	f7ff faf4 	bl	80083c0 <osalThreadResumeI>
    osalSysUnlockFromISR();
 8008dd8:	f7ff faca 	bl	8008370 <osalSysUnlockFromISR>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8008ddc:	9b05      	ldr	r3, [sp, #20]
 8008dde:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 8008de2:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_IEPINT) {
 8008de4:	9b04      	ldr	r3, [sp, #16]
 8008de6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008dea:	2b00      	cmp	r3, #0
 8008dec:	d023      	beq.n	8008e36 <usb_lld_serve_interrupt+0x186>
    if (src & (1 << 0))
 8008dee:	9b03      	ldr	r3, [sp, #12]
 8008df0:	f003 0301 	and.w	r3, r3, #1
 8008df4:	2b00      	cmp	r3, #0
 8008df6:	d003      	beq.n	8008e00 <usb_lld_serve_interrupt+0x150>
      otg_epin_handler(usbp, 0);
 8008df8:	9801      	ldr	r0, [sp, #4]
 8008dfa:	2100      	movs	r1, #0
 8008dfc:	f7ff fd10 	bl	8008820 <otg_epin_handler>
    if (src & (1 << 1))
 8008e00:	9b03      	ldr	r3, [sp, #12]
 8008e02:	f003 0302 	and.w	r3, r3, #2
 8008e06:	2b00      	cmp	r3, #0
 8008e08:	d003      	beq.n	8008e12 <usb_lld_serve_interrupt+0x162>
      otg_epin_handler(usbp, 1);
 8008e0a:	9801      	ldr	r0, [sp, #4]
 8008e0c:	2101      	movs	r1, #1
 8008e0e:	f7ff fd07 	bl	8008820 <otg_epin_handler>
    if (src & (1 << 2))
 8008e12:	9b03      	ldr	r3, [sp, #12]
 8008e14:	f003 0304 	and.w	r3, r3, #4
 8008e18:	2b00      	cmp	r3, #0
 8008e1a:	d003      	beq.n	8008e24 <usb_lld_serve_interrupt+0x174>
      otg_epin_handler(usbp, 2);
 8008e1c:	9801      	ldr	r0, [sp, #4]
 8008e1e:	2102      	movs	r1, #2
 8008e20:	f7ff fcfe 	bl	8008820 <otg_epin_handler>
    if (src & (1 << 3))
 8008e24:	9b03      	ldr	r3, [sp, #12]
 8008e26:	f003 0308 	and.w	r3, r3, #8
 8008e2a:	2b00      	cmp	r3, #0
 8008e2c:	d003      	beq.n	8008e36 <usb_lld_serve_interrupt+0x186>
      otg_epin_handler(usbp, 3);
 8008e2e:	9801      	ldr	r0, [sp, #4]
 8008e30:	2103      	movs	r1, #3
 8008e32:	f7ff fcf5 	bl	8008820 <otg_epin_handler>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 8008e36:	9b04      	ldr	r3, [sp, #16]
 8008e38:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8008e3c:	2b00      	cmp	r3, #0
 8008e3e:	d023      	beq.n	8008e88 <usb_lld_serve_interrupt+0x1d8>
    if (src & (1 << 16))
 8008e40:	9b03      	ldr	r3, [sp, #12]
 8008e42:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8008e46:	2b00      	cmp	r3, #0
 8008e48:	d003      	beq.n	8008e52 <usb_lld_serve_interrupt+0x1a2>
      otg_epout_handler(usbp, 0);
 8008e4a:	9801      	ldr	r0, [sp, #4]
 8008e4c:	2100      	movs	r1, #0
 8008e4e:	f7ff fd8f 	bl	8008970 <otg_epout_handler>
    if (src & (1 << 17))
 8008e52:	9b03      	ldr	r3, [sp, #12]
 8008e54:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008e58:	2b00      	cmp	r3, #0
 8008e5a:	d003      	beq.n	8008e64 <usb_lld_serve_interrupt+0x1b4>
      otg_epout_handler(usbp, 1);
 8008e5c:	9801      	ldr	r0, [sp, #4]
 8008e5e:	2101      	movs	r1, #1
 8008e60:	f7ff fd86 	bl	8008970 <otg_epout_handler>
    if (src & (1 << 18))
 8008e64:	9b03      	ldr	r3, [sp, #12]
 8008e66:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008e6a:	2b00      	cmp	r3, #0
 8008e6c:	d003      	beq.n	8008e76 <usb_lld_serve_interrupt+0x1c6>
      otg_epout_handler(usbp, 2);
 8008e6e:	9801      	ldr	r0, [sp, #4]
 8008e70:	2102      	movs	r1, #2
 8008e72:	f7ff fd7d 	bl	8008970 <otg_epout_handler>
    if (src & (1 << 19))
 8008e76:	9b03      	ldr	r3, [sp, #12]
 8008e78:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8008e7c:	2b00      	cmp	r3, #0
 8008e7e:	d003      	beq.n	8008e88 <usb_lld_serve_interrupt+0x1d8>
      otg_epout_handler(usbp, 3);
 8008e80:	9801      	ldr	r0, [sp, #4]
 8008e82:	2103      	movs	r1, #3
 8008e84:	f7ff fd74 	bl	8008970 <otg_epout_handler>
      otg_epout_handler(usbp, 4);
    if (src & (1 << 21))
      otg_epout_handler(usbp, 5);
#endif
  }
}
 8008e88:	b007      	add	sp, #28
 8008e8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8008e8e:	bf00      	nop

08008e90 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8008e90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);
 8008e92:	4803      	ldr	r0, [pc, #12]	; (8008ea0 <Vector14C+0x10>)
 8008e94:	f7ff ff0c 	bl	8008cb0 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8008e98:	f7fa fe5a 	bl	8003b50 <_port_irq_epilogue>
}
 8008e9c:	bd08      	pop	{r3, pc}
 8008e9e:	bf00      	nop
 8008ea0:	20003b68 	.word	0x20003b68
 8008ea4:	f3af 8000 	nop.w
 8008ea8:	f3af 8000 	nop.w
 8008eac:	f3af 8000 	nop.w

08008eb0 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8008eb0:	b508      	push	{r3, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8008eb2:	4809      	ldr	r0, [pc, #36]	; (8008ed8 <usb_lld_init+0x28>)
 8008eb4:	f7fd fec4 	bl	8006c40 <usbObjectInit>
  USBD1.wait      = NULL;
 8008eb8:	4b07      	ldr	r3, [pc, #28]	; (8008ed8 <usb_lld_init+0x28>)
 8008eba:	2200      	movs	r2, #0
 8008ebc:	67da      	str	r2, [r3, #124]	; 0x7c
  USBD1.otg       = OTG_FS;
 8008ebe:	4b06      	ldr	r3, [pc, #24]	; (8008ed8 <usb_lld_init+0x28>)
 8008ec0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8008ec4:	66da      	str	r2, [r3, #108]	; 0x6c
  USBD1.otgparams = &fsparams;
 8008ec6:	4b04      	ldr	r3, [pc, #16]	; (8008ed8 <usb_lld_init+0x28>)
 8008ec8:	4a04      	ldr	r2, [pc, #16]	; (8008edc <usb_lld_init+0x2c>)
 8008eca:	671a      	str	r2, [r3, #112]	; 0x70

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8008ecc:	4b02      	ldr	r3, [pc, #8]	; (8008ed8 <usb_lld_init+0x28>)
 8008ece:	2200      	movs	r2, #0
 8008ed0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                    CH_DBG_STACK_FILL_VALUE);
  }
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif
}
 8008ed4:	bd08      	pop	{r3, pc}
 8008ed6:	bf00      	nop
 8008ed8:	20003b68 	.word	0x20003b68
 8008edc:	0801ac04 	.word	0x0801ac04

08008ee0 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8008ee0:	b500      	push	{lr}
 8008ee2:	b087      	sub	sp, #28
 8008ee4:	9003      	str	r0, [sp, #12]
  stm32_otg_t *otgp = usbp->otg;
 8008ee6:	9b03      	ldr	r3, [sp, #12]
 8008ee8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008eea:	9305      	str	r3, [sp, #20]

  if (usbp->state == USB_STOP) {
 8008eec:	9b03      	ldr	r3, [sp, #12]
 8008eee:	781b      	ldrb	r3, [r3, #0]
 8008ef0:	2b01      	cmp	r3, #1
 8008ef2:	d172      	bne.n	8008fda <usb_lld_start+0xfa>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8008ef4:	9a03      	ldr	r2, [sp, #12]
 8008ef6:	4b3a      	ldr	r3, [pc, #232]	; (8008fe0 <usb_lld_start+0x100>)
 8008ef8:	429a      	cmp	r2, r3
 8008efa:	d119      	bne.n	8008f30 <usb_lld_start+0x50>
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(false);
 8008efc:	4b39      	ldr	r3, [pc, #228]	; (8008fe4 <usb_lld_start+0x104>)
 8008efe:	4a39      	ldr	r2, [pc, #228]	; (8008fe4 <usb_lld_start+0x104>)
 8008f00:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8008f02:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008f06:	64da      	str	r2, [r3, #76]	; 0x4c
      rccResetOTG_FS();
 8008f08:	4b36      	ldr	r3, [pc, #216]	; (8008fe4 <usb_lld_start+0x104>)
 8008f0a:	4a36      	ldr	r2, [pc, #216]	; (8008fe4 <usb_lld_start+0x104>)
 8008f0c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8008f0e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008f12:	62da      	str	r2, [r3, #44]	; 0x2c
 8008f14:	4b33      	ldr	r3, [pc, #204]	; (8008fe4 <usb_lld_start+0x104>)
 8008f16:	2200      	movs	r2, #0
 8008f18:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8008f1a:	2043      	movs	r0, #67	; 0x43
 8008f1c:	210e      	movs	r1, #14
 8008f1e:	f7fe fa07 	bl	8007330 <nvicEnableVector>

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8008f22:	9b05      	ldr	r3, [sp, #20]
 8008f24:	4a30      	ldr	r2, [pc, #192]	; (8008fe8 <usb_lld_start+0x108>)
 8008f26:	60da      	str	r2, [r3, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8008f28:	9b05      	ldr	r3, [sp, #20]
 8008f2a:	4a30      	ldr	r2, [pc, #192]	; (8008fec <usb_lld_start+0x10c>)
 8008f2c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
    }
#endif

    /* Clearing mask of TXFIFOs to be filled.*/
    usbp->txpending = 0;
 8008f30:	9b03      	ldr	r3, [sp, #12]
 8008f32:	2200      	movs	r2, #0
 8008f34:	679a      	str	r2, [r3, #120]	; 0x78

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8008f36:	9b05      	ldr	r3, [sp, #20]
 8008f38:	2200      	movs	r2, #0
 8008f3a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8008f3e:	9b05      	ldr	r3, [sp, #20]
 8008f40:	22c0      	movs	r2, #192	; 0xc0
 8008f42:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8008f44:	9b05      	ldr	r3, [sp, #20]
 8008f46:	f44f 1204 	mov.w	r2, #2162688	; 0x210000
 8008f4a:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8008f4c:	9803      	ldr	r0, [sp, #12]
 8008f4e:	f7ff fa47 	bl	80083e0 <otg_core_reset>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8008f52:	9b05      	ldr	r3, [sp, #20]
 8008f54:	2200      	movs	r2, #0
 8008f56:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8008f58:	9803      	ldr	r0, [sp, #12]
 8008f5a:	f7ff fa61 	bl	8008420 <otg_disable_ep>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8008f5e:	9b05      	ldr	r3, [sp, #20]
 8008f60:	2200      	movs	r2, #0
 8008f62:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8008f66:	9b05      	ldr	r3, [sp, #20]
 8008f68:	2200      	movs	r2, #0
 8008f6a:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8008f6e:	9b05      	ldr	r3, [sp, #20]
 8008f70:	2200      	movs	r2, #0
 8008f72:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8008f76:	9b03      	ldr	r3, [sp, #12]
 8008f78:	685b      	ldr	r3, [r3, #4]
 8008f7a:	68db      	ldr	r3, [r3, #12]
 8008f7c:	2b00      	cmp	r3, #0
 8008f7e:	d103      	bne.n	8008f88 <usb_lld_start+0xa8>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8008f80:	9b05      	ldr	r3, [sp, #20]
 8008f82:	4a1b      	ldr	r2, [pc, #108]	; (8008ff0 <usb_lld_start+0x110>)
 8008f84:	619a      	str	r2, [r3, #24]
 8008f86:	e002      	b.n	8008f8e <usb_lld_start+0xae>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8008f88:	9b05      	ldr	r3, [sp, #20]
 8008f8a:	4a1a      	ldr	r2, [pc, #104]	; (8008ff4 <usb_lld_start+0x114>)
 8008f8c:	619a      	str	r2, [r3, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8008f8e:	9b05      	ldr	r3, [sp, #20]
 8008f90:	f04f 32ff 	mov.w	r2, #4294967295
 8008f94:	615a      	str	r2, [r3, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8008f96:	9b03      	ldr	r3, [sp, #12]
 8008f98:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008f9c:	2b00      	cmp	r3, #0
 8008f9e:	d116      	bne.n	8008fce <usb_lld_start+0xee>
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8008fa0:	9b03      	ldr	r3, [sp, #12]
 8008fa2:	3388      	adds	r3, #136	; 0x88
 8008fa4:	9a03      	ldr	r2, [sp, #12]
 8008fa6:	9200      	str	r2, [sp, #0]
 8008fa8:	4618      	mov	r0, r3
 8008faa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008fae:	2202      	movs	r2, #2
 8008fb0:	4b11      	ldr	r3, [pc, #68]	; (8008ff8 <usb_lld_start+0x118>)
 8008fb2:	f7f8 f8ed 	bl	8001190 <chThdCreateI>
 8008fb6:	4602      	mov	r2, r0
 8008fb8:	9b03      	ldr	r3, [sp, #12]
 8008fba:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
 8008fbe:	9b03      	ldr	r3, [sp, #12]
 8008fc0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008fc4:	4618      	mov	r0, r3
 8008fc6:	f7ff f99b 	bl	8008300 <chThdStartI>
      chSchRescheduleS();
 8008fca:	f7f7 fed9 	bl	8000d80 <chSchRescheduleS>
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8008fce:	9b05      	ldr	r3, [sp, #20]
 8008fd0:	689b      	ldr	r3, [r3, #8]
 8008fd2:	f043 0201 	orr.w	r2, r3, #1
 8008fd6:	9b05      	ldr	r3, [sp, #20]
 8008fd8:	609a      	str	r2, [r3, #8]
  }
}
 8008fda:	b007      	add	sp, #28
 8008fdc:	f85d fb04 	ldr.w	pc, [sp], #4
 8008fe0:	20003b68 	.word	0x20003b68
 8008fe4:	40021000 	.word	0x40021000
 8008fe8:	40001440 	.word	0x40001440
 8008fec:	02200003 	.word	0x02200003
 8008ff0:	c0303c00 	.word	0xc0303c00
 8008ff4:	c0303c08 	.word	0xc0303c08
 8008ff8:	08009891 	.word	0x08009891
 8008ffc:	f3af 8000 	nop.w

08009000 <usb_lld_stop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_stop(USBDriver *usbp) {
 8009000:	b500      	push	{lr}
 8009002:	b085      	sub	sp, #20
 8009004:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8009006:	9b01      	ldr	r3, [sp, #4]
 8009008:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800900a:	9303      	str	r3, [sp, #12]

  /* If in ready state then disables the USB clock.*/
  if (usbp->state != USB_STOP) {
 800900c:	9b01      	ldr	r3, [sp, #4]
 800900e:	781b      	ldrb	r3, [r3, #0]
 8009010:	2b01      	cmp	r3, #1
 8009012:	d01c      	beq.n	800904e <usb_lld_stop+0x4e>

    /* Disabling all endpoints in case the driver has been stopped while
       active.*/
    otg_disable_ep(usbp);
 8009014:	9801      	ldr	r0, [sp, #4]
 8009016:	f7ff fa03 	bl	8008420 <otg_disable_ep>

    usbp->txpending = 0;
 800901a:	9b01      	ldr	r3, [sp, #4]
 800901c:	2200      	movs	r2, #0
 800901e:	679a      	str	r2, [r3, #120]	; 0x78

    otgp->DAINTMSK   = 0;
 8009020:	9b03      	ldr	r3, [sp, #12]
 8009022:	2200      	movs	r2, #0
 8009024:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    otgp->GAHBCFG    = 0;
 8009028:	9b03      	ldr	r3, [sp, #12]
 800902a:	2200      	movs	r2, #0
 800902c:	609a      	str	r2, [r3, #8]
    otgp->GCCFG      = 0;
 800902e:	9b03      	ldr	r3, [sp, #12]
 8009030:	2200      	movs	r2, #0
 8009032:	639a      	str	r2, [r3, #56]	; 0x38

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8009034:	9a01      	ldr	r2, [sp, #4]
 8009036:	4b07      	ldr	r3, [pc, #28]	; (8009054 <usb_lld_stop+0x54>)
 8009038:	429a      	cmp	r2, r3
 800903a:	d108      	bne.n	800904e <usb_lld_stop+0x4e>
      nvicDisableVector(STM32_OTG1_NUMBER);
 800903c:	2043      	movs	r0, #67	; 0x43
 800903e:	f7fe f99f 	bl	8007380 <nvicDisableVector>
      rccDisableOTG_FS(false);
 8009042:	4b05      	ldr	r3, [pc, #20]	; (8009058 <usb_lld_stop+0x58>)
 8009044:	4a04      	ldr	r2, [pc, #16]	; (8009058 <usb_lld_stop+0x58>)
 8009046:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8009048:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800904c:	64da      	str	r2, [r3, #76]	; 0x4c
      rccDisableOTG_HSULPI(true)
#endif
    }
#endif
  }
}
 800904e:	b005      	add	sp, #20
 8009050:	f85d fb04 	ldr.w	pc, [sp], #4
 8009054:	20003b68 	.word	0x20003b68
 8009058:	40021000 	.word	0x40021000
 800905c:	f3af 8000 	nop.w

08009060 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8009060:	b510      	push	{r4, lr}
 8009062:	b084      	sub	sp, #16
 8009064:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8009066:	9b01      	ldr	r3, [sp, #4]
 8009068:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800906a:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 800906c:	9801      	ldr	r0, [sp, #4]
 800906e:	2100      	movs	r1, #0
 8009070:	f7ff fa36 	bl	80084e0 <otg_txfifo_flush>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8009074:	9b02      	ldr	r3, [sp, #8]
 8009076:	2200      	movs	r2, #0
 8009078:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800907c:	9b02      	ldr	r3, [sp, #8]
 800907e:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8009082:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8009086:	2300      	movs	r3, #0
 8009088:	9303      	str	r3, [sp, #12]
 800908a:	e024      	b.n	80090d6 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800908c:	9a02      	ldr	r2, [sp, #8]
 800908e:	9b03      	ldr	r3, [sp, #12]
 8009090:	3348      	adds	r3, #72	; 0x48
 8009092:	015b      	lsls	r3, r3, #5
 8009094:	4413      	add	r3, r2
 8009096:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800909a:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 800909c:	9a02      	ldr	r2, [sp, #8]
 800909e:	9b03      	ldr	r3, [sp, #12]
 80090a0:	3358      	adds	r3, #88	; 0x58
 80090a2:	015b      	lsls	r3, r3, #5
 80090a4:	4413      	add	r3, r2
 80090a6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80090aa:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80090ac:	9a02      	ldr	r2, [sp, #8]
 80090ae:	9b03      	ldr	r3, [sp, #12]
 80090b0:	015b      	lsls	r3, r3, #5
 80090b2:	4413      	add	r3, r2
 80090b4:	f603 1308 	addw	r3, r3, #2312	; 0x908
 80090b8:	f04f 32ff 	mov.w	r2, #4294967295
 80090bc:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80090be:	9a02      	ldr	r2, [sp, #8]
 80090c0:	9b03      	ldr	r3, [sp, #12]
 80090c2:	015b      	lsls	r3, r3, #5
 80090c4:	4413      	add	r3, r2
 80090c6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80090ca:	f04f 32ff 	mov.w	r2, #4294967295
 80090ce:	601a      	str	r2, [r3, #0]
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80090d0:	9b03      	ldr	r3, [sp, #12]
 80090d2:	3301      	adds	r3, #1
 80090d4:	9303      	str	r3, [sp, #12]
 80090d6:	9b01      	ldr	r3, [sp, #4]
 80090d8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80090da:	689a      	ldr	r2, [r3, #8]
 80090dc:	9b03      	ldr	r3, [sp, #12]
 80090de:	429a      	cmp	r2, r3
 80090e0:	d2d4      	bcs.n	800908c <usb_lld_reset+0x2c>
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 80090e2:	9801      	ldr	r0, [sp, #4]
 80090e4:	f7ff fa1c 	bl	8008520 <otg_ram_reset>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80090e8:	9b01      	ldr	r3, [sp, #4]
 80090ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80090ec:	681a      	ldr	r2, [r3, #0]
 80090ee:	9b02      	ldr	r3, [sp, #8]
 80090f0:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 80090f2:	9801      	ldr	r0, [sp, #4]
 80090f4:	f7ff f9dc 	bl	80084b0 <otg_rxfifo_flush>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80090f8:	9b02      	ldr	r3, [sp, #8]
 80090fa:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 80090fe:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8009102:	9b02      	ldr	r3, [sp, #8]
 8009104:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8009108:	9b02      	ldr	r3, [sp, #8]
 800910a:	699b      	ldr	r3, [r3, #24]
 800910c:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8009110:	f043 0310 	orr.w	r3, r3, #16
 8009114:	9a02      	ldr	r2, [sp, #8]
 8009116:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8009118:	9b02      	ldr	r3, [sp, #8]
 800911a:	2209      	movs	r2, #9
 800911c:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8009120:	9b02      	ldr	r3, [sp, #8]
 8009122:	2209      	movs	r2, #9
 8009124:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8009128:	9b01      	ldr	r3, [sp, #4]
 800912a:	4a16      	ldr	r2, [pc, #88]	; (8009184 <usb_lld_reset+0x124>)
 800912c:	60da      	str	r2, [r3, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 800912e:	9b02      	ldr	r3, [sp, #8]
 8009130:	2200      	movs	r2, #0
 8009132:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 8009136:	2340      	movs	r3, #64	; 0x40
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8009138:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800913c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009140:	9a02      	ldr	r2, [sp, #8]
 8009142:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8009146:	9b02      	ldr	r3, [sp, #8]
 8009148:	2200      	movs	r2, #0
 800914a:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 800914e:	2340      	movs	r3, #64	; 0x40
 8009150:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8009154:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8009158:	9a02      	ldr	r2, [sp, #8]
 800915a:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800915e:	2340      	movs	r3, #64	; 0x40
 8009160:	089b      	lsrs	r3, r3, #2
 8009162:	b29b      	uxth	r3, r3
 8009164:	041b      	lsls	r3, r3, #16
 8009166:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 8009168:	2340      	movs	r3, #64	; 0x40
 800916a:	089b      	lsrs	r3, r3, #2
 800916c:	b29b      	uxth	r3, r3
 800916e:	9801      	ldr	r0, [sp, #4]
 8009170:	4619      	mov	r1, r3
 8009172:	f7ff f9e5 	bl	8008540 <otg_ram_alloc>
 8009176:	4603      	mov	r3, r0
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8009178:	ea44 0203 	orr.w	r2, r4, r3
 800917c:	9b02      	ldr	r3, [sp, #8]
 800917e:	629a      	str	r2, [r3, #40]	; 0x28
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
                                                  ep0config.in_maxsize / 4));
}
 8009180:	b004      	add	sp, #16
 8009182:	bd10      	pop	{r4, pc}
 8009184:	0801abe0 	.word	0x0801abe0
 8009188:	f3af 8000 	nop.w
 800918c:	f3af 8000 	nop.w

08009190 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 8009190:	b084      	sub	sp, #16
 8009192:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8009194:	9b01      	ldr	r3, [sp, #4]
 8009196:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009198:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800919a:	9b03      	ldr	r3, [sp, #12]
 800919c:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 80091a0:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 80091a4:	9b01      	ldr	r3, [sp, #4]
 80091a6:	f893 3066 	ldrb.w	r3, [r3, #102]	; 0x66
 80091aa:	011b      	lsls	r3, r3, #4
 80091ac:	431a      	orrs	r2, r3
 80091ae:	9b03      	ldr	r3, [sp, #12]
 80091b0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 80091b4:	b004      	add	sp, #16
 80091b6:	4770      	bx	lr
 80091b8:	f3af 8000 	nop.w
 80091bc:	f3af 8000 	nop.w

080091c0 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 80091c0:	b530      	push	{r4, r5, lr}
 80091c2:	b087      	sub	sp, #28
 80091c4:	9001      	str	r0, [sp, #4]
 80091c6:	460b      	mov	r3, r1
 80091c8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 80091cc:	9b01      	ldr	r3, [sp, #4]
 80091ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80091d0:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80091d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80091d6:	9a01      	ldr	r2, [sp, #4]
 80091d8:	3302      	adds	r3, #2
 80091da:	009b      	lsls	r3, r3, #2
 80091dc:	4413      	add	r3, r2
 80091de:	685b      	ldr	r3, [r3, #4]
 80091e0:	681b      	ldr	r3, [r3, #0]
 80091e2:	f003 0303 	and.w	r3, r3, #3
 80091e6:	2b03      	cmp	r3, #3
 80091e8:	f200 8108 	bhi.w	80093fc <usb_lld_init_endpoint+0x23c>
 80091ec:	a201      	add	r2, pc, #4	; (adr r2, 80091f4 <usb_lld_init_endpoint+0x34>)
 80091ee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80091f2:	bf00      	nop
 80091f4:	08009205 	.word	0x08009205
 80091f8:	0800920b 	.word	0x0800920b
 80091fc:	08009211 	.word	0x08009211
 8009200:	08009217 	.word	0x08009217
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8009204:	4b7f      	ldr	r3, [pc, #508]	; (8009404 <usb_lld_init_endpoint+0x244>)
 8009206:	9305      	str	r3, [sp, #20]
    break;
 8009208:	e008      	b.n	800921c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 800920a:	4b7f      	ldr	r3, [pc, #508]	; (8009408 <usb_lld_init_endpoint+0x248>)
 800920c:	9305      	str	r3, [sp, #20]
    break;
 800920e:	e005      	b.n	800921c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8009210:	4b7e      	ldr	r3, [pc, #504]	; (800940c <usb_lld_init_endpoint+0x24c>)
 8009212:	9305      	str	r3, [sp, #20]
    break;
 8009214:	e002      	b.n	800921c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8009216:	4b7e      	ldr	r3, [pc, #504]	; (8009410 <usb_lld_init_endpoint+0x250>)
 8009218:	9305      	str	r3, [sp, #20]
    break;
 800921a:	bf00      	nop
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 800921c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009220:	9a03      	ldr	r2, [sp, #12]
 8009222:	015b      	lsls	r3, r3, #5
 8009224:	4413      	add	r3, r2
 8009226:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800922a:	2200      	movs	r2, #0
 800922c:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 800922e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009232:	9a01      	ldr	r2, [sp, #4]
 8009234:	3302      	adds	r3, #2
 8009236:	009b      	lsls	r3, r3, #2
 8009238:	4413      	add	r3, r2
 800923a:	685b      	ldr	r3, [r3, #4]
 800923c:	699b      	ldr	r3, [r3, #24]
 800923e:	2b00      	cmp	r3, #0
 8009240:	d020      	beq.n	8009284 <usb_lld_init_endpoint+0xc4>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8009242:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8009246:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800924a:	9a01      	ldr	r2, [sp, #4]
 800924c:	3302      	adds	r3, #2
 800924e:	009b      	lsls	r3, r3, #2
 8009250:	4413      	add	r3, r2
 8009252:	685b      	ldr	r3, [r3, #4]
 8009254:	8a5b      	ldrh	r3, [r3, #18]
 8009256:	461a      	mov	r2, r3
 8009258:	9b05      	ldr	r3, [sp, #20]
 800925a:	431a      	orrs	r2, r3
 800925c:	9903      	ldr	r1, [sp, #12]
 800925e:	f100 0358 	add.w	r3, r0, #88	; 0x58
 8009262:	015b      	lsls	r3, r3, #5
 8009264:	440b      	add	r3, r1
 8009266:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8009268:	9b03      	ldr	r3, [sp, #12]
 800926a:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800926e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009272:	3310      	adds	r3, #16
 8009274:	2101      	movs	r1, #1
 8009276:	fa01 f303 	lsl.w	r3, r1, r3
 800927a:	431a      	orrs	r2, r3
 800927c:	9b03      	ldr	r3, [sp, #12]
 800927e:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8009282:	e01d      	b.n	80092c0 <usb_lld_init_endpoint+0x100>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8009284:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009288:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800928c:	9903      	ldr	r1, [sp, #12]
 800928e:	3258      	adds	r2, #88	; 0x58
 8009290:	0152      	lsls	r2, r2, #5
 8009292:	440a      	add	r2, r1
 8009294:	6812      	ldr	r2, [r2, #0]
 8009296:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800929a:	9903      	ldr	r1, [sp, #12]
 800929c:	3358      	adds	r3, #88	; 0x58
 800929e:	015b      	lsls	r3, r3, #5
 80092a0:	440b      	add	r3, r1
 80092a2:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 80092a4:	9b03      	ldr	r3, [sp, #12]
 80092a6:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80092aa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092ae:	3310      	adds	r3, #16
 80092b0:	2101      	movs	r1, #1
 80092b2:	fa01 f303 	lsl.w	r3, r1, r3
 80092b6:	43db      	mvns	r3, r3
 80092b8:	401a      	ands	r2, r3
 80092ba:	9b03      	ldr	r3, [sp, #12]
 80092bc:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 80092c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092c4:	9a03      	ldr	r2, [sp, #12]
 80092c6:	015b      	lsls	r3, r3, #5
 80092c8:	4413      	add	r3, r2
 80092ca:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80092ce:	2200      	movs	r2, #0
 80092d0:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 80092d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092d6:	9a01      	ldr	r2, [sp, #4]
 80092d8:	3302      	adds	r3, #2
 80092da:	009b      	lsls	r3, r3, #2
 80092dc:	4413      	add	r3, r2
 80092de:	685b      	ldr	r3, [r3, #4]
 80092e0:	695b      	ldr	r3, [r3, #20]
 80092e2:	2b00      	cmp	r3, #0
 80092e4:	d05d      	beq.n	80093a2 <usb_lld_init_endpoint+0x1e2>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80092e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092ea:	9a01      	ldr	r2, [sp, #4]
 80092ec:	3302      	adds	r3, #2
 80092ee:	009b      	lsls	r3, r3, #2
 80092f0:	4413      	add	r3, r2
 80092f2:	685b      	ldr	r3, [r3, #4]
 80092f4:	8a1b      	ldrh	r3, [r3, #16]
 80092f6:	089b      	lsrs	r3, r3, #2
 80092f8:	b29b      	uxth	r3, r3
 80092fa:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 80092fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009300:	9a01      	ldr	r2, [sp, #4]
 8009302:	3302      	adds	r3, #2
 8009304:	009b      	lsls	r3, r3, #2
 8009306:	4413      	add	r3, r2
 8009308:	685b      	ldr	r3, [r3, #4]
 800930a:	8b9b      	ldrh	r3, [r3, #28]
 800930c:	2b01      	cmp	r3, #1
 800930e:	d90c      	bls.n	800932a <usb_lld_init_endpoint+0x16a>
      fsize *= usbp->epc[ep]->in_multiplier;
 8009310:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009314:	9a01      	ldr	r2, [sp, #4]
 8009316:	3302      	adds	r3, #2
 8009318:	009b      	lsls	r3, r3, #2
 800931a:	4413      	add	r3, r2
 800931c:	685b      	ldr	r3, [r3, #4]
 800931e:	8b9b      	ldrh	r3, [r3, #28]
 8009320:	461a      	mov	r2, r3
 8009322:	9b04      	ldr	r3, [sp, #16]
 8009324:	fb02 f303 	mul.w	r3, r2, r3
 8009328:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800932a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800932e:	1e5c      	subs	r4, r3, #1
 8009330:	9b04      	ldr	r3, [sp, #16]
 8009332:	041d      	lsls	r5, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 8009334:	9801      	ldr	r0, [sp, #4]
 8009336:	9904      	ldr	r1, [sp, #16]
 8009338:	f7ff f902 	bl	8008540 <otg_ram_alloc>
 800933c:	4603      	mov	r3, r0
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800933e:	ea45 0203 	orr.w	r2, r5, r3
 8009342:	9903      	ldr	r1, [sp, #12]
 8009344:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8009348:	009b      	lsls	r3, r3, #2
 800934a:	440b      	add	r3, r1
 800934c:	605a      	str	r2, [r3, #4]
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);
 800934e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009352:	9801      	ldr	r0, [sp, #4]
 8009354:	4619      	mov	r1, r3
 8009356:	f7ff f8c3 	bl	80084e0 <otg_txfifo_flush>

    otgp->ie[ep].DIEPCTL = ctl |
 800935a:	f89d 0003 	ldrb.w	r0, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 800935e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009362:	059b      	lsls	r3, r3, #22
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8009364:	461a      	mov	r2, r3
 8009366:	9b05      	ldr	r3, [sp, #20]
 8009368:	431a      	orrs	r2, r3
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 800936a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800936e:	9901      	ldr	r1, [sp, #4]
 8009370:	3302      	adds	r3, #2
 8009372:	009b      	lsls	r3, r3, #2
 8009374:	440b      	add	r3, r1
 8009376:	685b      	ldr	r3, [r3, #4]
 8009378:	8a1b      	ldrh	r3, [r3, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 800937a:	431a      	orrs	r2, r3
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 800937c:	9903      	ldr	r1, [sp, #12]
 800937e:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8009382:	015b      	lsls	r3, r3, #5
 8009384:	440b      	add	r3, r1
 8009386:	601a      	str	r2, [r3, #0]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8009388:	9b03      	ldr	r3, [sp, #12]
 800938a:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800938e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009392:	2101      	movs	r1, #1
 8009394:	fa01 f303 	lsl.w	r3, r1, r3
 8009398:	431a      	orrs	r2, r3
 800939a:	9b03      	ldr	r3, [sp, #12]
 800939c:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 80093a0:	e02d      	b.n	80093fe <usb_lld_init_endpoint+0x23e>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80093a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093a6:	3b01      	subs	r3, #1
 80093a8:	9a03      	ldr	r2, [sp, #12]
 80093aa:	3340      	adds	r3, #64	; 0x40
 80093ac:	009b      	lsls	r3, r3, #2
 80093ae:	4413      	add	r3, r2
 80093b0:	4a18      	ldr	r2, [pc, #96]	; (8009414 <usb_lld_init_endpoint+0x254>)
 80093b2:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 80093b4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093b8:	9801      	ldr	r0, [sp, #4]
 80093ba:	4619      	mov	r1, r3
 80093bc:	f7ff f890 	bl	80084e0 <otg_txfifo_flush>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80093c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093c4:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80093c8:	9903      	ldr	r1, [sp, #12]
 80093ca:	3248      	adds	r2, #72	; 0x48
 80093cc:	0152      	lsls	r2, r2, #5
 80093ce:	440a      	add	r2, r1
 80093d0:	6812      	ldr	r2, [r2, #0]
 80093d2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80093d6:	9903      	ldr	r1, [sp, #12]
 80093d8:	3348      	adds	r3, #72	; 0x48
 80093da:	015b      	lsls	r3, r3, #5
 80093dc:	440b      	add	r3, r1
 80093de:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 80093e0:	9b03      	ldr	r3, [sp, #12]
 80093e2:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80093e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093ea:	2101      	movs	r1, #1
 80093ec:	fa01 f303 	lsl.w	r3, r1, r3
 80093f0:	43db      	mvns	r3, r3
 80093f2:	401a      	ands	r2, r3
 80093f4:	9b03      	ldr	r3, [sp, #12]
 80093f6:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 80093fa:	e000      	b.n	80093fe <usb_lld_init_endpoint+0x23e>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
    break;
  default:
    return;
 80093fc:	bf00      	nop
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  }
}
 80093fe:	b007      	add	sp, #28
 8009400:	bd30      	pop	{r4, r5, pc}
 8009402:	bf00      	nop
 8009404:	10008000 	.word	0x10008000
 8009408:	10048000 	.word	0x10048000
 800940c:	10088000 	.word	0x10088000
 8009410:	100c8000 	.word	0x100c8000
 8009414:	02000400 	.word	0x02000400
 8009418:	f3af 8000 	nop.w
 800941c:	f3af 8000 	nop.w

08009420 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 8009420:	b500      	push	{lr}
 8009422:	b083      	sub	sp, #12
 8009424:	9001      	str	r0, [sp, #4]

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8009426:	9801      	ldr	r0, [sp, #4]
 8009428:	f7ff f87a 	bl	8008520 <otg_ram_reset>

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 800942c:	9801      	ldr	r0, [sp, #4]
 800942e:	f7fe fff7 	bl	8008420 <otg_disable_ep>
}
 8009432:	b003      	add	sp, #12
 8009434:	f85d fb04 	ldr.w	pc, [sp], #4
 8009438:	f3af 8000 	nop.w
 800943c:	f3af 8000 	nop.w

08009440 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 8009440:	b084      	sub	sp, #16
 8009442:	9001      	str	r0, [sp, #4]
 8009444:	460b      	mov	r3, r1
 8009446:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800944a:	9b01      	ldr	r3, [sp, #4]
 800944c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800944e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009452:	3358      	adds	r3, #88	; 0x58
 8009454:	015b      	lsls	r3, r3, #5
 8009456:	4413      	add	r3, r2
 8009458:	681b      	ldr	r3, [r3, #0]
 800945a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 800945c:	9b03      	ldr	r3, [sp, #12]
 800945e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8009462:	2b00      	cmp	r3, #0
 8009464:	d101      	bne.n	800946a <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 8009466:	2300      	movs	r3, #0
 8009468:	e007      	b.n	800947a <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 800946a:	9b03      	ldr	r3, [sp, #12]
 800946c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8009470:	2b00      	cmp	r3, #0
 8009472:	d001      	beq.n	8009478 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 8009474:	2301      	movs	r3, #1
 8009476:	e000      	b.n	800947a <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 8009478:	2302      	movs	r3, #2
}
 800947a:	4618      	mov	r0, r3
 800947c:	b004      	add	sp, #16
 800947e:	4770      	bx	lr

08009480 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 8009480:	b084      	sub	sp, #16
 8009482:	9001      	str	r0, [sp, #4]
 8009484:	460b      	mov	r3, r1
 8009486:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 800948a:	9b01      	ldr	r3, [sp, #4]
 800948c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800948e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009492:	3348      	adds	r3, #72	; 0x48
 8009494:	015b      	lsls	r3, r3, #5
 8009496:	4413      	add	r3, r2
 8009498:	681b      	ldr	r3, [r3, #0]
 800949a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 800949c:	9b03      	ldr	r3, [sp, #12]
 800949e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80094a2:	2b00      	cmp	r3, #0
 80094a4:	d101      	bne.n	80094aa <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 80094a6:	2300      	movs	r3, #0
 80094a8:	e007      	b.n	80094ba <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 80094aa:	9b03      	ldr	r3, [sp, #12]
 80094ac:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80094b0:	2b00      	cmp	r3, #0
 80094b2:	d001      	beq.n	80094b8 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 80094b4:	2301      	movs	r3, #1
 80094b6:	e000      	b.n	80094ba <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 80094b8:	2302      	movs	r3, #2
}
 80094ba:	4618      	mov	r0, r3
 80094bc:	b004      	add	sp, #16
 80094be:	4770      	bx	lr

080094c0 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 80094c0:	b500      	push	{lr}
 80094c2:	b085      	sub	sp, #20
 80094c4:	9003      	str	r0, [sp, #12]
 80094c6:	460b      	mov	r3, r1
 80094c8:	9201      	str	r2, [sp, #4]
 80094ca:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 80094ce:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80094d2:	9a03      	ldr	r2, [sp, #12]
 80094d4:	3302      	adds	r3, #2
 80094d6:	009b      	lsls	r3, r3, #2
 80094d8:	4413      	add	r3, r2
 80094da:	685b      	ldr	r3, [r3, #4]
 80094dc:	6a1b      	ldr	r3, [r3, #32]
 80094de:	9801      	ldr	r0, [sp, #4]
 80094e0:	4619      	mov	r1, r3
 80094e2:	2208      	movs	r2, #8
 80094e4:	f00e f87c 	bl	80175e0 <memcpy>
}
 80094e8:	b005      	add	sp, #20
 80094ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80094ee:	bf00      	nop

080094f0 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 80094f0:	b086      	sub	sp, #24
 80094f2:	9001      	str	r0, [sp, #4]
 80094f4:	460b      	mov	r3, r1
 80094f6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80094fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80094fe:	9a01      	ldr	r2, [sp, #4]
 8009500:	3302      	adds	r3, #2
 8009502:	009b      	lsls	r3, r3, #2
 8009504:	4413      	add	r3, r2
 8009506:	685b      	ldr	r3, [r3, #4]
 8009508:	699b      	ldr	r3, [r3, #24]
 800950a:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800950c:	9b05      	ldr	r3, [sp, #20]
 800950e:	681a      	ldr	r2, [r3, #0]
 8009510:	9b05      	ldr	r3, [sp, #20]
 8009512:	60da      	str	r2, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8009514:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009518:	2b00      	cmp	r3, #0
 800951a:	d106      	bne.n	800952a <usb_lld_start_out+0x3a>
 800951c:	9b05      	ldr	r3, [sp, #20]
 800951e:	681b      	ldr	r3, [r3, #0]
 8009520:	2b40      	cmp	r3, #64	; 0x40
 8009522:	d902      	bls.n	800952a <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8009524:	9b05      	ldr	r3, [sp, #20]
 8009526:	2240      	movs	r2, #64	; 0x40
 8009528:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800952a:	9b05      	ldr	r3, [sp, #20]
 800952c:	681a      	ldr	r2, [r3, #0]
 800952e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009532:	9901      	ldr	r1, [sp, #4]
 8009534:	3302      	adds	r3, #2
 8009536:	009b      	lsls	r3, r3, #2
 8009538:	440b      	add	r3, r1
 800953a:	685b      	ldr	r3, [r3, #4]
 800953c:	8a5b      	ldrh	r3, [r3, #18]
 800953e:	4413      	add	r3, r2
 8009540:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 8009542:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009546:	9901      	ldr	r1, [sp, #4]
 8009548:	3302      	adds	r3, #2
 800954a:	009b      	lsls	r3, r3, #2
 800954c:	440b      	add	r3, r1
 800954e:	685b      	ldr	r3, [r3, #4]
 8009550:	8a5b      	ldrh	r3, [r3, #18]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8009552:	fbb2 f3f3 	udiv	r3, r2, r3
 8009556:	9304      	str	r3, [sp, #16]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8009558:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800955c:	9a01      	ldr	r2, [sp, #4]
 800955e:	3302      	adds	r3, #2
 8009560:	009b      	lsls	r3, r3, #2
 8009562:	4413      	add	r3, r2
 8009564:	685b      	ldr	r3, [r3, #4]
 8009566:	8a5b      	ldrh	r3, [r3, #18]
 8009568:	9a04      	ldr	r2, [sp, #16]
 800956a:	fb02 f303 	mul.w	r3, r2, r3
 800956e:	3303      	adds	r3, #3
 8009570:	f023 0303 	bic.w	r3, r3, #3
 8009574:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8009576:	9b01      	ldr	r3, [sp, #4]
 8009578:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800957a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800957e:	9a04      	ldr	r2, [sp, #16]
 8009580:	04d0      	lsls	r0, r2, #19
 8009582:	9a03      	ldr	r2, [sp, #12]
 8009584:	4302      	orrs	r2, r0
 8009586:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 800958a:	015b      	lsls	r3, r3, #5
 800958c:	440b      	add	r3, r1
 800958e:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8009592:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8009594:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009598:	9a01      	ldr	r2, [sp, #4]
 800959a:	3302      	adds	r3, #2
 800959c:	009b      	lsls	r3, r3, #2
 800959e:	4413      	add	r3, r2
 80095a0:	685b      	ldr	r3, [r3, #4]
 80095a2:	681b      	ldr	r3, [r3, #0]
 80095a4:	f003 0303 	and.w	r3, r3, #3
 80095a8:	2b01      	cmp	r3, #1
 80095aa:	d12c      	bne.n	8009606 <usb_lld_start_out+0x116>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80095ac:	9b01      	ldr	r3, [sp, #4]
 80095ae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80095b0:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 80095b4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80095b8:	2b00      	cmp	r3, #0
 80095ba:	d012      	beq.n	80095e2 <usb_lld_start_out+0xf2>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 80095bc:	9b01      	ldr	r3, [sp, #4]
 80095be:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80095c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80095c4:	9a01      	ldr	r2, [sp, #4]
 80095c6:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80095c8:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80095cc:	3258      	adds	r2, #88	; 0x58
 80095ce:	0152      	lsls	r2, r2, #5
 80095d0:	4402      	add	r2, r0
 80095d2:	6812      	ldr	r2, [r2, #0]
 80095d4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80095d8:	3358      	adds	r3, #88	; 0x58
 80095da:	015b      	lsls	r3, r3, #5
 80095dc:	440b      	add	r3, r1
 80095de:	601a      	str	r2, [r3, #0]
 80095e0:	e011      	b.n	8009606 <usb_lld_start_out+0x116>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 80095e2:	9b01      	ldr	r3, [sp, #4]
 80095e4:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80095e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80095ea:	9a01      	ldr	r2, [sp, #4]
 80095ec:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80095ee:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80095f2:	3258      	adds	r2, #88	; 0x58
 80095f4:	0152      	lsls	r2, r2, #5
 80095f6:	4402      	add	r2, r0
 80095f8:	6812      	ldr	r2, [r2, #0]
 80095fa:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80095fe:	3358      	adds	r3, #88	; 0x58
 8009600:	015b      	lsls	r3, r3, #5
 8009602:	440b      	add	r3, r1
 8009604:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8009606:	9b01      	ldr	r3, [sp, #4]
 8009608:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800960a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800960e:	9a01      	ldr	r2, [sp, #4]
 8009610:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009612:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009616:	3258      	adds	r2, #88	; 0x58
 8009618:	0152      	lsls	r2, r2, #5
 800961a:	4402      	add	r2, r0
 800961c:	6812      	ldr	r2, [r2, #0]
 800961e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8009622:	3358      	adds	r3, #88	; 0x58
 8009624:	015b      	lsls	r3, r3, #5
 8009626:	440b      	add	r3, r1
 8009628:	601a      	str	r2, [r3, #0]
}
 800962a:	b006      	add	sp, #24
 800962c:	4770      	bx	lr
 800962e:	bf00      	nop

08009630 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8009630:	b084      	sub	sp, #16
 8009632:	9001      	str	r0, [sp, #4]
 8009634:	460b      	mov	r3, r1
 8009636:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800963a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800963e:	9a01      	ldr	r2, [sp, #4]
 8009640:	3302      	adds	r3, #2
 8009642:	009b      	lsls	r3, r3, #2
 8009644:	4413      	add	r3, r2
 8009646:	685b      	ldr	r3, [r3, #4]
 8009648:	695b      	ldr	r3, [r3, #20]
 800964a:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800964c:	9b03      	ldr	r3, [sp, #12]
 800964e:	681a      	ldr	r2, [r3, #0]
 8009650:	9b03      	ldr	r3, [sp, #12]
 8009652:	60da      	str	r2, [r3, #12]
  if (isp->txsize == 0) {
 8009654:	9b03      	ldr	r3, [sp, #12]
 8009656:	681b      	ldr	r3, [r3, #0]
 8009658:	2b00      	cmp	r3, #0
 800965a:	d10b      	bne.n	8009674 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800965c:	9b01      	ldr	r3, [sp, #4]
 800965e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8009660:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009664:	015b      	lsls	r3, r3, #5
 8009666:	4413      	add	r3, r2
 8009668:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800966c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8009670:	601a      	str	r2, [r3, #0]
 8009672:	e031      	b.n	80096d8 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8009674:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009678:	2b00      	cmp	r3, #0
 800967a:	d106      	bne.n	800968a <usb_lld_start_in+0x5a>
 800967c:	9b03      	ldr	r3, [sp, #12]
 800967e:	681b      	ldr	r3, [r3, #0]
 8009680:	2b40      	cmp	r3, #64	; 0x40
 8009682:	d902      	bls.n	800968a <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 8009684:	9b03      	ldr	r3, [sp, #12]
 8009686:	2240      	movs	r2, #64	; 0x40
 8009688:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800968a:	9b03      	ldr	r3, [sp, #12]
 800968c:	681a      	ldr	r2, [r3, #0]
 800968e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009692:	9901      	ldr	r1, [sp, #4]
 8009694:	3302      	adds	r3, #2
 8009696:	009b      	lsls	r3, r3, #2
 8009698:	440b      	add	r3, r1
 800969a:	685b      	ldr	r3, [r3, #4]
 800969c:	8a1b      	ldrh	r3, [r3, #16]
 800969e:	4413      	add	r3, r2
 80096a0:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 80096a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80096a6:	9901      	ldr	r1, [sp, #4]
 80096a8:	3302      	adds	r3, #2
 80096aa:	009b      	lsls	r3, r3, #2
 80096ac:	440b      	add	r3, r1
 80096ae:	685b      	ldr	r3, [r3, #4]
 80096b0:	8a1b      	ldrh	r3, [r3, #16]
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80096b2:	fbb2 f3f3 	udiv	r3, r2, r3
 80096b6:	9302      	str	r3, [sp, #8]
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80096b8:	9b01      	ldr	r3, [sp, #4]
 80096ba:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80096bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80096c0:	9a02      	ldr	r2, [sp, #8]
 80096c2:	04d0      	lsls	r0, r2, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 80096c4:	9a03      	ldr	r2, [sp, #12]
 80096c6:	6812      	ldr	r2, [r2, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80096c8:	4302      	orrs	r2, r0
 80096ca:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80096ce:	015b      	lsls	r3, r3, #5
 80096d0:	440b      	add	r3, r1
 80096d2:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80096d6:	601a      	str	r2, [r3, #0]
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80096d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80096dc:	9a01      	ldr	r2, [sp, #4]
 80096de:	3302      	adds	r3, #2
 80096e0:	009b      	lsls	r3, r3, #2
 80096e2:	4413      	add	r3, r2
 80096e4:	685b      	ldr	r3, [r3, #4]
 80096e6:	681b      	ldr	r3, [r3, #0]
 80096e8:	f003 0303 	and.w	r3, r3, #3
 80096ec:	2b01      	cmp	r3, #1
 80096ee:	d12c      	bne.n	800974a <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80096f0:	9b01      	ldr	r3, [sp, #4]
 80096f2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80096f4:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 80096f8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80096fc:	2b00      	cmp	r3, #0
 80096fe:	d012      	beq.n	8009726 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8009700:	9b01      	ldr	r3, [sp, #4]
 8009702:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8009704:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009708:	9a01      	ldr	r2, [sp, #4]
 800970a:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 800970c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009710:	3248      	adds	r2, #72	; 0x48
 8009712:	0152      	lsls	r2, r2, #5
 8009714:	4402      	add	r2, r0
 8009716:	6812      	ldr	r2, [r2, #0]
 8009718:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800971c:	3348      	adds	r3, #72	; 0x48
 800971e:	015b      	lsls	r3, r3, #5
 8009720:	440b      	add	r3, r1
 8009722:	601a      	str	r2, [r3, #0]
 8009724:	e011      	b.n	800974a <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8009726:	9b01      	ldr	r3, [sp, #4]
 8009728:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800972a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800972e:	9a01      	ldr	r2, [sp, #4]
 8009730:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009732:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009736:	3248      	adds	r2, #72	; 0x48
 8009738:	0152      	lsls	r2, r2, #5
 800973a:	4402      	add	r2, r0
 800973c:	6812      	ldr	r2, [r2, #0]
 800973e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8009742:	3348      	adds	r3, #72	; 0x48
 8009744:	015b      	lsls	r3, r3, #5
 8009746:	440b      	add	r3, r1
 8009748:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800974a:	9b01      	ldr	r3, [sp, #4]
 800974c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800974e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009752:	9a01      	ldr	r2, [sp, #4]
 8009754:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009756:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800975a:	3248      	adds	r2, #72	; 0x48
 800975c:	0152      	lsls	r2, r2, #5
 800975e:	4402      	add	r2, r0
 8009760:	6812      	ldr	r2, [r2, #0]
 8009762:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8009766:	3348      	adds	r3, #72	; 0x48
 8009768:	015b      	lsls	r3, r3, #5
 800976a:	440b      	add	r3, r1
 800976c:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800976e:	9b01      	ldr	r3, [sp, #4]
 8009770:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009772:	9a01      	ldr	r2, [sp, #4]
 8009774:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 8009776:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 800977a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800977e:	2001      	movs	r0, #1
 8009780:	fa00 f202 	lsl.w	r2, r0, r2
 8009784:	430a      	orrs	r2, r1
 8009786:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 800978a:	b004      	add	sp, #16
 800978c:	4770      	bx	lr
 800978e:	bf00      	nop

08009790 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8009790:	b082      	sub	sp, #8
 8009792:	9001      	str	r0, [sp, #4]
 8009794:	460b      	mov	r3, r1
 8009796:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800979a:	9b01      	ldr	r3, [sp, #4]
 800979c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800979e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80097a2:	9a01      	ldr	r2, [sp, #4]
 80097a4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80097a6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80097aa:	3258      	adds	r2, #88	; 0x58
 80097ac:	0152      	lsls	r2, r2, #5
 80097ae:	4402      	add	r2, r0
 80097b0:	6812      	ldr	r2, [r2, #0]
 80097b2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80097b6:	3358      	adds	r3, #88	; 0x58
 80097b8:	015b      	lsls	r3, r3, #5
 80097ba:	440b      	add	r3, r1
 80097bc:	601a      	str	r2, [r3, #0]
}
 80097be:	b002      	add	sp, #8
 80097c0:	4770      	bx	lr
 80097c2:	bf00      	nop
 80097c4:	f3af 8000 	nop.w
 80097c8:	f3af 8000 	nop.w
 80097cc:	f3af 8000 	nop.w

080097d0 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 80097d0:	b082      	sub	sp, #8
 80097d2:	9001      	str	r0, [sp, #4]
 80097d4:	460b      	mov	r3, r1
 80097d6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80097da:	9b01      	ldr	r3, [sp, #4]
 80097dc:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80097de:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80097e2:	9a01      	ldr	r2, [sp, #4]
 80097e4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80097e6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80097ea:	3248      	adds	r2, #72	; 0x48
 80097ec:	0152      	lsls	r2, r2, #5
 80097ee:	4402      	add	r2, r0
 80097f0:	6812      	ldr	r2, [r2, #0]
 80097f2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80097f6:	3348      	adds	r3, #72	; 0x48
 80097f8:	015b      	lsls	r3, r3, #5
 80097fa:	440b      	add	r3, r1
 80097fc:	601a      	str	r2, [r3, #0]
}
 80097fe:	b002      	add	sp, #8
 8009800:	4770      	bx	lr
 8009802:	bf00      	nop
 8009804:	f3af 8000 	nop.w
 8009808:	f3af 8000 	nop.w
 800980c:	f3af 8000 	nop.w

08009810 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8009810:	b082      	sub	sp, #8
 8009812:	9001      	str	r0, [sp, #4]
 8009814:	460b      	mov	r3, r1
 8009816:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800981a:	9b01      	ldr	r3, [sp, #4]
 800981c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800981e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009822:	9a01      	ldr	r2, [sp, #4]
 8009824:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009826:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800982a:	3258      	adds	r2, #88	; 0x58
 800982c:	0152      	lsls	r2, r2, #5
 800982e:	4402      	add	r2, r0
 8009830:	6812      	ldr	r2, [r2, #0]
 8009832:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8009836:	3358      	adds	r3, #88	; 0x58
 8009838:	015b      	lsls	r3, r3, #5
 800983a:	440b      	add	r3, r1
 800983c:	601a      	str	r2, [r3, #0]
}
 800983e:	b002      	add	sp, #8
 8009840:	4770      	bx	lr
 8009842:	bf00      	nop
 8009844:	f3af 8000 	nop.w
 8009848:	f3af 8000 	nop.w
 800984c:	f3af 8000 	nop.w

08009850 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8009850:	b082      	sub	sp, #8
 8009852:	9001      	str	r0, [sp, #4]
 8009854:	460b      	mov	r3, r1
 8009856:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800985a:	9b01      	ldr	r3, [sp, #4]
 800985c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800985e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009862:	9a01      	ldr	r2, [sp, #4]
 8009864:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009866:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800986a:	3248      	adds	r2, #72	; 0x48
 800986c:	0152      	lsls	r2, r2, #5
 800986e:	4402      	add	r2, r0
 8009870:	6812      	ldr	r2, [r2, #0]
 8009872:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8009876:	3348      	adds	r3, #72	; 0x48
 8009878:	015b      	lsls	r3, r3, #5
 800987a:	440b      	add	r3, r1
 800987c:	601a      	str	r2, [r3, #0]
}
 800987e:	b002      	add	sp, #8
 8009880:	4770      	bx	lr
 8009882:	bf00      	nop
 8009884:	f3af 8000 	nop.w
 8009888:	f3af 8000 	nop.w
 800988c:	f3af 8000 	nop.w

08009890 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8009890:	b500      	push	{lr}
 8009892:	b089      	sub	sp, #36	; 0x24
 8009894:	9001      	str	r0, [sp, #4]
  USBDriver *usbp = (USBDriver *)p;
 8009896:	9b01      	ldr	r3, [sp, #4]
 8009898:	9306      	str	r3, [sp, #24]
  stm32_otg_t *otgp = usbp->otg;
 800989a:	9b06      	ldr	r3, [sp, #24]
 800989c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800989e:	9305      	str	r3, [sp, #20]

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 80098a0:	483d      	ldr	r0, [pc, #244]	; (8009998 <usb_lld_pump+0x108>)
 80098a2:	f7fe fd3d 	bl	8008320 <chRegSetThreadName>
#endif
  osalSysLock();
 80098a6:	f7fe fd4b 	bl	8008340 <osalSysLock>
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 80098aa:	9b06      	ldr	r3, [sp, #24]
 80098ac:	781b      	ldrb	r3, [r3, #0]
 80098ae:	2b01      	cmp	r3, #1
 80098b0:	d009      	beq.n	80098c6 <usb_lld_pump+0x36>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 80098b2:	9b06      	ldr	r3, [sp, #24]
 80098b4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 80098b6:	2b00      	cmp	r3, #0
 80098b8:	d110      	bne.n	80098dc <usb_lld_pump+0x4c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 80098ba:	9b05      	ldr	r3, [sp, #20]
 80098bc:	695b      	ldr	r3, [r3, #20]
 80098be:	f003 0310 	and.w	r3, r3, #16
 80098c2:	2b00      	cmp	r3, #0
 80098c4:	d10a      	bne.n	80098dc <usb_lld_pump+0x4c>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 80098c6:	9b05      	ldr	r3, [sp, #20]
 80098c8:	699b      	ldr	r3, [r3, #24]
 80098ca:	f043 0210 	orr.w	r2, r3, #16
 80098ce:	9b05      	ldr	r3, [sp, #20]
 80098d0:	619a      	str	r2, [r3, #24]
      osalThreadSuspendS(&usbp->wait);
 80098d2:	9b06      	ldr	r3, [sp, #24]
 80098d4:	337c      	adds	r3, #124	; 0x7c
 80098d6:	4618      	mov	r0, r3
 80098d8:	f7fe fd62 	bl	80083a0 <osalThreadSuspendS>
    }
    osalSysUnlock();
 80098dc:	f7fe fd38 	bl	8008350 <osalSysUnlock>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80098e0:	2300      	movs	r3, #0
 80098e2:	f88d 301f 	strb.w	r3, [sp, #31]
 80098e6:	e04d      	b.n	8009984 <usb_lld_pump+0xf4>

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80098e8:	e002      	b.n	80098f0 <usb_lld_pump+0x60>
        otg_rxfifo_handler(usbp);
 80098ea:	9806      	ldr	r0, [sp, #24]
 80098ec:	f7fe fe78 	bl	80085e0 <otg_rxfifo_handler>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80098f0:	9b05      	ldr	r3, [sp, #20]
 80098f2:	695b      	ldr	r3, [r3, #20]
 80098f4:	f003 0310 	and.w	r3, r3, #16
 80098f8:	2b00      	cmp	r3, #0
 80098fa:	d1f6      	bne.n	80098ea <usb_lld_pump+0x5a>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80098fc:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8009900:	2201      	movs	r2, #1
 8009902:	fa02 f303 	lsl.w	r3, r2, r3
 8009906:	9304      	str	r3, [sp, #16]
      if (usbp->txpending & epmask) {
 8009908:	9b06      	ldr	r3, [sp, #24]
 800990a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800990c:	9b04      	ldr	r3, [sp, #16]
 800990e:	4013      	ands	r3, r2
 8009910:	2b00      	cmp	r3, #0
 8009912:	d032      	beq.n	800997a <usb_lld_pump+0xea>
        bool done;

        osalSysLock();
 8009914:	f7fe fd14 	bl	8008340 <osalSysLock>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8009918:	9b05      	ldr	r3, [sp, #20]
 800991a:	689b      	ldr	r3, [r3, #8]
 800991c:	f023 0201 	bic.w	r2, r3, #1
 8009920:	9b05      	ldr	r3, [sp, #20]
 8009922:	609a      	str	r2, [r3, #8]
        usbp->txpending &= ~epmask;
 8009924:	9b06      	ldr	r3, [sp, #24]
 8009926:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8009928:	9b04      	ldr	r3, [sp, #16]
 800992a:	43db      	mvns	r3, r3
 800992c:	401a      	ands	r2, r3
 800992e:	9b06      	ldr	r3, [sp, #24]
 8009930:	679a      	str	r2, [r3, #120]	; 0x78
        osalSysUnlock();
 8009932:	f7fe fd0d 	bl	8008350 <osalSysUnlock>

        done = otg_txfifo_handler(usbp, ep);
 8009936:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800993a:	9806      	ldr	r0, [sp, #24]
 800993c:	4619      	mov	r1, r3
 800993e:	f7fe fed7 	bl	80086f0 <otg_txfifo_handler>
 8009942:	4603      	mov	r3, r0
 8009944:	f88d 300f 	strb.w	r3, [sp, #15]

        osalSysLock();
 8009948:	f7fe fcfa 	bl	8008340 <osalSysLock>
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800994c:	9b05      	ldr	r3, [sp, #20]
 800994e:	689b      	ldr	r3, [r3, #8]
 8009950:	f043 0201 	orr.w	r2, r3, #1
 8009954:	9b05      	ldr	r3, [sp, #20]
 8009956:	609a      	str	r2, [r3, #8]
        if (!done)
 8009958:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800995c:	f083 0301 	eor.w	r3, r3, #1
 8009960:	b2db      	uxtb	r3, r3
 8009962:	2b00      	cmp	r3, #0
 8009964:	d007      	beq.n	8009976 <usb_lld_pump+0xe6>
          otgp->DIEPEMPMSK |= epmask;
 8009966:	9b05      	ldr	r3, [sp, #20]
 8009968:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 800996c:	9b04      	ldr	r3, [sp, #16]
 800996e:	431a      	orrs	r2, r3
 8009970:	9b05      	ldr	r3, [sp, #20]
 8009972:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
        osalSysUnlock();
 8009976:	f7fe fceb 	bl	8008350 <osalSysUnlock>
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800997a:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800997e:	3301      	adds	r3, #1
 8009980:	f88d 301f 	strb.w	r3, [sp, #31]
 8009984:	f89d 201f 	ldrb.w	r2, [sp, #31]
 8009988:	9b06      	ldr	r3, [sp, #24]
 800998a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800998c:	689b      	ldr	r3, [r3, #8]
 800998e:	429a      	cmp	r2, r3
 8009990:	d9aa      	bls.n	80098e8 <usb_lld_pump+0x58>
        if (!done)
          otgp->DIEPEMPMSK |= epmask;
        osalSysUnlock();
      }
    }
    osalSysLock();
 8009992:	f7fe fcd5 	bl	8008340 <osalSysLock>
  }
 8009996:	e788      	b.n	80098aa <usb_lld_pump+0x1a>
 8009998:	0801ac10 	.word	0x0801ac10
 800999c:	f3af 8000 	nop.w

080099a0 <osalSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void) {
 80099a0:	b508      	push	{r3, lr}

  return chSysGetStatusAndLockX();
 80099a2:	f7f6 ff6d 	bl	8000880 <chSysGetStatusAndLockX>
 80099a6:	4603      	mov	r3, r0
}
 80099a8:	4618      	mov	r0, r3
 80099aa:	bd08      	pop	{r3, pc}
 80099ac:	f3af 8000 	nop.w

080099b0 <osalSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {
 80099b0:	b500      	push	{lr}
 80099b2:	b083      	sub	sp, #12
 80099b4:	9001      	str	r0, [sp, #4]

  chSysRestoreStatusX(sts);
 80099b6:	9801      	ldr	r0, [sp, #4]
 80099b8:	f7f6 ff82 	bl	80008c0 <chSysRestoreStatusX>
}
 80099bc:	b003      	add	sp, #12
 80099be:	f85d fb04 	ldr.w	pc, [sp], #4
 80099c2:	bf00      	nop
 80099c4:	f3af 8000 	nop.w
 80099c8:	f3af 8000 	nop.w
 80099cc:	f3af 8000 	nop.w

080099d0 <rtc_enter_init>:
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 80099d0:	4b08      	ldr	r3, [pc, #32]	; (80099f4 <rtc_enter_init+0x24>)
 80099d2:	681b      	ldr	r3, [r3, #0]
 80099d4:	4a07      	ldr	r2, [pc, #28]	; (80099f4 <rtc_enter_init+0x24>)
 80099d6:	6812      	ldr	r2, [r2, #0]
 80099d8:	68d2      	ldr	r2, [r2, #12]
 80099da:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80099de:	60da      	str	r2, [r3, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 80099e0:	bf00      	nop
 80099e2:	4b04      	ldr	r3, [pc, #16]	; (80099f4 <rtc_enter_init+0x24>)
 80099e4:	681b      	ldr	r3, [r3, #0]
 80099e6:	68db      	ldr	r3, [r3, #12]
 80099e8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80099ec:	2b00      	cmp	r3, #0
 80099ee:	d0f8      	beq.n	80099e2 <rtc_enter_init+0x12>
    ;
}
 80099f0:	4770      	bx	lr
 80099f2:	bf00      	nop
 80099f4:	20003d38 	.word	0x20003d38
 80099f8:	f3af 8000 	nop.w
 80099fc:	f3af 8000 	nop.w

08009a00 <rtc_exit_init>:
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 8009a00:	4b04      	ldr	r3, [pc, #16]	; (8009a14 <rtc_exit_init+0x14>)
 8009a02:	681b      	ldr	r3, [r3, #0]
 8009a04:	4a03      	ldr	r2, [pc, #12]	; (8009a14 <rtc_exit_init+0x14>)
 8009a06:	6812      	ldr	r2, [r2, #0]
 8009a08:	68d2      	ldr	r2, [r2, #12]
 8009a0a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8009a0e:	60da      	str	r2, [r3, #12]
}
 8009a10:	4770      	bx	lr
 8009a12:	bf00      	nop
 8009a14:	20003d38 	.word	0x20003d38
 8009a18:	f3af 8000 	nop.w
 8009a1c:	f3af 8000 	nop.w

08009a20 <rtc_decode_time>:
 * @param[in] tr        TR register value
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
 8009a20:	b084      	sub	sp, #16
 8009a22:	9001      	str	r0, [sp, #4]
 8009a24:	9100      	str	r1, [sp, #0]
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
 8009a26:	9b01      	ldr	r3, [sp, #4]
 8009a28:	0d1b      	lsrs	r3, r3, #20
 8009a2a:	f003 0303 	and.w	r3, r3, #3
 8009a2e:	4a21      	ldr	r2, [pc, #132]	; (8009ab4 <rtc_decode_time+0x94>)
 8009a30:	fb02 f303 	mul.w	r3, r2, r3
 8009a34:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
 8009a36:	9b01      	ldr	r3, [sp, #4]
 8009a38:	0c1b      	lsrs	r3, r3, #16
 8009a3a:	f003 030f 	and.w	r3, r3, #15
 8009a3e:	4a1e      	ldr	r2, [pc, #120]	; (8009ab8 <rtc_decode_time+0x98>)
 8009a40:	fb02 f303 	mul.w	r3, r2, r3
 8009a44:	9a03      	ldr	r2, [sp, #12]
 8009a46:	4413      	add	r3, r2
 8009a48:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
 8009a4a:	9b01      	ldr	r3, [sp, #4]
 8009a4c:	0b1b      	lsrs	r3, r3, #12
 8009a4e:	f003 0307 	and.w	r3, r3, #7
 8009a52:	4a1a      	ldr	r2, [pc, #104]	; (8009abc <rtc_decode_time+0x9c>)
 8009a54:	fb02 f303 	mul.w	r3, r2, r3
 8009a58:	9a03      	ldr	r2, [sp, #12]
 8009a5a:	4413      	add	r3, r2
 8009a5c:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
 8009a5e:	9b01      	ldr	r3, [sp, #4]
 8009a60:	0a1b      	lsrs	r3, r3, #8
 8009a62:	f003 030f 	and.w	r3, r3, #15
 8009a66:	f64e 2260 	movw	r2, #60000	; 0xea60
 8009a6a:	fb02 f303 	mul.w	r3, r2, r3
 8009a6e:	9a03      	ldr	r2, [sp, #12]
 8009a70:	4413      	add	r3, r2
 8009a72:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_ST_OFFSET) & 7)   * 10000;
 8009a74:	9b01      	ldr	r3, [sp, #4]
 8009a76:	091b      	lsrs	r3, r3, #4
 8009a78:	f003 0307 	and.w	r3, r3, #7
 8009a7c:	f242 7210 	movw	r2, #10000	; 0x2710
 8009a80:	fb02 f303 	mul.w	r3, r2, r3
 8009a84:	9a03      	ldr	r2, [sp, #12]
 8009a86:	4413      	add	r3, r2
 8009a88:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_SU_OFFSET) & 15)  * 1000;
 8009a8a:	9b01      	ldr	r3, [sp, #4]
 8009a8c:	f003 030f 	and.w	r3, r3, #15
 8009a90:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8009a94:	fb02 f303 	mul.w	r3, r2, r3
 8009a98:	9a03      	ldr	r2, [sp, #12]
 8009a9a:	4413      	add	r3, r2
 8009a9c:	9303      	str	r3, [sp, #12]
  timespec->millisecond = n;
 8009a9e:	9b03      	ldr	r3, [sp, #12]
 8009aa0:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 8009aa4:	9a00      	ldr	r2, [sp, #0]
 8009aa6:	6853      	ldr	r3, [r2, #4]
 8009aa8:	f361 031a 	bfi	r3, r1, #0, #27
 8009aac:	6053      	str	r3, [r2, #4]
}
 8009aae:	b004      	add	sp, #16
 8009ab0:	4770      	bx	lr
 8009ab2:	bf00      	nop
 8009ab4:	02255100 	.word	0x02255100
 8009ab8:	0036ee80 	.word	0x0036ee80
 8009abc:	000927c0 	.word	0x000927c0

08009ac0 <rtc_decode_date>:
 * @param[in] dr        DR register value
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {
 8009ac0:	b082      	sub	sp, #8
 8009ac2:	9001      	str	r0, [sp, #4]
 8009ac4:	9100      	str	r1, [sp, #0]

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 8009ac6:	9b01      	ldr	r3, [sp, #4]
 8009ac8:	0d1b      	lsrs	r3, r3, #20
 8009aca:	b2db      	uxtb	r3, r3
 8009acc:	f003 030f 	and.w	r3, r3, #15
 8009ad0:	b2db      	uxtb	r3, r3
 8009ad2:	461a      	mov	r2, r3
 8009ad4:	0092      	lsls	r2, r2, #2
 8009ad6:	4413      	add	r3, r2
 8009ad8:	005b      	lsls	r3, r3, #1
 8009ada:	b2da      	uxtb	r2, r3
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
 8009adc:	9b01      	ldr	r3, [sp, #4]
 8009ade:	0c1b      	lsrs	r3, r3, #16
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 8009ae0:	b2db      	uxtb	r3, r3
 8009ae2:	f003 030f 	and.w	r3, r3, #15
 8009ae6:	b2db      	uxtb	r3, r3
 8009ae8:	4413      	add	r3, r2
 8009aea:	b2d9      	uxtb	r1, r3
 8009aec:	9a00      	ldr	r2, [sp, #0]
 8009aee:	7813      	ldrb	r3, [r2, #0]
 8009af0:	f361 0307 	bfi	r3, r1, #0, #8
 8009af4:	7013      	strb	r3, [r2, #0]
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8009af6:	9b01      	ldr	r3, [sp, #4]
 8009af8:	0b1b      	lsrs	r3, r3, #12
 8009afa:	b2db      	uxtb	r3, r3
 8009afc:	f003 0301 	and.w	r3, r3, #1
 8009b00:	b2db      	uxtb	r3, r3
 8009b02:	461a      	mov	r2, r3
 8009b04:	0092      	lsls	r2, r2, #2
 8009b06:	4413      	add	r3, r2
 8009b08:	005b      	lsls	r3, r3, #1
 8009b0a:	b2da      	uxtb	r2, r3
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
 8009b0c:	9b01      	ldr	r3, [sp, #4]
 8009b0e:	0a1b      	lsrs	r3, r3, #8
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8009b10:	b2db      	uxtb	r3, r3
 8009b12:	f003 030f 	and.w	r3, r3, #15
 8009b16:	b2db      	uxtb	r3, r3
 8009b18:	4413      	add	r3, r2
 8009b1a:	b2db      	uxtb	r3, r3
 8009b1c:	f003 030f 	and.w	r3, r3, #15
 8009b20:	b2d9      	uxtb	r1, r3
 8009b22:	9a00      	ldr	r2, [sp, #0]
 8009b24:	7853      	ldrb	r3, [r2, #1]
 8009b26:	f361 0303 	bfi	r3, r1, #0, #4
 8009b2a:	7053      	strb	r3, [r2, #1]
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 8009b2c:	9b01      	ldr	r3, [sp, #4]
 8009b2e:	091b      	lsrs	r3, r3, #4
 8009b30:	b2db      	uxtb	r3, r3
 8009b32:	f003 0303 	and.w	r3, r3, #3
 8009b36:	b2db      	uxtb	r3, r3
 8009b38:	461a      	mov	r2, r3
 8009b3a:	0092      	lsls	r2, r2, #2
 8009b3c:	4413      	add	r3, r2
 8009b3e:	005b      	lsls	r3, r3, #1
 8009b40:	b2da      	uxtb	r2, r3
 8009b42:	9b01      	ldr	r3, [sp, #4]
 8009b44:	b2db      	uxtb	r3, r3
 8009b46:	f003 030f 	and.w	r3, r3, #15
 8009b4a:	b2db      	uxtb	r3, r3
 8009b4c:	4413      	add	r3, r2
 8009b4e:	b2db      	uxtb	r3, r3
 8009b50:	f003 031f 	and.w	r3, r3, #31
 8009b54:	b2d9      	uxtb	r1, r3
 8009b56:	9a00      	ldr	r2, [sp, #0]
 8009b58:	7893      	ldrb	r3, [r2, #2]
 8009b5a:	f361 0304 	bfi	r3, r1, #0, #5
 8009b5e:	7093      	strb	r3, [r2, #2]
                     ((dr >> RTC_DR_DU_OFFSET) & 15);
  timespec->dayofweek = (dr >> RTC_DR_WDU_OFFSET) & 7;
 8009b60:	9b01      	ldr	r3, [sp, #4]
 8009b62:	0b5b      	lsrs	r3, r3, #13
 8009b64:	b2db      	uxtb	r3, r3
 8009b66:	f003 0307 	and.w	r3, r3, #7
 8009b6a:	b2d9      	uxtb	r1, r3
 8009b6c:	9a00      	ldr	r2, [sp, #0]
 8009b6e:	7853      	ldrb	r3, [r2, #1]
 8009b70:	f361 1347 	bfi	r3, r1, #5, #3
 8009b74:	7053      	strb	r3, [r2, #1]
}
 8009b76:	b002      	add	sp, #8
 8009b78:	4770      	bx	lr
 8009b7a:	bf00      	nop
 8009b7c:	f3af 8000 	nop.w

08009b80 <rtc_encode_time>:
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 * @return              the TR register encoding.
 *
 * @notapi
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
 8009b80:	b084      	sub	sp, #16
 8009b82:	9001      	str	r0, [sp, #4]
  uint32_t n, tr = 0;
 8009b84:	2300      	movs	r3, #0
 8009b86:	9303      	str	r3, [sp, #12]

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 8009b88:	9b01      	ldr	r3, [sp, #4]
 8009b8a:	685b      	ldr	r3, [r3, #4]
 8009b8c:	f3c3 031a 	ubfx	r3, r3, #0, #27
 8009b90:	4a39      	ldr	r2, [pc, #228]	; (8009c78 <rtc_encode_time+0xf8>)
 8009b92:	fb82 1203 	smull	r1, r2, r2, r3
 8009b96:	1192      	asrs	r2, r2, #6
 8009b98:	17db      	asrs	r3, r3, #31
 8009b9a:	1ad3      	subs	r3, r2, r3
 8009b9c:	9302      	str	r3, [sp, #8]

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
 8009b9e:	9902      	ldr	r1, [sp, #8]
 8009ba0:	4b36      	ldr	r3, [pc, #216]	; (8009c7c <rtc_encode_time+0xfc>)
 8009ba2:	fba3 2301 	umull	r2, r3, r3, r1
 8009ba6:	08da      	lsrs	r2, r3, #3
 8009ba8:	4613      	mov	r3, r2
 8009baa:	009b      	lsls	r3, r3, #2
 8009bac:	4413      	add	r3, r2
 8009bae:	005b      	lsls	r3, r3, #1
 8009bb0:	1aca      	subs	r2, r1, r3
 8009bb2:	9b03      	ldr	r3, [sp, #12]
 8009bb4:	4313      	orrs	r3, r2
 8009bb6:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009bb8:	9a02      	ldr	r2, [sp, #8]
 8009bba:	4b30      	ldr	r3, [pc, #192]	; (8009c7c <rtc_encode_time+0xfc>)
 8009bbc:	fba3 1302 	umull	r1, r3, r3, r2
 8009bc0:	08db      	lsrs	r3, r3, #3
 8009bc2:	9302      	str	r3, [sp, #8]
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
 8009bc4:	9902      	ldr	r1, [sp, #8]
 8009bc6:	4b2e      	ldr	r3, [pc, #184]	; (8009c80 <rtc_encode_time+0x100>)
 8009bc8:	fba3 2301 	umull	r2, r3, r3, r1
 8009bcc:	089a      	lsrs	r2, r3, #2
 8009bce:	4613      	mov	r3, r2
 8009bd0:	005b      	lsls	r3, r3, #1
 8009bd2:	4413      	add	r3, r2
 8009bd4:	005b      	lsls	r3, r3, #1
 8009bd6:	1aca      	subs	r2, r1, r3
 8009bd8:	0113      	lsls	r3, r2, #4
 8009bda:	9a03      	ldr	r2, [sp, #12]
 8009bdc:	4313      	orrs	r3, r2
 8009bde:	9303      	str	r3, [sp, #12]
  n /= 6;
 8009be0:	9a02      	ldr	r2, [sp, #8]
 8009be2:	4b27      	ldr	r3, [pc, #156]	; (8009c80 <rtc_encode_time+0x100>)
 8009be4:	fba3 1302 	umull	r1, r3, r3, r2
 8009be8:	089b      	lsrs	r3, r3, #2
 8009bea:	9302      	str	r3, [sp, #8]

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
 8009bec:	9902      	ldr	r1, [sp, #8]
 8009bee:	4b23      	ldr	r3, [pc, #140]	; (8009c7c <rtc_encode_time+0xfc>)
 8009bf0:	fba3 2301 	umull	r2, r3, r3, r1
 8009bf4:	08da      	lsrs	r2, r3, #3
 8009bf6:	4613      	mov	r3, r2
 8009bf8:	009b      	lsls	r3, r3, #2
 8009bfa:	4413      	add	r3, r2
 8009bfc:	005b      	lsls	r3, r3, #1
 8009bfe:	1aca      	subs	r2, r1, r3
 8009c00:	0213      	lsls	r3, r2, #8
 8009c02:	9a03      	ldr	r2, [sp, #12]
 8009c04:	4313      	orrs	r3, r2
 8009c06:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009c08:	9a02      	ldr	r2, [sp, #8]
 8009c0a:	4b1c      	ldr	r3, [pc, #112]	; (8009c7c <rtc_encode_time+0xfc>)
 8009c0c:	fba3 1302 	umull	r1, r3, r3, r2
 8009c10:	08db      	lsrs	r3, r3, #3
 8009c12:	9302      	str	r3, [sp, #8]
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
 8009c14:	9902      	ldr	r1, [sp, #8]
 8009c16:	4b1a      	ldr	r3, [pc, #104]	; (8009c80 <rtc_encode_time+0x100>)
 8009c18:	fba3 2301 	umull	r2, r3, r3, r1
 8009c1c:	089a      	lsrs	r2, r3, #2
 8009c1e:	4613      	mov	r3, r2
 8009c20:	005b      	lsls	r3, r3, #1
 8009c22:	4413      	add	r3, r2
 8009c24:	005b      	lsls	r3, r3, #1
 8009c26:	1aca      	subs	r2, r1, r3
 8009c28:	0313      	lsls	r3, r2, #12
 8009c2a:	9a03      	ldr	r2, [sp, #12]
 8009c2c:	4313      	orrs	r3, r2
 8009c2e:	9303      	str	r3, [sp, #12]
  n /= 6;
 8009c30:	9a02      	ldr	r2, [sp, #8]
 8009c32:	4b13      	ldr	r3, [pc, #76]	; (8009c80 <rtc_encode_time+0x100>)
 8009c34:	fba3 1302 	umull	r1, r3, r3, r2
 8009c38:	089b      	lsrs	r3, r3, #2
 8009c3a:	9302      	str	r3, [sp, #8]

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
 8009c3c:	9902      	ldr	r1, [sp, #8]
 8009c3e:	4b0f      	ldr	r3, [pc, #60]	; (8009c7c <rtc_encode_time+0xfc>)
 8009c40:	fba3 2301 	umull	r2, r3, r3, r1
 8009c44:	08da      	lsrs	r2, r3, #3
 8009c46:	4613      	mov	r3, r2
 8009c48:	009b      	lsls	r3, r3, #2
 8009c4a:	4413      	add	r3, r2
 8009c4c:	005b      	lsls	r3, r3, #1
 8009c4e:	1aca      	subs	r2, r1, r3
 8009c50:	0413      	lsls	r3, r2, #16
 8009c52:	9a03      	ldr	r2, [sp, #12]
 8009c54:	4313      	orrs	r3, r2
 8009c56:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009c58:	9a02      	ldr	r2, [sp, #8]
 8009c5a:	4b08      	ldr	r3, [pc, #32]	; (8009c7c <rtc_encode_time+0xfc>)
 8009c5c:	fba3 1302 	umull	r1, r3, r3, r2
 8009c60:	08db      	lsrs	r3, r3, #3
 8009c62:	9302      	str	r3, [sp, #8]
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8009c64:	9b02      	ldr	r3, [sp, #8]
 8009c66:	051b      	lsls	r3, r3, #20
 8009c68:	9a03      	ldr	r2, [sp, #12]
 8009c6a:	4313      	orrs	r3, r2
 8009c6c:	9303      	str	r3, [sp, #12]

  return tr;
 8009c6e:	9b03      	ldr	r3, [sp, #12]
}
 8009c70:	4618      	mov	r0, r3
 8009c72:	b004      	add	sp, #16
 8009c74:	4770      	bx	lr
 8009c76:	bf00      	nop
 8009c78:	10624dd3 	.word	0x10624dd3
 8009c7c:	cccccccd 	.word	0xcccccccd
 8009c80:	aaaaaaab 	.word	0xaaaaaaab
 8009c84:	f3af 8000 	nop.w
 8009c88:	f3af 8000 	nop.w
 8009c8c:	f3af 8000 	nop.w

08009c90 <rtc_encode_date>:
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 * @return              the DR register encoding.
 *
 * @notapi
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
 8009c90:	b084      	sub	sp, #16
 8009c92:	9001      	str	r0, [sp, #4]
  uint32_t n, dr = 0;
 8009c94:	2300      	movs	r3, #0
 8009c96:	9303      	str	r3, [sp, #12]

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8009c98:	9b01      	ldr	r3, [sp, #4]
 8009c9a:	781b      	ldrb	r3, [r3, #0]
 8009c9c:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
 8009c9e:	9902      	ldr	r1, [sp, #8]
 8009ca0:	4b3e      	ldr	r3, [pc, #248]	; (8009d9c <rtc_encode_date+0x10c>)
 8009ca2:	fba3 2301 	umull	r2, r3, r3, r1
 8009ca6:	08da      	lsrs	r2, r3, #3
 8009ca8:	4613      	mov	r3, r2
 8009caa:	009b      	lsls	r3, r3, #2
 8009cac:	4413      	add	r3, r2
 8009cae:	005b      	lsls	r3, r3, #1
 8009cb0:	1aca      	subs	r2, r1, r3
 8009cb2:	0413      	lsls	r3, r2, #16
 8009cb4:	9a03      	ldr	r2, [sp, #12]
 8009cb6:	4313      	orrs	r3, r2
 8009cb8:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009cba:	9a02      	ldr	r2, [sp, #8]
 8009cbc:	4b37      	ldr	r3, [pc, #220]	; (8009d9c <rtc_encode_date+0x10c>)
 8009cbe:	fba3 1302 	umull	r1, r3, r3, r2
 8009cc2:	08db      	lsrs	r3, r3, #3
 8009cc4:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);
 8009cc6:	9902      	ldr	r1, [sp, #8]
 8009cc8:	4b34      	ldr	r3, [pc, #208]	; (8009d9c <rtc_encode_date+0x10c>)
 8009cca:	fba3 2301 	umull	r2, r3, r3, r1
 8009cce:	08da      	lsrs	r2, r3, #3
 8009cd0:	4613      	mov	r3, r2
 8009cd2:	009b      	lsls	r3, r3, #2
 8009cd4:	4413      	add	r3, r2
 8009cd6:	005b      	lsls	r3, r3, #1
 8009cd8:	1aca      	subs	r2, r1, r3
 8009cda:	0513      	lsls	r3, r2, #20
 8009cdc:	9a03      	ldr	r2, [sp, #12]
 8009cde:	4313      	orrs	r3, r2
 8009ce0:	9303      	str	r3, [sp, #12]

  /* Months conversion.*/
  n = timespec->month;
 8009ce2:	9b01      	ldr	r3, [sp, #4]
 8009ce4:	785b      	ldrb	r3, [r3, #1]
 8009ce6:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8009cea:	b2db      	uxtb	r3, r3
 8009cec:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 8009cee:	9902      	ldr	r1, [sp, #8]
 8009cf0:	4b2a      	ldr	r3, [pc, #168]	; (8009d9c <rtc_encode_date+0x10c>)
 8009cf2:	fba3 2301 	umull	r2, r3, r3, r1
 8009cf6:	08da      	lsrs	r2, r3, #3
 8009cf8:	4613      	mov	r3, r2
 8009cfa:	009b      	lsls	r3, r3, #2
 8009cfc:	4413      	add	r3, r2
 8009cfe:	005b      	lsls	r3, r3, #1
 8009d00:	1aca      	subs	r2, r1, r3
 8009d02:	0213      	lsls	r3, r2, #8
 8009d04:	9a03      	ldr	r2, [sp, #12]
 8009d06:	4313      	orrs	r3, r2
 8009d08:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009d0a:	9a02      	ldr	r2, [sp, #8]
 8009d0c:	4b23      	ldr	r3, [pc, #140]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d0e:	fba3 1302 	umull	r1, r3, r3, r2
 8009d12:	08db      	lsrs	r3, r3, #3
 8009d14:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);
 8009d16:	9902      	ldr	r1, [sp, #8]
 8009d18:	4b20      	ldr	r3, [pc, #128]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d1a:	fba3 2301 	umull	r2, r3, r3, r1
 8009d1e:	08da      	lsrs	r2, r3, #3
 8009d20:	4613      	mov	r3, r2
 8009d22:	009b      	lsls	r3, r3, #2
 8009d24:	4413      	add	r3, r2
 8009d26:	005b      	lsls	r3, r3, #1
 8009d28:	1aca      	subs	r2, r1, r3
 8009d2a:	0313      	lsls	r3, r2, #12
 8009d2c:	9a03      	ldr	r2, [sp, #12]
 8009d2e:	4313      	orrs	r3, r2
 8009d30:	9303      	str	r3, [sp, #12]

  /* Days conversion.*/
  n = timespec->day;
 8009d32:	9b01      	ldr	r3, [sp, #4]
 8009d34:	789b      	ldrb	r3, [r3, #2]
 8009d36:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8009d3a:	b2db      	uxtb	r3, r3
 8009d3c:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
 8009d3e:	9902      	ldr	r1, [sp, #8]
 8009d40:	4b16      	ldr	r3, [pc, #88]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d42:	fba3 2301 	umull	r2, r3, r3, r1
 8009d46:	08da      	lsrs	r2, r3, #3
 8009d48:	4613      	mov	r3, r2
 8009d4a:	009b      	lsls	r3, r3, #2
 8009d4c:	4413      	add	r3, r2
 8009d4e:	005b      	lsls	r3, r3, #1
 8009d50:	1aca      	subs	r2, r1, r3
 8009d52:	9b03      	ldr	r3, [sp, #12]
 8009d54:	4313      	orrs	r3, r2
 8009d56:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009d58:	9a02      	ldr	r2, [sp, #8]
 8009d5a:	4b10      	ldr	r3, [pc, #64]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d5c:	fba3 1302 	umull	r1, r3, r3, r2
 8009d60:	08db      	lsrs	r3, r3, #3
 8009d62:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);
 8009d64:	9902      	ldr	r1, [sp, #8]
 8009d66:	4b0d      	ldr	r3, [pc, #52]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d68:	fba3 2301 	umull	r2, r3, r3, r1
 8009d6c:	08da      	lsrs	r2, r3, #3
 8009d6e:	4613      	mov	r3, r2
 8009d70:	009b      	lsls	r3, r3, #2
 8009d72:	4413      	add	r3, r2
 8009d74:	005b      	lsls	r3, r3, #1
 8009d76:	1aca      	subs	r2, r1, r3
 8009d78:	0113      	lsls	r3, r2, #4
 8009d7a:	9a03      	ldr	r2, [sp, #12]
 8009d7c:	4313      	orrs	r3, r2
 8009d7e:	9303      	str	r3, [sp, #12]

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8009d80:	9b01      	ldr	r3, [sp, #4]
 8009d82:	785b      	ldrb	r3, [r3, #1]
 8009d84:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8009d88:	b2db      	uxtb	r3, r3
 8009d8a:	035b      	lsls	r3, r3, #13
 8009d8c:	9a03      	ldr	r2, [sp, #12]
 8009d8e:	4313      	orrs	r3, r2
 8009d90:	9303      	str	r3, [sp, #12]

  return dr;
 8009d92:	9b03      	ldr	r3, [sp, #12]
}
 8009d94:	4618      	mov	r0, r3
 8009d96:	b004      	add	sp, #16
 8009d98:	4770      	bx	lr
 8009d9a:	bf00      	nop
 8009d9c:	cccccccd 	.word	0xcccccccd

08009da0 <rtc_lld_init>:
/**
 * @brief   Enable access to registers.
 *
 * @notapi
 */
void rtc_lld_init(void) {
 8009da0:	b508      	push	{r3, lr}

  /* RTC object initialization.*/
  rtcObjectInit(&RTCD1);
 8009da2:	4819      	ldr	r0, [pc, #100]	; (8009e08 <rtc_lld_init+0x68>)
 8009da4:	f7fb f964 	bl	8005070 <rtcObjectInit>

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;
 8009da8:	4b17      	ldr	r3, [pc, #92]	; (8009e08 <rtc_lld_init+0x68>)
 8009daa:	4a18      	ldr	r2, [pc, #96]	; (8009e0c <rtc_lld_init+0x6c>)
 8009dac:	601a      	str	r2, [r3, #0]

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 8009dae:	4b16      	ldr	r3, [pc, #88]	; (8009e08 <rtc_lld_init+0x68>)
 8009db0:	681b      	ldr	r3, [r3, #0]
 8009db2:	22ca      	movs	r2, #202	; 0xca
 8009db4:	625a      	str	r2, [r3, #36]	; 0x24
  RTCD1.rtc->WPR = 0x53;
 8009db6:	4b14      	ldr	r3, [pc, #80]	; (8009e08 <rtc_lld_init+0x68>)
 8009db8:	681b      	ldr	r3, [r3, #0]
 8009dba:	2253      	movs	r2, #83	; 0x53
 8009dbc:	625a      	str	r2, [r3, #36]	; 0x24

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8009dbe:	4b12      	ldr	r3, [pc, #72]	; (8009e08 <rtc_lld_init+0x68>)
 8009dc0:	681b      	ldr	r3, [r3, #0]
 8009dc2:	68db      	ldr	r3, [r3, #12]
 8009dc4:	f003 0310 	and.w	r3, r3, #16
 8009dc8:	2b00      	cmp	r3, #0
 8009dca:	d114      	bne.n	8009df6 <rtc_lld_init+0x56>

    rtc_enter_init();
 8009dcc:	f7ff fe00 	bl	80099d0 <rtc_enter_init>

    RTCD1.rtc->CR   = 0;
 8009dd0:	4b0d      	ldr	r3, [pc, #52]	; (8009e08 <rtc_lld_init+0x68>)
 8009dd2:	681b      	ldr	r3, [r3, #0]
 8009dd4:	2200      	movs	r2, #0
 8009dd6:	609a      	str	r2, [r3, #8]
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 8009dd8:	4b0b      	ldr	r3, [pc, #44]	; (8009e08 <rtc_lld_init+0x68>)
 8009dda:	681b      	ldr	r3, [r3, #0]
 8009ddc:	2280      	movs	r2, #128	; 0x80
 8009dde:	60da      	str	r2, [r3, #12]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8009de0:	4b09      	ldr	r3, [pc, #36]	; (8009e08 <rtc_lld_init+0x68>)
 8009de2:	681b      	ldr	r3, [r3, #0]
 8009de4:	4a0a      	ldr	r2, [pc, #40]	; (8009e10 <rtc_lld_init+0x70>)
 8009de6:	611a      	str	r2, [r3, #16]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8009de8:	4b07      	ldr	r3, [pc, #28]	; (8009e08 <rtc_lld_init+0x68>)
 8009dea:	681b      	ldr	r3, [r3, #0]
 8009dec:	4a08      	ldr	r2, [pc, #32]	; (8009e10 <rtc_lld_init+0x70>)
 8009dee:	611a      	str	r2, [r3, #16]

    rtc_exit_init();
 8009df0:	f7ff fe06 	bl	8009a00 <rtc_exit_init>
 8009df4:	e007      	b.n	8009e06 <rtc_lld_init+0x66>
  }
  else
    RTCD1.rtc->ISR &= ~RTC_ISR_RSF;
 8009df6:	4b04      	ldr	r3, [pc, #16]	; (8009e08 <rtc_lld_init+0x68>)
 8009df8:	681b      	ldr	r3, [r3, #0]
 8009dfa:	4a03      	ldr	r2, [pc, #12]	; (8009e08 <rtc_lld_init+0x68>)
 8009dfc:	6812      	ldr	r2, [r2, #0]
 8009dfe:	68d2      	ldr	r2, [r2, #12]
 8009e00:	f022 0220 	bic.w	r2, r2, #32
 8009e04:	60da      	str	r2, [r3, #12]
}
 8009e06:	bd08      	pop	{r3, pc}
 8009e08:	20003d38 	.word	0x20003d38
 8009e0c:	40002800 	.word	0x40002800
 8009e10:	001f03ff 	.word	0x001f03ff
 8009e14:	f3af 8000 	nop.w
 8009e18:	f3af 8000 	nop.w
 8009e1c:	f3af 8000 	nop.w

08009e20 <rtc_lld_set_time>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_set_time(RTCDriver *rtcp, const RTCDateTime *timespec) {
 8009e20:	b500      	push	{lr}
 8009e22:	b087      	sub	sp, #28
 8009e24:	9001      	str	r0, [sp, #4]
 8009e26:	9100      	str	r1, [sp, #0]
  uint32_t dr, tr;
  syssts_t sts;

  tr = rtc_encode_time(timespec);
 8009e28:	9800      	ldr	r0, [sp, #0]
 8009e2a:	f7ff fea9 	bl	8009b80 <rtc_encode_time>
 8009e2e:	9005      	str	r0, [sp, #20]
  dr = rtc_encode_date(timespec);
 8009e30:	9800      	ldr	r0, [sp, #0]
 8009e32:	f7ff ff2d 	bl	8009c90 <rtc_encode_date>
 8009e36:	9004      	str	r0, [sp, #16]

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 8009e38:	f7ff fdb2 	bl	80099a0 <osalSysGetStatusAndLockX>
 8009e3c:	9003      	str	r0, [sp, #12]

  /* Writing the registers.*/
  rtc_enter_init();
 8009e3e:	f7ff fdc7 	bl	80099d0 <rtc_enter_init>
  rtcp->rtc->TR  = tr;
 8009e42:	9b01      	ldr	r3, [sp, #4]
 8009e44:	681b      	ldr	r3, [r3, #0]
 8009e46:	9a05      	ldr	r2, [sp, #20]
 8009e48:	601a      	str	r2, [r3, #0]
  rtcp->rtc->DR  = dr;
 8009e4a:	9b01      	ldr	r3, [sp, #4]
 8009e4c:	681b      	ldr	r3, [r3, #0]
 8009e4e:	9a04      	ldr	r2, [sp, #16]
 8009e50:	605a      	str	r2, [r3, #4]
  rtcp->rtc->CR |= timespec->dstflag << RTC_CR_BKP_OFFSET;
 8009e52:	9b01      	ldr	r3, [sp, #4]
 8009e54:	681b      	ldr	r3, [r3, #0]
 8009e56:	9a01      	ldr	r2, [sp, #4]
 8009e58:	6812      	ldr	r2, [r2, #0]
 8009e5a:	6891      	ldr	r1, [r2, #8]
 8009e5c:	9a00      	ldr	r2, [sp, #0]
 8009e5e:	7852      	ldrb	r2, [r2, #1]
 8009e60:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8009e64:	b2d2      	uxtb	r2, r2
 8009e66:	0492      	lsls	r2, r2, #18
 8009e68:	430a      	orrs	r2, r1
 8009e6a:	609a      	str	r2, [r3, #8]
  rtc_exit_init();
 8009e6c:	f7ff fdc8 	bl	8009a00 <rtc_exit_init>

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 8009e70:	9803      	ldr	r0, [sp, #12]
 8009e72:	f7ff fd9d 	bl	80099b0 <osalSysRestoreStatusX>
}
 8009e76:	b007      	add	sp, #28
 8009e78:	f85d fb04 	ldr.w	pc, [sp], #4
 8009e7c:	f3af 8000 	nop.w

08009e80 <rtc_lld_get_time>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_get_time(RTCDriver *rtcp, RTCDateTime *timespec) {
 8009e80:	b500      	push	{lr}
 8009e82:	b089      	sub	sp, #36	; 0x24
 8009e84:	9001      	str	r0, [sp, #4]
 8009e86:	9100      	str	r1, [sp, #0]
  uint32_t ssr;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 8009e88:	f7ff fd8a 	bl	80099a0 <osalSysGetStatusAndLockX>
 8009e8c:	9007      	str	r0, [sp, #28]

  /* Synchronization with the RTC and reading the registers, note
     DR must be read last.*/
  while ((rtcp->rtc->ISR & RTC_ISR_RSF) == 0)
 8009e8e:	bf00      	nop
 8009e90:	9b01      	ldr	r3, [sp, #4]
 8009e92:	681b      	ldr	r3, [r3, #0]
 8009e94:	68db      	ldr	r3, [r3, #12]
 8009e96:	f003 0320 	and.w	r3, r3, #32
 8009e9a:	2b00      	cmp	r3, #0
 8009e9c:	d0f8      	beq.n	8009e90 <rtc_lld_get_time+0x10>
    ;
#if STM32_RTC_HAS_SUBSECONDS
  ssr = rtcp->rtc->SSR;
 8009e9e:	9b01      	ldr	r3, [sp, #4]
 8009ea0:	681b      	ldr	r3, [r3, #0]
 8009ea2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009ea4:	9306      	str	r3, [sp, #24]
#endif /* STM32_RTC_HAS_SUBSECONDS */
  tr  = rtcp->rtc->TR;
 8009ea6:	9b01      	ldr	r3, [sp, #4]
 8009ea8:	681b      	ldr	r3, [r3, #0]
 8009eaa:	681b      	ldr	r3, [r3, #0]
 8009eac:	9305      	str	r3, [sp, #20]
  dr  = rtcp->rtc->DR;
 8009eae:	9b01      	ldr	r3, [sp, #4]
 8009eb0:	681b      	ldr	r3, [r3, #0]
 8009eb2:	685b      	ldr	r3, [r3, #4]
 8009eb4:	9304      	str	r3, [sp, #16]
  cr  = rtcp->rtc->CR;
 8009eb6:	9b01      	ldr	r3, [sp, #4]
 8009eb8:	681b      	ldr	r3, [r3, #0]
 8009eba:	689b      	ldr	r3, [r3, #8]
 8009ebc:	9303      	str	r3, [sp, #12]
  rtcp->rtc->ISR &= ~RTC_ISR_RSF;
 8009ebe:	9b01      	ldr	r3, [sp, #4]
 8009ec0:	681b      	ldr	r3, [r3, #0]
 8009ec2:	9a01      	ldr	r2, [sp, #4]
 8009ec4:	6812      	ldr	r2, [r2, #0]
 8009ec6:	68d2      	ldr	r2, [r2, #12]
 8009ec8:	f022 0220 	bic.w	r2, r2, #32
 8009ecc:	60da      	str	r2, [r3, #12]

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 8009ece:	9807      	ldr	r0, [sp, #28]
 8009ed0:	f7ff fd6e 	bl	80099b0 <osalSysRestoreStatusX>

  /* Decoding day time, this starts the atomic read sequence, see "Reading
     the calendar" in the RTC documentation.*/
  rtc_decode_time(tr, timespec);
 8009ed4:	9805      	ldr	r0, [sp, #20]
 8009ed6:	9900      	ldr	r1, [sp, #0]
 8009ed8:	f7ff fda2 	bl	8009a20 <rtc_decode_time>

  /* If the RTC is capable of sub-second counting then the value is
     normalized in milliseconds and added to the time.*/
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
 8009edc:	9b06      	ldr	r3, [sp, #24]
 8009ede:	4a14      	ldr	r2, [pc, #80]	; (8009f30 <rtc_lld_get_time+0xb0>)
 8009ee0:	fb02 f303 	mul.w	r3, r2, r3
 8009ee4:	f503 2379 	add.w	r3, r3, #1019904	; 0xf9000
 8009ee8:	f603 4318 	addw	r3, r3, #3096	; 0xc18
 8009eec:	0a9b      	lsrs	r3, r3, #10
 8009eee:	9302      	str	r3, [sp, #8]
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 8009ef0:	9b00      	ldr	r3, [sp, #0]
 8009ef2:	685b      	ldr	r3, [r3, #4]
 8009ef4:	f3c3 031a 	ubfx	r3, r3, #0, #27
 8009ef8:	461a      	mov	r2, r3
 8009efa:	9b02      	ldr	r3, [sp, #8]
 8009efc:	4413      	add	r3, r2
 8009efe:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 8009f02:	9a00      	ldr	r2, [sp, #0]
 8009f04:	6853      	ldr	r3, [r2, #4]
 8009f06:	f361 031a 	bfi	r3, r1, #0, #27
 8009f0a:	6053      	str	r3, [r2, #4]

  /* Decoding date, this concludes the atomic read sequence.*/
  rtc_decode_date(dr, timespec);
 8009f0c:	9804      	ldr	r0, [sp, #16]
 8009f0e:	9900      	ldr	r1, [sp, #0]
 8009f10:	f7ff fdd6 	bl	8009ac0 <rtc_decode_date>

  /* Retrieving the DST bit.*/
  timespec->dstflag = (cr >> RTC_CR_BKP_OFFSET) & 1;
 8009f14:	9b03      	ldr	r3, [sp, #12]
 8009f16:	0c9b      	lsrs	r3, r3, #18
 8009f18:	b2db      	uxtb	r3, r3
 8009f1a:	f003 0301 	and.w	r3, r3, #1
 8009f1e:	b2d9      	uxtb	r1, r3
 8009f20:	9a00      	ldr	r2, [sp, #0]
 8009f22:	7853      	ldrb	r3, [r2, #1]
 8009f24:	f361 1304 	bfi	r3, r1, #4, #1
 8009f28:	7053      	strb	r3, [r2, #1]
}
 8009f2a:	b009      	add	sp, #36	; 0x24
 8009f2c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009f30:	fffffc18 	.word	0xfffffc18
 8009f34:	f3af 8000 	nop.w
 8009f38:	f3af 8000 	nop.w
 8009f3c:	f3af 8000 	nop.w

08009f40 <rtc_lld_set_alarm>:
 *
 * @notapi
 */
void rtc_lld_set_alarm(RTCDriver *rtcp,
                       rtcalarm_t alarm,
                       const RTCAlarm *alarmspec) {
 8009f40:	b500      	push	{lr}
 8009f42:	b087      	sub	sp, #28
 8009f44:	9003      	str	r0, [sp, #12]
 8009f46:	9102      	str	r1, [sp, #8]
 8009f48:	9201      	str	r2, [sp, #4]
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 8009f4a:	f7ff fd29 	bl	80099a0 <osalSysGetStatusAndLockX>
 8009f4e:	9005      	str	r0, [sp, #20]

  if (alarm == 0) {
 8009f50:	9b02      	ldr	r3, [sp, #8]
 8009f52:	2b00      	cmp	r3, #0
 8009f54:	d139      	bne.n	8009fca <rtc_lld_set_alarm+0x8a>
    if (alarmspec != NULL) {
 8009f56:	9b01      	ldr	r3, [sp, #4]
 8009f58:	2b00      	cmp	r3, #0
 8009f5a:	d025      	beq.n	8009fa8 <rtc_lld_set_alarm+0x68>
      rtcp->rtc->CR &= ~RTC_CR_ALRAE;
 8009f5c:	9b03      	ldr	r3, [sp, #12]
 8009f5e:	681b      	ldr	r3, [r3, #0]
 8009f60:	9a03      	ldr	r2, [sp, #12]
 8009f62:	6812      	ldr	r2, [r2, #0]
 8009f64:	6892      	ldr	r2, [r2, #8]
 8009f66:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009f6a:	609a      	str	r2, [r3, #8]
      while (!(rtcp->rtc->ISR & RTC_ISR_ALRAWF))
 8009f6c:	bf00      	nop
 8009f6e:	9b03      	ldr	r3, [sp, #12]
 8009f70:	681b      	ldr	r3, [r3, #0]
 8009f72:	68db      	ldr	r3, [r3, #12]
 8009f74:	f003 0301 	and.w	r3, r3, #1
 8009f78:	2b00      	cmp	r3, #0
 8009f7a:	d0f8      	beq.n	8009f6e <rtc_lld_set_alarm+0x2e>
        ;
      rtcp->rtc->ALRMAR = alarmspec->alrmr;
 8009f7c:	9b03      	ldr	r3, [sp, #12]
 8009f7e:	681b      	ldr	r3, [r3, #0]
 8009f80:	9a01      	ldr	r2, [sp, #4]
 8009f82:	6812      	ldr	r2, [r2, #0]
 8009f84:	61da      	str	r2, [r3, #28]
      rtcp->rtc->CR |= RTC_CR_ALRAE;
 8009f86:	9b03      	ldr	r3, [sp, #12]
 8009f88:	681b      	ldr	r3, [r3, #0]
 8009f8a:	9a03      	ldr	r2, [sp, #12]
 8009f8c:	6812      	ldr	r2, [r2, #0]
 8009f8e:	6892      	ldr	r2, [r2, #8]
 8009f90:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8009f94:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR |= RTC_CR_ALRAIE;
 8009f96:	9b03      	ldr	r3, [sp, #12]
 8009f98:	681b      	ldr	r3, [r3, #0]
 8009f9a:	9a03      	ldr	r2, [sp, #12]
 8009f9c:	6812      	ldr	r2, [r2, #0]
 8009f9e:	6892      	ldr	r2, [r2, #8]
 8009fa0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009fa4:	609a      	str	r2, [r3, #8]
 8009fa6:	e049      	b.n	800a03c <rtc_lld_set_alarm+0xfc>
    }
    else {
      rtcp->rtc->CR &= ~RTC_CR_ALRAIE;
 8009fa8:	9b03      	ldr	r3, [sp, #12]
 8009faa:	681b      	ldr	r3, [r3, #0]
 8009fac:	9a03      	ldr	r2, [sp, #12]
 8009fae:	6812      	ldr	r2, [r2, #0]
 8009fb0:	6892      	ldr	r2, [r2, #8]
 8009fb2:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8009fb6:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR &= ~RTC_CR_ALRAE;
 8009fb8:	9b03      	ldr	r3, [sp, #12]
 8009fba:	681b      	ldr	r3, [r3, #0]
 8009fbc:	9a03      	ldr	r2, [sp, #12]
 8009fbe:	6812      	ldr	r2, [r2, #0]
 8009fc0:	6892      	ldr	r2, [r2, #8]
 8009fc2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009fc6:	609a      	str	r2, [r3, #8]
 8009fc8:	e038      	b.n	800a03c <rtc_lld_set_alarm+0xfc>
    }
  }
#if RTC_ALARMS > 1
  else {
    if (alarmspec != NULL) {
 8009fca:	9b01      	ldr	r3, [sp, #4]
 8009fcc:	2b00      	cmp	r3, #0
 8009fce:	d025      	beq.n	800a01c <rtc_lld_set_alarm+0xdc>
      rtcp->rtc->CR &= ~RTC_CR_ALRBE;
 8009fd0:	9b03      	ldr	r3, [sp, #12]
 8009fd2:	681b      	ldr	r3, [r3, #0]
 8009fd4:	9a03      	ldr	r2, [sp, #12]
 8009fd6:	6812      	ldr	r2, [r2, #0]
 8009fd8:	6892      	ldr	r2, [r2, #8]
 8009fda:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8009fde:	609a      	str	r2, [r3, #8]
      while (!(rtcp->rtc->ISR & RTC_ISR_ALRBWF))
 8009fe0:	bf00      	nop
 8009fe2:	9b03      	ldr	r3, [sp, #12]
 8009fe4:	681b      	ldr	r3, [r3, #0]
 8009fe6:	68db      	ldr	r3, [r3, #12]
 8009fe8:	f003 0302 	and.w	r3, r3, #2
 8009fec:	2b00      	cmp	r3, #0
 8009fee:	d0f8      	beq.n	8009fe2 <rtc_lld_set_alarm+0xa2>
        ;
      rtcp->rtc->ALRMBR = alarmspec->alrmr;
 8009ff0:	9b03      	ldr	r3, [sp, #12]
 8009ff2:	681b      	ldr	r3, [r3, #0]
 8009ff4:	9a01      	ldr	r2, [sp, #4]
 8009ff6:	6812      	ldr	r2, [r2, #0]
 8009ff8:	621a      	str	r2, [r3, #32]
      rtcp->rtc->CR |= RTC_CR_ALRBE;
 8009ffa:	9b03      	ldr	r3, [sp, #12]
 8009ffc:	681b      	ldr	r3, [r3, #0]
 8009ffe:	9a03      	ldr	r2, [sp, #12]
 800a000:	6812      	ldr	r2, [r2, #0]
 800a002:	6892      	ldr	r2, [r2, #8]
 800a004:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800a008:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR |= RTC_CR_ALRBIE;
 800a00a:	9b03      	ldr	r3, [sp, #12]
 800a00c:	681b      	ldr	r3, [r3, #0]
 800a00e:	9a03      	ldr	r2, [sp, #12]
 800a010:	6812      	ldr	r2, [r2, #0]
 800a012:	6892      	ldr	r2, [r2, #8]
 800a014:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800a018:	609a      	str	r2, [r3, #8]
 800a01a:	e00f      	b.n	800a03c <rtc_lld_set_alarm+0xfc>
    }
    else {
      rtcp->rtc->CR &= ~RTC_CR_ALRBIE;
 800a01c:	9b03      	ldr	r3, [sp, #12]
 800a01e:	681b      	ldr	r3, [r3, #0]
 800a020:	9a03      	ldr	r2, [sp, #12]
 800a022:	6812      	ldr	r2, [r2, #0]
 800a024:	6892      	ldr	r2, [r2, #8]
 800a026:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a02a:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR &= ~RTC_CR_ALRBE;
 800a02c:	9b03      	ldr	r3, [sp, #12]
 800a02e:	681b      	ldr	r3, [r3, #0]
 800a030:	9a03      	ldr	r2, [sp, #12]
 800a032:	6812      	ldr	r2, [r2, #0]
 800a034:	6892      	ldr	r2, [r2, #8]
 800a036:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800a03a:	609a      	str	r2, [r3, #8]
    }
  }
#endif /* RTC_ALARMS > 1 */

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 800a03c:	9805      	ldr	r0, [sp, #20]
 800a03e:	f7ff fcb7 	bl	80099b0 <osalSysRestoreStatusX>
}
 800a042:	b007      	add	sp, #28
 800a044:	f85d fb04 	ldr.w	pc, [sp], #4
 800a048:	f3af 8000 	nop.w
 800a04c:	f3af 8000 	nop.w

0800a050 <rtc_lld_get_alarm>:
 *
 * @notapi
 */
void rtc_lld_get_alarm(RTCDriver *rtcp,
                       rtcalarm_t alarm,
                       RTCAlarm *alarmspec) {
 800a050:	b084      	sub	sp, #16
 800a052:	9003      	str	r0, [sp, #12]
 800a054:	9102      	str	r1, [sp, #8]
 800a056:	9201      	str	r2, [sp, #4]

  if (alarm == 0)
 800a058:	9b02      	ldr	r3, [sp, #8]
 800a05a:	2b00      	cmp	r3, #0
 800a05c:	d105      	bne.n	800a06a <rtc_lld_get_alarm+0x1a>
    alarmspec->alrmr = rtcp->rtc->ALRMAR;
 800a05e:	9b03      	ldr	r3, [sp, #12]
 800a060:	681b      	ldr	r3, [r3, #0]
 800a062:	69da      	ldr	r2, [r3, #28]
 800a064:	9b01      	ldr	r3, [sp, #4]
 800a066:	601a      	str	r2, [r3, #0]
 800a068:	e004      	b.n	800a074 <rtc_lld_get_alarm+0x24>
#if RTC_ALARMS > 1
  else
    alarmspec->alrmr = rtcp->rtc->ALRMBR;
 800a06a:	9b03      	ldr	r3, [sp, #12]
 800a06c:	681b      	ldr	r3, [r3, #0]
 800a06e:	6a1a      	ldr	r2, [r3, #32]
 800a070:	9b01      	ldr	r3, [sp, #4]
 800a072:	601a      	str	r2, [r3, #0]
#endif /* RTC_ALARMS > 1 */
}
 800a074:	b004      	add	sp, #16
 800a076:	4770      	bx	lr
 800a078:	f3af 8000 	nop.w
 800a07c:	f3af 8000 	nop.w

0800a080 <rtcSTM32SetPeriodicWakeup>:
 * @param[in] rtcp       pointer to RTC driver structure
 * @param[in] wakeupspec pointer to a @p RTCWakeup structure
 *
 * @api
 */
void rtcSTM32SetPeriodicWakeup(RTCDriver *rtcp, const RTCWakeup *wakeupspec) {
 800a080:	b500      	push	{lr}
 800a082:	b085      	sub	sp, #20
 800a084:	9001      	str	r0, [sp, #4]
 800a086:	9100      	str	r1, [sp, #0]
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 800a088:	f7ff fc8a 	bl	80099a0 <osalSysGetStatusAndLockX>
 800a08c:	9003      	str	r0, [sp, #12]

  if (wakeupspec != NULL) {
 800a08e:	9b00      	ldr	r3, [sp, #0]
 800a090:	2b00      	cmp	r3, #0
 800a092:	d02e      	beq.n	800a0f2 <rtcSTM32SetPeriodicWakeup+0x72>
    osalDbgCheck(wakeupspec->wutr != 0x30000);

    rtcp->rtc->CR &= ~RTC_CR_WUTE;
 800a094:	9b01      	ldr	r3, [sp, #4]
 800a096:	681b      	ldr	r3, [r3, #0]
 800a098:	9a01      	ldr	r2, [sp, #4]
 800a09a:	6812      	ldr	r2, [r2, #0]
 800a09c:	6892      	ldr	r2, [r2, #8]
 800a09e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a0a2:	609a      	str	r2, [r3, #8]
    while (!(rtcp->rtc->ISR & RTC_ISR_WUTWF))
 800a0a4:	bf00      	nop
 800a0a6:	9b01      	ldr	r3, [sp, #4]
 800a0a8:	681b      	ldr	r3, [r3, #0]
 800a0aa:	68db      	ldr	r3, [r3, #12]
 800a0ac:	f003 0304 	and.w	r3, r3, #4
 800a0b0:	2b00      	cmp	r3, #0
 800a0b2:	d0f8      	beq.n	800a0a6 <rtcSTM32SetPeriodicWakeup+0x26>
      ;
    rtcp->rtc->WUTR = wakeupspec->wutr & 0xFFFF;
 800a0b4:	9b01      	ldr	r3, [sp, #4]
 800a0b6:	681b      	ldr	r3, [r3, #0]
 800a0b8:	9a00      	ldr	r2, [sp, #0]
 800a0ba:	6812      	ldr	r2, [r2, #0]
 800a0bc:	b292      	uxth	r2, r2
 800a0be:	615a      	str	r2, [r3, #20]
    rtcp->rtc->CR   = (wakeupspec->wutr >> 16) & 0x7;
 800a0c0:	9b01      	ldr	r3, [sp, #4]
 800a0c2:	681b      	ldr	r3, [r3, #0]
 800a0c4:	9a00      	ldr	r2, [sp, #0]
 800a0c6:	6812      	ldr	r2, [r2, #0]
 800a0c8:	0c12      	lsrs	r2, r2, #16
 800a0ca:	f002 0207 	and.w	r2, r2, #7
 800a0ce:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR |= RTC_CR_WUTIE;
 800a0d0:	9b01      	ldr	r3, [sp, #4]
 800a0d2:	681b      	ldr	r3, [r3, #0]
 800a0d4:	9a01      	ldr	r2, [sp, #4]
 800a0d6:	6812      	ldr	r2, [r2, #0]
 800a0d8:	6892      	ldr	r2, [r2, #8]
 800a0da:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800a0de:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR |= RTC_CR_WUTE;
 800a0e0:	9b01      	ldr	r3, [sp, #4]
 800a0e2:	681b      	ldr	r3, [r3, #0]
 800a0e4:	9a01      	ldr	r2, [sp, #4]
 800a0e6:	6812      	ldr	r2, [r2, #0]
 800a0e8:	6892      	ldr	r2, [r2, #8]
 800a0ea:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a0ee:	609a      	str	r2, [r3, #8]
 800a0f0:	e00f      	b.n	800a112 <rtcSTM32SetPeriodicWakeup+0x92>
  }
  else {
    rtcp->rtc->CR &= ~RTC_CR_WUTIE;
 800a0f2:	9b01      	ldr	r3, [sp, #4]
 800a0f4:	681b      	ldr	r3, [r3, #0]
 800a0f6:	9a01      	ldr	r2, [sp, #4]
 800a0f8:	6812      	ldr	r2, [r2, #0]
 800a0fa:	6892      	ldr	r2, [r2, #8]
 800a0fc:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800a100:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR &= ~RTC_CR_WUTE;
 800a102:	9b01      	ldr	r3, [sp, #4]
 800a104:	681b      	ldr	r3, [r3, #0]
 800a106:	9a01      	ldr	r2, [sp, #4]
 800a108:	6812      	ldr	r2, [r2, #0]
 800a10a:	6892      	ldr	r2, [r2, #8]
 800a10c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a110:	609a      	str	r2, [r3, #8]
  }

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 800a112:	9803      	ldr	r0, [sp, #12]
 800a114:	f7ff fc4c 	bl	80099b0 <osalSysRestoreStatusX>
}
 800a118:	b005      	add	sp, #20
 800a11a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a11e:	bf00      	nop

0800a120 <rtcSTM32GetPeriodicWakeup>:
 * @param[in] rtcp        pointer to RTC driver structure
 * @param[out] wakeupspec pointer to a @p RTCWakeup structure
 *
 * @api
 */
void rtcSTM32GetPeriodicWakeup(RTCDriver *rtcp, RTCWakeup *wakeupspec) {
 800a120:	b500      	push	{lr}
 800a122:	b085      	sub	sp, #20
 800a124:	9001      	str	r0, [sp, #4]
 800a126:	9100      	str	r1, [sp, #0]
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 800a128:	f7ff fc3a 	bl	80099a0 <osalSysGetStatusAndLockX>
 800a12c:	9003      	str	r0, [sp, #12]

  wakeupspec->wutr  = 0;
 800a12e:	9b00      	ldr	r3, [sp, #0]
 800a130:	2200      	movs	r2, #0
 800a132:	601a      	str	r2, [r3, #0]
  wakeupspec->wutr |= rtcp->rtc->WUTR;
 800a134:	9b00      	ldr	r3, [sp, #0]
 800a136:	681a      	ldr	r2, [r3, #0]
 800a138:	9b01      	ldr	r3, [sp, #4]
 800a13a:	681b      	ldr	r3, [r3, #0]
 800a13c:	695b      	ldr	r3, [r3, #20]
 800a13e:	431a      	orrs	r2, r3
 800a140:	9b00      	ldr	r3, [sp, #0]
 800a142:	601a      	str	r2, [r3, #0]
  wakeupspec->wutr |= (((uint32_t)rtcp->rtc->CR) & 0x7) << 16;
 800a144:	9b00      	ldr	r3, [sp, #0]
 800a146:	681a      	ldr	r2, [r3, #0]
 800a148:	9b01      	ldr	r3, [sp, #4]
 800a14a:	681b      	ldr	r3, [r3, #0]
 800a14c:	689b      	ldr	r3, [r3, #8]
 800a14e:	f003 0307 	and.w	r3, r3, #7
 800a152:	041b      	lsls	r3, r3, #16
 800a154:	431a      	orrs	r2, r3
 800a156:	9b00      	ldr	r3, [sp, #0]
 800a158:	601a      	str	r2, [r3, #0]

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 800a15a:	9803      	ldr	r0, [sp, #12]
 800a15c:	f7ff fc28 	bl	80099b0 <osalSysRestoreStatusX>
}
 800a160:	b005      	add	sp, #20
 800a162:	f85d fb04 	ldr.w	pc, [sp], #4
 800a166:	bf00      	nop
 800a168:	f3af 8000 	nop.w
 800a16c:	f3af 8000 	nop.w

0800a170 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a170:	b082      	sub	sp, #8
 800a172:	2320      	movs	r3, #32
 800a174:	9301      	str	r3, [sp, #4]
 800a176:	9b01      	ldr	r3, [sp, #4]
 800a178:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a17c:	b002      	add	sp, #8
 800a17e:	4770      	bx	lr

0800a180 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a180:	b082      	sub	sp, #8
 800a182:	2300      	movs	r3, #0
 800a184:	9301      	str	r3, [sp, #4]
 800a186:	9b01      	ldr	r3, [sp, #4]
 800a188:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a18c:	b002      	add	sp, #8
 800a18e:	4770      	bx	lr

0800a190 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800a190:	b508      	push	{r3, lr}

  port_lock();
 800a192:	f7ff ffed 	bl	800a170 <port_lock>
}
 800a196:	bd08      	pop	{r3, pc}
 800a198:	f3af 8000 	nop.w
 800a19c:	f3af 8000 	nop.w

0800a1a0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800a1a0:	b508      	push	{r3, lr}

  port_unlock();
 800a1a2:	f7ff ffed 	bl	800a180 <port_unlock>
}
 800a1a6:	bd08      	pop	{r3, pc}
 800a1a8:	f3af 8000 	nop.w
 800a1ac:	f3af 8000 	nop.w

0800a1b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a1b0:	b508      	push	{r3, lr}

  port_lock();
 800a1b2:	f7ff ffdd 	bl	800a170 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800a1b6:	bd08      	pop	{r3, pc}
 800a1b8:	f3af 8000 	nop.w
 800a1bc:	f3af 8000 	nop.w

0800a1c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a1c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800a1c2:	f7ff ffdd 	bl	800a180 <port_unlock>
}
 800a1c6:	bd08      	pop	{r3, pc}
 800a1c8:	f3af 8000 	nop.w
 800a1cc:	f3af 8000 	nop.w

0800a1d0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800a1d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800a1d2:	f7ff ffdd 	bl	800a190 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800a1d6:	bd08      	pop	{r3, pc}
 800a1d8:	f3af 8000 	nop.w
 800a1dc:	f3af 8000 	nop.w

0800a1e0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800a1e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800a1e2:	f7ff ffdd 	bl	800a1a0 <port_unlock_from_isr>
}
 800a1e6:	bd08      	pop	{r3, pc}
 800a1e8:	f3af 8000 	nop.w
 800a1ec:	f3af 8000 	nop.w

0800a1f0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 800a1f0:	b508      	push	{r3, lr}

  chSysLock();
 800a1f2:	f7ff ffdd 	bl	800a1b0 <chSysLock>
}
 800a1f6:	bd08      	pop	{r3, pc}
 800a1f8:	f3af 8000 	nop.w
 800a1fc:	f3af 8000 	nop.w

0800a200 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 800a200:	b508      	push	{r3, lr}

  chSysUnlock();
 800a202:	f7ff ffdd 	bl	800a1c0 <chSysUnlock>
}
 800a206:	bd08      	pop	{r3, pc}
 800a208:	f3af 8000 	nop.w
 800a20c:	f3af 8000 	nop.w

0800a210 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800a210:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800a212:	f7ff ffdd 	bl	800a1d0 <chSysLockFromISR>
}
 800a216:	bd08      	pop	{r3, pc}
 800a218:	f3af 8000 	nop.w
 800a21c:	f3af 8000 	nop.w

0800a220 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800a220:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800a222:	f7ff ffdd 	bl	800a1e0 <chSysUnlockFromISR>
}
 800a226:	bd08      	pop	{r3, pc}
 800a228:	f3af 8000 	nop.w
 800a22c:	f3af 8000 	nop.w

0800a230 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 800a230:	b500      	push	{lr}
 800a232:	b083      	sub	sp, #12
 800a234:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 800a236:	9801      	ldr	r0, [sp, #4]
 800a238:	f7f7 f84a 	bl	80012d0 <chThdSleep>
}
 800a23c:	b003      	add	sp, #12
 800a23e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a242:	bf00      	nop
 800a244:	f3af 8000 	nop.w
 800a248:	f3af 8000 	nop.w
 800a24c:	f3af 8000 	nop.w

0800a250 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 800a250:	b500      	push	{lr}
 800a252:	b083      	sub	sp, #12
 800a254:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 800a256:	9801      	ldr	r0, [sp, #4]
 800a258:	f7f7 f8fa 	bl	8001450 <chThdSuspendS>
 800a25c:	4603      	mov	r3, r0
}
 800a25e:	4618      	mov	r0, r3
 800a260:	b003      	add	sp, #12
 800a262:	f85d fb04 	ldr.w	pc, [sp], #4
 800a266:	bf00      	nop
 800a268:	f3af 8000 	nop.w
 800a26c:	f3af 8000 	nop.w

0800a270 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 800a270:	b500      	push	{lr}
 800a272:	b083      	sub	sp, #12
 800a274:	9001      	str	r0, [sp, #4]
 800a276:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 800a278:	9801      	ldr	r0, [sp, #4]
 800a27a:	9900      	ldr	r1, [sp, #0]
 800a27c:	f7f7 f920 	bl	80014c0 <chThdResumeI>
}
 800a280:	b003      	add	sp, #12
 800a282:	f85d fb04 	ldr.w	pc, [sp], #4
 800a286:	bf00      	nop
 800a288:	f3af 8000 	nop.w
 800a28c:	f3af 8000 	nop.w

0800a290 <sdc_lld_prepare_read_bytes>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read_bytes(SDCDriver *sdcp,
                                       uint8_t *buf, uint32_t bytes) {
 800a290:	b500      	push	{lr}
 800a292:	b087      	sub	sp, #28
 800a294:	9003      	str	r0, [sp, #12]
 800a296:	9102      	str	r1, [sp, #8]
 800a298:	9201      	str	r2, [sp, #4]
  osalDbgCheck(bytes < 0x1000000);

  sdcp->sdmmc->DTIMER = SDMMC_READ_TIMEOUT;
 800a29a:	9b03      	ldr	r3, [sp, #12]
 800a29c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a29e:	4a2d      	ldr	r2, [pc, #180]	; (800a354 <sdc_lld_prepare_read_bytes+0xc4>)
 800a2a0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800a2a2:	9803      	ldr	r0, [sp, #12]
 800a2a4:	f7fb fbb4 	bl	8005a10 <_sdc_wait_for_transfer_state>
 800a2a8:	4603      	mov	r3, r0
 800a2aa:	2b00      	cmp	r3, #0
 800a2ac:	d001      	beq.n	800a2b2 <sdc_lld_prepare_read_bytes+0x22>
    return HAL_FAILED;
 800a2ae:	2301      	movs	r3, #1
 800a2b0:	e04b      	b.n	800a34a <sdc_lld_prepare_read_bytes+0xba>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800a2b2:	9b03      	ldr	r3, [sp, #12]
 800a2b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2b6:	685b      	ldr	r3, [r3, #4]
 800a2b8:	9a02      	ldr	r2, [sp, #8]
 800a2ba:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
 800a2bc:	9b03      	ldr	r3, [sp, #12]
 800a2be:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2c0:	685b      	ldr	r3, [r3, #4]
 800a2c2:	9a01      	ldr	r2, [sp, #4]
 800a2c4:	0892      	lsrs	r2, r2, #2
 800a2c6:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 800a2c8:	9b03      	ldr	r3, [sp, #12]
 800a2ca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2cc:	68db      	ldr	r3, [r3, #12]
 800a2ce:	681b      	ldr	r3, [r3, #0]
 800a2d0:	9305      	str	r3, [sp, #20]
 800a2d2:	9b03      	ldr	r3, [sp, #12]
 800a2d4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2d6:	7c1b      	ldrb	r3, [r3, #16]
 800a2d8:	220f      	movs	r2, #15
 800a2da:	fa02 f303 	lsl.w	r3, r2, r3
 800a2de:	43db      	mvns	r3, r3
 800a2e0:	9a05      	ldr	r2, [sp, #20]
 800a2e2:	4013      	ands	r3, r2
 800a2e4:	9305      	str	r3, [sp, #20]
 800a2e6:	9b03      	ldr	r3, [sp, #12]
 800a2e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a2ea:	0c1a      	lsrs	r2, r3, #16
 800a2ec:	9b03      	ldr	r3, [sp, #12]
 800a2ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2f0:	7c1b      	ldrb	r3, [r3, #16]
 800a2f2:	fa02 f303 	lsl.w	r3, r2, r3
 800a2f6:	9a05      	ldr	r2, [sp, #20]
 800a2f8:	4313      	orrs	r3, r2
 800a2fa:	9305      	str	r3, [sp, #20]
 800a2fc:	9b03      	ldr	r3, [sp, #12]
 800a2fe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a300:	68db      	ldr	r3, [r3, #12]
 800a302:	9a05      	ldr	r2, [sp, #20]
 800a304:	601a      	str	r2, [r3, #0]
 800a306:	9b03      	ldr	r3, [sp, #12]
 800a308:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a30a:	685b      	ldr	r3, [r3, #4]
 800a30c:	9a03      	ldr	r2, [sp, #12]
 800a30e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a310:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800a312:	9b03      	ldr	r3, [sp, #12]
 800a314:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a316:	685b      	ldr	r3, [r3, #4]
 800a318:	9a03      	ldr	r2, [sp, #12]
 800a31a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a31c:	6852      	ldr	r2, [r2, #4]
 800a31e:	6812      	ldr	r2, [r2, #0]
 800a320:	f042 0201 	orr.w	r2, r2, #1
 800a324:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800a326:	9b03      	ldr	r3, [sp, #12]
 800a328:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a32a:	4a0b      	ldr	r2, [pc, #44]	; (800a358 <sdc_lld_prepare_read_bytes+0xc8>)
 800a32c:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800a32e:	9b03      	ldr	r3, [sp, #12]
 800a330:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a332:	f44f 7295 	mov.w	r2, #298	; 0x12a
 800a336:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_RXOVERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = bytes;
 800a338:	9b03      	ldr	r3, [sp, #12]
 800a33a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a33c:	9a01      	ldr	r2, [sp, #4]
 800a33e:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 800a340:	9b03      	ldr	r3, [sp, #12]
 800a342:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a344:	220f      	movs	r2, #15
 800a346:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DTMODE |   /* multibyte data transfer */
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  return HAL_SUCCESS;
 800a348:	2300      	movs	r3, #0
}
 800a34a:	4618      	mov	r0, r3
 800a34c:	b007      	add	sp, #28
 800a34e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a352:	bf00      	nop
 800a354:	000927c0 	.word	0x000927c0
 800a358:	004005ff 	.word	0x004005ff
 800a35c:	f3af 8000 	nop.w

0800a360 <sdc_lld_prepare_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read(SDCDriver *sdcp, uint32_t startblk,
                                 uint32_t n, uint32_t *resp) {
 800a360:	b500      	push	{lr}
 800a362:	b085      	sub	sp, #20
 800a364:	9003      	str	r0, [sp, #12]
 800a366:	9102      	str	r1, [sp, #8]
 800a368:	9201      	str	r2, [sp, #4]
 800a36a:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800a36c:	9b03      	ldr	r3, [sp, #12]
 800a36e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a370:	f003 0310 	and.w	r3, r3, #16
 800a374:	2b00      	cmp	r3, #0
 800a376:	d102      	bne.n	800a37e <sdc_lld_prepare_read+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 800a378:	9b02      	ldr	r3, [sp, #8]
 800a37a:	025b      	lsls	r3, r3, #9
 800a37c:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 800a37e:	9b01      	ldr	r3, [sp, #4]
 800a380:	2b01      	cmp	r3, #1
 800a382:	d910      	bls.n	800a3a6 <sdc_lld_prepare_read+0x46>
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 800a384:	9803      	ldr	r0, [sp, #12]
 800a386:	2112      	movs	r1, #18
 800a388:	9a02      	ldr	r2, [sp, #8]
 800a38a:	9b00      	ldr	r3, [sp, #0]
 800a38c:	f000 fab8 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a390:	4603      	mov	r3, r0
 800a392:	2b00      	cmp	r3, #0
 800a394:	d105      	bne.n	800a3a2 <sdc_lld_prepare_read+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a396:	9b00      	ldr	r3, [sp, #0]
 800a398:	681a      	ldr	r2, [r3, #0]
 800a39a:	4b0e      	ldr	r3, [pc, #56]	; (800a3d4 <sdc_lld_prepare_read+0x74>)
 800a39c:	4013      	ands	r3, r2
 800a39e:	2b00      	cmp	r3, #0
 800a3a0:	d012      	beq.n	800a3c8 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 800a3a2:	2301      	movs	r3, #1
 800a3a4:	e011      	b.n	800a3ca <sdc_lld_prepare_read+0x6a>
  }
  else{
    /* Send read single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
 800a3a6:	9803      	ldr	r0, [sp, #12]
 800a3a8:	2111      	movs	r1, #17
 800a3aa:	9a02      	ldr	r2, [sp, #8]
 800a3ac:	9b00      	ldr	r3, [sp, #0]
 800a3ae:	f000 faa7 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a3b2:	4603      	mov	r3, r0
 800a3b4:	2b00      	cmp	r3, #0
 800a3b6:	d105      	bne.n	800a3c4 <sdc_lld_prepare_read+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a3b8:	9b00      	ldr	r3, [sp, #0]
 800a3ba:	681a      	ldr	r2, [r3, #0]
 800a3bc:	4b05      	ldr	r3, [pc, #20]	; (800a3d4 <sdc_lld_prepare_read+0x74>)
 800a3be:	4013      	ands	r3, r2
 800a3c0:	2b00      	cmp	r3, #0
 800a3c2:	d001      	beq.n	800a3c8 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 800a3c4:	2301      	movs	r3, #1
 800a3c6:	e000      	b.n	800a3ca <sdc_lld_prepare_read+0x6a>
  }

  return HAL_SUCCESS;
 800a3c8:	2300      	movs	r3, #0
}
 800a3ca:	4618      	mov	r0, r3
 800a3cc:	b005      	add	sp, #20
 800a3ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800a3d2:	bf00      	nop
 800a3d4:	fdffe008 	.word	0xfdffe008
 800a3d8:	f3af 8000 	nop.w
 800a3dc:	f3af 8000 	nop.w

0800a3e0 <sdc_lld_prepare_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_write(SDCDriver *sdcp, uint32_t startblk,
                                  uint32_t n, uint32_t *resp) {
 800a3e0:	b500      	push	{lr}
 800a3e2:	b085      	sub	sp, #20
 800a3e4:	9003      	str	r0, [sp, #12]
 800a3e6:	9102      	str	r1, [sp, #8]
 800a3e8:	9201      	str	r2, [sp, #4]
 800a3ea:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800a3ec:	9b03      	ldr	r3, [sp, #12]
 800a3ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a3f0:	f003 0310 	and.w	r3, r3, #16
 800a3f4:	2b00      	cmp	r3, #0
 800a3f6:	d102      	bne.n	800a3fe <sdc_lld_prepare_write+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 800a3f8:	9b02      	ldr	r3, [sp, #8]
 800a3fa:	025b      	lsls	r3, r3, #9
 800a3fc:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 800a3fe:	9b01      	ldr	r3, [sp, #4]
 800a400:	2b01      	cmp	r3, #1
 800a402:	d910      	bls.n	800a426 <sdc_lld_prepare_write+0x46>
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 800a404:	9803      	ldr	r0, [sp, #12]
 800a406:	2119      	movs	r1, #25
 800a408:	9a02      	ldr	r2, [sp, #8]
 800a40a:	9b00      	ldr	r3, [sp, #0]
 800a40c:	f000 fa78 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a410:	4603      	mov	r3, r0
 800a412:	2b00      	cmp	r3, #0
 800a414:	d105      	bne.n	800a422 <sdc_lld_prepare_write+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a416:	9b00      	ldr	r3, [sp, #0]
 800a418:	681a      	ldr	r2, [r3, #0]
 800a41a:	4b0e      	ldr	r3, [pc, #56]	; (800a454 <sdc_lld_prepare_write+0x74>)
 800a41c:	4013      	ands	r3, r2
 800a41e:	2b00      	cmp	r3, #0
 800a420:	d012      	beq.n	800a448 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 800a422:	2301      	movs	r3, #1
 800a424:	e011      	b.n	800a44a <sdc_lld_prepare_write+0x6a>
  }
  else{
    /* Write single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
 800a426:	9803      	ldr	r0, [sp, #12]
 800a428:	2118      	movs	r1, #24
 800a42a:	9a02      	ldr	r2, [sp, #8]
 800a42c:	9b00      	ldr	r3, [sp, #0]
 800a42e:	f000 fa67 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a432:	4603      	mov	r3, r0
 800a434:	2b00      	cmp	r3, #0
 800a436:	d105      	bne.n	800a444 <sdc_lld_prepare_write+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a438:	9b00      	ldr	r3, [sp, #0]
 800a43a:	681a      	ldr	r2, [r3, #0]
 800a43c:	4b05      	ldr	r3, [pc, #20]	; (800a454 <sdc_lld_prepare_write+0x74>)
 800a43e:	4013      	ands	r3, r2
 800a440:	2b00      	cmp	r3, #0
 800a442:	d001      	beq.n	800a448 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 800a444:	2301      	movs	r3, #1
 800a446:	e000      	b.n	800a44a <sdc_lld_prepare_write+0x6a>
  }

  return HAL_SUCCESS;
 800a448:	2300      	movs	r3, #0
}
 800a44a:	4618      	mov	r0, r3
 800a44c:	b005      	add	sp, #20
 800a44e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a452:	bf00      	nop
 800a454:	fdffe008 	.word	0xfdffe008
 800a458:	f3af 8000 	nop.w
 800a45c:	f3af 8000 	nop.w

0800a460 <sdc_lld_wait_transaction_end>:
 * @return              The operation status.
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 */
static bool sdc_lld_wait_transaction_end(SDCDriver *sdcp, uint32_t n,
                                         uint32_t *resp) {
 800a460:	b500      	push	{lr}
 800a462:	b085      	sub	sp, #20
 800a464:	9003      	str	r0, [sp, #12]
 800a466:	9102      	str	r1, [sp, #8]
 800a468:	9201      	str	r2, [sp, #4]

  /* Note the mask is checked before going to sleep because the interrupt
     may have occurred before reaching the critical zone.*/
  osalSysLock();
 800a46a:	f7ff fec1 	bl	800a1f0 <osalSysLock>
  if (sdcp->sdmmc->MASK != 0)
 800a46e:	9b03      	ldr	r3, [sp, #12]
 800a470:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a472:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a474:	2b00      	cmp	r3, #0
 800a476:	d004      	beq.n	800a482 <sdc_lld_wait_transaction_end+0x22>
    osalThreadSuspendS(&sdcp->thread);
 800a478:	9b03      	ldr	r3, [sp, #12]
 800a47a:	333c      	adds	r3, #60	; 0x3c
 800a47c:	4618      	mov	r0, r3
 800a47e:	f7ff fee7 	bl	800a250 <osalThreadSuspendS>
  if ((sdcp->sdmmc->STA & SDMMC_STA_DATAEND) == 0) {
 800a482:	9b03      	ldr	r3, [sp, #12]
 800a484:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a486:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a488:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800a48c:	2b00      	cmp	r3, #0
 800a48e:	d103      	bne.n	800a498 <sdc_lld_wait_transaction_end+0x38>
    osalSysUnlock();
 800a490:	f7ff feb6 	bl	800a200 <osalSysUnlock>
    return HAL_FAILED;
 800a494:	2301      	movs	r3, #1
 800a496:	e030      	b.n	800a4fa <sdc_lld_wait_transaction_end+0x9a>
  }

  /* Waits for transfer completion at DMA level, then the stream is
     disabled and cleared.*/
  dmaWaitCompletion(sdcp->dma);
 800a498:	bf00      	nop
 800a49a:	9b03      	ldr	r3, [sp, #12]
 800a49c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a49e:	685b      	ldr	r3, [r3, #4]
 800a4a0:	685b      	ldr	r3, [r3, #4]
 800a4a2:	2b00      	cmp	r3, #0
 800a4a4:	d1f9      	bne.n	800a49a <sdc_lld_wait_transaction_end+0x3a>
 800a4a6:	9b03      	ldr	r3, [sp, #12]
 800a4a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a4aa:	685b      	ldr	r3, [r3, #4]
 800a4ac:	9a03      	ldr	r2, [sp, #12]
 800a4ae:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a4b0:	6852      	ldr	r2, [r2, #4]
 800a4b2:	6812      	ldr	r2, [r2, #0]
 800a4b4:	f022 020f 	bic.w	r2, r2, #15
 800a4b8:	601a      	str	r2, [r3, #0]
 800a4ba:	9b03      	ldr	r3, [sp, #12]
 800a4bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a4be:	681b      	ldr	r3, [r3, #0]
 800a4c0:	9a03      	ldr	r2, [sp, #12]
 800a4c2:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a4c4:	7c12      	ldrb	r2, [r2, #16]
 800a4c6:	210f      	movs	r1, #15
 800a4c8:	fa01 f202 	lsl.w	r2, r1, r2
 800a4cc:	605a      	str	r2, [r3, #4]

  sdcp->sdmmc->ICR = SDMMC_ICR_ALL_FLAGS;
 800a4ce:	9b03      	ldr	r3, [sp, #12]
 800a4d0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a4d2:	4a0c      	ldr	r2, [pc, #48]	; (800a504 <sdc_lld_wait_transaction_end+0xa4>)
 800a4d4:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->DCTRL = 0;
 800a4d6:	9b03      	ldr	r3, [sp, #12]
 800a4d8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a4da:	2200      	movs	r2, #0
 800a4dc:	62da      	str	r2, [r3, #44]	; 0x2c
  osalSysUnlock();
 800a4de:	f7ff fe8f 	bl	800a200 <osalSysUnlock>

  /* Finalize transaction.*/
  if (n > 1)
 800a4e2:	9b02      	ldr	r3, [sp, #8]
 800a4e4:	2b01      	cmp	r3, #1
 800a4e6:	d907      	bls.n	800a4f8 <sdc_lld_wait_transaction_end+0x98>
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 800a4e8:	9803      	ldr	r0, [sp, #12]
 800a4ea:	210c      	movs	r1, #12
 800a4ec:	2200      	movs	r2, #0
 800a4ee:	9b01      	ldr	r3, [sp, #4]
 800a4f0:	f000 fa06 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a4f4:	4603      	mov	r3, r0
 800a4f6:	e000      	b.n	800a4fa <sdc_lld_wait_transaction_end+0x9a>

  return HAL_SUCCESS;
 800a4f8:	2300      	movs	r3, #0
}
 800a4fa:	4618      	mov	r0, r3
 800a4fc:	b005      	add	sp, #20
 800a4fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800a502:	bf00      	nop
 800a504:	004005ff 	.word	0x004005ff
 800a508:	f3af 8000 	nop.w
 800a50c:	f3af 8000 	nop.w

0800a510 <sdc_lld_collect_errors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] sta       value of the STA register
 *
 * @notapi
 */
static void sdc_lld_collect_errors(SDCDriver *sdcp, uint32_t sta) {
 800a510:	b084      	sub	sp, #16
 800a512:	9001      	str	r0, [sp, #4]
 800a514:	9100      	str	r1, [sp, #0]
  uint32_t errors = SDC_NO_ERROR;
 800a516:	2300      	movs	r3, #0
 800a518:	9303      	str	r3, [sp, #12]

  if (sta & SDMMC_STA_CCRCFAIL)
 800a51a:	9b00      	ldr	r3, [sp, #0]
 800a51c:	f003 0301 	and.w	r3, r3, #1
 800a520:	2b00      	cmp	r3, #0
 800a522:	d003      	beq.n	800a52c <sdc_lld_collect_errors+0x1c>
    errors |= SDC_CMD_CRC_ERROR;
 800a524:	9b03      	ldr	r3, [sp, #12]
 800a526:	f043 0301 	orr.w	r3, r3, #1
 800a52a:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_DCRCFAIL)
 800a52c:	9b00      	ldr	r3, [sp, #0]
 800a52e:	f003 0302 	and.w	r3, r3, #2
 800a532:	2b00      	cmp	r3, #0
 800a534:	d003      	beq.n	800a53e <sdc_lld_collect_errors+0x2e>
    errors |= SDC_DATA_CRC_ERROR;
 800a536:	9b03      	ldr	r3, [sp, #12]
 800a538:	f043 0302 	orr.w	r3, r3, #2
 800a53c:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_CTIMEOUT)
 800a53e:	9b00      	ldr	r3, [sp, #0]
 800a540:	f003 0304 	and.w	r3, r3, #4
 800a544:	2b00      	cmp	r3, #0
 800a546:	d003      	beq.n	800a550 <sdc_lld_collect_errors+0x40>
    errors |= SDC_COMMAND_TIMEOUT;
 800a548:	9b03      	ldr	r3, [sp, #12]
 800a54a:	f043 0308 	orr.w	r3, r3, #8
 800a54e:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_DTIMEOUT)
 800a550:	9b00      	ldr	r3, [sp, #0]
 800a552:	f003 0308 	and.w	r3, r3, #8
 800a556:	2b00      	cmp	r3, #0
 800a558:	d003      	beq.n	800a562 <sdc_lld_collect_errors+0x52>
    errors |= SDC_DATA_TIMEOUT;
 800a55a:	9b03      	ldr	r3, [sp, #12]
 800a55c:	f043 0304 	orr.w	r3, r3, #4
 800a560:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_TXUNDERR)
 800a562:	9b00      	ldr	r3, [sp, #0]
 800a564:	f003 0310 	and.w	r3, r3, #16
 800a568:	2b00      	cmp	r3, #0
 800a56a:	d003      	beq.n	800a574 <sdc_lld_collect_errors+0x64>
    errors |= SDC_TX_UNDERRUN;
 800a56c:	9b03      	ldr	r3, [sp, #12]
 800a56e:	f043 0310 	orr.w	r3, r3, #16
 800a572:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_RXOVERR)
 800a574:	9b00      	ldr	r3, [sp, #0]
 800a576:	f003 0320 	and.w	r3, r3, #32
 800a57a:	2b00      	cmp	r3, #0
 800a57c:	d003      	beq.n	800a586 <sdc_lld_collect_errors+0x76>
    errors |= SDC_RX_OVERRUN;
 800a57e:	9b03      	ldr	r3, [sp, #12]
 800a580:	f043 0320 	orr.w	r3, r3, #32
 800a584:	9303      	str	r3, [sp, #12]
/*  if (sta & SDMMC_STA_STBITERR)
    errors |= SDC_STARTBIT_ERROR;*/

  sdcp->errors |= errors;
 800a586:	9b01      	ldr	r3, [sp, #4]
 800a588:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a58a:	9b03      	ldr	r3, [sp, #12]
 800a58c:	431a      	orrs	r2, r3
 800a58e:	9b01      	ldr	r3, [sp, #4]
 800a590:	635a      	str	r2, [r3, #52]	; 0x34
}
 800a592:	b004      	add	sp, #16
 800a594:	4770      	bx	lr
 800a596:	bf00      	nop
 800a598:	f3af 8000 	nop.w
 800a59c:	f3af 8000 	nop.w

0800a5a0 <sdc_lld_error_cleanup>:
 *
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
 800a5a0:	b500      	push	{lr}
 800a5a2:	b087      	sub	sp, #28
 800a5a4:	9003      	str	r0, [sp, #12]
 800a5a6:	9102      	str	r1, [sp, #8]
 800a5a8:	9201      	str	r2, [sp, #4]
  uint32_t sta = sdcp->sdmmc->STA;
 800a5aa:	9b03      	ldr	r3, [sp, #12]
 800a5ac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a5b0:	9305      	str	r3, [sp, #20]

  dmaStreamDisable(sdcp->dma);
 800a5b2:	9b03      	ldr	r3, [sp, #12]
 800a5b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a5b6:	685b      	ldr	r3, [r3, #4]
 800a5b8:	9a03      	ldr	r2, [sp, #12]
 800a5ba:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a5bc:	6852      	ldr	r2, [r2, #4]
 800a5be:	6812      	ldr	r2, [r2, #0]
 800a5c0:	f022 020f 	bic.w	r2, r2, #15
 800a5c4:	601a      	str	r2, [r3, #0]
 800a5c6:	9b03      	ldr	r3, [sp, #12]
 800a5c8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a5ca:	681b      	ldr	r3, [r3, #0]
 800a5cc:	9a03      	ldr	r2, [sp, #12]
 800a5ce:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a5d0:	7c12      	ldrb	r2, [r2, #16]
 800a5d2:	210f      	movs	r1, #15
 800a5d4:	fa01 f202 	lsl.w	r2, r1, r2
 800a5d8:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800a5da:	9b03      	ldr	r3, [sp, #12]
 800a5dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5de:	4a0d      	ldr	r2, [pc, #52]	; (800a614 <sdc_lld_error_cleanup+0x74>)
 800a5e0:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = 0;
 800a5e2:	9b03      	ldr	r3, [sp, #12]
 800a5e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5e6:	2200      	movs	r2, #0
 800a5e8:	63da      	str	r2, [r3, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = 0;
 800a5ea:	9b03      	ldr	r3, [sp, #12]
 800a5ec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5ee:	2200      	movs	r2, #0
 800a5f0:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 800a5f2:	9803      	ldr	r0, [sp, #12]
 800a5f4:	9905      	ldr	r1, [sp, #20]
 800a5f6:	f7ff ff8b 	bl	800a510 <sdc_lld_collect_errors>

  if (n > 1)
 800a5fa:	9b02      	ldr	r3, [sp, #8]
 800a5fc:	2b01      	cmp	r3, #1
 800a5fe:	d905      	bls.n	800a60c <sdc_lld_error_cleanup+0x6c>
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 800a600:	9803      	ldr	r0, [sp, #12]
 800a602:	210c      	movs	r1, #12
 800a604:	2200      	movs	r2, #0
 800a606:	9b01      	ldr	r3, [sp, #4]
 800a608:	f000 f97a 	bl	800a900 <sdc_lld_send_cmd_short_crc>
}
 800a60c:	b007      	add	sp, #28
 800a60e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a612:	bf00      	nop
 800a614:	004005ff 	.word	0x004005ff
 800a618:	f3af 8000 	nop.w
 800a61c:	f3af 8000 	nop.w

0800a620 <Vector104>:
 * @details It just wakes transaction thread. All error  handling performs in
 *          that thread.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDMMC1_HANDLER) {
 800a620:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 800a622:	f7ff fdf5 	bl	800a210 <osalSysLockFromISR>

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  SDMMC1->MASK = 0;
 800a626:	4b06      	ldr	r3, [pc, #24]	; (800a640 <Vector104+0x20>)
 800a628:	2200      	movs	r2, #0
 800a62a:	63da      	str	r2, [r3, #60]	; 0x3c

  osalThreadResumeI(&SDCD1.thread, MSG_OK);
 800a62c:	4805      	ldr	r0, [pc, #20]	; (800a644 <Vector104+0x24>)
 800a62e:	2100      	movs	r1, #0
 800a630:	f7ff fe1e 	bl	800a270 <osalThreadResumeI>

  osalSysUnlockFromISR();
 800a634:	f7ff fdf4 	bl	800a220 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 800a638:	f7f9 fa8a 	bl	8003b50 <_port_irq_epilogue>
}
 800a63c:	bd08      	pop	{r3, pc}
 800a63e:	bf00      	nop
 800a640:	40012800 	.word	0x40012800
 800a644:	20003d78 	.word	0x20003d78
 800a648:	f3af 8000 	nop.w
 800a64c:	f3af 8000 	nop.w

0800a650 <sdc_lld_init>:
/**
 * @brief   Low level SDC driver initialization.
 *
 * @notapi
 */
void sdc_lld_init(void) {
 800a650:	b508      	push	{r3, lr}

  sdcObjectInit(&SDCD1);
 800a652:	4806      	ldr	r0, [pc, #24]	; (800a66c <sdc_lld_init+0x1c>)
 800a654:	f7fb fa14 	bl	8005a80 <sdcObjectInit>
  SDCD1.thread = NULL;
 800a658:	4b04      	ldr	r3, [pc, #16]	; (800a66c <sdc_lld_init+0x1c>)
 800a65a:	2200      	movs	r2, #0
 800a65c:	63da      	str	r2, [r3, #60]	; 0x3c
  SDCD1.dma    = STM32_DMA_STREAM(STM32_SDC_SDMMC1_DMA_STREAM);
 800a65e:	4b03      	ldr	r3, [pc, #12]	; (800a66c <sdc_lld_init+0x1c>)
 800a660:	4a03      	ldr	r2, [pc, #12]	; (800a670 <sdc_lld_init+0x20>)
 800a662:	645a      	str	r2, [r3, #68]	; 0x44
  SDCD1.sdmmc  = SDMMC1;
 800a664:	4b01      	ldr	r3, [pc, #4]	; (800a66c <sdc_lld_init+0x1c>)
 800a666:	4a03      	ldr	r2, [pc, #12]	; (800a674 <sdc_lld_init+0x24>)
 800a668:	649a      	str	r2, [r3, #72]	; 0x48
}
 800a66a:	bd08      	pop	{r3, pc}
 800a66c:	20003d3c 	.word	0x20003d3c
 800a670:	0801ab88 	.word	0x0801ab88
 800a674:	40012800 	.word	0x40012800
 800a678:	f3af 8000 	nop.w
 800a67c:	f3af 8000 	nop.w

0800a680 <sdc_lld_start>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start(SDCDriver *sdcp) {
 800a680:	b500      	push	{lr}
 800a682:	b085      	sub	sp, #20
 800a684:	9001      	str	r0, [sp, #4]

  /* Checking configuration, using a default if NULL has been passed.*/
  if (sdcp->config == NULL) {
 800a686:	9b01      	ldr	r3, [sp, #4]
 800a688:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a68a:	2b00      	cmp	r3, #0
 800a68c:	d102      	bne.n	800a694 <sdc_lld_start+0x14>
    sdcp->config = &sdc_default_cfg;
 800a68e:	9b01      	ldr	r3, [sp, #4]
 800a690:	4a1b      	ldr	r2, [pc, #108]	; (800a700 <sdc_lld_start+0x80>)
 800a692:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  sdcp->dmamode = STM32_DMA_CR_CHSEL(DMA_CHANNEL) |
 800a694:	9b01      	ldr	r3, [sp, #4]
 800a696:	4a1b      	ldr	r2, [pc, #108]	; (800a704 <sdc_lld_start+0x84>)
 800a698:	641a      	str	r2, [r3, #64]	; 0x40
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
                   STM32_DMA_CR_PBURST_INCR4 |
                   STM32_DMA_CR_MBURST_INCR4;
#endif

  if (sdcp->state == BLK_STOP) {
 800a69a:	9b01      	ldr	r3, [sp, #4]
 800a69c:	791b      	ldrb	r3, [r3, #4]
 800a69e:	2b01      	cmp	r3, #1
 800a6a0:	d11b      	bne.n	800a6da <sdc_lld_start+0x5a>
    /* Note, the DMA must be enabled before the IRQs.*/
    bool b;
    b = dmaStreamAllocate(sdcp->dma, STM32_SDC_SDMMC1_IRQ_PRIORITY, NULL, NULL);
 800a6a2:	9b01      	ldr	r3, [sp, #4]
 800a6a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a6a6:	4618      	mov	r0, r3
 800a6a8:	2109      	movs	r1, #9
 800a6aa:	2200      	movs	r2, #0
 800a6ac:	2300      	movs	r3, #0
 800a6ae:	f7fd fb5f 	bl	8007d70 <dmaStreamAllocate>
 800a6b2:	4603      	mov	r3, r0
 800a6b4:	f88d 300f 	strb.w	r3, [sp, #15]
    osalDbgAssert(!b, "stream already allocated");
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdmmc->FIFO);
 800a6b8:	9b01      	ldr	r3, [sp, #4]
 800a6ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a6bc:	685b      	ldr	r3, [r3, #4]
 800a6be:	9a01      	ldr	r2, [sp, #4]
 800a6c0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a6c2:	3280      	adds	r2, #128	; 0x80
 800a6c4:	609a      	str	r2, [r3, #8]
#if STM32_DMA_ADVANCED
    dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS | STM32_DMA_FCR_FTH_FULL);
#endif
    nvicEnableVector(STM32_SDMMC1_NUMBER, STM32_SDC_SDMMC1_IRQ_PRIORITY);
 800a6c6:	2031      	movs	r0, #49	; 0x31
 800a6c8:	2109      	movs	r1, #9
 800a6ca:	f7fc fe31 	bl	8007330 <nvicEnableVector>
    rccEnableSDMMC1(FALSE);
 800a6ce:	4b0e      	ldr	r3, [pc, #56]	; (800a708 <sdc_lld_start+0x88>)
 800a6d0:	4a0d      	ldr	r2, [pc, #52]	; (800a708 <sdc_lld_start+0x88>)
 800a6d2:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800a6d4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a6d8:	661a      	str	r2, [r3, #96]	; 0x60
  }

  /* Configuration, card clock is initially stopped.*/
  sdcp->sdmmc->POWER  = 0;
 800a6da:	9b01      	ldr	r3, [sp, #4]
 800a6dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6de:	2200      	movs	r2, #0
 800a6e0:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR  = 0;
 800a6e2:	9b01      	ldr	r3, [sp, #4]
 800a6e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6e6:	2200      	movs	r2, #0
 800a6e8:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->DCTRL  = 0;
 800a6ea:	9b01      	ldr	r3, [sp, #4]
 800a6ec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6ee:	2200      	movs	r2, #0
 800a6f0:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->sdmmc->DTIMER = 0;
 800a6f2:	9b01      	ldr	r3, [sp, #4]
 800a6f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6f6:	2200      	movs	r2, #0
 800a6f8:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a6fa:	b005      	add	sp, #20
 800a6fc:	f85d fb04 	ldr.w	pc, [sp], #4
 800a700:	0801ac20 	.word	0x0801ac20
 800a704:	00073a80 	.word	0x00073a80
 800a708:	40021000 	.word	0x40021000
 800a70c:	f3af 8000 	nop.w

0800a710 <sdc_lld_stop>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop(SDCDriver *sdcp) {
 800a710:	b500      	push	{lr}
 800a712:	b083      	sub	sp, #12
 800a714:	9001      	str	r0, [sp, #4]

  if (sdcp->state != BLK_STOP) {
 800a716:	9b01      	ldr	r3, [sp, #4]
 800a718:	791b      	ldrb	r3, [r3, #4]
 800a71a:	2b01      	cmp	r3, #1
 800a71c:	d01d      	beq.n	800a75a <sdc_lld_stop+0x4a>

    /* SDIO deactivation.*/
    sdcp->sdmmc->POWER  = 0;
 800a71e:	9b01      	ldr	r3, [sp, #4]
 800a720:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a722:	2200      	movs	r2, #0
 800a724:	601a      	str	r2, [r3, #0]
    sdcp->sdmmc->CLKCR  = 0;
 800a726:	9b01      	ldr	r3, [sp, #4]
 800a728:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a72a:	2200      	movs	r2, #0
 800a72c:	605a      	str	r2, [r3, #4]
    sdcp->sdmmc->DCTRL  = 0;
 800a72e:	9b01      	ldr	r3, [sp, #4]
 800a730:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a732:	2200      	movs	r2, #0
 800a734:	62da      	str	r2, [r3, #44]	; 0x2c
    sdcp->sdmmc->DTIMER = 0;
 800a736:	9b01      	ldr	r3, [sp, #4]
 800a738:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a73a:	2200      	movs	r2, #0
 800a73c:	625a      	str	r2, [r3, #36]	; 0x24

    /* Clock deactivation.*/
    nvicDisableVector(STM32_SDMMC1_NUMBER);
 800a73e:	2031      	movs	r0, #49	; 0x31
 800a740:	f7fc fe1e 	bl	8007380 <nvicDisableVector>
    dmaStreamRelease(sdcp->dma);
 800a744:	9b01      	ldr	r3, [sp, #4]
 800a746:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a748:	4618      	mov	r0, r3
 800a74a:	f7fd fb81 	bl	8007e50 <dmaStreamRelease>
    rccDisableSDMMC1(FALSE);
 800a74e:	4b04      	ldr	r3, [pc, #16]	; (800a760 <sdc_lld_stop+0x50>)
 800a750:	4a03      	ldr	r2, [pc, #12]	; (800a760 <sdc_lld_stop+0x50>)
 800a752:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800a754:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a758:	661a      	str	r2, [r3, #96]	; 0x60
  }
}
 800a75a:	b003      	add	sp, #12
 800a75c:	f85d fb04 	ldr.w	pc, [sp], #4
 800a760:	40021000 	.word	0x40021000
 800a764:	f3af 8000 	nop.w
 800a768:	f3af 8000 	nop.w
 800a76c:	f3af 8000 	nop.w

0800a770 <sdc_lld_start_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start_clk(SDCDriver *sdcp) {
 800a770:	b500      	push	{lr}
 800a772:	b083      	sub	sp, #12
 800a774:	9001      	str	r0, [sp, #4]

  /* Initial clock setting: 400kHz, 1bit mode.*/
  sdcp->sdmmc->CLKCR  = SDMMC_CLKDIV_LS;
 800a776:	9b01      	ldr	r3, [sp, #4]
 800a778:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a77a:	2276      	movs	r2, #118	; 0x76
 800a77c:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER |= SDMMC_POWER_PWRCTRL_0 | SDMMC_POWER_PWRCTRL_1;
 800a77e:	9b01      	ldr	r3, [sp, #4]
 800a780:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a782:	9a01      	ldr	r2, [sp, #4]
 800a784:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a786:	6812      	ldr	r2, [r2, #0]
 800a788:	f042 0203 	orr.w	r2, r2, #3
 800a78c:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR |= SDMMC_CLKCR_CLKEN;
 800a78e:	9b01      	ldr	r3, [sp, #4]
 800a790:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a792:	9a01      	ldr	r2, [sp, #4]
 800a794:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a796:	6852      	ldr	r2, [r2, #4]
 800a798:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800a79c:	605a      	str	r2, [r3, #4]

  /* Clock activation delay.*/
  osalThreadSleep(OSAL_MS2ST(STM32_SDC_SDMMC_CLOCK_DELAY));
 800a79e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800a7a2:	f7ff fd45 	bl	800a230 <osalThreadSleep>
}
 800a7a6:	b003      	add	sp, #12
 800a7a8:	f85d fb04 	ldr.w	pc, [sp], #4
 800a7ac:	f3af 8000 	nop.w

0800a7b0 <sdc_lld_set_data_clk>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] clk       the clock mode
 *
 * @notapi
 */
void sdc_lld_set_data_clk(SDCDriver *sdcp, sdcbusclk_t clk) {
 800a7b0:	b082      	sub	sp, #8
 800a7b2:	9001      	str	r0, [sp, #4]
 800a7b4:	460b      	mov	r3, r1
 800a7b6:	f88d 3003 	strb.w	r3, [sp, #3]
  else
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) | SDMMC_CLKDIV_HS;
#else
  (void)clk;

  sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) | SDMMC_CLKDIV_HS;
 800a7ba:	9b01      	ldr	r3, [sp, #4]
 800a7bc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7be:	9a01      	ldr	r2, [sp, #4]
 800a7c0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a7c2:	6852      	ldr	r2, [r2, #4]
 800a7c4:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800a7c8:	605a      	str	r2, [r3, #4]
#endif
}
 800a7ca:	b002      	add	sp, #8
 800a7cc:	4770      	bx	lr
 800a7ce:	bf00      	nop

0800a7d0 <sdc_lld_stop_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop_clk(SDCDriver *sdcp) {
 800a7d0:	b082      	sub	sp, #8
 800a7d2:	9001      	str	r0, [sp, #4]

  sdcp->sdmmc->CLKCR = 0;
 800a7d4:	9b01      	ldr	r3, [sp, #4]
 800a7d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7d8:	2200      	movs	r2, #0
 800a7da:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER = 0;
 800a7dc:	9b01      	ldr	r3, [sp, #4]
 800a7de:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7e0:	2200      	movs	r2, #0
 800a7e2:	601a      	str	r2, [r3, #0]
}
 800a7e4:	b002      	add	sp, #8
 800a7e6:	4770      	bx	lr
 800a7e8:	f3af 8000 	nop.w
 800a7ec:	f3af 8000 	nop.w

0800a7f0 <sdc_lld_set_bus_mode>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
 800a7f0:	b084      	sub	sp, #16
 800a7f2:	9001      	str	r0, [sp, #4]
 800a7f4:	460b      	mov	r3, r1
 800a7f6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 800a7fa:	9b01      	ldr	r3, [sp, #4]
 800a7fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7fe:	685b      	ldr	r3, [r3, #4]
 800a800:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 800a804:	9303      	str	r3, [sp, #12]

  switch (mode) {
 800a806:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a80a:	2b01      	cmp	r3, #1
 800a80c:	d008      	beq.n	800a820 <sdc_lld_set_bus_mode+0x30>
 800a80e:	2b02      	cmp	r3, #2
 800a810:	d00d      	beq.n	800a82e <sdc_lld_set_bus_mode+0x3e>
 800a812:	2b00      	cmp	r3, #0
 800a814:	d112      	bne.n	800a83c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_1BIT:
    sdcp->sdmmc->CLKCR = clk;
 800a816:	9b01      	ldr	r3, [sp, #4]
 800a818:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a81a:	9a03      	ldr	r2, [sp, #12]
 800a81c:	605a      	str	r2, [r3, #4]
    break;
 800a81e:	e00d      	b.n	800a83c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_4BIT:
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_0;
 800a820:	9b01      	ldr	r3, [sp, #4]
 800a822:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a824:	9a03      	ldr	r2, [sp, #12]
 800a826:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800a82a:	605a      	str	r2, [r3, #4]
    break;
 800a82c:	e006      	b.n	800a83c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_8BIT:
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_1;
 800a82e:	9b01      	ldr	r3, [sp, #4]
 800a830:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a832:	9a03      	ldr	r2, [sp, #12]
 800a834:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800a838:	605a      	str	r2, [r3, #4]
    break;
 800a83a:	bf00      	nop
  }
}
 800a83c:	b004      	add	sp, #16
 800a83e:	4770      	bx	lr

0800a840 <sdc_lld_send_cmd_none>:
 * @param[in] cmd       card command
 * @param[in] arg       command argument
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {
 800a840:	b084      	sub	sp, #16
 800a842:	9003      	str	r0, [sp, #12]
 800a844:	460b      	mov	r3, r1
 800a846:	9201      	str	r2, [sp, #4]
 800a848:	f88d 300b 	strb.w	r3, [sp, #11]

  sdcp->sdmmc->ARG = arg;
 800a84c:	9b03      	ldr	r3, [sp, #12]
 800a84e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a850:	9a01      	ldr	r2, [sp, #4]
 800a852:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 800a854:	9b03      	ldr	r3, [sp, #12]
 800a856:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a858:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a85c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a860:	60da      	str	r2, [r3, #12]
  while ((sdcp->sdmmc->STA & SDMMC_STA_CMDSENT) == 0)
 800a862:	bf00      	nop
 800a864:	9b03      	ldr	r3, [sp, #12]
 800a866:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a868:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a86a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a86e:	2b00      	cmp	r3, #0
 800a870:	d0f8      	beq.n	800a864 <sdc_lld_send_cmd_none+0x24>
    ;
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
 800a872:	9b03      	ldr	r3, [sp, #12]
 800a874:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a876:	2280      	movs	r2, #128	; 0x80
 800a878:	639a      	str	r2, [r3, #56]	; 0x38
}
 800a87a:	b004      	add	sp, #16
 800a87c:	4770      	bx	lr
 800a87e:	bf00      	nop

0800a880 <sdc_lld_send_cmd_short>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
 800a880:	b500      	push	{lr}
 800a882:	b087      	sub	sp, #28
 800a884:	9003      	str	r0, [sp, #12]
 800a886:	9201      	str	r2, [sp, #4]
 800a888:	9300      	str	r3, [sp, #0]
 800a88a:	460b      	mov	r3, r1
 800a88c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdmmc->ARG = arg;
 800a890:	9b03      	ldr	r3, [sp, #12]
 800a892:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a894:	9a01      	ldr	r2, [sp, #4]
 800a896:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800a898:	9b03      	ldr	r3, [sp, #12]
 800a89a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a89c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a8a0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a8a4:	b2d2      	uxtb	r2, r2
 800a8a6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a8aa:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a8ac:	bf00      	nop
 800a8ae:	9b03      	ldr	r3, [sp, #12]
 800a8b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a8b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a8b4:	9305      	str	r3, [sp, #20]
 800a8b6:	9b05      	ldr	r3, [sp, #20]
 800a8b8:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800a8bc:	2b00      	cmp	r3, #0
 800a8be:	d0f6      	beq.n	800a8ae <sdc_lld_send_cmd_short+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a8c0:	9b03      	ldr	r3, [sp, #12]
 800a8c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a8c4:	9a05      	ldr	r2, [sp, #20]
 800a8c6:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800a8ca:	639a      	str	r2, [r3, #56]	; 0x38
                           SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
 800a8cc:	9b05      	ldr	r3, [sp, #20]
 800a8ce:	f003 0304 	and.w	r3, r3, #4
 800a8d2:	2b00      	cmp	r3, #0
 800a8d4:	d005      	beq.n	800a8e2 <sdc_lld_send_cmd_short+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 800a8d6:	9803      	ldr	r0, [sp, #12]
 800a8d8:	9905      	ldr	r1, [sp, #20]
 800a8da:	f7ff fe19 	bl	800a510 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800a8de:	2301      	movs	r3, #1
 800a8e0:	e005      	b.n	800a8ee <sdc_lld_send_cmd_short+0x6e>
  }
  *resp = sdcp->sdmmc->RESP1;
 800a8e2:	9b03      	ldr	r3, [sp, #12]
 800a8e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a8e6:	695a      	ldr	r2, [r3, #20]
 800a8e8:	9b00      	ldr	r3, [sp, #0]
 800a8ea:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 800a8ec:	2300      	movs	r3, #0
}
 800a8ee:	4618      	mov	r0, r3
 800a8f0:	b007      	add	sp, #28
 800a8f2:	f85d fb04 	ldr.w	pc, [sp], #4
 800a8f6:	bf00      	nop
 800a8f8:	f3af 8000 	nop.w
 800a8fc:	f3af 8000 	nop.w

0800a900 <sdc_lld_send_cmd_short_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                                uint32_t *resp) {
 800a900:	b500      	push	{lr}
 800a902:	b087      	sub	sp, #28
 800a904:	9003      	str	r0, [sp, #12]
 800a906:	9201      	str	r2, [sp, #4]
 800a908:	9300      	str	r3, [sp, #0]
 800a90a:	460b      	mov	r3, r1
 800a90c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdmmc->ARG = arg;
 800a910:	9b03      	ldr	r3, [sp, #12]
 800a912:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a914:	9a01      	ldr	r2, [sp, #4]
 800a916:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800a918:	9b03      	ldr	r3, [sp, #12]
 800a91a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a91c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a920:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a924:	b2d2      	uxtb	r2, r2
 800a926:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a92a:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a92c:	bf00      	nop
 800a92e:	9b03      	ldr	r3, [sp, #12]
 800a930:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a932:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a934:	9305      	str	r3, [sp, #20]
 800a936:	9b05      	ldr	r3, [sp, #20]
 800a938:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800a93c:	2b00      	cmp	r3, #0
 800a93e:	d0f6      	beq.n	800a92e <sdc_lld_send_cmd_short_crc+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL);
 800a940:	9b03      	ldr	r3, [sp, #12]
 800a942:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a944:	9a05      	ldr	r2, [sp, #20]
 800a946:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800a94a:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 800a94c:	9b05      	ldr	r3, [sp, #20]
 800a94e:	f003 0305 	and.w	r3, r3, #5
 800a952:	2b00      	cmp	r3, #0
 800a954:	d005      	beq.n	800a962 <sdc_lld_send_cmd_short_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 800a956:	9803      	ldr	r0, [sp, #12]
 800a958:	9905      	ldr	r1, [sp, #20]
 800a95a:	f7ff fdd9 	bl	800a510 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800a95e:	2301      	movs	r3, #1
 800a960:	e005      	b.n	800a96e <sdc_lld_send_cmd_short_crc+0x6e>
  }
  *resp = sdcp->sdmmc->RESP1;
 800a962:	9b03      	ldr	r3, [sp, #12]
 800a964:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a966:	695a      	ldr	r2, [r3, #20]
 800a968:	9b00      	ldr	r3, [sp, #0]
 800a96a:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 800a96c:	2300      	movs	r3, #0
}
 800a96e:	4618      	mov	r0, r3
 800a970:	b007      	add	sp, #28
 800a972:	f85d fb04 	ldr.w	pc, [sp], #4
 800a976:	bf00      	nop
 800a978:	f3af 8000 	nop.w
 800a97c:	f3af 8000 	nop.w

0800a980 <sdc_lld_send_cmd_long_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_long_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                               uint32_t *resp) {
 800a980:	b500      	push	{lr}
 800a982:	b087      	sub	sp, #28
 800a984:	9003      	str	r0, [sp, #12]
 800a986:	9201      	str	r2, [sp, #4]
 800a988:	9300      	str	r3, [sp, #0]
 800a98a:	460b      	mov	r3, r1
 800a98c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  (void)sdcp;

  sdcp->sdmmc->ARG = arg;
 800a990:	9b03      	ldr	r3, [sp, #12]
 800a992:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a994:	9a01      	ldr	r2, [sp, #4]
 800a996:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 800a998:	9b03      	ldr	r3, [sp, #12]
 800a99a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a99c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a9a0:	f062 023f 	orn	r2, r2, #63	; 0x3f
 800a9a4:	b2d2      	uxtb	r2, r2
 800a9a6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a9aa:	60da      	str	r2, [r3, #12]
                                    SDMMC_CMD_CPSMEN;
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a9ac:	bf00      	nop
 800a9ae:	9b03      	ldr	r3, [sp, #12]
 800a9b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a9b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a9b4:	9305      	str	r3, [sp, #20]
 800a9b6:	9b05      	ldr	r3, [sp, #20]
 800a9b8:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800a9bc:	2b00      	cmp	r3, #0
 800a9be:	d0f6      	beq.n	800a9ae <sdc_lld_send_cmd_long_crc+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a9c0:	9b03      	ldr	r3, [sp, #12]
 800a9c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a9c4:	9a05      	ldr	r2, [sp, #20]
 800a9c6:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800a9ca:	639a      	str	r2, [r3, #56]	; 0x38
                           SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_ERROR_MASK)) != 0) {
 800a9cc:	9b05      	ldr	r3, [sp, #20]
 800a9ce:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a9d2:	2b00      	cmp	r3, #0
 800a9d4:	d005      	beq.n	800a9e2 <sdc_lld_send_cmd_long_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 800a9d6:	9803      	ldr	r0, [sp, #12]
 800a9d8:	9905      	ldr	r1, [sp, #20]
 800a9da:	f7ff fd99 	bl	800a510 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800a9de:	2301      	movs	r3, #1
 800a9e0:	e01a      	b.n	800aa18 <sdc_lld_send_cmd_long_crc+0x98>
  }
  /* Save bytes in reverse order because MSB in response comes first.*/
  *resp++ = sdcp->sdmmc->RESP4;
 800a9e2:	9b00      	ldr	r3, [sp, #0]
 800a9e4:	1d1a      	adds	r2, r3, #4
 800a9e6:	9200      	str	r2, [sp, #0]
 800a9e8:	9a03      	ldr	r2, [sp, #12]
 800a9ea:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a9ec:	6a12      	ldr	r2, [r2, #32]
 800a9ee:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP3;
 800a9f0:	9b00      	ldr	r3, [sp, #0]
 800a9f2:	1d1a      	adds	r2, r3, #4
 800a9f4:	9200      	str	r2, [sp, #0]
 800a9f6:	9a03      	ldr	r2, [sp, #12]
 800a9f8:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a9fa:	69d2      	ldr	r2, [r2, #28]
 800a9fc:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP2;
 800a9fe:	9b00      	ldr	r3, [sp, #0]
 800aa00:	1d1a      	adds	r2, r3, #4
 800aa02:	9200      	str	r2, [sp, #0]
 800aa04:	9a03      	ldr	r2, [sp, #12]
 800aa06:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800aa08:	6992      	ldr	r2, [r2, #24]
 800aa0a:	601a      	str	r2, [r3, #0]
  *resp   = sdcp->sdmmc->RESP1;
 800aa0c:	9b03      	ldr	r3, [sp, #12]
 800aa0e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aa10:	695a      	ldr	r2, [r3, #20]
 800aa12:	9b00      	ldr	r3, [sp, #0]
 800aa14:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 800aa16:	2300      	movs	r3, #0
}
 800aa18:	4618      	mov	r0, r3
 800aa1a:	b007      	add	sp, #28
 800aa1c:	f85d fb04 	ldr.w	pc, [sp], #4

0800aa20 <sdc_lld_read_special>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_special(SDCDriver *sdcp, uint8_t *buf, size_t bytes,
                          uint8_t cmd, uint32_t arg) {
 800aa20:	b500      	push	{lr}
 800aa22:	b087      	sub	sp, #28
 800aa24:	9003      	str	r0, [sp, #12]
 800aa26:	9102      	str	r1, [sp, #8]
 800aa28:	9201      	str	r2, [sp, #4]
 800aa2a:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
 800aa2e:	9803      	ldr	r0, [sp, #12]
 800aa30:	9902      	ldr	r1, [sp, #8]
 800aa32:	9a01      	ldr	r2, [sp, #4]
 800aa34:	f7ff fc2c 	bl	800a290 <sdc_lld_prepare_read_bytes>
 800aa38:	4603      	mov	r3, r0
 800aa3a:	2b00      	cmp	r3, #0
 800aa3c:	d000      	beq.n	800aa40 <sdc_lld_read_special+0x20>
    goto error;
 800aa3e:	e01b      	b.n	800aa78 <sdc_lld_read_special+0x58>

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 800aa40:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800aa44:	ab05      	add	r3, sp, #20
 800aa46:	9803      	ldr	r0, [sp, #12]
 800aa48:	4611      	mov	r1, r2
 800aa4a:	9a08      	ldr	r2, [sp, #32]
 800aa4c:	f7ff ff58 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800aa50:	4603      	mov	r3, r0
 800aa52:	2b00      	cmp	r3, #0
 800aa54:	d110      	bne.n	800aa78 <sdc_lld_read_special+0x58>
                                 || MMCSD_R1_ERROR(resp[0]))
 800aa56:	9a05      	ldr	r2, [sp, #20]
 800aa58:	4b0d      	ldr	r3, [pc, #52]	; (800aa90 <sdc_lld_read_special+0x70>)
 800aa5a:	4013      	ands	r3, r2
 800aa5c:	2b00      	cmp	r3, #0
 800aa5e:	d10b      	bne.n	800aa78 <sdc_lld_read_special+0x58>
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, 1, resp))
 800aa60:	ab05      	add	r3, sp, #20
 800aa62:	9803      	ldr	r0, [sp, #12]
 800aa64:	2101      	movs	r1, #1
 800aa66:	461a      	mov	r2, r3
 800aa68:	f7ff fcfa 	bl	800a460 <sdc_lld_wait_transaction_end>
 800aa6c:	4603      	mov	r3, r0
 800aa6e:	2b00      	cmp	r3, #0
 800aa70:	d000      	beq.n	800aa74 <sdc_lld_read_special+0x54>
    goto error;
 800aa72:	e001      	b.n	800aa78 <sdc_lld_read_special+0x58>

  return HAL_SUCCESS;
 800aa74:	2300      	movs	r3, #0
 800aa76:	e006      	b.n	800aa86 <sdc_lld_read_special+0x66>

error:
  sdc_lld_error_cleanup(sdcp, 1, resp);
 800aa78:	ab05      	add	r3, sp, #20
 800aa7a:	9803      	ldr	r0, [sp, #12]
 800aa7c:	2101      	movs	r1, #1
 800aa7e:	461a      	mov	r2, r3
 800aa80:	f7ff fd8e 	bl	800a5a0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800aa84:	2301      	movs	r3, #1
}
 800aa86:	4618      	mov	r0, r3
 800aa88:	b007      	add	sp, #28
 800aa8a:	f85d fb04 	ldr.w	pc, [sp], #4
 800aa8e:	bf00      	nop
 800aa90:	fdffe008 	.word	0xfdffe008
 800aa94:	f3af 8000 	nop.w
 800aa98:	f3af 8000 	nop.w
 800aa9c:	f3af 8000 	nop.w

0800aaa0 <sdc_lld_read_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
                          uint8_t *buf, uint32_t blocks) {
 800aaa0:	b500      	push	{lr}
 800aaa2:	b087      	sub	sp, #28
 800aaa4:	9003      	str	r0, [sp, #12]
 800aaa6:	9102      	str	r1, [sp, #8]
 800aaa8:	9201      	str	r2, [sp, #4]
 800aaaa:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = SDMMC_READ_TIMEOUT;
 800aaac:	9b03      	ldr	r3, [sp, #12]
 800aaae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aab0:	4a3b      	ldr	r2, [pc, #236]	; (800aba0 <sdc_lld_read_aligned+0x100>)
 800aab2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800aab4:	9803      	ldr	r0, [sp, #12]
 800aab6:	f7fa ffab 	bl	8005a10 <_sdc_wait_for_transfer_state>
 800aaba:	4603      	mov	r3, r0
 800aabc:	2b00      	cmp	r3, #0
 800aabe:	d001      	beq.n	800aac4 <sdc_lld_read_aligned+0x24>
    return HAL_FAILED;
 800aac0:	2301      	movs	r3, #1
 800aac2:	e069      	b.n	800ab98 <sdc_lld_read_aligned+0xf8>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800aac4:	9b03      	ldr	r3, [sp, #12]
 800aac6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aac8:	685b      	ldr	r3, [r3, #4]
 800aaca:	9a01      	ldr	r2, [sp, #4]
 800aacc:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 800aace:	9b03      	ldr	r3, [sp, #12]
 800aad0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aad2:	685b      	ldr	r3, [r3, #4]
 800aad4:	9a00      	ldr	r2, [sp, #0]
 800aad6:	0252      	lsls	r2, r2, #9
 800aad8:	0892      	lsrs	r2, r2, #2
 800aada:	605a      	str	r2, [r3, #4]
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 800aadc:	9b03      	ldr	r3, [sp, #12]
 800aade:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aae0:	68db      	ldr	r3, [r3, #12]
 800aae2:	681b      	ldr	r3, [r3, #0]
 800aae4:	9305      	str	r3, [sp, #20]
 800aae6:	9b03      	ldr	r3, [sp, #12]
 800aae8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aaea:	7c1b      	ldrb	r3, [r3, #16]
 800aaec:	220f      	movs	r2, #15
 800aaee:	fa02 f303 	lsl.w	r3, r2, r3
 800aaf2:	43db      	mvns	r3, r3
 800aaf4:	9a05      	ldr	r2, [sp, #20]
 800aaf6:	4013      	ands	r3, r2
 800aaf8:	9305      	str	r3, [sp, #20]
 800aafa:	9b03      	ldr	r3, [sp, #12]
 800aafc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800aafe:	0c1a      	lsrs	r2, r3, #16
 800ab00:	9b03      	ldr	r3, [sp, #12]
 800ab02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab04:	7c1b      	ldrb	r3, [r3, #16]
 800ab06:	fa02 f303 	lsl.w	r3, r2, r3
 800ab0a:	9a05      	ldr	r2, [sp, #20]
 800ab0c:	4313      	orrs	r3, r2
 800ab0e:	9305      	str	r3, [sp, #20]
 800ab10:	9b03      	ldr	r3, [sp, #12]
 800ab12:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab14:	68db      	ldr	r3, [r3, #12]
 800ab16:	9a05      	ldr	r2, [sp, #20]
 800ab18:	601a      	str	r2, [r3, #0]
 800ab1a:	9b03      	ldr	r3, [sp, #12]
 800ab1c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab1e:	685b      	ldr	r3, [r3, #4]
 800ab20:	9a03      	ldr	r2, [sp, #12]
 800ab22:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ab24:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800ab26:	9b03      	ldr	r3, [sp, #12]
 800ab28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab2a:	685b      	ldr	r3, [r3, #4]
 800ab2c:	9a03      	ldr	r2, [sp, #12]
 800ab2e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800ab30:	6852      	ldr	r2, [r2, #4]
 800ab32:	6812      	ldr	r2, [r2, #0]
 800ab34:	f042 0201 	orr.w	r2, r2, #1
 800ab38:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800ab3a:	9b03      	ldr	r3, [sp, #12]
 800ab3c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab3e:	4a19      	ldr	r2, [pc, #100]	; (800aba4 <sdc_lld_read_aligned+0x104>)
 800ab40:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800ab42:	9b03      	ldr	r3, [sp, #12]
 800ab44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab46:	f44f 7295 	mov.w	r2, #298	; 0x12a
 800ab4a:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_RXOVERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800ab4c:	9b03      	ldr	r3, [sp, #12]
 800ab4e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab50:	9a00      	ldr	r2, [sp, #0]
 800ab52:	0252      	lsls	r2, r2, #9
 800ab54:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 800ab56:	9b03      	ldr	r3, [sp, #12]
 800ab58:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab5a:	229b      	movs	r2, #155	; 0x9b
 800ab5c:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DBLOCKSIZE_3 |
                       SDMMC_DCTRL_DBLOCKSIZE_0 |
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  if (sdc_lld_prepare_read(sdcp, startblk, blocks, resp) == TRUE)
 800ab5e:	ab04      	add	r3, sp, #16
 800ab60:	9803      	ldr	r0, [sp, #12]
 800ab62:	9902      	ldr	r1, [sp, #8]
 800ab64:	9a00      	ldr	r2, [sp, #0]
 800ab66:	f7ff fbfb 	bl	800a360 <sdc_lld_prepare_read>
 800ab6a:	4603      	mov	r3, r0
 800ab6c:	2b00      	cmp	r3, #0
 800ab6e:	d000      	beq.n	800ab72 <sdc_lld_read_aligned+0xd2>
    goto error;
 800ab70:	e00b      	b.n	800ab8a <sdc_lld_read_aligned+0xea>

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 800ab72:	ab04      	add	r3, sp, #16
 800ab74:	9803      	ldr	r0, [sp, #12]
 800ab76:	9900      	ldr	r1, [sp, #0]
 800ab78:	461a      	mov	r2, r3
 800ab7a:	f7ff fc71 	bl	800a460 <sdc_lld_wait_transaction_end>
 800ab7e:	4603      	mov	r3, r0
 800ab80:	2b00      	cmp	r3, #0
 800ab82:	d000      	beq.n	800ab86 <sdc_lld_read_aligned+0xe6>
    goto error;
 800ab84:	e001      	b.n	800ab8a <sdc_lld_read_aligned+0xea>

  return HAL_SUCCESS;
 800ab86:	2300      	movs	r3, #0
 800ab88:	e006      	b.n	800ab98 <sdc_lld_read_aligned+0xf8>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 800ab8a:	ab04      	add	r3, sp, #16
 800ab8c:	9803      	ldr	r0, [sp, #12]
 800ab8e:	9900      	ldr	r1, [sp, #0]
 800ab90:	461a      	mov	r2, r3
 800ab92:	f7ff fd05 	bl	800a5a0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800ab96:	2301      	movs	r3, #1
}
 800ab98:	4618      	mov	r0, r3
 800ab9a:	b007      	add	sp, #28
 800ab9c:	f85d fb04 	ldr.w	pc, [sp], #4
 800aba0:	000927c0 	.word	0x000927c0
 800aba4:	004005ff 	.word	0x004005ff
 800aba8:	f3af 8000 	nop.w
 800abac:	f3af 8000 	nop.w

0800abb0 <sdc_lld_write_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
                           const uint8_t *buf, uint32_t blocks) {
 800abb0:	b500      	push	{lr}
 800abb2:	b087      	sub	sp, #28
 800abb4:	9003      	str	r0, [sp, #12]
 800abb6:	9102      	str	r1, [sp, #8]
 800abb8:	9201      	str	r2, [sp, #4]
 800abba:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = SDMMC_WRITE_TIMEOUT;
 800abbc:	9b03      	ldr	r3, [sp, #12]
 800abbe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800abc0:	4a3d      	ldr	r2, [pc, #244]	; (800acb8 <sdc_lld_write_aligned+0x108>)
 800abc2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800abc4:	9803      	ldr	r0, [sp, #12]
 800abc6:	f7fa ff23 	bl	8005a10 <_sdc_wait_for_transfer_state>
 800abca:	4603      	mov	r3, r0
 800abcc:	2b00      	cmp	r3, #0
 800abce:	d001      	beq.n	800abd4 <sdc_lld_write_aligned+0x24>
    return HAL_FAILED;
 800abd0:	2301      	movs	r3, #1
 800abd2:	e06d      	b.n	800acb0 <sdc_lld_write_aligned+0x100>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800abd4:	9b03      	ldr	r3, [sp, #12]
 800abd6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abd8:	685b      	ldr	r3, [r3, #4]
 800abda:	9a01      	ldr	r2, [sp, #4]
 800abdc:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 800abde:	9b03      	ldr	r3, [sp, #12]
 800abe0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abe2:	685b      	ldr	r3, [r3, #4]
 800abe4:	9a00      	ldr	r2, [sp, #0]
 800abe6:	0252      	lsls	r2, r2, #9
 800abe8:	0892      	lsrs	r2, r2, #2
 800abea:	605a      	str	r2, [r3, #4]
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 800abec:	9b03      	ldr	r3, [sp, #12]
 800abee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abf0:	68db      	ldr	r3, [r3, #12]
 800abf2:	681b      	ldr	r3, [r3, #0]
 800abf4:	9305      	str	r3, [sp, #20]
 800abf6:	9b03      	ldr	r3, [sp, #12]
 800abf8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abfa:	7c1b      	ldrb	r3, [r3, #16]
 800abfc:	220f      	movs	r2, #15
 800abfe:	fa02 f303 	lsl.w	r3, r2, r3
 800ac02:	43db      	mvns	r3, r3
 800ac04:	9a05      	ldr	r2, [sp, #20]
 800ac06:	4013      	ands	r3, r2
 800ac08:	9305      	str	r3, [sp, #20]
 800ac0a:	9b03      	ldr	r3, [sp, #12]
 800ac0c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ac0e:	f043 0310 	orr.w	r3, r3, #16
 800ac12:	0c1a      	lsrs	r2, r3, #16
 800ac14:	9b03      	ldr	r3, [sp, #12]
 800ac16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac18:	7c1b      	ldrb	r3, [r3, #16]
 800ac1a:	fa02 f303 	lsl.w	r3, r2, r3
 800ac1e:	9a05      	ldr	r2, [sp, #20]
 800ac20:	4313      	orrs	r3, r2
 800ac22:	9305      	str	r3, [sp, #20]
 800ac24:	9b03      	ldr	r3, [sp, #12]
 800ac26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac28:	68db      	ldr	r3, [r3, #12]
 800ac2a:	9a05      	ldr	r2, [sp, #20]
 800ac2c:	601a      	str	r2, [r3, #0]
 800ac2e:	9b03      	ldr	r3, [sp, #12]
 800ac30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac32:	685b      	ldr	r3, [r3, #4]
 800ac34:	9a03      	ldr	r2, [sp, #12]
 800ac36:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ac38:	f042 0210 	orr.w	r2, r2, #16
 800ac3c:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800ac3e:	9b03      	ldr	r3, [sp, #12]
 800ac40:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac42:	685b      	ldr	r3, [r3, #4]
 800ac44:	9a03      	ldr	r2, [sp, #12]
 800ac46:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800ac48:	6852      	ldr	r2, [r2, #4]
 800ac4a:	6812      	ldr	r2, [r2, #0]
 800ac4c:	f042 0201 	orr.w	r2, r2, #1
 800ac50:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800ac52:	9b03      	ldr	r3, [sp, #12]
 800ac54:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac56:	4a19      	ldr	r2, [pc, #100]	; (800acbc <sdc_lld_write_aligned+0x10c>)
 800ac58:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800ac5a:	9b03      	ldr	r3, [sp, #12]
 800ac5c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac5e:	f44f 728d 	mov.w	r2, #282	; 0x11a
 800ac62:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_TXUNDERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800ac64:	9b03      	ldr	r3, [sp, #12]
 800ac66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac68:	9a00      	ldr	r2, [sp, #0]
 800ac6a:	0252      	lsls	r2, r2, #9
 800ac6c:	629a      	str	r2, [r3, #40]	; 0x28

  /* Talk to card what we want from it.*/
  if (sdc_lld_prepare_write(sdcp, startblk, blocks, resp) == TRUE)
 800ac6e:	ab04      	add	r3, sp, #16
 800ac70:	9803      	ldr	r0, [sp, #12]
 800ac72:	9902      	ldr	r1, [sp, #8]
 800ac74:	9a00      	ldr	r2, [sp, #0]
 800ac76:	f7ff fbb3 	bl	800a3e0 <sdc_lld_prepare_write>
 800ac7a:	4603      	mov	r3, r0
 800ac7c:	2b00      	cmp	r3, #0
 800ac7e:	d000      	beq.n	800ac82 <sdc_lld_write_aligned+0xd2>
    goto error;
 800ac80:	e00f      	b.n	800aca2 <sdc_lld_write_aligned+0xf2>

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DBLOCKSIZE_3 |
 800ac82:	9b03      	ldr	r3, [sp, #12]
 800ac84:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac86:	2299      	movs	r2, #153	; 0x99
 800ac88:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DBLOCKSIZE_0 |
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 800ac8a:	ab04      	add	r3, sp, #16
 800ac8c:	9803      	ldr	r0, [sp, #12]
 800ac8e:	9900      	ldr	r1, [sp, #0]
 800ac90:	461a      	mov	r2, r3
 800ac92:	f7ff fbe5 	bl	800a460 <sdc_lld_wait_transaction_end>
 800ac96:	4603      	mov	r3, r0
 800ac98:	2b00      	cmp	r3, #0
 800ac9a:	d000      	beq.n	800ac9e <sdc_lld_write_aligned+0xee>
    goto error;
 800ac9c:	e001      	b.n	800aca2 <sdc_lld_write_aligned+0xf2>

  return HAL_SUCCESS;
 800ac9e:	2300      	movs	r3, #0
 800aca0:	e006      	b.n	800acb0 <sdc_lld_write_aligned+0x100>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 800aca2:	ab04      	add	r3, sp, #16
 800aca4:	9803      	ldr	r0, [sp, #12]
 800aca6:	9900      	ldr	r1, [sp, #0]
 800aca8:	461a      	mov	r2, r3
 800acaa:	f7ff fc79 	bl	800a5a0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800acae:	2301      	movs	r3, #1
}
 800acb0:	4618      	mov	r0, r3
 800acb2:	b007      	add	sp, #28
 800acb4:	f85d fb04 	ldr.w	pc, [sp], #4
 800acb8:	005b8d80 	.word	0x005b8d80
 800acbc:	004005ff 	.word	0x004005ff

0800acc0 <sdc_lld_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read(SDCDriver *sdcp, uint32_t startblk,
                  uint8_t *buf, uint32_t blocks) {
 800acc0:	b500      	push	{lr}
 800acc2:	b087      	sub	sp, #28
 800acc4:	9003      	str	r0, [sp, #12]
 800acc6:	9102      	str	r1, [sp, #8]
 800acc8:	9201      	str	r2, [sp, #4]
 800acca:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 800accc:	9b01      	ldr	r3, [sp, #4]
 800acce:	f003 0303 	and.w	r3, r3, #3
 800acd2:	2b00      	cmp	r3, #0
 800acd4:	d028      	beq.n	800ad28 <sdc_lld_read+0x68>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800acd6:	2300      	movs	r3, #0
 800acd8:	9305      	str	r3, [sp, #20]
 800acda:	e01f      	b.n	800ad1c <sdc_lld_read+0x5c>
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
 800acdc:	9803      	ldr	r0, [sp, #12]
 800acde:	9902      	ldr	r1, [sp, #8]
 800ace0:	4a17      	ldr	r2, [pc, #92]	; (800ad40 <sdc_lld_read+0x80>)
 800ace2:	2301      	movs	r3, #1
 800ace4:	f7ff fedc 	bl	800aaa0 <sdc_lld_read_aligned>
 800ace8:	4603      	mov	r3, r0
 800acea:	2b00      	cmp	r3, #0
 800acec:	d001      	beq.n	800acf2 <sdc_lld_read+0x32>
        return HAL_FAILED;
 800acee:	2301      	movs	r3, #1
 800acf0:	e021      	b.n	800ad36 <sdc_lld_read+0x76>
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 800acf2:	9a01      	ldr	r2, [sp, #4]
 800acf4:	4b12      	ldr	r3, [pc, #72]	; (800ad40 <sdc_lld_read+0x80>)
 800acf6:	4611      	mov	r1, r2
 800acf8:	461a      	mov	r2, r3
 800acfa:	f44f 7300 	mov.w	r3, #512	; 0x200
 800acfe:	4608      	mov	r0, r1
 800ad00:	4611      	mov	r1, r2
 800ad02:	461a      	mov	r2, r3
 800ad04:	f00c fc6c 	bl	80175e0 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 800ad08:	9b01      	ldr	r3, [sp, #4]
 800ad0a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800ad0e:	9301      	str	r3, [sp, #4]
      startblk++;
 800ad10:	9b02      	ldr	r3, [sp, #8]
 800ad12:	3301      	adds	r3, #1
 800ad14:	9302      	str	r3, [sp, #8]
                  uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800ad16:	9b05      	ldr	r3, [sp, #20]
 800ad18:	3301      	adds	r3, #1
 800ad1a:	9305      	str	r3, [sp, #20]
 800ad1c:	9a05      	ldr	r2, [sp, #20]
 800ad1e:	9b00      	ldr	r3, [sp, #0]
 800ad20:	429a      	cmp	r2, r3
 800ad22:	d3db      	bcc.n	800acdc <sdc_lld_read+0x1c>
        return HAL_FAILED;
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
      startblk++;
    }
    return HAL_SUCCESS;
 800ad24:	2300      	movs	r3, #0
 800ad26:	e006      	b.n	800ad36 <sdc_lld_read+0x76>
  }
#endif /* STM32_SDC_SDMMC_UNALIGNED_SUPPORT */
  return sdc_lld_read_aligned(sdcp, startblk, buf, blocks);
 800ad28:	9803      	ldr	r0, [sp, #12]
 800ad2a:	9902      	ldr	r1, [sp, #8]
 800ad2c:	9a01      	ldr	r2, [sp, #4]
 800ad2e:	9b00      	ldr	r3, [sp, #0]
 800ad30:	f7ff feb6 	bl	800aaa0 <sdc_lld_read_aligned>
 800ad34:	4603      	mov	r3, r0
}
 800ad36:	4618      	mov	r0, r3
 800ad38:	b007      	add	sp, #28
 800ad3a:	f85d fb04 	ldr.w	pc, [sp], #4
 800ad3e:	bf00      	nop
 800ad40:	20001264 	.word	0x20001264
 800ad44:	f3af 8000 	nop.w
 800ad48:	f3af 8000 	nop.w
 800ad4c:	f3af 8000 	nop.w

0800ad50 <sdc_lld_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write(SDCDriver *sdcp, uint32_t startblk,
                   const uint8_t *buf, uint32_t blocks) {
 800ad50:	b500      	push	{lr}
 800ad52:	b087      	sub	sp, #28
 800ad54:	9003      	str	r0, [sp, #12]
 800ad56:	9102      	str	r1, [sp, #8]
 800ad58:	9201      	str	r2, [sp, #4]
 800ad5a:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 800ad5c:	9b01      	ldr	r3, [sp, #4]
 800ad5e:	f003 0303 	and.w	r3, r3, #3
 800ad62:	2b00      	cmp	r3, #0
 800ad64:	d028      	beq.n	800adb8 <sdc_lld_write+0x68>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800ad66:	2300      	movs	r3, #0
 800ad68:	9305      	str	r3, [sp, #20]
 800ad6a:	e01f      	b.n	800adac <sdc_lld_write+0x5c>
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
 800ad6c:	4a18      	ldr	r2, [pc, #96]	; (800add0 <sdc_lld_write+0x80>)
 800ad6e:	9b01      	ldr	r3, [sp, #4]
 800ad70:	4611      	mov	r1, r2
 800ad72:	461a      	mov	r2, r3
 800ad74:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ad78:	4608      	mov	r0, r1
 800ad7a:	4611      	mov	r1, r2
 800ad7c:	461a      	mov	r2, r3
 800ad7e:	f00c fc2f 	bl	80175e0 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 800ad82:	9b01      	ldr	r3, [sp, #4]
 800ad84:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800ad88:	9301      	str	r3, [sp, #4]
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
 800ad8a:	9803      	ldr	r0, [sp, #12]
 800ad8c:	9902      	ldr	r1, [sp, #8]
 800ad8e:	4a10      	ldr	r2, [pc, #64]	; (800add0 <sdc_lld_write+0x80>)
 800ad90:	2301      	movs	r3, #1
 800ad92:	f7ff ff0d 	bl	800abb0 <sdc_lld_write_aligned>
 800ad96:	4603      	mov	r3, r0
 800ad98:	2b00      	cmp	r3, #0
 800ad9a:	d001      	beq.n	800ada0 <sdc_lld_write+0x50>
        return HAL_FAILED;
 800ad9c:	2301      	movs	r3, #1
 800ad9e:	e012      	b.n	800adc6 <sdc_lld_write+0x76>
      startblk++;
 800ada0:	9b02      	ldr	r3, [sp, #8]
 800ada2:	3301      	adds	r3, #1
 800ada4:	9302      	str	r3, [sp, #8]
                   const uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800ada6:	9b05      	ldr	r3, [sp, #20]
 800ada8:	3301      	adds	r3, #1
 800adaa:	9305      	str	r3, [sp, #20]
 800adac:	9a05      	ldr	r2, [sp, #20]
 800adae:	9b00      	ldr	r3, [sp, #0]
 800adb0:	429a      	cmp	r2, r3
 800adb2:	d3db      	bcc.n	800ad6c <sdc_lld_write+0x1c>
      buf += MMCSD_BLOCK_SIZE;
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
        return HAL_FAILED;
      startblk++;
    }
    return HAL_SUCCESS;
 800adb4:	2300      	movs	r3, #0
 800adb6:	e006      	b.n	800adc6 <sdc_lld_write+0x76>
  }
#endif /* STM32_SDC_SDMMC_UNALIGNED_SUPPORT */
  return sdc_lld_write_aligned(sdcp, startblk, buf, blocks);
 800adb8:	9803      	ldr	r0, [sp, #12]
 800adba:	9902      	ldr	r1, [sp, #8]
 800adbc:	9a01      	ldr	r2, [sp, #4]
 800adbe:	9b00      	ldr	r3, [sp, #0]
 800adc0:	f7ff fef6 	bl	800abb0 <sdc_lld_write_aligned>
 800adc4:	4603      	mov	r3, r0
}
 800adc6:	4618      	mov	r0, r3
 800adc8:	b007      	add	sp, #28
 800adca:	f85d fb04 	ldr.w	pc, [sp], #4
 800adce:	bf00      	nop
 800add0:	20001264 	.word	0x20001264
 800add4:	f3af 8000 	nop.w
 800add8:	f3af 8000 	nop.w
 800addc:	f3af 8000 	nop.w

0800ade0 <sdc_lld_sync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdc_lld_sync(SDCDriver *sdcp) {
 800ade0:	b082      	sub	sp, #8
 800ade2:	9001      	str	r0, [sp, #4]

  /* TODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
 800ade4:	2300      	movs	r3, #0
}
 800ade6:	4618      	mov	r0, r3
 800ade8:	b002      	add	sp, #8
 800adea:	4770      	bx	lr
 800adec:	f3af 8000 	nop.w

0800adf0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800adf0:	b082      	sub	sp, #8
 800adf2:	2320      	movs	r3, #32
 800adf4:	9301      	str	r3, [sp, #4]
 800adf6:	9b01      	ldr	r3, [sp, #4]
 800adf8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800adfc:	b002      	add	sp, #8
 800adfe:	4770      	bx	lr

0800ae00 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800ae00:	b082      	sub	sp, #8
 800ae02:	2300      	movs	r3, #0
 800ae04:	9301      	str	r3, [sp, #4]
 800ae06:	9b01      	ldr	r3, [sp, #4]
 800ae08:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ae0c:	b002      	add	sp, #8
 800ae0e:	4770      	bx	lr

0800ae10 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800ae10:	b508      	push	{r3, lr}

  port_lock();
 800ae12:	f7ff ffed 	bl	800adf0 <port_lock>
}
 800ae16:	bd08      	pop	{r3, pc}
 800ae18:	f3af 8000 	nop.w
 800ae1c:	f3af 8000 	nop.w

0800ae20 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800ae20:	b508      	push	{r3, lr}

  port_unlock();
 800ae22:	f7ff ffed 	bl	800ae00 <port_unlock>
}
 800ae26:	bd08      	pop	{r3, pc}
 800ae28:	f3af 8000 	nop.w
 800ae2c:	f3af 8000 	nop.w

0800ae30 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800ae30:	b508      	push	{r3, lr}

  port_lock();
 800ae32:	f7ff ffdd 	bl	800adf0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800ae36:	bd08      	pop	{r3, pc}
 800ae38:	f3af 8000 	nop.w
 800ae3c:	f3af 8000 	nop.w

0800ae40 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800ae40:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800ae42:	f7ff ffdd 	bl	800ae00 <port_unlock>
}
 800ae46:	bd08      	pop	{r3, pc}
 800ae48:	f3af 8000 	nop.w
 800ae4c:	f3af 8000 	nop.w

0800ae50 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800ae50:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800ae52:	f7ff ffdd 	bl	800ae10 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800ae56:	bd08      	pop	{r3, pc}
 800ae58:	f3af 8000 	nop.w
 800ae5c:	f3af 8000 	nop.w

0800ae60 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800ae60:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800ae62:	f7ff ffdd 	bl	800ae20 <port_unlock_from_isr>
}
 800ae66:	bd08      	pop	{r3, pc}
 800ae68:	f3af 8000 	nop.w
 800ae6c:	f3af 8000 	nop.w

0800ae70 <osalSysHalt>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
 800ae70:	b500      	push	{lr}
 800ae72:	b083      	sub	sp, #12
 800ae74:	9001      	str	r0, [sp, #4]

  chSysHalt(reason);
 800ae76:	9801      	ldr	r0, [sp, #4]
 800ae78:	f7f5 fc52 	bl	8000720 <chSysHalt>
}
 800ae7c:	b003      	add	sp, #12
 800ae7e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ae82:	bf00      	nop
 800ae84:	f3af 8000 	nop.w
 800ae88:	f3af 8000 	nop.w
 800ae8c:	f3af 8000 	nop.w

0800ae90 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800ae90:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800ae92:	f7ff ffdd 	bl	800ae50 <chSysLockFromISR>
}
 800ae96:	bd08      	pop	{r3, pc}
 800ae98:	f3af 8000 	nop.w
 800ae9c:	f3af 8000 	nop.w

0800aea0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800aea0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800aea2:	f7ff ffdd 	bl	800ae60 <chSysUnlockFromISR>
}
 800aea6:	bd08      	pop	{r3, pc}
 800aea8:	f3af 8000 	nop.w
 800aeac:	f3af 8000 	nop.w

0800aeb0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 800aeb0:	b500      	push	{lr}
 800aeb2:	b083      	sub	sp, #12
 800aeb4:	9001      	str	r0, [sp, #4]
 800aeb6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 800aeb8:	9801      	ldr	r0, [sp, #4]
 800aeba:	9900      	ldr	r1, [sp, #0]
 800aebc:	f7f6 fb00 	bl	80014c0 <chThdResumeI>
}
 800aec0:	b003      	add	sp, #12
 800aec2:	f85d fb04 	ldr.w	pc, [sp], #4
 800aec6:	bf00      	nop
 800aec8:	f3af 8000 	nop.w
 800aecc:	f3af 8000 	nop.w

0800aed0 <spi_lld_serve_rx_interrupt>:
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 800aed0:	b500      	push	{lr}
 800aed2:	b083      	sub	sp, #12
 800aed4:	9001      	str	r0, [sp, #4]
 800aed6:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800aed8:	9b00      	ldr	r3, [sp, #0]
 800aeda:	f003 0308 	and.w	r3, r3, #8
 800aede:	2b00      	cmp	r3, #0
 800aee0:	d002      	beq.n	800aee8 <spi_lld_serve_rx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800aee2:	4828      	ldr	r0, [pc, #160]	; (800af84 <spi_lld_serve_rx_interrupt+0xb4>)
 800aee4:	f7ff ffc4 	bl	800ae70 <osalSysHalt>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 800aee8:	9b01      	ldr	r3, [sp, #4]
 800aeea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aeec:	685b      	ldr	r3, [r3, #4]
 800aeee:	9a01      	ldr	r2, [sp, #4]
 800aef0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800aef2:	6852      	ldr	r2, [r2, #4]
 800aef4:	6812      	ldr	r2, [r2, #0]
 800aef6:	f022 020f 	bic.w	r2, r2, #15
 800aefa:	601a      	str	r2, [r3, #0]
 800aefc:	9b01      	ldr	r3, [sp, #4]
 800aefe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800af00:	681b      	ldr	r3, [r3, #0]
 800af02:	9a01      	ldr	r2, [sp, #4]
 800af04:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800af06:	7c12      	ldrb	r2, [r2, #16]
 800af08:	210f      	movs	r1, #15
 800af0a:	fa01 f202 	lsl.w	r2, r1, r2
 800af0e:	605a      	str	r2, [r3, #4]
  dmaStreamDisable(spip->dmarx);
 800af10:	9b01      	ldr	r3, [sp, #4]
 800af12:	6a1b      	ldr	r3, [r3, #32]
 800af14:	685b      	ldr	r3, [r3, #4]
 800af16:	9a01      	ldr	r2, [sp, #4]
 800af18:	6a12      	ldr	r2, [r2, #32]
 800af1a:	6852      	ldr	r2, [r2, #4]
 800af1c:	6812      	ldr	r2, [r2, #0]
 800af1e:	f022 020f 	bic.w	r2, r2, #15
 800af22:	601a      	str	r2, [r3, #0]
 800af24:	9b01      	ldr	r3, [sp, #4]
 800af26:	6a1b      	ldr	r3, [r3, #32]
 800af28:	681b      	ldr	r3, [r3, #0]
 800af2a:	9a01      	ldr	r2, [sp, #4]
 800af2c:	6a12      	ldr	r2, [r2, #32]
 800af2e:	7c12      	ldrb	r2, [r2, #16]
 800af30:	210f      	movs	r1, #15
 800af32:	fa01 f202 	lsl.w	r2, r1, r2
 800af36:	605a      	str	r2, [r3, #4]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 800af38:	9b01      	ldr	r3, [sp, #4]
 800af3a:	685b      	ldr	r3, [r3, #4]
 800af3c:	681b      	ldr	r3, [r3, #0]
 800af3e:	2b00      	cmp	r3, #0
 800af40:	d00f      	beq.n	800af62 <spi_lld_serve_rx_interrupt+0x92>
 800af42:	9b01      	ldr	r3, [sp, #4]
 800af44:	2204      	movs	r2, #4
 800af46:	701a      	strb	r2, [r3, #0]
 800af48:	9b01      	ldr	r3, [sp, #4]
 800af4a:	685b      	ldr	r3, [r3, #4]
 800af4c:	681b      	ldr	r3, [r3, #0]
 800af4e:	9801      	ldr	r0, [sp, #4]
 800af50:	4798      	blx	r3
 800af52:	9b01      	ldr	r3, [sp, #4]
 800af54:	781b      	ldrb	r3, [r3, #0]
 800af56:	2b04      	cmp	r3, #4
 800af58:	d106      	bne.n	800af68 <spi_lld_serve_rx_interrupt+0x98>
 800af5a:	9b01      	ldr	r3, [sp, #4]
 800af5c:	2202      	movs	r2, #2
 800af5e:	701a      	strb	r2, [r3, #0]
 800af60:	e002      	b.n	800af68 <spi_lld_serve_rx_interrupt+0x98>
 800af62:	9b01      	ldr	r3, [sp, #4]
 800af64:	2202      	movs	r2, #2
 800af66:	701a      	strb	r2, [r3, #0]
 800af68:	f7ff ff92 	bl	800ae90 <osalSysLockFromISR>
 800af6c:	9b01      	ldr	r3, [sp, #4]
 800af6e:	3308      	adds	r3, #8
 800af70:	4618      	mov	r0, r3
 800af72:	2100      	movs	r1, #0
 800af74:	f7ff ff9c 	bl	800aeb0 <osalThreadResumeI>
 800af78:	f7ff ff92 	bl	800aea0 <osalSysUnlockFromISR>
}
 800af7c:	b003      	add	sp, #12
 800af7e:	f85d fb04 	ldr.w	pc, [sp], #4
 800af82:	bf00      	nop
 800af84:	0801ac34 	.word	0x0801ac34
 800af88:	f3af 8000 	nop.w
 800af8c:	f3af 8000 	nop.w

0800af90 <spi_lld_serve_tx_interrupt>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 800af90:	b500      	push	{lr}
 800af92:	b083      	sub	sp, #12
 800af94:	9001      	str	r0, [sp, #4]
 800af96:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800af98:	9b00      	ldr	r3, [sp, #0]
 800af9a:	f003 0308 	and.w	r3, r3, #8
 800af9e:	2b00      	cmp	r3, #0
 800afa0:	d002      	beq.n	800afa8 <spi_lld_serve_tx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800afa2:	4803      	ldr	r0, [pc, #12]	; (800afb0 <spi_lld_serve_tx_interrupt+0x20>)
 800afa4:	f7ff ff64 	bl	800ae70 <osalSysHalt>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 800afa8:	b003      	add	sp, #12
 800afaa:	f85d fb04 	ldr.w	pc, [sp], #4
 800afae:	bf00      	nop
 800afb0:	0801ac34 	.word	0x0801ac34
 800afb4:	f3af 8000 	nop.w
 800afb8:	f3af 8000 	nop.w
 800afbc:	f3af 8000 	nop.w

0800afc0 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 800afc0:	b508      	push	{r3, lr}
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800afc2:	4809      	ldr	r0, [pc, #36]	; (800afe8 <spi_lld_init+0x28>)
 800afc4:	f7fb fa4c 	bl	8006460 <spiObjectInit>
  SPID2.spi       = SPI2;
 800afc8:	4b07      	ldr	r3, [pc, #28]	; (800afe8 <spi_lld_init+0x28>)
 800afca:	4a08      	ldr	r2, [pc, #32]	; (800afec <spi_lld_init+0x2c>)
 800afcc:	61da      	str	r2, [r3, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 800afce:	4b06      	ldr	r3, [pc, #24]	; (800afe8 <spi_lld_init+0x28>)
 800afd0:	4a07      	ldr	r2, [pc, #28]	; (800aff0 <spi_lld_init+0x30>)
 800afd2:	621a      	str	r2, [r3, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 800afd4:	4b04      	ldr	r3, [pc, #16]	; (800afe8 <spi_lld_init+0x28>)
 800afd6:	4a07      	ldr	r2, [pc, #28]	; (800aff4 <spi_lld_init+0x34>)
 800afd8:	625a      	str	r2, [r3, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 800afda:	4b03      	ldr	r3, [pc, #12]	; (800afe8 <spi_lld_init+0x28>)
 800afdc:	4a06      	ldr	r2, [pc, #24]	; (800aff8 <spi_lld_init+0x38>)
 800afde:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 800afe0:	4b01      	ldr	r3, [pc, #4]	; (800afe8 <spi_lld_init+0x28>)
 800afe2:	4a06      	ldr	r2, [pc, #24]	; (800affc <spi_lld_init+0x3c>)
 800afe4:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 800afe6:	bd08      	pop	{r3, pc}
 800afe8:	20003d88 	.word	0x20003d88
 800afec:	40003800 	.word	0x40003800
 800aff0:	0801aafc 	.word	0x0801aafc
 800aff4:	0801ab10 	.word	0x0801ab10
 800aff8:	0001100a 	.word	0x0001100a
 800affc:	00011018 	.word	0x00011018

0800b000 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 800b000:	b500      	push	{lr}
 800b002:	b085      	sub	sp, #20
 800b004:	9001      	str	r0, [sp, #4]
  uint32_t ds;

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 800b006:	9b01      	ldr	r3, [sp, #4]
 800b008:	781b      	ldrb	r3, [r3, #0]
 800b00a:	2b01      	cmp	r3, #1
 800b00c:	d12d      	bne.n	800b06a <spi_lld_start+0x6a>
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
 800b00e:	9a01      	ldr	r2, [sp, #4]
 800b010:	4b3c      	ldr	r3, [pc, #240]	; (800b104 <spi_lld_start+0x104>)
 800b012:	429a      	cmp	r2, r3
 800b014:	d11b      	bne.n	800b04e <spi_lld_start+0x4e>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 800b016:	9b01      	ldr	r3, [sp, #4]
 800b018:	6a1b      	ldr	r3, [r3, #32]
 800b01a:	4618      	mov	r0, r3
 800b01c:	210a      	movs	r1, #10
 800b01e:	4a3a      	ldr	r2, [pc, #232]	; (800b108 <spi_lld_start+0x108>)
 800b020:	9b01      	ldr	r3, [sp, #4]
 800b022:	f7fc fea5 	bl	8007d70 <dmaStreamAllocate>
 800b026:	4603      	mov	r3, r0
 800b028:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 800b02c:	9b01      	ldr	r3, [sp, #4]
 800b02e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b030:	4618      	mov	r0, r3
 800b032:	210a      	movs	r1, #10
 800b034:	4a35      	ldr	r2, [pc, #212]	; (800b10c <spi_lld_start+0x10c>)
 800b036:	9b01      	ldr	r3, [sp, #4]
 800b038:	f7fc fe9a 	bl	8007d70 <dmaStreamAllocate>
 800b03c:	4603      	mov	r3, r0
 800b03e:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI2(FALSE);
 800b042:	4b33      	ldr	r3, [pc, #204]	; (800b110 <spi_lld_start+0x110>)
 800b044:	4a32      	ldr	r2, [pc, #200]	; (800b110 <spi_lld_start+0x110>)
 800b046:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800b048:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800b04c:	659a      	str	r2, [r3, #88]	; 0x58
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800b04e:	9b01      	ldr	r3, [sp, #4]
 800b050:	6a1b      	ldr	r3, [r3, #32]
 800b052:	685b      	ldr	r3, [r3, #4]
 800b054:	9a01      	ldr	r2, [sp, #4]
 800b056:	69d2      	ldr	r2, [r2, #28]
 800b058:	320c      	adds	r2, #12
 800b05a:	609a      	str	r2, [r3, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800b05c:	9b01      	ldr	r3, [sp, #4]
 800b05e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b060:	685b      	ldr	r3, [r3, #4]
 800b062:	9a01      	ldr	r2, [sp, #4]
 800b064:	69d2      	ldr	r2, [r2, #28]
 800b066:	320c      	adds	r2, #12
 800b068:	609a      	str	r2, [r3, #8]
  }

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
 800b06a:	9b01      	ldr	r3, [sp, #4]
 800b06c:	685b      	ldr	r3, [r3, #4]
 800b06e:	899b      	ldrh	r3, [r3, #12]
 800b070:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800b074:	9302      	str	r3, [sp, #8]
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 800b076:	9b02      	ldr	r3, [sp, #8]
 800b078:	2b00      	cmp	r3, #0
 800b07a:	d003      	beq.n	800b084 <spi_lld_start+0x84>
 800b07c:	9b02      	ldr	r3, [sp, #8]
 800b07e:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800b082:	d80c      	bhi.n	800b09e <spi_lld_start+0x9e>
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b084:	9b01      	ldr	r3, [sp, #4]
 800b086:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800b088:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b08c:	9b01      	ldr	r3, [sp, #4]
 800b08e:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b090:	9b01      	ldr	r3, [sp, #4]
 800b092:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800b094:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b098:	9b01      	ldr	r3, [sp, #4]
 800b09a:	62da      	str	r2, [r3, #44]	; 0x2c
 800b09c:	e00f      	b.n	800b0be <spi_lld_start+0xbe>
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b09e:	9b01      	ldr	r3, [sp, #4]
 800b0a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b0a2:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800b0a6:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b0aa:	9b01      	ldr	r3, [sp, #4]
 800b0ac:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b0ae:	9b01      	ldr	r3, [sp, #4]
 800b0b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b0b2:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800b0b6:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b0ba:	9b01      	ldr	r3, [sp, #4]
 800b0bc:	62da      	str	r2, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }

  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 800b0be:	9b01      	ldr	r3, [sp, #4]
 800b0c0:	69db      	ldr	r3, [r3, #28]
 800b0c2:	2200      	movs	r2, #0
 800b0c4:	601a      	str	r2, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 800b0c6:	9b01      	ldr	r3, [sp, #4]
 800b0c8:	69db      	ldr	r3, [r3, #28]
 800b0ca:	9a01      	ldr	r2, [sp, #4]
 800b0cc:	6852      	ldr	r2, [r2, #4]
 800b0ce:	8952      	ldrh	r2, [r2, #10]
 800b0d0:	f042 0204 	orr.w	r2, r2, #4
 800b0d4:	b292      	uxth	r2, r2
 800b0d6:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
 800b0d8:	9b01      	ldr	r3, [sp, #4]
 800b0da:	69da      	ldr	r2, [r3, #28]
 800b0dc:	9b01      	ldr	r3, [sp, #4]
 800b0de:	685b      	ldr	r3, [r3, #4]
 800b0e0:	899b      	ldrh	r3, [r3, #12]
 800b0e2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800b0e6:	f043 0307 	orr.w	r3, r3, #7
 800b0ea:	b29b      	uxth	r3, r3
 800b0ec:	6053      	str	r3, [r2, #4]
                    SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 800b0ee:	9b01      	ldr	r3, [sp, #4]
 800b0f0:	69db      	ldr	r3, [r3, #28]
 800b0f2:	9a01      	ldr	r2, [sp, #4]
 800b0f4:	69d2      	ldr	r2, [r2, #28]
 800b0f6:	6812      	ldr	r2, [r2, #0]
 800b0f8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800b0fc:	601a      	str	r2, [r3, #0]
}
 800b0fe:	b005      	add	sp, #20
 800b100:	f85d fb04 	ldr.w	pc, [sp], #4
 800b104:	20003d88 	.word	0x20003d88
 800b108:	0800aed1 	.word	0x0800aed1
 800b10c:	0800af91 	.word	0x0800af91
 800b110:	40021000 	.word	0x40021000
 800b114:	f3af 8000 	nop.w
 800b118:	f3af 8000 	nop.w
 800b11c:	f3af 8000 	nop.w

0800b120 <spi_lld_stop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_stop(SPIDriver *spip) {
 800b120:	b500      	push	{lr}
 800b122:	b083      	sub	sp, #12
 800b124:	9001      	str	r0, [sp, #4]

  /* If in ready state then disables the SPI clock.*/
  if (spip->state == SPI_READY) {
 800b126:	9b01      	ldr	r3, [sp, #4]
 800b128:	781b      	ldrb	r3, [r3, #0]
 800b12a:	2b02      	cmp	r3, #2
 800b12c:	d11b      	bne.n	800b166 <spi_lld_stop+0x46>

    /* SPI disable.*/
    spip->spi->CR1 = 0;
 800b12e:	9b01      	ldr	r3, [sp, #4]
 800b130:	69db      	ldr	r3, [r3, #28]
 800b132:	2200      	movs	r2, #0
 800b134:	601a      	str	r2, [r3, #0]
    spip->spi->CR2 = 0;
 800b136:	9b01      	ldr	r3, [sp, #4]
 800b138:	69db      	ldr	r3, [r3, #28]
 800b13a:	2200      	movs	r2, #0
 800b13c:	605a      	str	r2, [r3, #4]
    dmaStreamRelease(spip->dmarx);
 800b13e:	9b01      	ldr	r3, [sp, #4]
 800b140:	6a1b      	ldr	r3, [r3, #32]
 800b142:	4618      	mov	r0, r3
 800b144:	f7fc fe84 	bl	8007e50 <dmaStreamRelease>
    dmaStreamRelease(spip->dmatx);
 800b148:	9b01      	ldr	r3, [sp, #4]
 800b14a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b14c:	4618      	mov	r0, r3
 800b14e:	f7fc fe7f 	bl	8007e50 <dmaStreamRelease>
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip)
      rccDisableSPI1(FALSE);
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip)
 800b152:	9a01      	ldr	r2, [sp, #4]
 800b154:	4b05      	ldr	r3, [pc, #20]	; (800b16c <spi_lld_stop+0x4c>)
 800b156:	429a      	cmp	r2, r3
 800b158:	d105      	bne.n	800b166 <spi_lld_stop+0x46>
      rccDisableSPI2(FALSE);
 800b15a:	4b05      	ldr	r3, [pc, #20]	; (800b170 <spi_lld_stop+0x50>)
 800b15c:	4a04      	ldr	r2, [pc, #16]	; (800b170 <spi_lld_stop+0x50>)
 800b15e:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800b160:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800b164:	659a      	str	r2, [r3, #88]	; 0x58
#if STM32_SPI_USE_SPI6
    if (&SPID6 == spip)
      rccDisableSPI6(FALSE);
#endif
  }
}
 800b166:	b003      	add	sp, #12
 800b168:	f85d fb04 	ldr.w	pc, [sp], #4
 800b16c:	20003d88 	.word	0x20003d88
 800b170:	40021000 	.word	0x40021000
 800b174:	f3af 8000 	nop.w
 800b178:	f3af 8000 	nop.w
 800b17c:	f3af 8000 	nop.w

0800b180 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {
 800b180:	b082      	sub	sp, #8
 800b182:	9001      	str	r0, [sp, #4]

  palClearPad(spip->config->ssport, spip->config->sspad);
 800b184:	9b01      	ldr	r3, [sp, #4]
 800b186:	685b      	ldr	r3, [r3, #4]
 800b188:	685b      	ldr	r3, [r3, #4]
 800b18a:	9a01      	ldr	r2, [sp, #4]
 800b18c:	6852      	ldr	r2, [r2, #4]
 800b18e:	8912      	ldrh	r2, [r2, #8]
 800b190:	2101      	movs	r1, #1
 800b192:	fa01 f202 	lsl.w	r2, r1, r2
 800b196:	b292      	uxth	r2, r2
 800b198:	835a      	strh	r2, [r3, #26]
}
 800b19a:	b002      	add	sp, #8
 800b19c:	4770      	bx	lr
 800b19e:	bf00      	nop

0800b1a0 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {
 800b1a0:	b082      	sub	sp, #8
 800b1a2:	9001      	str	r0, [sp, #4]

  palSetPad(spip->config->ssport, spip->config->sspad);
 800b1a4:	9b01      	ldr	r3, [sp, #4]
 800b1a6:	685b      	ldr	r3, [r3, #4]
 800b1a8:	685b      	ldr	r3, [r3, #4]
 800b1aa:	9a01      	ldr	r2, [sp, #4]
 800b1ac:	6852      	ldr	r2, [r2, #4]
 800b1ae:	8912      	ldrh	r2, [r2, #8]
 800b1b0:	2101      	movs	r1, #1
 800b1b2:	fa01 f202 	lsl.w	r2, r1, r2
 800b1b6:	b292      	uxth	r2, r2
 800b1b8:	831a      	strh	r2, [r3, #24]
}
 800b1ba:	b002      	add	sp, #8
 800b1bc:	4770      	bx	lr
 800b1be:	bf00      	nop

0800b1c0 <spi_lld_ignore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @notapi
 */
void spi_lld_ignore(SPIDriver *spip, size_t n) {
 800b1c0:	b084      	sub	sp, #16
 800b1c2:	9001      	str	r0, [sp, #4]
 800b1c4:	9100      	str	r1, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800b1c6:	9b01      	ldr	r3, [sp, #4]
 800b1c8:	6a1b      	ldr	r3, [r3, #32]
 800b1ca:	685b      	ldr	r3, [r3, #4]
 800b1cc:	4a38      	ldr	r2, [pc, #224]	; (800b2b0 <spi_lld_ignore+0xf0>)
 800b1ce:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b1d0:	9b01      	ldr	r3, [sp, #4]
 800b1d2:	6a1b      	ldr	r3, [r3, #32]
 800b1d4:	685b      	ldr	r3, [r3, #4]
 800b1d6:	9a00      	ldr	r2, [sp, #0]
 800b1d8:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800b1da:	9b01      	ldr	r3, [sp, #4]
 800b1dc:	6a1b      	ldr	r3, [r3, #32]
 800b1de:	68db      	ldr	r3, [r3, #12]
 800b1e0:	681b      	ldr	r3, [r3, #0]
 800b1e2:	9303      	str	r3, [sp, #12]
 800b1e4:	9b01      	ldr	r3, [sp, #4]
 800b1e6:	6a1b      	ldr	r3, [r3, #32]
 800b1e8:	7c1b      	ldrb	r3, [r3, #16]
 800b1ea:	220f      	movs	r2, #15
 800b1ec:	fa02 f303 	lsl.w	r3, r2, r3
 800b1f0:	43db      	mvns	r3, r3
 800b1f2:	9a03      	ldr	r2, [sp, #12]
 800b1f4:	4013      	ands	r3, r2
 800b1f6:	9303      	str	r3, [sp, #12]
 800b1f8:	9b01      	ldr	r3, [sp, #4]
 800b1fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b1fc:	0c1a      	lsrs	r2, r3, #16
 800b1fe:	9b01      	ldr	r3, [sp, #4]
 800b200:	6a1b      	ldr	r3, [r3, #32]
 800b202:	7c1b      	ldrb	r3, [r3, #16]
 800b204:	fa02 f303 	lsl.w	r3, r2, r3
 800b208:	9a03      	ldr	r2, [sp, #12]
 800b20a:	4313      	orrs	r3, r2
 800b20c:	9303      	str	r3, [sp, #12]
 800b20e:	9b01      	ldr	r3, [sp, #4]
 800b210:	6a1b      	ldr	r3, [r3, #32]
 800b212:	68db      	ldr	r3, [r3, #12]
 800b214:	9a03      	ldr	r2, [sp, #12]
 800b216:	601a      	str	r2, [r3, #0]
 800b218:	9b01      	ldr	r3, [sp, #4]
 800b21a:	6a1b      	ldr	r3, [r3, #32]
 800b21c:	685b      	ldr	r3, [r3, #4]
 800b21e:	9a01      	ldr	r2, [sp, #4]
 800b220:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b222:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800b224:	9b01      	ldr	r3, [sp, #4]
 800b226:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b228:	685b      	ldr	r3, [r3, #4]
 800b22a:	4a22      	ldr	r2, [pc, #136]	; (800b2b4 <spi_lld_ignore+0xf4>)
 800b22c:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b22e:	9b01      	ldr	r3, [sp, #4]
 800b230:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b232:	685b      	ldr	r3, [r3, #4]
 800b234:	9a00      	ldr	r2, [sp, #0]
 800b236:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800b238:	9b01      	ldr	r3, [sp, #4]
 800b23a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b23c:	68db      	ldr	r3, [r3, #12]
 800b23e:	681b      	ldr	r3, [r3, #0]
 800b240:	9302      	str	r3, [sp, #8]
 800b242:	9b01      	ldr	r3, [sp, #4]
 800b244:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b246:	7c1b      	ldrb	r3, [r3, #16]
 800b248:	220f      	movs	r2, #15
 800b24a:	fa02 f303 	lsl.w	r3, r2, r3
 800b24e:	43db      	mvns	r3, r3
 800b250:	9a02      	ldr	r2, [sp, #8]
 800b252:	4013      	ands	r3, r2
 800b254:	9302      	str	r3, [sp, #8]
 800b256:	9b01      	ldr	r3, [sp, #4]
 800b258:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b25a:	0c1a      	lsrs	r2, r3, #16
 800b25c:	9b01      	ldr	r3, [sp, #4]
 800b25e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b260:	7c1b      	ldrb	r3, [r3, #16]
 800b262:	fa02 f303 	lsl.w	r3, r2, r3
 800b266:	9a02      	ldr	r2, [sp, #8]
 800b268:	4313      	orrs	r3, r2
 800b26a:	9302      	str	r3, [sp, #8]
 800b26c:	9b01      	ldr	r3, [sp, #4]
 800b26e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b270:	68db      	ldr	r3, [r3, #12]
 800b272:	9a02      	ldr	r2, [sp, #8]
 800b274:	601a      	str	r2, [r3, #0]
 800b276:	9b01      	ldr	r3, [sp, #4]
 800b278:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b27a:	685b      	ldr	r3, [r3, #4]
 800b27c:	9a01      	ldr	r2, [sp, #4]
 800b27e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b280:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b282:	9b01      	ldr	r3, [sp, #4]
 800b284:	6a1b      	ldr	r3, [r3, #32]
 800b286:	685b      	ldr	r3, [r3, #4]
 800b288:	9a01      	ldr	r2, [sp, #4]
 800b28a:	6a12      	ldr	r2, [r2, #32]
 800b28c:	6852      	ldr	r2, [r2, #4]
 800b28e:	6812      	ldr	r2, [r2, #0]
 800b290:	f042 0201 	orr.w	r2, r2, #1
 800b294:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b296:	9b01      	ldr	r3, [sp, #4]
 800b298:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b29a:	685b      	ldr	r3, [r3, #4]
 800b29c:	9a01      	ldr	r2, [sp, #4]
 800b29e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b2a0:	6852      	ldr	r2, [r2, #4]
 800b2a2:	6812      	ldr	r2, [r2, #0]
 800b2a4:	f042 0201 	orr.w	r2, r2, #1
 800b2a8:	601a      	str	r2, [r3, #0]
}
 800b2aa:	b004      	add	sp, #16
 800b2ac:	4770      	bx	lr
 800b2ae:	bf00      	nop
 800b2b0:	20001464 	.word	0x20001464
 800b2b4:	0801ac30 	.word	0x0801ac30
 800b2b8:	f3af 8000 	nop.w
 800b2bc:	f3af 8000 	nop.w

0800b2c0 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 800b2c0:	b086      	sub	sp, #24
 800b2c2:	9003      	str	r0, [sp, #12]
 800b2c4:	9102      	str	r1, [sp, #8]
 800b2c6:	9201      	str	r2, [sp, #4]
 800b2c8:	9300      	str	r3, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800b2ca:	9b03      	ldr	r3, [sp, #12]
 800b2cc:	6a1b      	ldr	r3, [r3, #32]
 800b2ce:	685b      	ldr	r3, [r3, #4]
 800b2d0:	9a00      	ldr	r2, [sp, #0]
 800b2d2:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b2d4:	9b03      	ldr	r3, [sp, #12]
 800b2d6:	6a1b      	ldr	r3, [r3, #32]
 800b2d8:	685b      	ldr	r3, [r3, #4]
 800b2da:	9a02      	ldr	r2, [sp, #8]
 800b2dc:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800b2de:	9b03      	ldr	r3, [sp, #12]
 800b2e0:	6a1b      	ldr	r3, [r3, #32]
 800b2e2:	68db      	ldr	r3, [r3, #12]
 800b2e4:	681b      	ldr	r3, [r3, #0]
 800b2e6:	9305      	str	r3, [sp, #20]
 800b2e8:	9b03      	ldr	r3, [sp, #12]
 800b2ea:	6a1b      	ldr	r3, [r3, #32]
 800b2ec:	7c1b      	ldrb	r3, [r3, #16]
 800b2ee:	220f      	movs	r2, #15
 800b2f0:	fa02 f303 	lsl.w	r3, r2, r3
 800b2f4:	43db      	mvns	r3, r3
 800b2f6:	9a05      	ldr	r2, [sp, #20]
 800b2f8:	4013      	ands	r3, r2
 800b2fa:	9305      	str	r3, [sp, #20]
 800b2fc:	9b03      	ldr	r3, [sp, #12]
 800b2fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b300:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b304:	0c1a      	lsrs	r2, r3, #16
 800b306:	9b03      	ldr	r3, [sp, #12]
 800b308:	6a1b      	ldr	r3, [r3, #32]
 800b30a:	7c1b      	ldrb	r3, [r3, #16]
 800b30c:	fa02 f303 	lsl.w	r3, r2, r3
 800b310:	9a05      	ldr	r2, [sp, #20]
 800b312:	4313      	orrs	r3, r2
 800b314:	9305      	str	r3, [sp, #20]
 800b316:	9b03      	ldr	r3, [sp, #12]
 800b318:	6a1b      	ldr	r3, [r3, #32]
 800b31a:	68db      	ldr	r3, [r3, #12]
 800b31c:	9a05      	ldr	r2, [sp, #20]
 800b31e:	601a      	str	r2, [r3, #0]
 800b320:	9b03      	ldr	r3, [sp, #12]
 800b322:	6a1b      	ldr	r3, [r3, #32]
 800b324:	685b      	ldr	r3, [r3, #4]
 800b326:	9a03      	ldr	r2, [sp, #12]
 800b328:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b32a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b32e:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800b330:	9b03      	ldr	r3, [sp, #12]
 800b332:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b334:	685b      	ldr	r3, [r3, #4]
 800b336:	9a01      	ldr	r2, [sp, #4]
 800b338:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b33a:	9b03      	ldr	r3, [sp, #12]
 800b33c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b33e:	685b      	ldr	r3, [r3, #4]
 800b340:	9a02      	ldr	r2, [sp, #8]
 800b342:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800b344:	9b03      	ldr	r3, [sp, #12]
 800b346:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b348:	68db      	ldr	r3, [r3, #12]
 800b34a:	681b      	ldr	r3, [r3, #0]
 800b34c:	9304      	str	r3, [sp, #16]
 800b34e:	9b03      	ldr	r3, [sp, #12]
 800b350:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b352:	7c1b      	ldrb	r3, [r3, #16]
 800b354:	220f      	movs	r2, #15
 800b356:	fa02 f303 	lsl.w	r3, r2, r3
 800b35a:	43db      	mvns	r3, r3
 800b35c:	9a04      	ldr	r2, [sp, #16]
 800b35e:	4013      	ands	r3, r2
 800b360:	9304      	str	r3, [sp, #16]
 800b362:	9b03      	ldr	r3, [sp, #12]
 800b364:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b366:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b36a:	0c1a      	lsrs	r2, r3, #16
 800b36c:	9b03      	ldr	r3, [sp, #12]
 800b36e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b370:	7c1b      	ldrb	r3, [r3, #16]
 800b372:	fa02 f303 	lsl.w	r3, r2, r3
 800b376:	9a04      	ldr	r2, [sp, #16]
 800b378:	4313      	orrs	r3, r2
 800b37a:	9304      	str	r3, [sp, #16]
 800b37c:	9b03      	ldr	r3, [sp, #12]
 800b37e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b380:	68db      	ldr	r3, [r3, #12]
 800b382:	9a04      	ldr	r2, [sp, #16]
 800b384:	601a      	str	r2, [r3, #0]
 800b386:	9b03      	ldr	r3, [sp, #12]
 800b388:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b38a:	685b      	ldr	r3, [r3, #4]
 800b38c:	9a03      	ldr	r2, [sp, #12]
 800b38e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b390:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b394:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b396:	9b03      	ldr	r3, [sp, #12]
 800b398:	6a1b      	ldr	r3, [r3, #32]
 800b39a:	685b      	ldr	r3, [r3, #4]
 800b39c:	9a03      	ldr	r2, [sp, #12]
 800b39e:	6a12      	ldr	r2, [r2, #32]
 800b3a0:	6852      	ldr	r2, [r2, #4]
 800b3a2:	6812      	ldr	r2, [r2, #0]
 800b3a4:	f042 0201 	orr.w	r2, r2, #1
 800b3a8:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b3aa:	9b03      	ldr	r3, [sp, #12]
 800b3ac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b3ae:	685b      	ldr	r3, [r3, #4]
 800b3b0:	9a03      	ldr	r2, [sp, #12]
 800b3b2:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b3b4:	6852      	ldr	r2, [r2, #4]
 800b3b6:	6812      	ldr	r2, [r2, #0]
 800b3b8:	f042 0201 	orr.w	r2, r2, #1
 800b3bc:	601a      	str	r2, [r3, #0]
}
 800b3be:	b006      	add	sp, #24
 800b3c0:	4770      	bx	lr
 800b3c2:	bf00      	nop
 800b3c4:	f3af 8000 	nop.w
 800b3c8:	f3af 8000 	nop.w
 800b3cc:	f3af 8000 	nop.w

0800b3d0 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 800b3d0:	b086      	sub	sp, #24
 800b3d2:	9003      	str	r0, [sp, #12]
 800b3d4:	9102      	str	r1, [sp, #8]
 800b3d6:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800b3d8:	9b03      	ldr	r3, [sp, #12]
 800b3da:	6a1b      	ldr	r3, [r3, #32]
 800b3dc:	685b      	ldr	r3, [r3, #4]
 800b3de:	4a3a      	ldr	r2, [pc, #232]	; (800b4c8 <spi_lld_send+0xf8>)
 800b3e0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b3e2:	9b03      	ldr	r3, [sp, #12]
 800b3e4:	6a1b      	ldr	r3, [r3, #32]
 800b3e6:	685b      	ldr	r3, [r3, #4]
 800b3e8:	9a02      	ldr	r2, [sp, #8]
 800b3ea:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800b3ec:	9b03      	ldr	r3, [sp, #12]
 800b3ee:	6a1b      	ldr	r3, [r3, #32]
 800b3f0:	68db      	ldr	r3, [r3, #12]
 800b3f2:	681b      	ldr	r3, [r3, #0]
 800b3f4:	9305      	str	r3, [sp, #20]
 800b3f6:	9b03      	ldr	r3, [sp, #12]
 800b3f8:	6a1b      	ldr	r3, [r3, #32]
 800b3fa:	7c1b      	ldrb	r3, [r3, #16]
 800b3fc:	220f      	movs	r2, #15
 800b3fe:	fa02 f303 	lsl.w	r3, r2, r3
 800b402:	43db      	mvns	r3, r3
 800b404:	9a05      	ldr	r2, [sp, #20]
 800b406:	4013      	ands	r3, r2
 800b408:	9305      	str	r3, [sp, #20]
 800b40a:	9b03      	ldr	r3, [sp, #12]
 800b40c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b40e:	0c1a      	lsrs	r2, r3, #16
 800b410:	9b03      	ldr	r3, [sp, #12]
 800b412:	6a1b      	ldr	r3, [r3, #32]
 800b414:	7c1b      	ldrb	r3, [r3, #16]
 800b416:	fa02 f303 	lsl.w	r3, r2, r3
 800b41a:	9a05      	ldr	r2, [sp, #20]
 800b41c:	4313      	orrs	r3, r2
 800b41e:	9305      	str	r3, [sp, #20]
 800b420:	9b03      	ldr	r3, [sp, #12]
 800b422:	6a1b      	ldr	r3, [r3, #32]
 800b424:	68db      	ldr	r3, [r3, #12]
 800b426:	9a05      	ldr	r2, [sp, #20]
 800b428:	601a      	str	r2, [r3, #0]
 800b42a:	9b03      	ldr	r3, [sp, #12]
 800b42c:	6a1b      	ldr	r3, [r3, #32]
 800b42e:	685b      	ldr	r3, [r3, #4]
 800b430:	9a03      	ldr	r2, [sp, #12]
 800b432:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b434:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800b436:	9b03      	ldr	r3, [sp, #12]
 800b438:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b43a:	685b      	ldr	r3, [r3, #4]
 800b43c:	9a01      	ldr	r2, [sp, #4]
 800b43e:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b440:	9b03      	ldr	r3, [sp, #12]
 800b442:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b444:	685b      	ldr	r3, [r3, #4]
 800b446:	9a02      	ldr	r2, [sp, #8]
 800b448:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800b44a:	9b03      	ldr	r3, [sp, #12]
 800b44c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b44e:	68db      	ldr	r3, [r3, #12]
 800b450:	681b      	ldr	r3, [r3, #0]
 800b452:	9304      	str	r3, [sp, #16]
 800b454:	9b03      	ldr	r3, [sp, #12]
 800b456:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b458:	7c1b      	ldrb	r3, [r3, #16]
 800b45a:	220f      	movs	r2, #15
 800b45c:	fa02 f303 	lsl.w	r3, r2, r3
 800b460:	43db      	mvns	r3, r3
 800b462:	9a04      	ldr	r2, [sp, #16]
 800b464:	4013      	ands	r3, r2
 800b466:	9304      	str	r3, [sp, #16]
 800b468:	9b03      	ldr	r3, [sp, #12]
 800b46a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b46c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b470:	0c1a      	lsrs	r2, r3, #16
 800b472:	9b03      	ldr	r3, [sp, #12]
 800b474:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b476:	7c1b      	ldrb	r3, [r3, #16]
 800b478:	fa02 f303 	lsl.w	r3, r2, r3
 800b47c:	9a04      	ldr	r2, [sp, #16]
 800b47e:	4313      	orrs	r3, r2
 800b480:	9304      	str	r3, [sp, #16]
 800b482:	9b03      	ldr	r3, [sp, #12]
 800b484:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b486:	68db      	ldr	r3, [r3, #12]
 800b488:	9a04      	ldr	r2, [sp, #16]
 800b48a:	601a      	str	r2, [r3, #0]
 800b48c:	9b03      	ldr	r3, [sp, #12]
 800b48e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b490:	685b      	ldr	r3, [r3, #4]
 800b492:	9a03      	ldr	r2, [sp, #12]
 800b494:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b496:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b49a:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b49c:	9b03      	ldr	r3, [sp, #12]
 800b49e:	6a1b      	ldr	r3, [r3, #32]
 800b4a0:	685b      	ldr	r3, [r3, #4]
 800b4a2:	9a03      	ldr	r2, [sp, #12]
 800b4a4:	6a12      	ldr	r2, [r2, #32]
 800b4a6:	6852      	ldr	r2, [r2, #4]
 800b4a8:	6812      	ldr	r2, [r2, #0]
 800b4aa:	f042 0201 	orr.w	r2, r2, #1
 800b4ae:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b4b0:	9b03      	ldr	r3, [sp, #12]
 800b4b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b4b4:	685b      	ldr	r3, [r3, #4]
 800b4b6:	9a03      	ldr	r2, [sp, #12]
 800b4b8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b4ba:	6852      	ldr	r2, [r2, #4]
 800b4bc:	6812      	ldr	r2, [r2, #0]
 800b4be:	f042 0201 	orr.w	r2, r2, #1
 800b4c2:	601a      	str	r2, [r3, #0]
}
 800b4c4:	b006      	add	sp, #24
 800b4c6:	4770      	bx	lr
 800b4c8:	20001464 	.word	0x20001464
 800b4cc:	f3af 8000 	nop.w

0800b4d0 <spi_lld_receive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
 800b4d0:	b086      	sub	sp, #24
 800b4d2:	9003      	str	r0, [sp, #12]
 800b4d4:	9102      	str	r1, [sp, #8]
 800b4d6:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800b4d8:	9b03      	ldr	r3, [sp, #12]
 800b4da:	6a1b      	ldr	r3, [r3, #32]
 800b4dc:	685b      	ldr	r3, [r3, #4]
 800b4de:	9a01      	ldr	r2, [sp, #4]
 800b4e0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b4e2:	9b03      	ldr	r3, [sp, #12]
 800b4e4:	6a1b      	ldr	r3, [r3, #32]
 800b4e6:	685b      	ldr	r3, [r3, #4]
 800b4e8:	9a02      	ldr	r2, [sp, #8]
 800b4ea:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800b4ec:	9b03      	ldr	r3, [sp, #12]
 800b4ee:	6a1b      	ldr	r3, [r3, #32]
 800b4f0:	68db      	ldr	r3, [r3, #12]
 800b4f2:	681b      	ldr	r3, [r3, #0]
 800b4f4:	9305      	str	r3, [sp, #20]
 800b4f6:	9b03      	ldr	r3, [sp, #12]
 800b4f8:	6a1b      	ldr	r3, [r3, #32]
 800b4fa:	7c1b      	ldrb	r3, [r3, #16]
 800b4fc:	220f      	movs	r2, #15
 800b4fe:	fa02 f303 	lsl.w	r3, r2, r3
 800b502:	43db      	mvns	r3, r3
 800b504:	9a05      	ldr	r2, [sp, #20]
 800b506:	4013      	ands	r3, r2
 800b508:	9305      	str	r3, [sp, #20]
 800b50a:	9b03      	ldr	r3, [sp, #12]
 800b50c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b50e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b512:	0c1a      	lsrs	r2, r3, #16
 800b514:	9b03      	ldr	r3, [sp, #12]
 800b516:	6a1b      	ldr	r3, [r3, #32]
 800b518:	7c1b      	ldrb	r3, [r3, #16]
 800b51a:	fa02 f303 	lsl.w	r3, r2, r3
 800b51e:	9a05      	ldr	r2, [sp, #20]
 800b520:	4313      	orrs	r3, r2
 800b522:	9305      	str	r3, [sp, #20]
 800b524:	9b03      	ldr	r3, [sp, #12]
 800b526:	6a1b      	ldr	r3, [r3, #32]
 800b528:	68db      	ldr	r3, [r3, #12]
 800b52a:	9a05      	ldr	r2, [sp, #20]
 800b52c:	601a      	str	r2, [r3, #0]
 800b52e:	9b03      	ldr	r3, [sp, #12]
 800b530:	6a1b      	ldr	r3, [r3, #32]
 800b532:	685b      	ldr	r3, [r3, #4]
 800b534:	9a03      	ldr	r2, [sp, #12]
 800b536:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b538:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b53c:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800b53e:	9b03      	ldr	r3, [sp, #12]
 800b540:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b542:	685b      	ldr	r3, [r3, #4]
 800b544:	4a20      	ldr	r2, [pc, #128]	; (800b5c8 <spi_lld_receive+0xf8>)
 800b546:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b548:	9b03      	ldr	r3, [sp, #12]
 800b54a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b54c:	685b      	ldr	r3, [r3, #4]
 800b54e:	9a02      	ldr	r2, [sp, #8]
 800b550:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800b552:	9b03      	ldr	r3, [sp, #12]
 800b554:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b556:	68db      	ldr	r3, [r3, #12]
 800b558:	681b      	ldr	r3, [r3, #0]
 800b55a:	9304      	str	r3, [sp, #16]
 800b55c:	9b03      	ldr	r3, [sp, #12]
 800b55e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b560:	7c1b      	ldrb	r3, [r3, #16]
 800b562:	220f      	movs	r2, #15
 800b564:	fa02 f303 	lsl.w	r3, r2, r3
 800b568:	43db      	mvns	r3, r3
 800b56a:	9a04      	ldr	r2, [sp, #16]
 800b56c:	4013      	ands	r3, r2
 800b56e:	9304      	str	r3, [sp, #16]
 800b570:	9b03      	ldr	r3, [sp, #12]
 800b572:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b574:	0c1a      	lsrs	r2, r3, #16
 800b576:	9b03      	ldr	r3, [sp, #12]
 800b578:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b57a:	7c1b      	ldrb	r3, [r3, #16]
 800b57c:	fa02 f303 	lsl.w	r3, r2, r3
 800b580:	9a04      	ldr	r2, [sp, #16]
 800b582:	4313      	orrs	r3, r2
 800b584:	9304      	str	r3, [sp, #16]
 800b586:	9b03      	ldr	r3, [sp, #12]
 800b588:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b58a:	68db      	ldr	r3, [r3, #12]
 800b58c:	9a04      	ldr	r2, [sp, #16]
 800b58e:	601a      	str	r2, [r3, #0]
 800b590:	9b03      	ldr	r3, [sp, #12]
 800b592:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b594:	685b      	ldr	r3, [r3, #4]
 800b596:	9a03      	ldr	r2, [sp, #12]
 800b598:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b59a:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b59c:	9b03      	ldr	r3, [sp, #12]
 800b59e:	6a1b      	ldr	r3, [r3, #32]
 800b5a0:	685b      	ldr	r3, [r3, #4]
 800b5a2:	9a03      	ldr	r2, [sp, #12]
 800b5a4:	6a12      	ldr	r2, [r2, #32]
 800b5a6:	6852      	ldr	r2, [r2, #4]
 800b5a8:	6812      	ldr	r2, [r2, #0]
 800b5aa:	f042 0201 	orr.w	r2, r2, #1
 800b5ae:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b5b0:	9b03      	ldr	r3, [sp, #12]
 800b5b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b5b4:	685b      	ldr	r3, [r3, #4]
 800b5b6:	9a03      	ldr	r2, [sp, #12]
 800b5b8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b5ba:	6852      	ldr	r2, [r2, #4]
 800b5bc:	6812      	ldr	r2, [r2, #0]
 800b5be:	f042 0201 	orr.w	r2, r2, #1
 800b5c2:	601a      	str	r2, [r3, #0]
}
 800b5c4:	b006      	add	sp, #24
 800b5c6:	4770      	bx	lr
 800b5c8:	0801ac30 	.word	0x0801ac30
 800b5cc:	f3af 8000 	nop.w

0800b5d0 <spi_lld_polled_exchange>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint16_t spi_lld_polled_exchange(SPIDriver *spip, uint16_t frame) {
 800b5d0:	b084      	sub	sp, #16
 800b5d2:	9001      	str	r0, [sp, #4]
 800b5d4:	460b      	mov	r3, r1
 800b5d6:	f8ad 3002 	strh.w	r3, [sp, #2]
  /*
   * Data register must be accessed with the appropriate data size.
   * Byte size access (uint8_t *) for transactions that are <= 8-bit.
   * Halfword size access (uint16_t) for transactions that are <= 8-bit.
   */
  if ((spip->config->cr2 & SPI_CR2_DS) <= (SPI_CR2_DS_2 |
 800b5da:	9b01      	ldr	r3, [sp, #4]
 800b5dc:	685b      	ldr	r3, [r3, #4]
 800b5de:	899b      	ldrh	r3, [r3, #12]
 800b5e0:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800b5e4:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800b5e8:	d814      	bhi.n	800b614 <spi_lld_polled_exchange+0x44>
                                           SPI_CR2_DS_1 |
                                           SPI_CR2_DS_0)) {
    volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800b5ea:	9b01      	ldr	r3, [sp, #4]
 800b5ec:	69db      	ldr	r3, [r3, #28]
 800b5ee:	330c      	adds	r3, #12
 800b5f0:	9303      	str	r3, [sp, #12]
    *spidr = (uint8_t)frame;
 800b5f2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800b5f6:	b2da      	uxtb	r2, r3
 800b5f8:	9b03      	ldr	r3, [sp, #12]
 800b5fa:	701a      	strb	r2, [r3, #0]
    while ((spip->spi->SR & SPI_SR_RXNE) == 0)
 800b5fc:	bf00      	nop
 800b5fe:	9b01      	ldr	r3, [sp, #4]
 800b600:	69db      	ldr	r3, [r3, #28]
 800b602:	689b      	ldr	r3, [r3, #8]
 800b604:	f003 0301 	and.w	r3, r3, #1
 800b608:	2b00      	cmp	r3, #0
 800b60a:	d0f8      	beq.n	800b5fe <spi_lld_polled_exchange+0x2e>
      ;
    return (uint16_t)*spidr;
 800b60c:	9b03      	ldr	r3, [sp, #12]
 800b60e:	781b      	ldrb	r3, [r3, #0]
 800b610:	b2db      	uxtb	r3, r3
 800b612:	e010      	b.n	800b636 <spi_lld_polled_exchange+0x66>
  }
  else {
    spip->spi->DR = frame;
 800b614:	9b01      	ldr	r3, [sp, #4]
 800b616:	69db      	ldr	r3, [r3, #28]
 800b618:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 800b61c:	60da      	str	r2, [r3, #12]
    while ((spip->spi->SR & SPI_SR_RXNE) == 0)
 800b61e:	bf00      	nop
 800b620:	9b01      	ldr	r3, [sp, #4]
 800b622:	69db      	ldr	r3, [r3, #28]
 800b624:	689b      	ldr	r3, [r3, #8]
 800b626:	f003 0301 	and.w	r3, r3, #1
 800b62a:	2b00      	cmp	r3, #0
 800b62c:	d0f8      	beq.n	800b620 <spi_lld_polled_exchange+0x50>
      ;
    return spip->spi->DR;
 800b62e:	9b01      	ldr	r3, [sp, #4]
 800b630:	69db      	ldr	r3, [r3, #28]
 800b632:	68db      	ldr	r3, [r3, #12]
 800b634:	b29b      	uxth	r3, r3
  }
}
 800b636:	4618      	mov	r0, r3
 800b638:	b004      	add	sp, #16
 800b63a:	4770      	bx	lr
 800b63c:	f3af 8000 	nop.w

0800b640 <spi_lld_polled_tx>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */

int spi_lld_polled_tx(SPIDriver *spip, uint8_t val) {
 800b640:	b084      	sub	sp, #16
 800b642:	9001      	str	r0, [sp, #4]
 800b644:	460b      	mov	r3, r1
 800b646:	f88d 3003 	strb.w	r3, [sp, #3]

  /* check TXE flag */
  while ((spip->spi->SR & SPI_SR_TXE) != SPI_SR_TXE);
 800b64a:	bf00      	nop
 800b64c:	9b01      	ldr	r3, [sp, #4]
 800b64e:	69db      	ldr	r3, [r3, #28]
 800b650:	689b      	ldr	r3, [r3, #8]
 800b652:	f003 0302 	and.w	r3, r3, #2
 800b656:	2b00      	cmp	r3, #0
 800b658:	d0f8      	beq.n	800b64c <spi_lld_polled_tx+0xc>

  /* Write the data */
  volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800b65a:	9b01      	ldr	r3, [sp, #4]
 800b65c:	69db      	ldr	r3, [r3, #28]
 800b65e:	330c      	adds	r3, #12
 800b660:	9303      	str	r3, [sp, #12]
  *spidr = val;
 800b662:	9b03      	ldr	r3, [sp, #12]
 800b664:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800b668:	701a      	strb	r2, [r3, #0]

  /* Check to see that the Transmitter is empty */
  while (spip->spi->SR & SPI_SR_FTLVL);
 800b66a:	bf00      	nop
 800b66c:	9b01      	ldr	r3, [sp, #4]
 800b66e:	69db      	ldr	r3, [r3, #28]
 800b670:	689b      	ldr	r3, [r3, #8]
 800b672:	f403 53c0 	and.w	r3, r3, #6144	; 0x1800
 800b676:	2b00      	cmp	r3, #0
 800b678:	d1f8      	bne.n	800b66c <spi_lld_polled_tx+0x2c>
  while ((spip->spi->SR & SPI_SR_BSY) == SPI_SR_BSY);
 800b67a:	bf00      	nop
 800b67c:	9b01      	ldr	r3, [sp, #4]
 800b67e:	69db      	ldr	r3, [r3, #28]
 800b680:	689b      	ldr	r3, [r3, #8]
 800b682:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b686:	2b00      	cmp	r3, #0
 800b688:	d1f8      	bne.n	800b67c <spi_lld_polled_tx+0x3c>

  return (0);
 800b68a:	2300      	movs	r3, #0
}
 800b68c:	4618      	mov	r0, r3
 800b68e:	b004      	add	sp, #16
 800b690:	4770      	bx	lr
 800b692:	bf00      	nop
 800b694:	f3af 8000 	nop.w
 800b698:	f3af 8000 	nop.w
 800b69c:	f3af 8000 	nop.w

0800b6a0 <spi_lld_polled_rx>:

int spi_lld_polled_rx(SPIDriver *spip) {
 800b6a0:	b500      	push	{lr}
 800b6a2:	b085      	sub	sp, #20
 800b6a4:	9001      	str	r0, [sp, #4]
  /* In master RX mode the clock is automaticaly generated on the SPI enable.
  So to guarantee the clock generation for only one data, the clock must be
  disabled after the first bit and before the latest bit */
  /* Interrupts should be disabled during this operation */

  chSysLock();
 800b6a6:	f7ff fbc3 	bl	800ae30 <chSysLock>
  spip->spi->CR1 |= SPI_CR1_SPE;   // Turn on the SPI 
 800b6aa:	9b01      	ldr	r3, [sp, #4]
 800b6ac:	69db      	ldr	r3, [r3, #28]
 800b6ae:	9a01      	ldr	r2, [sp, #4]
 800b6b0:	69d2      	ldr	r2, [r2, #28]
 800b6b2:	6812      	ldr	r2, [r2, #0]
 800b6b4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800b6b8:	601a      	str	r2, [r3, #0]
  __asm("dsb\n");
 800b6ba:	f3bf 8f4f 	dsb	sy
  __asm("dsb\n");
 800b6be:	f3bf 8f4f 	dsb	sy
  spip->spi->CR1 &= ~SPI_CR1_SPE;   // Turn off the SPI
 800b6c2:	9b01      	ldr	r3, [sp, #4]
 800b6c4:	69db      	ldr	r3, [r3, #28]
 800b6c6:	9a01      	ldr	r2, [sp, #4]
 800b6c8:	69d2      	ldr	r2, [r2, #28]
 800b6ca:	6812      	ldr	r2, [r2, #0]
 800b6cc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800b6d0:	601a      	str	r2, [r3, #0]
  chSysUnlock();
 800b6d2:	f7ff fbb5 	bl	800ae40 <chSysUnlock>
  
  while ((spip->spi->SR & SPI_SR_RXNE) != SPI_SR_RXNE);
 800b6d6:	bf00      	nop
 800b6d8:	9b01      	ldr	r3, [sp, #4]
 800b6da:	69db      	ldr	r3, [r3, #28]
 800b6dc:	689b      	ldr	r3, [r3, #8]
 800b6de:	f003 0301 	and.w	r3, r3, #1
 800b6e2:	2b00      	cmp	r3, #0
 800b6e4:	d0f8      	beq.n	800b6d8 <spi_lld_polled_rx+0x38>
  /* read the received data */
  volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800b6e6:	9b01      	ldr	r3, [sp, #4]
 800b6e8:	69db      	ldr	r3, [r3, #28]
 800b6ea:	330c      	adds	r3, #12
 800b6ec:	9303      	str	r3, [sp, #12]
  val = *spidr;
 800b6ee:	9b03      	ldr	r3, [sp, #12]
 800b6f0:	781b      	ldrb	r3, [r3, #0]
 800b6f2:	f88d 300b 	strb.w	r3, [sp, #11]
  while ((spip->spi->SR & SPI_SR_BSY) == SPI_SR_BSY);
 800b6f6:	bf00      	nop
 800b6f8:	9b01      	ldr	r3, [sp, #4]
 800b6fa:	69db      	ldr	r3, [r3, #28]
 800b6fc:	689b      	ldr	r3, [r3, #8]
 800b6fe:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b702:	2b00      	cmp	r3, #0
 800b704:	d1f8      	bne.n	800b6f8 <spi_lld_polled_rx+0x58>
  return (val);
 800b706:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800b70a:	4618      	mov	r0, r3
 800b70c:	b005      	add	sp, #20
 800b70e:	f85d fb04 	ldr.w	pc, [sp], #4
 800b712:	bf00      	nop
 800b714:	f3af 8000 	nop.w
 800b718:	f3af 8000 	nop.w
 800b71c:	f3af 8000 	nop.w

0800b720 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b720:	b082      	sub	sp, #8
 800b722:	2320      	movs	r3, #32
 800b724:	9301      	str	r3, [sp, #4]
 800b726:	9b01      	ldr	r3, [sp, #4]
 800b728:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b72c:	b002      	add	sp, #8
 800b72e:	4770      	bx	lr

0800b730 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b730:	b082      	sub	sp, #8
 800b732:	2300      	movs	r3, #0
 800b734:	9301      	str	r3, [sp, #4]
 800b736:	9b01      	ldr	r3, [sp, #4]
 800b738:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b73c:	b002      	add	sp, #8
 800b73e:	4770      	bx	lr

0800b740 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800b740:	b508      	push	{r3, lr}

  port_lock();
 800b742:	f7ff ffed 	bl	800b720 <port_lock>
}
 800b746:	bd08      	pop	{r3, pc}
 800b748:	f3af 8000 	nop.w
 800b74c:	f3af 8000 	nop.w

0800b750 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800b750:	b508      	push	{r3, lr}

  port_unlock();
 800b752:	f7ff ffed 	bl	800b730 <port_unlock>
}
 800b756:	bd08      	pop	{r3, pc}
 800b758:	f3af 8000 	nop.w
 800b75c:	f3af 8000 	nop.w

0800b760 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800b760:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800b762:	f7ff ffed 	bl	800b740 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800b766:	bd08      	pop	{r3, pc}
 800b768:	f3af 8000 	nop.w
 800b76c:	f3af 8000 	nop.w

0800b770 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800b770:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800b772:	f7ff ffed 	bl	800b750 <port_unlock_from_isr>
}
 800b776:	bd08      	pop	{r3, pc}
 800b778:	f3af 8000 	nop.w
 800b77c:	f3af 8000 	nop.w

0800b780 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 800b780:	b082      	sub	sp, #8
 800b782:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800b784:	9b01      	ldr	r3, [sp, #4]
 800b786:	695a      	ldr	r2, [r3, #20]
 800b788:	9b01      	ldr	r3, [sp, #4]
 800b78a:	699b      	ldr	r3, [r3, #24]
 800b78c:	429a      	cmp	r2, r3
 800b78e:	d105      	bne.n	800b79c <chOQIsEmptyI+0x1c>
 800b790:	9b01      	ldr	r3, [sp, #4]
 800b792:	689b      	ldr	r3, [r3, #8]
 800b794:	2b00      	cmp	r3, #0
 800b796:	d001      	beq.n	800b79c <chOQIsEmptyI+0x1c>
 800b798:	2301      	movs	r3, #1
 800b79a:	e000      	b.n	800b79e <chOQIsEmptyI+0x1e>
 800b79c:	2300      	movs	r3, #0
 800b79e:	f003 0301 	and.w	r3, r3, #1
 800b7a2:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800b7a4:	4618      	mov	r0, r3
 800b7a6:	b002      	add	sp, #8
 800b7a8:	4770      	bx	lr
 800b7aa:	bf00      	nop
 800b7ac:	f3af 8000 	nop.w

0800b7b0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800b7b0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800b7b2:	f7ff ffd5 	bl	800b760 <chSysLockFromISR>
}
 800b7b6:	bd08      	pop	{r3, pc}
 800b7b8:	f3af 8000 	nop.w
 800b7bc:	f3af 8000 	nop.w

0800b7c0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800b7c0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800b7c2:	f7ff ffd5 	bl	800b770 <chSysUnlockFromISR>
}
 800b7c6:	bd08      	pop	{r3, pc}
 800b7c8:	f3af 8000 	nop.w
 800b7cc:	f3af 8000 	nop.w

0800b7d0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 800b7d0:	b500      	push	{lr}
 800b7d2:	b083      	sub	sp, #12
 800b7d4:	9001      	str	r0, [sp, #4]
 800b7d6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 800b7d8:	9801      	ldr	r0, [sp, #4]
 800b7da:	9900      	ldr	r1, [sp, #0]
 800b7dc:	f7f6 ff50 	bl	8002680 <chEvtBroadcastFlagsI>
}
 800b7e0:	b003      	add	sp, #12
 800b7e2:	f85d fb04 	ldr.w	pc, [sp], #4
 800b7e6:	bf00      	nop
 800b7e8:	f3af 8000 	nop.w
 800b7ec:	f3af 8000 	nop.w

0800b7f0 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 800b7f0:	b084      	sub	sp, #16
 800b7f2:	9001      	str	r0, [sp, #4]
 800b7f4:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 800b7f6:	9b01      	ldr	r3, [sp, #4]
 800b7f8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b7fa:	9303      	str	r3, [sp, #12]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800b7fc:	9b01      	ldr	r3, [sp, #4]
 800b7fe:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800b800:	9b00      	ldr	r3, [sp, #0]
 800b802:	681b      	ldr	r3, [r3, #0]
 800b804:	fbb2 f2f3 	udiv	r2, r2, r3
 800b808:	9b03      	ldr	r3, [sp, #12]
 800b80a:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800b80c:	9b00      	ldr	r3, [sp, #0]
 800b80e:	689b      	ldr	r3, [r3, #8]
 800b810:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800b814:	9b03      	ldr	r3, [sp, #12]
 800b816:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800b818:	9b00      	ldr	r3, [sp, #0]
 800b81a:	68db      	ldr	r3, [r3, #12]
 800b81c:	f043 0201 	orr.w	r2, r3, #1
 800b820:	9b03      	ldr	r3, [sp, #12]
 800b822:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800b824:	9b00      	ldr	r3, [sp, #0]
 800b826:	685b      	ldr	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800b828:	f443 7396 	orr.w	r3, r3, #300	; 0x12c
 800b82c:	f043 0301 	orr.w	r3, r3, #1
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800b830:	9a03      	ldr	r2, [sp, #12]
 800b832:	6013      	str	r3, [r2, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800b834:	9b03      	ldr	r3, [sp, #12]
 800b836:	f04f 32ff 	mov.w	r2, #4294967295
 800b83a:	621a      	str	r2, [r3, #32]
}
 800b83c:	b004      	add	sp, #16
 800b83e:	4770      	bx	lr

0800b840 <usart_deinit>:
 * @brief   USART de-initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] u         pointer to an USART I/O block
 */
static void usart_deinit(USART_TypeDef *u) {
 800b840:	b082      	sub	sp, #8
 800b842:	9001      	str	r0, [sp, #4]

  u->CR1 = 0;
 800b844:	9b01      	ldr	r3, [sp, #4]
 800b846:	2200      	movs	r2, #0
 800b848:	601a      	str	r2, [r3, #0]
  u->CR2 = 0;
 800b84a:	9b01      	ldr	r3, [sp, #4]
 800b84c:	2200      	movs	r2, #0
 800b84e:	605a      	str	r2, [r3, #4]
  u->CR3 = 0;
 800b850:	9b01      	ldr	r3, [sp, #4]
 800b852:	2200      	movs	r2, #0
 800b854:	609a      	str	r2, [r3, #8]
}
 800b856:	b002      	add	sp, #8
 800b858:	4770      	bx	lr
 800b85a:	bf00      	nop
 800b85c:	f3af 8000 	nop.w

0800b860 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 800b860:	b500      	push	{lr}
 800b862:	b085      	sub	sp, #20
 800b864:	9001      	str	r0, [sp, #4]
 800b866:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 800b868:	2300      	movs	r3, #0
 800b86a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 800b86c:	9b00      	ldr	r3, [sp, #0]
 800b86e:	f003 0308 	and.w	r3, r3, #8
 800b872:	2b00      	cmp	r3, #0
 800b874:	d003      	beq.n	800b87e <set_error+0x1e>
    sts |= SD_OVERRUN_ERROR;
 800b876:	9b03      	ldr	r3, [sp, #12]
 800b878:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b87c:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 800b87e:	9b00      	ldr	r3, [sp, #0]
 800b880:	f003 0301 	and.w	r3, r3, #1
 800b884:	2b00      	cmp	r3, #0
 800b886:	d003      	beq.n	800b890 <set_error+0x30>
    sts |= SD_PARITY_ERROR;
 800b888:	9b03      	ldr	r3, [sp, #12]
 800b88a:	f043 0320 	orr.w	r3, r3, #32
 800b88e:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 800b890:	9b00      	ldr	r3, [sp, #0]
 800b892:	f003 0302 	and.w	r3, r3, #2
 800b896:	2b00      	cmp	r3, #0
 800b898:	d003      	beq.n	800b8a2 <set_error+0x42>
    sts |= SD_FRAMING_ERROR;
 800b89a:	9b03      	ldr	r3, [sp, #12]
 800b89c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b8a0:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 800b8a2:	9b00      	ldr	r3, [sp, #0]
 800b8a4:	f003 0304 	and.w	r3, r3, #4
 800b8a8:	2b00      	cmp	r3, #0
 800b8aa:	d003      	beq.n	800b8b4 <set_error+0x54>
    sts |= SD_NOISE_ERROR;
 800b8ac:	9b03      	ldr	r3, [sp, #12]
 800b8ae:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b8b2:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 800b8b4:	f7ff ff7c 	bl	800b7b0 <osalSysLockFromISR>
  chnAddFlagsI(sdp, sts);
 800b8b8:	9b01      	ldr	r3, [sp, #4]
 800b8ba:	3304      	adds	r3, #4
 800b8bc:	4618      	mov	r0, r3
 800b8be:	9903      	ldr	r1, [sp, #12]
 800b8c0:	f7ff ff86 	bl	800b7d0 <osalEventBroadcastFlagsI>
  osalSysUnlockFromISR();
 800b8c4:	f7ff ff7c 	bl	800b7c0 <osalSysUnlockFromISR>
}
 800b8c8:	b005      	add	sp, #20
 800b8ca:	f85d fb04 	ldr.w	pc, [sp], #4
 800b8ce:	bf00      	nop

0800b8d0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800b8d0:	b500      	push	{lr}
 800b8d2:	b087      	sub	sp, #28
 800b8d4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 800b8d6:	9b01      	ldr	r3, [sp, #4]
 800b8d8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b8da:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 800b8dc:	9b05      	ldr	r3, [sp, #20]
 800b8de:	681b      	ldr	r3, [r3, #0]
 800b8e0:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800b8e2:	9b05      	ldr	r3, [sp, #20]
 800b8e4:	69db      	ldr	r3, [r3, #28]
 800b8e6:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 800b8e8:	9b05      	ldr	r3, [sp, #20]
 800b8ea:	9a03      	ldr	r2, [sp, #12]
 800b8ec:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800b8ee:	9b03      	ldr	r3, [sp, #12]
 800b8f0:	f003 030f 	and.w	r3, r3, #15
 800b8f4:	2b00      	cmp	r3, #0
 800b8f6:	d003      	beq.n	800b900 <serve_interrupt+0x30>
    set_error(sdp, isr);
 800b8f8:	9801      	ldr	r0, [sp, #4]
 800b8fa:	9903      	ldr	r1, [sp, #12]
 800b8fc:	f7ff ffb0 	bl	800b860 <set_error>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 800b900:	9b03      	ldr	r3, [sp, #12]
 800b902:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800b906:	2b00      	cmp	r3, #0
 800b908:	d00a      	beq.n	800b920 <serve_interrupt+0x50>
    osalSysLockFromISR();
 800b90a:	f7ff ff51 	bl	800b7b0 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 800b90e:	9b01      	ldr	r3, [sp, #4]
 800b910:	3304      	adds	r3, #4
 800b912:	4618      	mov	r0, r3
 800b914:	f44f 7100 	mov.w	r1, #512	; 0x200
 800b918:	f7ff ff5a 	bl	800b7d0 <osalEventBroadcastFlagsI>
    osalSysUnlockFromISR();
 800b91c:	f7ff ff50 	bl	800b7c0 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 800b920:	9b03      	ldr	r3, [sp, #12]
 800b922:	f003 0320 	and.w	r3, r3, #32
 800b926:	2b00      	cmp	r3, #0
 800b928:	d00b      	beq.n	800b942 <serve_interrupt+0x72>
    osalSysLockFromISR();
 800b92a:	f7ff ff41 	bl	800b7b0 <osalSysLockFromISR>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 800b92e:	9b05      	ldr	r3, [sp, #20]
 800b930:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800b932:	b29b      	uxth	r3, r3
 800b934:	b2db      	uxtb	r3, r3
 800b936:	9801      	ldr	r0, [sp, #4]
 800b938:	4619      	mov	r1, r3
 800b93a:	f7fa fca1 	bl	8006280 <sdIncomingDataI>
    osalSysUnlockFromISR();
 800b93e:	f7ff ff3f 	bl	800b7c0 <osalSysUnlockFromISR>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800b942:	9b04      	ldr	r3, [sp, #16]
 800b944:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b948:	2b00      	cmp	r3, #0
 800b94a:	d023      	beq.n	800b994 <serve_interrupt+0xc4>
 800b94c:	9b03      	ldr	r3, [sp, #12]
 800b94e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b952:	2b00      	cmp	r3, #0
 800b954:	d01e      	beq.n	800b994 <serve_interrupt+0xc4>
    msg_t b;
    osalSysLockFromISR();
 800b956:	f7ff ff2b 	bl	800b7b0 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
 800b95a:	9b01      	ldr	r3, [sp, #4]
 800b95c:	3330      	adds	r3, #48	; 0x30
 800b95e:	4618      	mov	r0, r3
 800b960:	f7f7 fdbe 	bl	80034e0 <chOQGetI>
 800b964:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
 800b966:	9b02      	ldr	r3, [sp, #8]
 800b968:	2b00      	cmp	r3, #0
 800b96a:	da0d      	bge.n	800b988 <serve_interrupt+0xb8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800b96c:	9b01      	ldr	r3, [sp, #4]
 800b96e:	3304      	adds	r3, #4
 800b970:	4618      	mov	r0, r3
 800b972:	2108      	movs	r1, #8
 800b974:	f7ff ff2c 	bl	800b7d0 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800b978:	9b04      	ldr	r3, [sp, #16]
 800b97a:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800b97e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800b982:	9b05      	ldr	r3, [sp, #20]
 800b984:	601a      	str	r2, [r3, #0]
 800b986:	e003      	b.n	800b990 <serve_interrupt+0xc0>
    }
    else
      u->TDR = b;
 800b988:	9b02      	ldr	r3, [sp, #8]
 800b98a:	b29a      	uxth	r2, r3
 800b98c:	9b05      	ldr	r3, [sp, #20]
 800b98e:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 800b990:	f7ff ff16 	bl	800b7c0 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 800b994:	9b03      	ldr	r3, [sp, #12]
 800b996:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b99a:	2b00      	cmp	r3, #0
 800b99c:	d016      	beq.n	800b9cc <serve_interrupt+0xfc>
    osalSysLockFromISR();
 800b99e:	f7ff ff07 	bl	800b7b0 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
 800b9a2:	9b01      	ldr	r3, [sp, #4]
 800b9a4:	3330      	adds	r3, #48	; 0x30
 800b9a6:	4618      	mov	r0, r3
 800b9a8:	f7ff feea 	bl	800b780 <chOQIsEmptyI>
 800b9ac:	4603      	mov	r3, r0
 800b9ae:	2b00      	cmp	r3, #0
 800b9b0:	d005      	beq.n	800b9be <serve_interrupt+0xee>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 800b9b2:	9b01      	ldr	r3, [sp, #4]
 800b9b4:	3304      	adds	r3, #4
 800b9b6:	4618      	mov	r0, r3
 800b9b8:	2110      	movs	r1, #16
 800b9ba:	f7ff ff09 	bl	800b7d0 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800b9be:	9b04      	ldr	r3, [sp, #16]
 800b9c0:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 800b9c4:	9b05      	ldr	r3, [sp, #20]
 800b9c6:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 800b9c8:	f7ff fefa 	bl	800b7c0 <osalSysUnlockFromISR>
  }
}
 800b9cc:	b007      	add	sp, #28
 800b9ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800b9d2:	bf00      	nop
 800b9d4:	f3af 8000 	nop.w
 800b9d8:	f3af 8000 	nop.w
 800b9dc:	f3af 8000 	nop.w

0800b9e0 <notify5>:
  UART4->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_UART5 || defined(__DOXYGEN__)
static void notify5(io_queue_t *qp) {
 800b9e0:	b082      	sub	sp, #8
 800b9e2:	9001      	str	r0, [sp, #4]

  (void)qp;
  UART5->CR1 |= USART_CR1_TXEIE;
 800b9e4:	4b03      	ldr	r3, [pc, #12]	; (800b9f4 <notify5+0x14>)
 800b9e6:	4a03      	ldr	r2, [pc, #12]	; (800b9f4 <notify5+0x14>)
 800b9e8:	6812      	ldr	r2, [r2, #0]
 800b9ea:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b9ee:	601a      	str	r2, [r3, #0]
}
 800b9f0:	b002      	add	sp, #8
 800b9f2:	4770      	bx	lr
 800b9f4:	40005000 	.word	0x40005000
 800b9f8:	f3af 8000 	nop.w
 800b9fc:	f3af 8000 	nop.w

0800ba00 <Vector114>:
/**
 * @brief   UART5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART5_HANDLER) {
 800ba00:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD5);
 800ba02:	4803      	ldr	r0, [pc, #12]	; (800ba10 <Vector114+0x10>)
 800ba04:	f7ff ff64 	bl	800b8d0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800ba08:	f7f8 f8a2 	bl	8003b50 <_port_irq_epilogue>
}
 800ba0c:	bd08      	pop	{r3, pc}
 800ba0e:	bf00      	nop
 800ba10:	20003db8 	.word	0x20003db8
 800ba14:	f3af 8000 	nop.w
 800ba18:	f3af 8000 	nop.w
 800ba1c:	f3af 8000 	nop.w

0800ba20 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 800ba20:	b508      	push	{r3, lr}
  nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_UART5
  sdObjectInit(&SD5, NULL, notify5);
 800ba22:	4808      	ldr	r0, [pc, #32]	; (800ba44 <sd_lld_init+0x24>)
 800ba24:	2100      	movs	r1, #0
 800ba26:	4a08      	ldr	r2, [pc, #32]	; (800ba48 <sd_lld_init+0x28>)
 800ba28:	f7fa fbc2 	bl	80061b0 <sdObjectInit>
  SD5.usart = UART5;
 800ba2c:	4b05      	ldr	r3, [pc, #20]	; (800ba44 <sd_lld_init+0x24>)
 800ba2e:	4a07      	ldr	r2, [pc, #28]	; (800ba4c <sd_lld_init+0x2c>)
 800ba30:	675a      	str	r2, [r3, #116]	; 0x74
  SD5.clock = STM32_UART5CLK;
 800ba32:	4b04      	ldr	r3, [pc, #16]	; (800ba44 <sd_lld_init+0x24>)
 800ba34:	4a06      	ldr	r2, [pc, #24]	; (800ba50 <sd_lld_init+0x30>)
 800ba36:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_UART5_NUMBER)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_SERIAL_UART5_PRIORITY);
 800ba38:	2035      	movs	r0, #53	; 0x35
 800ba3a:	210c      	movs	r1, #12
 800ba3c:	f7fb fc78 	bl	8007330 <nvicEnableVector>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 800ba40:	bd08      	pop	{r3, pc}
 800ba42:	bf00      	nop
 800ba44:	20003db8 	.word	0x20003db8
 800ba48:	0800b9e1 	.word	0x0800b9e1
 800ba4c:	40005000 	.word	0x40005000
 800ba50:	04c4b400 	.word	0x04c4b400
 800ba54:	f3af 8000 	nop.w
 800ba58:	f3af 8000 	nop.w
 800ba5c:	f3af 8000 	nop.w

0800ba60 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 800ba60:	b500      	push	{lr}
 800ba62:	b083      	sub	sp, #12
 800ba64:	9001      	str	r0, [sp, #4]
 800ba66:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 800ba68:	9b00      	ldr	r3, [sp, #0]
 800ba6a:	2b00      	cmp	r3, #0
 800ba6c:	d101      	bne.n	800ba72 <sd_lld_start+0x12>
    config = &default_config;
 800ba6e:	4b0b      	ldr	r3, [pc, #44]	; (800ba9c <sd_lld_start+0x3c>)
 800ba70:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 800ba72:	9b01      	ldr	r3, [sp, #4]
 800ba74:	7a1b      	ldrb	r3, [r3, #8]
 800ba76:	2b01      	cmp	r3, #1
 800ba78:	d109      	bne.n	800ba8e <sd_lld_start+0x2e>
    if (&SD4 == sdp) {
      rccEnableUART4(FALSE);
    }
#endif
#if STM32_SERIAL_USE_UART5
    if (&SD5 == sdp) {
 800ba7a:	9a01      	ldr	r2, [sp, #4]
 800ba7c:	4b08      	ldr	r3, [pc, #32]	; (800baa0 <sd_lld_start+0x40>)
 800ba7e:	429a      	cmp	r2, r3
 800ba80:	d105      	bne.n	800ba8e <sd_lld_start+0x2e>
      rccEnableUART5(FALSE);
 800ba82:	4b08      	ldr	r3, [pc, #32]	; (800baa4 <sd_lld_start+0x44>)
 800ba84:	4a07      	ldr	r2, [pc, #28]	; (800baa4 <sd_lld_start+0x44>)
 800ba86:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800ba88:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800ba8c:	659a      	str	r2, [r3, #88]	; 0x58
    if (&LPSD1 == sdp) {
      rccEnableLPUART1(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
 800ba8e:	9801      	ldr	r0, [sp, #4]
 800ba90:	9900      	ldr	r1, [sp, #0]
 800ba92:	f7ff fead 	bl	800b7f0 <usart_init>
}
 800ba96:	b003      	add	sp, #12
 800ba98:	f85d fb04 	ldr.w	pc, [sp], #4
 800ba9c:	0801ac40 	.word	0x0801ac40
 800baa0:	20003db8 	.word	0x20003db8
 800baa4:	40021000 	.word	0x40021000
 800baa8:	f3af 8000 	nop.w
 800baac:	f3af 8000 	nop.w

0800bab0 <sd_lld_stop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {
 800bab0:	b500      	push	{lr}
 800bab2:	b083      	sub	sp, #12
 800bab4:	9001      	str	r0, [sp, #4]

  if (sdp->state == SD_READY) {
 800bab6:	9b01      	ldr	r3, [sp, #4]
 800bab8:	7a1b      	ldrb	r3, [r3, #8]
 800baba:	2b02      	cmp	r3, #2
 800babc:	d10f      	bne.n	800bade <sd_lld_stop+0x2e>
    /* UART is de-initialized then clocks are disabled.*/
    usart_deinit(sdp->usart);
 800babe:	9b01      	ldr	r3, [sp, #4]
 800bac0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bac2:	4618      	mov	r0, r3
 800bac4:	f7ff febc 	bl	800b840 <usart_deinit>
      rccDisableUART4(FALSE);
      return;
    }
#endif
#if STM32_SERIAL_USE_UART5
    if (&SD5 == sdp) {
 800bac8:	9a01      	ldr	r2, [sp, #4]
 800baca:	4b06      	ldr	r3, [pc, #24]	; (800bae4 <sd_lld_stop+0x34>)
 800bacc:	429a      	cmp	r2, r3
 800bace:	d106      	bne.n	800bade <sd_lld_stop+0x2e>
      rccDisableUART5(FALSE);
 800bad0:	4b05      	ldr	r3, [pc, #20]	; (800bae8 <sd_lld_stop+0x38>)
 800bad2:	4a05      	ldr	r2, [pc, #20]	; (800bae8 <sd_lld_stop+0x38>)
 800bad4:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800bad6:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800bada:	659a      	str	r2, [r3, #88]	; 0x58
      return;
 800badc:	bf00      	nop
      rccDisableLPUART1(FALSE);
      return;
    }
#endif
  }
}
 800bade:	b003      	add	sp, #12
 800bae0:	f85d fb04 	ldr.w	pc, [sp], #4
 800bae4:	20003db8 	.word	0x20003db8
 800bae8:	40021000 	.word	0x40021000
 800baec:	f3af 8000 	nop.w

0800baf0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 800baf0:	b508      	push	{r3, lr}

  stm32_clock_init();
 800baf2:	f7fb fd2d 	bl	8007550 <stm32_clock_init>
}
 800baf6:	bd08      	pop	{r3, pc}
 800baf8:	f3af 8000 	nop.w
 800bafc:	f3af 8000 	nop.w

0800bb00 <sdc_lld_is_card_inserted>:

#if HAL_USE_SDC || defined(__DOXYGEN__)
/**
 * @brief   SDC card detection.
 */
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {
 800bb00:	b082      	sub	sp, #8
 800bb02:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return true;
 800bb04:	2301      	movs	r3, #1
}
 800bb06:	4618      	mov	r0, r3
 800bb08:	b002      	add	sp, #8
 800bb0a:	4770      	bx	lr
 800bb0c:	f3af 8000 	nop.w

0800bb10 <sdc_lld_is_write_protected>:

/**
 * @brief   SDC card write protection detection.
 */
bool sdc_lld_is_write_protected(SDCDriver *sdcp) {
 800bb10:	b082      	sub	sp, #8
 800bb12:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return false;
 800bb14:	2300      	movs	r3, #0
}
 800bb16:	4618      	mov	r0, r3
 800bb18:	b002      	add	sp, #8
 800bb1a:	4770      	bx	lr
 800bb1c:	f3af 8000 	nop.w

0800bb20 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 800bb20:	4770      	bx	lr
 800bb22:	bf00      	nop
 800bb24:	f3af 8000 	nop.w
 800bb28:	f3af 8000 	nop.w
 800bb2c:	f3af 8000 	nop.w

0800bb30 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800bb30:	b082      	sub	sp, #8
 800bb32:	2320      	movs	r3, #32
 800bb34:	9301      	str	r3, [sp, #4]
 800bb36:	9b01      	ldr	r3, [sp, #4]
 800bb38:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bb3c:	b002      	add	sp, #8
 800bb3e:	4770      	bx	lr

0800bb40 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800bb40:	b082      	sub	sp, #8
 800bb42:	2300      	movs	r3, #0
 800bb44:	9301      	str	r3, [sp, #4]
 800bb46:	9b01      	ldr	r3, [sp, #4]
 800bb48:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bb4c:	b002      	add	sp, #8
 800bb4e:	4770      	bx	lr

0800bb50 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800bb50:	b508      	push	{r3, lr}

  port_lock();
 800bb52:	f7ff ffed 	bl	800bb30 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800bb56:	bd08      	pop	{r3, pc}
 800bb58:	f3af 8000 	nop.w
 800bb5c:	f3af 8000 	nop.w

0800bb60 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800bb60:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800bb62:	f7ff ffed 	bl	800bb40 <port_unlock>
}
 800bb66:	bd08      	pop	{r3, pc}
 800bb68:	f3af 8000 	nop.w
 800bb6c:	f3af 8000 	nop.w

0800bb70 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800bb70:	4b01      	ldr	r3, [pc, #4]	; (800bb78 <chVTGetSystemTimeX+0x8>)
 800bb72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800bb74:	4618      	mov	r0, r3
 800bb76:	4770      	bx	lr
 800bb78:	200039a8 	.word	0x200039a8
 800bb7c:	f3af 8000 	nop.w

0800bb80 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800bb80:	b500      	push	{lr}
 800bb82:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800bb84:	f7ff ffe4 	bl	800bb50 <chSysLock>
  systime = chVTGetSystemTimeX();
 800bb88:	f7ff fff2 	bl	800bb70 <chVTGetSystemTimeX>
 800bb8c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800bb8e:	f7ff ffe7 	bl	800bb60 <chSysUnlock>

  return systime;
 800bb92:	9b01      	ldr	r3, [sp, #4]
}
 800bb94:	4618      	mov	r0, r3
 800bb96:	b003      	add	sp, #12
 800bb98:	f85d fb04 	ldr.w	pc, [sp], #4
 800bb9c:	f3af 8000 	nop.w

0800bba0 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 800bba0:	b084      	sub	sp, #16
 800bba2:	9003      	str	r0, [sp, #12]
 800bba4:	9102      	str	r1, [sp, #8]
 800bba6:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 800bba8:	9a03      	ldr	r2, [sp, #12]
 800bbaa:	9b02      	ldr	r3, [sp, #8]
 800bbac:	1ad2      	subs	r2, r2, r3
 800bbae:	9901      	ldr	r1, [sp, #4]
 800bbb0:	9b02      	ldr	r3, [sp, #8]
 800bbb2:	1acb      	subs	r3, r1, r3
 800bbb4:	429a      	cmp	r2, r3
 800bbb6:	bf2c      	ite	cs
 800bbb8:	2300      	movcs	r3, #0
 800bbba:	2301      	movcc	r3, #1
 800bbbc:	b2db      	uxtb	r3, r3
}
 800bbbe:	4618      	mov	r0, r3
 800bbc0:	b004      	add	sp, #16
 800bbc2:	4770      	bx	lr
 800bbc4:	f3af 8000 	nop.w
 800bbc8:	f3af 8000 	nop.w
 800bbcc:	f3af 8000 	nop.w

0800bbd0 <chVTIsSystemTimeWithin>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @api
 */
static inline bool chVTIsSystemTimeWithin(systime_t start, systime_t end) {
 800bbd0:	b500      	push	{lr}
 800bbd2:	b083      	sub	sp, #12
 800bbd4:	9001      	str	r0, [sp, #4]
 800bbd6:	9100      	str	r1, [sp, #0]

  return chVTIsTimeWithinX(chVTGetSystemTime(), start, end);
 800bbd8:	f7ff ffd2 	bl	800bb80 <chVTGetSystemTime>
 800bbdc:	4603      	mov	r3, r0
 800bbde:	4618      	mov	r0, r3
 800bbe0:	9901      	ldr	r1, [sp, #4]
 800bbe2:	9a00      	ldr	r2, [sp, #0]
 800bbe4:	f7ff ffdc 	bl	800bba0 <chVTIsTimeWithinX>
 800bbe8:	4603      	mov	r3, r0
}
 800bbea:	4618      	mov	r0, r3
 800bbec:	b003      	add	sp, #12
 800bbee:	f85d fb04 	ldr.w	pc, [sp], #4
 800bbf2:	bf00      	nop
 800bbf4:	f3af 8000 	nop.w
 800bbf8:	f3af 8000 	nop.w
 800bbfc:	f3af 8000 	nop.w

0800bc00 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800bc00:	b082      	sub	sp, #8
 800bc02:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 800bc04:	9b01      	ldr	r3, [sp, #4]
 800bc06:	68db      	ldr	r3, [r3, #12]
 800bc08:	2b00      	cmp	r3, #0
 800bc0a:	bf0c      	ite	eq
 800bc0c:	2300      	moveq	r3, #0
 800bc0e:	2301      	movne	r3, #1
 800bc10:	b2db      	uxtb	r3, r3
}
 800bc12:	4618      	mov	r0, r3
 800bc14:	b002      	add	sp, #8
 800bc16:	4770      	bx	lr
 800bc18:	f3af 8000 	nop.w
 800bc1c:	f3af 8000 	nop.w

0800bc20 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 800bc20:	b500      	push	{lr}
 800bc22:	b083      	sub	sp, #12
 800bc24:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 800bc26:	9801      	ldr	r0, [sp, #4]
 800bc28:	f7ff ffea 	bl	800bc00 <chVTIsArmedI>
 800bc2c:	4603      	mov	r3, r0
 800bc2e:	2b00      	cmp	r3, #0
 800bc30:	d002      	beq.n	800bc38 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 800bc32:	9801      	ldr	r0, [sp, #4]
 800bc34:	f7f4 feec 	bl	8000a10 <chVTDoResetI>
  }
}
 800bc38:	b003      	add	sp, #12
 800bc3a:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc3e:	bf00      	nop

0800bc40 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 800bc40:	b500      	push	{lr}
 800bc42:	b085      	sub	sp, #20
 800bc44:	9003      	str	r0, [sp, #12]
 800bc46:	9102      	str	r1, [sp, #8]
 800bc48:	9201      	str	r2, [sp, #4]
 800bc4a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800bc4c:	9803      	ldr	r0, [sp, #12]
 800bc4e:	f7ff ffe7 	bl	800bc20 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 800bc52:	9803      	ldr	r0, [sp, #12]
 800bc54:	9902      	ldr	r1, [sp, #8]
 800bc56:	9a01      	ldr	r2, [sp, #4]
 800bc58:	9b00      	ldr	r3, [sp, #0]
 800bc5a:	f7f4 fe99 	bl	8000990 <chVTDoSetI>
}
 800bc5e:	b005      	add	sp, #20
 800bc60:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc64:	f3af 8000 	nop.w
 800bc68:	f3af 8000 	nop.w
 800bc6c:	f3af 8000 	nop.w

0800bc70 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 800bc70:	b500      	push	{lr}
 800bc72:	b085      	sub	sp, #20
 800bc74:	9003      	str	r0, [sp, #12]
 800bc76:	9102      	str	r1, [sp, #8]
 800bc78:	9201      	str	r2, [sp, #4]
 800bc7a:	9300      	str	r3, [sp, #0]

  chSysLock();
 800bc7c:	f7ff ff68 	bl	800bb50 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 800bc80:	9803      	ldr	r0, [sp, #12]
 800bc82:	9902      	ldr	r1, [sp, #8]
 800bc84:	9a01      	ldr	r2, [sp, #4]
 800bc86:	9b00      	ldr	r3, [sp, #0]
 800bc88:	f7ff ffda 	bl	800bc40 <chVTSetI>
  chSysUnlock();
 800bc8c:	f7ff ff68 	bl	800bb60 <chSysUnlock>
}
 800bc90:	b005      	add	sp, #20
 800bc92:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc96:	bf00      	nop
 800bc98:	f3af 8000 	nop.w
 800bc9c:	f3af 8000 	nop.w

0800bca0 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 800bca0:	b500      	push	{lr}
 800bca2:	b089      	sub	sp, #36	; 0x24
 800bca4:	9001      	str	r0, [sp, #4]
  char buf[16], *p;

  if (!n)
 800bca6:	9b01      	ldr	r3, [sp, #4]
 800bca8:	2b00      	cmp	r3, #0
 800bcaa:	d109      	bne.n	800bcc0 <test_printn+0x20>
    chSequentialStreamPut(chp, '0');
 800bcac:	4b1e      	ldr	r3, [pc, #120]	; (800bd28 <test_printn+0x88>)
 800bcae:	681b      	ldr	r3, [r3, #0]
 800bcb0:	681b      	ldr	r3, [r3, #0]
 800bcb2:	689b      	ldr	r3, [r3, #8]
 800bcb4:	4a1c      	ldr	r2, [pc, #112]	; (800bd28 <test_printn+0x88>)
 800bcb6:	6812      	ldr	r2, [r2, #0]
 800bcb8:	4610      	mov	r0, r2
 800bcba:	2130      	movs	r1, #48	; 0x30
 800bcbc:	4798      	blx	r3
 800bcbe:	e02f      	b.n	800bd20 <test_printn+0x80>
  else {
    p = buf;
 800bcc0:	ab03      	add	r3, sp, #12
 800bcc2:	9307      	str	r3, [sp, #28]
    while (n)
 800bcc4:	e016      	b.n	800bcf4 <test_printn+0x54>
      *p++ = (n % 10) + '0', n /= 10;
 800bcc6:	9907      	ldr	r1, [sp, #28]
 800bcc8:	1c4b      	adds	r3, r1, #1
 800bcca:	9307      	str	r3, [sp, #28]
 800bccc:	9801      	ldr	r0, [sp, #4]
 800bcce:	4b17      	ldr	r3, [pc, #92]	; (800bd2c <test_printn+0x8c>)
 800bcd0:	fba3 2300 	umull	r2, r3, r3, r0
 800bcd4:	08da      	lsrs	r2, r3, #3
 800bcd6:	4613      	mov	r3, r2
 800bcd8:	009b      	lsls	r3, r3, #2
 800bcda:	4413      	add	r3, r2
 800bcdc:	005b      	lsls	r3, r3, #1
 800bcde:	1ac2      	subs	r2, r0, r3
 800bce0:	b2d3      	uxtb	r3, r2
 800bce2:	3330      	adds	r3, #48	; 0x30
 800bce4:	b2db      	uxtb	r3, r3
 800bce6:	700b      	strb	r3, [r1, #0]
 800bce8:	9a01      	ldr	r2, [sp, #4]
 800bcea:	4b10      	ldr	r3, [pc, #64]	; (800bd2c <test_printn+0x8c>)
 800bcec:	fba3 1302 	umull	r1, r3, r3, r2
 800bcf0:	08db      	lsrs	r3, r3, #3
 800bcf2:	9301      	str	r3, [sp, #4]

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 800bcf4:	9b01      	ldr	r3, [sp, #4]
 800bcf6:	2b00      	cmp	r3, #0
 800bcf8:	d1e5      	bne.n	800bcc6 <test_printn+0x26>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800bcfa:	e00d      	b.n	800bd18 <test_printn+0x78>
      chSequentialStreamPut(chp, *--p);
 800bcfc:	4b0a      	ldr	r3, [pc, #40]	; (800bd28 <test_printn+0x88>)
 800bcfe:	681b      	ldr	r3, [r3, #0]
 800bd00:	681b      	ldr	r3, [r3, #0]
 800bd02:	689b      	ldr	r3, [r3, #8]
 800bd04:	4a08      	ldr	r2, [pc, #32]	; (800bd28 <test_printn+0x88>)
 800bd06:	6811      	ldr	r1, [r2, #0]
 800bd08:	9a07      	ldr	r2, [sp, #28]
 800bd0a:	3a01      	subs	r2, #1
 800bd0c:	9207      	str	r2, [sp, #28]
 800bd0e:	9a07      	ldr	r2, [sp, #28]
 800bd10:	7812      	ldrb	r2, [r2, #0]
 800bd12:	4608      	mov	r0, r1
 800bd14:	4611      	mov	r1, r2
 800bd16:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800bd18:	ab03      	add	r3, sp, #12
 800bd1a:	9a07      	ldr	r2, [sp, #28]
 800bd1c:	429a      	cmp	r2, r3
 800bd1e:	d8ed      	bhi.n	800bcfc <test_printn+0x5c>
      chSequentialStreamPut(chp, *--p);
  }
}
 800bd20:	b009      	add	sp, #36	; 0x24
 800bd22:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd26:	bf00      	nop
 800bd28:	20001484 	.word	0x20001484
 800bd2c:	cccccccd 	.word	0xcccccccd

0800bd30 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 800bd30:	b500      	push	{lr}
 800bd32:	b083      	sub	sp, #12
 800bd34:	9001      	str	r0, [sp, #4]

  while (*msgp)
 800bd36:	e00c      	b.n	800bd52 <test_print+0x22>
    chSequentialStreamPut(chp, *msgp++);
 800bd38:	4b09      	ldr	r3, [pc, #36]	; (800bd60 <test_print+0x30>)
 800bd3a:	681b      	ldr	r3, [r3, #0]
 800bd3c:	681b      	ldr	r3, [r3, #0]
 800bd3e:	689a      	ldr	r2, [r3, #8]
 800bd40:	4b07      	ldr	r3, [pc, #28]	; (800bd60 <test_print+0x30>)
 800bd42:	6819      	ldr	r1, [r3, #0]
 800bd44:	9b01      	ldr	r3, [sp, #4]
 800bd46:	1c58      	adds	r0, r3, #1
 800bd48:	9001      	str	r0, [sp, #4]
 800bd4a:	781b      	ldrb	r3, [r3, #0]
 800bd4c:	4608      	mov	r0, r1
 800bd4e:	4619      	mov	r1, r3
 800bd50:	4790      	blx	r2
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800bd52:	9b01      	ldr	r3, [sp, #4]
 800bd54:	781b      	ldrb	r3, [r3, #0]
 800bd56:	2b00      	cmp	r3, #0
 800bd58:	d1ee      	bne.n	800bd38 <test_print+0x8>
    chSequentialStreamPut(chp, *msgp++);
}
 800bd5a:	b003      	add	sp, #12
 800bd5c:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd60:	20001484 	.word	0x20001484
 800bd64:	f3af 8000 	nop.w
 800bd68:	f3af 8000 	nop.w
 800bd6c:	f3af 8000 	nop.w

0800bd70 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 800bd70:	b500      	push	{lr}
 800bd72:	b083      	sub	sp, #12
 800bd74:	9001      	str	r0, [sp, #4]

  test_print(msgp);
 800bd76:	9801      	ldr	r0, [sp, #4]
 800bd78:	f7ff ffda 	bl	800bd30 <test_print>
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800bd7c:	4b06      	ldr	r3, [pc, #24]	; (800bd98 <test_println+0x28>)
 800bd7e:	681b      	ldr	r3, [r3, #0]
 800bd80:	681b      	ldr	r3, [r3, #0]
 800bd82:	681b      	ldr	r3, [r3, #0]
 800bd84:	4a04      	ldr	r2, [pc, #16]	; (800bd98 <test_println+0x28>)
 800bd86:	6812      	ldr	r2, [r2, #0]
 800bd88:	4610      	mov	r0, r2
 800bd8a:	4904      	ldr	r1, [pc, #16]	; (800bd9c <test_println+0x2c>)
 800bd8c:	2202      	movs	r2, #2
 800bd8e:	4798      	blx	r3
}
 800bd90:	b003      	add	sp, #12
 800bd92:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd96:	bf00      	nop
 800bd98:	20001484 	.word	0x20001484
 800bd9c:	0801ad84 	.word	0x0801ad84

0800bda0 <clear_tokens>:
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 800bda0:	4b01      	ldr	r3, [pc, #4]	; (800bda8 <clear_tokens+0x8>)
 800bda2:	4a02      	ldr	r2, [pc, #8]	; (800bdac <clear_tokens+0xc>)
 800bda4:	601a      	str	r2, [r3, #0]
}
 800bda6:	4770      	bx	lr
 800bda8:	20001480 	.word	0x20001480
 800bdac:	20001470 	.word	0x20001470

0800bdb0 <print_tokens>:

static void print_tokens(void) {
 800bdb0:	b500      	push	{lr}
 800bdb2:	b083      	sub	sp, #12
  char *cp = tokens_buffer;
 800bdb4:	4b0b      	ldr	r3, [pc, #44]	; (800bde4 <print_tokens+0x34>)
 800bdb6:	9301      	str	r3, [sp, #4]

  while (cp < tokp)
 800bdb8:	e00c      	b.n	800bdd4 <print_tokens+0x24>
    chSequentialStreamPut(chp, *cp++);
 800bdba:	4b0b      	ldr	r3, [pc, #44]	; (800bde8 <print_tokens+0x38>)
 800bdbc:	681b      	ldr	r3, [r3, #0]
 800bdbe:	681b      	ldr	r3, [r3, #0]
 800bdc0:	689a      	ldr	r2, [r3, #8]
 800bdc2:	4b09      	ldr	r3, [pc, #36]	; (800bde8 <print_tokens+0x38>)
 800bdc4:	6819      	ldr	r1, [r3, #0]
 800bdc6:	9b01      	ldr	r3, [sp, #4]
 800bdc8:	1c58      	adds	r0, r3, #1
 800bdca:	9001      	str	r0, [sp, #4]
 800bdcc:	781b      	ldrb	r3, [r3, #0]
 800bdce:	4608      	mov	r0, r1
 800bdd0:	4619      	mov	r1, r3
 800bdd2:	4790      	blx	r2
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 800bdd4:	4b05      	ldr	r3, [pc, #20]	; (800bdec <print_tokens+0x3c>)
 800bdd6:	681b      	ldr	r3, [r3, #0]
 800bdd8:	9a01      	ldr	r2, [sp, #4]
 800bdda:	429a      	cmp	r2, r3
 800bddc:	d3ed      	bcc.n	800bdba <print_tokens+0xa>
    chSequentialStreamPut(chp, *cp++);
}
 800bdde:	b003      	add	sp, #12
 800bde0:	f85d fb04 	ldr.w	pc, [sp], #4
 800bde4:	20001470 	.word	0x20001470
 800bde8:	20001484 	.word	0x20001484
 800bdec:	20001480 	.word	0x20001480

0800bdf0 <test_emit_token>:
/**
 * @brief   Emits a token into the tokens buffer.
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {
 800bdf0:	b500      	push	{lr}
 800bdf2:	b083      	sub	sp, #12
 800bdf4:	4603      	mov	r3, r0
 800bdf6:	f88d 3007 	strb.w	r3, [sp, #7]

  chSysLock();
 800bdfa:	f7ff fea9 	bl	800bb50 <chSysLock>
  *tokp++ = token;
 800bdfe:	4b06      	ldr	r3, [pc, #24]	; (800be18 <test_emit_token+0x28>)
 800be00:	681b      	ldr	r3, [r3, #0]
 800be02:	1c59      	adds	r1, r3, #1
 800be04:	4a04      	ldr	r2, [pc, #16]	; (800be18 <test_emit_token+0x28>)
 800be06:	6011      	str	r1, [r2, #0]
 800be08:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800be0c:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 800be0e:	f7ff fea7 	bl	800bb60 <chSysUnlock>
}
 800be12:	b003      	add	sp, #12
 800be14:	f85d fb04 	ldr.w	pc, [sp], #4
 800be18:	20001480 	.word	0x20001480
 800be1c:	f3af 8000 	nop.w

0800be20 <_test_fail>:

/*
 * Assertions.
 */
bool _test_fail(unsigned point) {
 800be20:	b082      	sub	sp, #8
 800be22:	9001      	str	r0, [sp, #4]

  test_global_fail = TRUE;
 800be24:	4b06      	ldr	r3, [pc, #24]	; (800be40 <_test_fail+0x20>)
 800be26:	2201      	movs	r2, #1
 800be28:	701a      	strb	r2, [r3, #0]
  local_fail = TRUE;
 800be2a:	4b06      	ldr	r3, [pc, #24]	; (800be44 <_test_fail+0x24>)
 800be2c:	2201      	movs	r2, #1
 800be2e:	701a      	strb	r2, [r3, #0]
  failpoint = point;
 800be30:	4b05      	ldr	r3, [pc, #20]	; (800be48 <_test_fail+0x28>)
 800be32:	9a01      	ldr	r2, [sp, #4]
 800be34:	601a      	str	r2, [r3, #0]
  return TRUE;
 800be36:	2301      	movs	r3, #1
}
 800be38:	4618      	mov	r0, r3
 800be3a:	b002      	add	sp, #8
 800be3c:	4770      	bx	lr
 800be3e:	bf00      	nop
 800be40:	20003e38 	.word	0x20003e38
 800be44:	20001468 	.word	0x20001468
 800be48:	2000146c 	.word	0x2000146c
 800be4c:	f3af 8000 	nop.w

0800be50 <_test_assert>:

bool _test_assert(unsigned point, bool condition) {
 800be50:	b500      	push	{lr}
 800be52:	b083      	sub	sp, #12
 800be54:	9001      	str	r0, [sp, #4]
 800be56:	460b      	mov	r3, r1
 800be58:	f88d 3003 	strb.w	r3, [sp, #3]

  if (!condition)
 800be5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800be60:	f083 0301 	eor.w	r3, r3, #1
 800be64:	b2db      	uxtb	r3, r3
 800be66:	2b00      	cmp	r3, #0
 800be68:	d004      	beq.n	800be74 <_test_assert+0x24>
    return _test_fail(point);
 800be6a:	9801      	ldr	r0, [sp, #4]
 800be6c:	f7ff ffd8 	bl	800be20 <_test_fail>
 800be70:	4603      	mov	r3, r0
 800be72:	e000      	b.n	800be76 <_test_assert+0x26>
  return FALSE;
 800be74:	2300      	movs	r3, #0
}
 800be76:	4618      	mov	r0, r3
 800be78:	b003      	add	sp, #12
 800be7a:	f85d fb04 	ldr.w	pc, [sp], #4
 800be7e:	bf00      	nop

0800be80 <_test_assert_sequence>:

bool _test_assert_sequence(unsigned point, char *expected) {
 800be80:	b500      	push	{lr}
 800be82:	b085      	sub	sp, #20
 800be84:	9001      	str	r0, [sp, #4]
 800be86:	9100      	str	r1, [sp, #0]
  char *cp = tokens_buffer;
 800be88:	4b13      	ldr	r3, [pc, #76]	; (800bed8 <_test_assert_sequence+0x58>)
 800be8a:	9303      	str	r3, [sp, #12]
  while (cp < tokp) {
 800be8c:	e00e      	b.n	800beac <_test_assert_sequence+0x2c>
    if (*cp++ != *expected++)
 800be8e:	9b03      	ldr	r3, [sp, #12]
 800be90:	1c5a      	adds	r2, r3, #1
 800be92:	9203      	str	r2, [sp, #12]
 800be94:	781a      	ldrb	r2, [r3, #0]
 800be96:	9b00      	ldr	r3, [sp, #0]
 800be98:	1c59      	adds	r1, r3, #1
 800be9a:	9100      	str	r1, [sp, #0]
 800be9c:	781b      	ldrb	r3, [r3, #0]
 800be9e:	429a      	cmp	r2, r3
 800bea0:	d004      	beq.n	800beac <_test_assert_sequence+0x2c>
     return _test_fail(point);
 800bea2:	9801      	ldr	r0, [sp, #4]
 800bea4:	f7ff ffbc 	bl	800be20 <_test_fail>
 800bea8:	4603      	mov	r3, r0
 800beaa:	e010      	b.n	800bece <_test_assert_sequence+0x4e>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 800beac:	4b0b      	ldr	r3, [pc, #44]	; (800bedc <_test_assert_sequence+0x5c>)
 800beae:	681b      	ldr	r3, [r3, #0]
 800beb0:	9a03      	ldr	r2, [sp, #12]
 800beb2:	429a      	cmp	r2, r3
 800beb4:	d3eb      	bcc.n	800be8e <_test_assert_sequence+0xe>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 800beb6:	9b00      	ldr	r3, [sp, #0]
 800beb8:	781b      	ldrb	r3, [r3, #0]
 800beba:	2b00      	cmp	r3, #0
 800bebc:	d004      	beq.n	800bec8 <_test_assert_sequence+0x48>
    return _test_fail(point);
 800bebe:	9801      	ldr	r0, [sp, #4]
 800bec0:	f7ff ffae 	bl	800be20 <_test_fail>
 800bec4:	4603      	mov	r3, r0
 800bec6:	e002      	b.n	800bece <_test_assert_sequence+0x4e>
  clear_tokens();
 800bec8:	f7ff ff6a 	bl	800bda0 <clear_tokens>
  return FALSE;
 800becc:	2300      	movs	r3, #0
}
 800bece:	4618      	mov	r0, r3
 800bed0:	b005      	add	sp, #20
 800bed2:	f85d fb04 	ldr.w	pc, [sp], #4
 800bed6:	bf00      	nop
 800bed8:	20001470 	.word	0x20001470
 800bedc:	20001480 	.word	0x20001480

0800bee0 <_test_assert_time_window>:

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 800bee0:	b500      	push	{lr}
 800bee2:	b085      	sub	sp, #20
 800bee4:	9003      	str	r0, [sp, #12]
 800bee6:	9102      	str	r1, [sp, #8]
 800bee8:	9201      	str	r2, [sp, #4]

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
 800beea:	9802      	ldr	r0, [sp, #8]
 800beec:	9901      	ldr	r1, [sp, #4]
 800beee:	f7ff fe6f 	bl	800bbd0 <chVTIsSystemTimeWithin>
 800bef2:	4603      	mov	r3, r0
 800bef4:	9803      	ldr	r0, [sp, #12]
 800bef6:	4619      	mov	r1, r3
 800bef8:	f7ff ffaa 	bl	800be50 <_test_assert>
 800befc:	4603      	mov	r3, r0
}
 800befe:	4618      	mov	r0, r3
 800bf00:	b005      	add	sp, #20
 800bf02:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf06:	bf00      	nop
 800bf08:	f3af 8000 	nop.w
 800bf0c:	f3af 8000 	nop.w

0800bf10 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 800bf10:	b500      	push	{lr}
 800bf12:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bf14:	2300      	movs	r3, #0
 800bf16:	9301      	str	r3, [sp, #4]
 800bf18:	e00f      	b.n	800bf3a <test_terminate_threads+0x2a>
    if (threads[i])
 800bf1a:	4b0b      	ldr	r3, [pc, #44]	; (800bf48 <test_terminate_threads+0x38>)
 800bf1c:	9a01      	ldr	r2, [sp, #4]
 800bf1e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf22:	2b00      	cmp	r3, #0
 800bf24:	d006      	beq.n	800bf34 <test_terminate_threads+0x24>
      chThdTerminate(threads[i]);
 800bf26:	4b08      	ldr	r3, [pc, #32]	; (800bf48 <test_terminate_threads+0x38>)
 800bf28:	9a01      	ldr	r2, [sp, #4]
 800bf2a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf2e:	4618      	mov	r0, r3
 800bf30:	f7f5 f9b6 	bl	80012a0 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bf34:	9b01      	ldr	r3, [sp, #4]
 800bf36:	3301      	adds	r3, #1
 800bf38:	9301      	str	r3, [sp, #4]
 800bf3a:	9b01      	ldr	r3, [sp, #4]
 800bf3c:	2b04      	cmp	r3, #4
 800bf3e:	ddec      	ble.n	800bf1a <test_terminate_threads+0xa>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 800bf40:	b003      	add	sp, #12
 800bf42:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf46:	bf00      	nop
 800bf48:	20003e3c 	.word	0x20003e3c
 800bf4c:	f3af 8000 	nop.w

0800bf50 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 800bf50:	b500      	push	{lr}
 800bf52:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bf54:	2300      	movs	r3, #0
 800bf56:	9301      	str	r3, [sp, #4]
 800bf58:	e014      	b.n	800bf84 <test_wait_threads+0x34>
    if (threads[i] != NULL) {
 800bf5a:	4b0d      	ldr	r3, [pc, #52]	; (800bf90 <test_wait_threads+0x40>)
 800bf5c:	9a01      	ldr	r2, [sp, #4]
 800bf5e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf62:	2b00      	cmp	r3, #0
 800bf64:	d00b      	beq.n	800bf7e <test_wait_threads+0x2e>
      chThdWait(threads[i]);
 800bf66:	4b0a      	ldr	r3, [pc, #40]	; (800bf90 <test_wait_threads+0x40>)
 800bf68:	9a01      	ldr	r2, [sp, #4]
 800bf6a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf6e:	4618      	mov	r0, r3
 800bf70:	f7f5 fa46 	bl	8001400 <chThdWait>
      threads[i] = NULL;
 800bf74:	4b06      	ldr	r3, [pc, #24]	; (800bf90 <test_wait_threads+0x40>)
 800bf76:	9a01      	ldr	r2, [sp, #4]
 800bf78:	2100      	movs	r1, #0
 800bf7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bf7e:	9b01      	ldr	r3, [sp, #4]
 800bf80:	3301      	adds	r3, #1
 800bf82:	9301      	str	r3, [sp, #4]
 800bf84:	9b01      	ldr	r3, [sp, #4]
 800bf86:	2b04      	cmp	r3, #4
 800bf88:	dde7      	ble.n	800bf5a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 800bf8a:	b003      	add	sp, #12
 800bf8c:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf90:	20003e3c 	.word	0x20003e3c
 800bf94:	f3af 8000 	nop.w
 800bf98:	f3af 8000 	nop.w
 800bf9c:	f3af 8000 	nop.w

0800bfa0 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 800bfa0:	b508      	push	{r3, lr}

  chThdSleep(1);
 800bfa2:	2001      	movs	r0, #1
 800bfa4:	f7f5 f994 	bl	80012d0 <chThdSleep>
  return chVTGetSystemTime();
 800bfa8:	f7ff fdea 	bl	800bb80 <chVTGetSystemTime>
 800bfac:	4603      	mov	r3, r0
}
 800bfae:	4618      	mov	r0, r3
 800bfb0:	bd08      	pop	{r3, pc}
 800bfb2:	bf00      	nop
 800bfb4:	f3af 8000 	nop.w
 800bfb8:	f3af 8000 	nop.w
 800bfbc:	f3af 8000 	nop.w

0800bfc0 <tmr>:
 * @brief   Set to @p TRUE when the test timer reaches its deadline.
 */
bool test_timer_done;

static virtual_timer_t vt;
static void tmr(void *p) {
 800bfc0:	b082      	sub	sp, #8
 800bfc2:	9001      	str	r0, [sp, #4]
  (void)p;

  test_timer_done = TRUE;
 800bfc4:	4b02      	ldr	r3, [pc, #8]	; (800bfd0 <tmr+0x10>)
 800bfc6:	2201      	movs	r2, #1
 800bfc8:	701a      	strb	r2, [r3, #0]
}
 800bfca:	b002      	add	sp, #8
 800bfcc:	4770      	bx	lr
 800bfce:	bf00      	nop
 800bfd0:	20003e39 	.word	0x20003e39
 800bfd4:	f3af 8000 	nop.w
 800bfd8:	f3af 8000 	nop.w
 800bfdc:	f3af 8000 	nop.w

0800bfe0 <test_start_timer>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 800bfe0:	b500      	push	{lr}
 800bfe2:	b085      	sub	sp, #20
 800bfe4:	9001      	str	r0, [sp, #4]

  systime_t duration = MS2ST(ms);
 800bfe6:	9b01      	ldr	r3, [sp, #4]
 800bfe8:	4a0a      	ldr	r2, [pc, #40]	; (800c014 <test_start_timer+0x34>)
 800bfea:	fb02 f303 	mul.w	r3, r2, r3
 800bfee:	f203 32e7 	addw	r2, r3, #999	; 0x3e7
 800bff2:	4b09      	ldr	r3, [pc, #36]	; (800c018 <test_start_timer+0x38>)
 800bff4:	fba3 1302 	umull	r1, r3, r3, r2
 800bff8:	099b      	lsrs	r3, r3, #6
 800bffa:	9303      	str	r3, [sp, #12]
  test_timer_done = FALSE;
 800bffc:	4b07      	ldr	r3, [pc, #28]	; (800c01c <test_start_timer+0x3c>)
 800bffe:	2200      	movs	r2, #0
 800c000:	701a      	strb	r2, [r3, #0]
  chVTSet(&vt, duration, tmr, NULL);
 800c002:	4807      	ldr	r0, [pc, #28]	; (800c020 <test_start_timer+0x40>)
 800c004:	9903      	ldr	r1, [sp, #12]
 800c006:	4a07      	ldr	r2, [pc, #28]	; (800c024 <test_start_timer+0x44>)
 800c008:	2300      	movs	r3, #0
 800c00a:	f7ff fe31 	bl	800bc70 <chVTSet>
}
 800c00e:	b005      	add	sp, #20
 800c010:	f85d fb04 	ldr.w	pc, [sp], #4
 800c014:	000186a0 	.word	0x000186a0
 800c018:	10624dd3 	.word	0x10624dd3
 800c01c:	20003e39 	.word	0x20003e39
 800c020:	20001488 	.word	0x20001488
 800c024:	0800bfc1 	.word	0x0800bfc1
 800c028:	f3af 8000 	nopgt.w
 800c02c:	f3af 8000 	nopgt.w

0800c030 <execute_test>:

/*
 * Test suite execution.
 */
static void execute_test(const struct testcase *tcp) {
 800c030:	b500      	pushgt	{lr}
 800c032:	b085      	sub	sp, #20
 800c034:	9001      	str	r0, [sp, #4]
  int i;

  /* Initialization */
  clear_tokens();
 800c036:	f7ff feb3 	bl	800bda0 <clear_tokens>
  local_fail = FALSE;
 800c03a:	4b13      	ldr	r3, [pc, #76]	; (800c088 <execute_test+0x58>)
 800c03c:	2200      	movs	r2, #0
 800c03e:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < MAX_THREADS; i++)
 800c040:	2300      	movs	r3, #0
 800c042:	9303      	str	r3, [sp, #12]
 800c044:	e007      	b.n	800c056 <execute_test+0x26>
    threads[i] = NULL;
 800c046:	4b11      	ldr	r3, [pc, #68]	; (800c08c <execute_test+0x5c>)
 800c048:	9a03      	ldr	r2, [sp, #12]
 800c04a:	2100      	movs	r1, #0
 800c04c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
 800c050:	9b03      	ldr	r3, [sp, #12]
 800c052:	3301      	adds	r3, #1
 800c054:	9303      	str	r3, [sp, #12]
 800c056:	9b03      	ldr	r3, [sp, #12]
 800c058:	2b04      	cmp	r3, #4
 800c05a:	ddf4      	ble.n	800c046 <execute_test+0x16>
    threads[i] = NULL;

  if (tcp->setup != NULL)
 800c05c:	9b01      	ldr	r3, [sp, #4]
 800c05e:	685b      	ldr	r3, [r3, #4]
 800c060:	2b00      	cmp	r3, #0
 800c062:	d002      	beq.n	800c06a <execute_test+0x3a>
    tcp->setup();
 800c064:	9b01      	ldr	r3, [sp, #4]
 800c066:	685b      	ldr	r3, [r3, #4]
 800c068:	4798      	blx	r3
  tcp->execute();
 800c06a:	9b01      	ldr	r3, [sp, #4]
 800c06c:	68db      	ldr	r3, [r3, #12]
 800c06e:	4798      	blx	r3
  if (tcp->teardown != NULL)
 800c070:	9b01      	ldr	r3, [sp, #4]
 800c072:	689b      	ldr	r3, [r3, #8]
 800c074:	2b00      	cmp	r3, #0
 800c076:	d002      	beq.n	800c07e <execute_test+0x4e>
    tcp->teardown();
 800c078:	9b01      	ldr	r3, [sp, #4]
 800c07a:	689b      	ldr	r3, [r3, #8]
 800c07c:	4798      	blx	r3

  test_wait_threads();
 800c07e:	f7ff ff67 	bl	800bf50 <test_wait_threads>
}
 800c082:	b005      	add	sp, #20
 800c084:	f85d fb04 	ldr.w	pc, [sp], #4
 800c088:	20001468 	.word	0x20001468
 800c08c:	20003e3c 	.word	0x20003e3c

0800c090 <print_line>:

static void print_line(void) {
 800c090:	b500      	push	{lr}
 800c092:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < 76; i++)
 800c094:	2300      	movs	r3, #0
 800c096:	9301      	str	r3, [sp, #4]
 800c098:	e00b      	b.n	800c0b2 <print_line+0x22>
    chSequentialStreamPut(chp, '-');
 800c09a:	4b0e      	ldr	r3, [pc, #56]	; (800c0d4 <print_line+0x44>)
 800c09c:	681b      	ldr	r3, [r3, #0]
 800c09e:	681b      	ldr	r3, [r3, #0]
 800c0a0:	689b      	ldr	r3, [r3, #8]
 800c0a2:	4a0c      	ldr	r2, [pc, #48]	; (800c0d4 <print_line+0x44>)
 800c0a4:	6812      	ldr	r2, [r2, #0]
 800c0a6:	4610      	mov	r0, r2
 800c0a8:	212d      	movs	r1, #45	; 0x2d
 800c0aa:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 800c0ac:	9b01      	ldr	r3, [sp, #4]
 800c0ae:	3301      	adds	r3, #1
 800c0b0:	9301      	str	r3, [sp, #4]
 800c0b2:	9b01      	ldr	r3, [sp, #4]
 800c0b4:	2b4b      	cmp	r3, #75	; 0x4b
 800c0b6:	d9f0      	bls.n	800c09a <print_line+0xa>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800c0b8:	4b06      	ldr	r3, [pc, #24]	; (800c0d4 <print_line+0x44>)
 800c0ba:	681b      	ldr	r3, [r3, #0]
 800c0bc:	681b      	ldr	r3, [r3, #0]
 800c0be:	681b      	ldr	r3, [r3, #0]
 800c0c0:	4a04      	ldr	r2, [pc, #16]	; (800c0d4 <print_line+0x44>)
 800c0c2:	6812      	ldr	r2, [r2, #0]
 800c0c4:	4610      	mov	r0, r2
 800c0c6:	4904      	ldr	r1, [pc, #16]	; (800c0d8 <print_line+0x48>)
 800c0c8:	2202      	movs	r2, #2
 800c0ca:	4798      	blx	r3
}
 800c0cc:	b003      	add	sp, #12
 800c0ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800c0d2:	bf00      	nop
 800c0d4:	20001484 	.word	0x20001484
 800c0d8:	0801ad84 	.word	0x0801ad84
 800c0dc:	f3af 8000 	nop.w

0800c0e0 <TestThread>:
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 800c0e0:	b500      	push	{lr}
 800c0e2:	b085      	sub	sp, #20
 800c0e4:	9001      	str	r0, [sp, #4]
  int i, j;

  chp = p;
 800c0e6:	4b5f      	ldr	r3, [pc, #380]	; (800c264 <TestThread+0x184>)
 800c0e8:	9a01      	ldr	r2, [sp, #4]
 800c0ea:	601a      	str	r2, [r3, #0]
  test_println("");
 800c0ec:	485e      	ldr	r0, [pc, #376]	; (800c268 <TestThread+0x188>)
 800c0ee:	f7ff fe3f 	bl	800bd70 <test_println>
  test_println("*** ChibiOS/RT test suite");
 800c0f2:	485e      	ldr	r0, [pc, #376]	; (800c26c <TestThread+0x18c>)
 800c0f4:	f7ff fe3c 	bl	800bd70 <test_println>
  test_println("***");
 800c0f8:	485d      	ldr	r0, [pc, #372]	; (800c270 <TestThread+0x190>)
 800c0fa:	f7ff fe39 	bl	800bd70 <test_println>
  test_print("*** Kernel:       ");
 800c0fe:	485d      	ldr	r0, [pc, #372]	; (800c274 <TestThread+0x194>)
 800c100:	f7ff fe16 	bl	800bd30 <test_print>
  test_println(CH_KERNEL_VERSION);
 800c104:	485c      	ldr	r0, [pc, #368]	; (800c278 <TestThread+0x198>)
 800c106:	f7ff fe33 	bl	800bd70 <test_println>
  test_print("*** Compiled:     ");
 800c10a:	485c      	ldr	r0, [pc, #368]	; (800c27c <TestThread+0x19c>)
 800c10c:	f7ff fe10 	bl	800bd30 <test_print>
  test_println(__DATE__ " - " __TIME__);
 800c110:	485b      	ldr	r0, [pc, #364]	; (800c280 <TestThread+0x1a0>)
 800c112:	f7ff fe2d 	bl	800bd70 <test_println>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
 800c116:	485b      	ldr	r0, [pc, #364]	; (800c284 <TestThread+0x1a4>)
 800c118:	f7ff fe0a 	bl	800bd30 <test_print>
  test_println(PORT_COMPILER_NAME);
 800c11c:	485a      	ldr	r0, [pc, #360]	; (800c288 <TestThread+0x1a8>)
 800c11e:	f7ff fe27 	bl	800bd70 <test_println>
#endif
  test_print("*** Architecture: ");
 800c122:	485a      	ldr	r0, [pc, #360]	; (800c28c <TestThread+0x1ac>)
 800c124:	f7ff fe04 	bl	800bd30 <test_print>
  test_println(PORT_ARCHITECTURE_NAME);
 800c128:	4859      	ldr	r0, [pc, #356]	; (800c290 <TestThread+0x1b0>)
 800c12a:	f7ff fe21 	bl	800bd70 <test_println>
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
 800c12e:	4859      	ldr	r0, [pc, #356]	; (800c294 <TestThread+0x1b4>)
 800c130:	f7ff fdfe 	bl	800bd30 <test_print>
  test_println(PORT_CORE_VARIANT_NAME);
 800c134:	4858      	ldr	r0, [pc, #352]	; (800c298 <TestThread+0x1b8>)
 800c136:	f7ff fe1b 	bl	800bd70 <test_println>
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
 800c13a:	4858      	ldr	r0, [pc, #352]	; (800c29c <TestThread+0x1bc>)
 800c13c:	f7ff fdf8 	bl	800bd30 <test_print>
  test_println(PORT_INFO);
 800c140:	4857      	ldr	r0, [pc, #348]	; (800c2a0 <TestThread+0x1c0>)
 800c142:	f7ff fe15 	bl	800bd70 <test_println>
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
 800c146:	4857      	ldr	r0, [pc, #348]	; (800c2a4 <TestThread+0x1c4>)
 800c148:	f7ff fdf2 	bl	800bd30 <test_print>
  test_println(PLATFORM_NAME);
 800c14c:	4856      	ldr	r0, [pc, #344]	; (800c2a8 <TestThread+0x1c8>)
 800c14e:	f7ff fe0f 	bl	800bd70 <test_println>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
 800c152:	4856      	ldr	r0, [pc, #344]	; (800c2ac <TestThread+0x1cc>)
 800c154:	f7ff fdec 	bl	800bd30 <test_print>
  test_println(BOARD_NAME);
 800c158:	4855      	ldr	r0, [pc, #340]	; (800c2b0 <TestThread+0x1d0>)
 800c15a:	f7ff fe09 	bl	800bd70 <test_println>
#endif
  test_println("");
 800c15e:	4842      	ldr	r0, [pc, #264]	; (800c268 <TestThread+0x188>)
 800c160:	f7ff fe06 	bl	800bd70 <test_println>

  test_global_fail = FALSE;
 800c164:	4b53      	ldr	r3, [pc, #332]	; (800c2b4 <TestThread+0x1d4>)
 800c166:	2200      	movs	r2, #0
 800c168:	701a      	strb	r2, [r3, #0]
  i = 0;
 800c16a:	2300      	movs	r3, #0
 800c16c:	9303      	str	r3, [sp, #12]
  while (patterns[i]) {
 800c16e:	e05d      	b.n	800c22c <TestThread+0x14c>
    j = 0;
 800c170:	2300      	movs	r3, #0
 800c172:	9302      	str	r3, [sp, #8]
    while (patterns[i][j]) {
 800c174:	e04d      	b.n	800c212 <TestThread+0x132>
      print_line();
 800c176:	f7ff ff8b 	bl	800c090 <print_line>
      test_print("--- Test Case ");
 800c17a:	484f      	ldr	r0, [pc, #316]	; (800c2b8 <TestThread+0x1d8>)
 800c17c:	f7ff fdd8 	bl	800bd30 <test_print>
      test_printn(i + 1);
 800c180:	9b03      	ldr	r3, [sp, #12]
 800c182:	3301      	adds	r3, #1
 800c184:	4618      	mov	r0, r3
 800c186:	f7ff fd8b 	bl	800bca0 <test_printn>
      test_print(".");
 800c18a:	484c      	ldr	r0, [pc, #304]	; (800c2bc <TestThread+0x1dc>)
 800c18c:	f7ff fdd0 	bl	800bd30 <test_print>
      test_printn(j + 1);
 800c190:	9b02      	ldr	r3, [sp, #8]
 800c192:	3301      	adds	r3, #1
 800c194:	4618      	mov	r0, r3
 800c196:	f7ff fd83 	bl	800bca0 <test_printn>
      test_print(" (");
 800c19a:	4849      	ldr	r0, [pc, #292]	; (800c2c0 <TestThread+0x1e0>)
 800c19c:	f7ff fdc8 	bl	800bd30 <test_print>
      test_print(patterns[i][j]->name);
 800c1a0:	4b48      	ldr	r3, [pc, #288]	; (800c2c4 <TestThread+0x1e4>)
 800c1a2:	9a03      	ldr	r2, [sp, #12]
 800c1a4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c1a8:	9b02      	ldr	r3, [sp, #8]
 800c1aa:	009b      	lsls	r3, r3, #2
 800c1ac:	4413      	add	r3, r2
 800c1ae:	681b      	ldr	r3, [r3, #0]
 800c1b0:	681b      	ldr	r3, [r3, #0]
 800c1b2:	4618      	mov	r0, r3
 800c1b4:	f7ff fdbc 	bl	800bd30 <test_print>
      test_println(")");
 800c1b8:	4843      	ldr	r0, [pc, #268]	; (800c2c8 <TestThread+0x1e8>)
 800c1ba:	f7ff fdd9 	bl	800bd70 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 800c1be:	f644 6020 	movw	r0, #20000	; 0x4e20
 800c1c2:	f7f5 f885 	bl	80012d0 <chThdSleep>
#endif
      execute_test(patterns[i][j]);
 800c1c6:	4b3f      	ldr	r3, [pc, #252]	; (800c2c4 <TestThread+0x1e4>)
 800c1c8:	9a03      	ldr	r2, [sp, #12]
 800c1ca:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c1ce:	9b02      	ldr	r3, [sp, #8]
 800c1d0:	009b      	lsls	r3, r3, #2
 800c1d2:	4413      	add	r3, r2
 800c1d4:	681b      	ldr	r3, [r3, #0]
 800c1d6:	4618      	mov	r0, r3
 800c1d8:	f7ff ff2a 	bl	800c030 <execute_test>
      if (local_fail) {
 800c1dc:	4b3b      	ldr	r3, [pc, #236]	; (800c2cc <TestThread+0x1ec>)
 800c1de:	781b      	ldrb	r3, [r3, #0]
 800c1e0:	2b00      	cmp	r3, #0
 800c1e2:	d010      	beq.n	800c206 <TestThread+0x126>
        test_print("--- Result: FAILURE (#");
 800c1e4:	483a      	ldr	r0, [pc, #232]	; (800c2d0 <TestThread+0x1f0>)
 800c1e6:	f7ff fda3 	bl	800bd30 <test_print>
        test_printn(failpoint);
 800c1ea:	4b3a      	ldr	r3, [pc, #232]	; (800c2d4 <TestThread+0x1f4>)
 800c1ec:	681b      	ldr	r3, [r3, #0]
 800c1ee:	4618      	mov	r0, r3
 800c1f0:	f7ff fd56 	bl	800bca0 <test_printn>
        test_print(" [");
 800c1f4:	4838      	ldr	r0, [pc, #224]	; (800c2d8 <TestThread+0x1f8>)
 800c1f6:	f7ff fd9b 	bl	800bd30 <test_print>
        print_tokens();
 800c1fa:	f7ff fdd9 	bl	800bdb0 <print_tokens>
        test_println("])");
 800c1fe:	4837      	ldr	r0, [pc, #220]	; (800c2dc <TestThread+0x1fc>)
 800c200:	f7ff fdb6 	bl	800bd70 <test_println>
 800c204:	e002      	b.n	800c20c <TestThread+0x12c>
      }
      else
        test_println("--- Result: SUCCESS");
 800c206:	4836      	ldr	r0, [pc, #216]	; (800c2e0 <TestThread+0x200>)
 800c208:	f7ff fdb2 	bl	800bd70 <test_println>
      j++;
 800c20c:	9b02      	ldr	r3, [sp, #8]
 800c20e:	3301      	adds	r3, #1
 800c210:	9302      	str	r3, [sp, #8]

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 800c212:	4b2c      	ldr	r3, [pc, #176]	; (800c2c4 <TestThread+0x1e4>)
 800c214:	9a03      	ldr	r2, [sp, #12]
 800c216:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c21a:	9b02      	ldr	r3, [sp, #8]
 800c21c:	009b      	lsls	r3, r3, #2
 800c21e:	4413      	add	r3, r2
 800c220:	681b      	ldr	r3, [r3, #0]
 800c222:	2b00      	cmp	r3, #0
 800c224:	d1a7      	bne.n	800c176 <TestThread+0x96>
      }
      else
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
 800c226:	9b03      	ldr	r3, [sp, #12]
 800c228:	3301      	adds	r3, #1
 800c22a:	9303      	str	r3, [sp, #12]
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 800c22c:	4b25      	ldr	r3, [pc, #148]	; (800c2c4 <TestThread+0x1e4>)
 800c22e:	9a03      	ldr	r2, [sp, #12]
 800c230:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c234:	2b00      	cmp	r3, #0
 800c236:	d19b      	bne.n	800c170 <TestThread+0x90>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 800c238:	f7ff ff2a 	bl	800c090 <print_line>
  test_println("");
 800c23c:	480a      	ldr	r0, [pc, #40]	; (800c268 <TestThread+0x188>)
 800c23e:	f7ff fd97 	bl	800bd70 <test_println>
  test_print("Final result: ");
 800c242:	4828      	ldr	r0, [pc, #160]	; (800c2e4 <TestThread+0x204>)
 800c244:	f7ff fd74 	bl	800bd30 <test_print>
  if (test_global_fail)
 800c248:	4b1a      	ldr	r3, [pc, #104]	; (800c2b4 <TestThread+0x1d4>)
 800c24a:	781b      	ldrb	r3, [r3, #0]
 800c24c:	2b00      	cmp	r3, #0
 800c24e:	d003      	beq.n	800c258 <TestThread+0x178>
    test_println("FAILURE");
 800c250:	4825      	ldr	r0, [pc, #148]	; (800c2e8 <TestThread+0x208>)
 800c252:	f7ff fd8d 	bl	800bd70 <test_println>
 800c256:	e002      	b.n	800c25e <TestThread+0x17e>
  else
    test_println("SUCCESS");
 800c258:	4824      	ldr	r0, [pc, #144]	; (800c2ec <TestThread+0x20c>)
 800c25a:	f7ff fd89 	bl	800bd70 <test_println>
}
 800c25e:	b005      	add	sp, #20
 800c260:	f85d fb04 	ldr.w	pc, [sp], #4
 800c264:	20001484 	.word	0x20001484
 800c268:	0801ad88 	.word	0x0801ad88
 800c26c:	0801ad8c 	.word	0x0801ad8c
 800c270:	0801ada8 	.word	0x0801ada8
 800c274:	0801adac 	.word	0x0801adac
 800c278:	0801adc0 	.word	0x0801adc0
 800c27c:	0801adc8 	.word	0x0801adc8
 800c280:	0801addc 	.word	0x0801addc
 800c284:	0801adf4 	.word	0x0801adf4
 800c288:	0801ae08 	.word	0x0801ae08
 800c28c:	0801ae50 	.word	0x0801ae50
 800c290:	0801ae64 	.word	0x0801ae64
 800c294:	0801ae70 	.word	0x0801ae70
 800c298:	0801ae84 	.word	0x0801ae84
 800c29c:	0801ae90 	.word	0x0801ae90
 800c2a0:	0801aea4 	.word	0x0801aea4
 800c2a4:	0801aebc 	.word	0x0801aebc
 800c2a8:	0801aed0 	.word	0x0801aed0
 800c2ac:	0801aeec 	.word	0x0801aeec
 800c2b0:	0801af00 	.word	0x0801af00
 800c2b4:	20003e38 	.word	0x20003e38
 800c2b8:	0801af10 	.word	0x0801af10
 800c2bc:	0801af20 	.word	0x0801af20
 800c2c0:	0801af24 	.word	0x0801af24
 800c2c4:	20000804 	.word	0x20000804
 800c2c8:	0801af28 	.word	0x0801af28
 800c2cc:	20001468 	.word	0x20001468
 800c2d0:	0801af2c 	.word	0x0801af2c
 800c2d4:	2000146c 	.word	0x2000146c
 800c2d8:	0801af44 	.word	0x0801af44
 800c2dc:	0801af48 	.word	0x0801af48
 800c2e0:	0801af4c 	.word	0x0801af4c
 800c2e4:	0801af60 	.word	0x0801af60
 800c2e8:	0801af70 	.word	0x0801af70
 800c2ec:	0801af78 	.word	0x0801af78

0800c2f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c2f0:	b082      	sub	sp, #8
 800c2f2:	2320      	movs	r3, #32
 800c2f4:	9301      	str	r3, [sp, #4]
 800c2f6:	9b01      	ldr	r3, [sp, #4]
 800c2f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c2fc:	b002      	add	sp, #8
 800c2fe:	4770      	bx	lr

0800c300 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c300:	b082      	sub	sp, #8
 800c302:	2300      	movs	r3, #0
 800c304:	9301      	str	r3, [sp, #4]
 800c306:	9b01      	ldr	r3, [sp, #4]
 800c308:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c30c:	b002      	add	sp, #8
 800c30e:	4770      	bx	lr

0800c310 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c310:	b508      	push	{r3, lr}

  port_lock();
 800c312:	f7ff ffed 	bl	800c2f0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800c316:	bd08      	pop	{r3, pc}
 800c318:	f3af 8000 	nop.w
 800c31c:	f3af 8000 	nop.w

0800c320 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c320:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800c322:	f7ff ffed 	bl	800c300 <port_unlock>
}
 800c326:	bd08      	pop	{r3, pc}
 800c328:	f3af 8000 	nop.w
 800c32c:	f3af 8000 	nop.w

0800c330 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800c330:	4b01      	ldr	r3, [pc, #4]	; (800c338 <chVTGetSystemTimeX+0x8>)
 800c332:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c334:	4618      	mov	r0, r3
 800c336:	4770      	bx	lr
 800c338:	200039a8 	.word	0x200039a8
 800c33c:	f3af 8000 	nop.w

0800c340 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800c340:	b500      	push	{lr}
 800c342:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800c344:	f7ff ffe4 	bl	800c310 <chSysLock>
  systime = chVTGetSystemTimeX();
 800c348:	f7ff fff2 	bl	800c330 <chVTGetSystemTimeX>
 800c34c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800c34e:	f7ff ffe7 	bl	800c320 <chSysUnlock>

  return systime;
 800c352:	9b01      	ldr	r3, [sp, #4]
}
 800c354:	4618      	mov	r0, r3
 800c356:	b003      	add	sp, #12
 800c358:	f85d fb04 	ldr.w	pc, [sp], #4
 800c35c:	f3af 8000 	nop.w

0800c360 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800c360:	4b01      	ldr	r3, [pc, #4]	; (800c368 <chThdGetSelfX+0x8>)
 800c362:	699b      	ldr	r3, [r3, #24]
}
 800c364:	4618      	mov	r0, r3
 800c366:	4770      	bx	lr
 800c368:	200039a8 	.word	0x200039a8
 800c36c:	f3af 8000 	nop.w

0800c370 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800c370:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800c372:	f7ff fff5 	bl	800c360 <chThdGetSelfX>
 800c376:	4603      	mov	r3, r0
 800c378:	689b      	ldr	r3, [r3, #8]
}
 800c37a:	4618      	mov	r0, r3
 800c37c:	bd08      	pop	{r3, pc}
 800c37e:	bf00      	nop

0800c380 <thread>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {
 800c380:	b500      	push	{lr}
 800c382:	b083      	sub	sp, #12
 800c384:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 800c386:	9b01      	ldr	r3, [sp, #4]
 800c388:	781b      	ldrb	r3, [r3, #0]
 800c38a:	4618      	mov	r0, r3
 800c38c:	f7ff fd30 	bl	800bdf0 <test_emit_token>
}
 800c390:	b003      	add	sp, #12
 800c392:	f85d fb04 	ldr.w	pc, [sp], #4
 800c396:	bf00      	nop
 800c398:	f3af 8000 	nop.w
 800c39c:	f3af 8000 	nop.w

0800c3a0 <thd1_execute>:

static void thd1_execute(void) {
 800c3a0:	b510      	push	{r4, lr}
 800c3a2:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800c3a4:	4b32      	ldr	r3, [pc, #200]	; (800c470 <thd1_execute+0xd0>)
 800c3a6:	681c      	ldr	r4, [r3, #0]
 800c3a8:	f7ff ffe2 	bl	800c370 <chThdGetPriorityX>
 800c3ac:	4603      	mov	r3, r0
 800c3ae:	3b05      	subs	r3, #5
 800c3b0:	4a30      	ldr	r2, [pc, #192]	; (800c474 <thd1_execute+0xd4>)
 800c3b2:	9200      	str	r2, [sp, #0]
 800c3b4:	4620      	mov	r0, r4
 800c3b6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c3ba:	461a      	mov	r2, r3
 800c3bc:	4b2e      	ldr	r3, [pc, #184]	; (800c478 <thd1_execute+0xd8>)
 800c3be:	f7f4 ff0f 	bl	80011e0 <chThdCreateStatic>
 800c3c2:	4602      	mov	r2, r0
 800c3c4:	4b2d      	ldr	r3, [pc, #180]	; (800c47c <thd1_execute+0xdc>)
 800c3c6:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800c3c8:	4b29      	ldr	r3, [pc, #164]	; (800c470 <thd1_execute+0xd0>)
 800c3ca:	685c      	ldr	r4, [r3, #4]
 800c3cc:	f7ff ffd0 	bl	800c370 <chThdGetPriorityX>
 800c3d0:	4603      	mov	r3, r0
 800c3d2:	3b04      	subs	r3, #4
 800c3d4:	4a2a      	ldr	r2, [pc, #168]	; (800c480 <thd1_execute+0xe0>)
 800c3d6:	9200      	str	r2, [sp, #0]
 800c3d8:	4620      	mov	r0, r4
 800c3da:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c3de:	461a      	mov	r2, r3
 800c3e0:	4b25      	ldr	r3, [pc, #148]	; (800c478 <thd1_execute+0xd8>)
 800c3e2:	f7f4 fefd 	bl	80011e0 <chThdCreateStatic>
 800c3e6:	4602      	mov	r2, r0
 800c3e8:	4b24      	ldr	r3, [pc, #144]	; (800c47c <thd1_execute+0xdc>)
 800c3ea:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800c3ec:	4b20      	ldr	r3, [pc, #128]	; (800c470 <thd1_execute+0xd0>)
 800c3ee:	689c      	ldr	r4, [r3, #8]
 800c3f0:	f7ff ffbe 	bl	800c370 <chThdGetPriorityX>
 800c3f4:	4603      	mov	r3, r0
 800c3f6:	3b03      	subs	r3, #3
 800c3f8:	4a22      	ldr	r2, [pc, #136]	; (800c484 <thd1_execute+0xe4>)
 800c3fa:	9200      	str	r2, [sp, #0]
 800c3fc:	4620      	mov	r0, r4
 800c3fe:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c402:	461a      	mov	r2, r3
 800c404:	4b1c      	ldr	r3, [pc, #112]	; (800c478 <thd1_execute+0xd8>)
 800c406:	f7f4 feeb 	bl	80011e0 <chThdCreateStatic>
 800c40a:	4602      	mov	r2, r0
 800c40c:	4b1b      	ldr	r3, [pc, #108]	; (800c47c <thd1_execute+0xdc>)
 800c40e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800c410:	4b17      	ldr	r3, [pc, #92]	; (800c470 <thd1_execute+0xd0>)
 800c412:	68dc      	ldr	r4, [r3, #12]
 800c414:	f7ff ffac 	bl	800c370 <chThdGetPriorityX>
 800c418:	4603      	mov	r3, r0
 800c41a:	3b02      	subs	r3, #2
 800c41c:	4a1a      	ldr	r2, [pc, #104]	; (800c488 <thd1_execute+0xe8>)
 800c41e:	9200      	str	r2, [sp, #0]
 800c420:	4620      	mov	r0, r4
 800c422:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c426:	461a      	mov	r2, r3
 800c428:	4b13      	ldr	r3, [pc, #76]	; (800c478 <thd1_execute+0xd8>)
 800c42a:	f7f4 fed9 	bl	80011e0 <chThdCreateStatic>
 800c42e:	4602      	mov	r2, r0
 800c430:	4b12      	ldr	r3, [pc, #72]	; (800c47c <thd1_execute+0xdc>)
 800c432:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800c434:	4b0e      	ldr	r3, [pc, #56]	; (800c470 <thd1_execute+0xd0>)
 800c436:	691c      	ldr	r4, [r3, #16]
 800c438:	f7ff ff9a 	bl	800c370 <chThdGetPriorityX>
 800c43c:	4603      	mov	r3, r0
 800c43e:	3b01      	subs	r3, #1
 800c440:	4a12      	ldr	r2, [pc, #72]	; (800c48c <thd1_execute+0xec>)
 800c442:	9200      	str	r2, [sp, #0]
 800c444:	4620      	mov	r0, r4
 800c446:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c44a:	461a      	mov	r2, r3
 800c44c:	4b0a      	ldr	r3, [pc, #40]	; (800c478 <thd1_execute+0xd8>)
 800c44e:	f7f4 fec7 	bl	80011e0 <chThdCreateStatic>
 800c452:	4602      	mov	r2, r0
 800c454:	4b09      	ldr	r3, [pc, #36]	; (800c47c <thd1_execute+0xdc>)
 800c456:	611a      	str	r2, [r3, #16]
  test_wait_threads();
 800c458:	f7ff fd7a 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800c45c:	2001      	movs	r0, #1
 800c45e:	490c      	ldr	r1, [pc, #48]	; (800c490 <thd1_execute+0xf0>)
 800c460:	f7ff fd0e 	bl	800be80 <_test_assert_sequence>
 800c464:	4603      	mov	r3, r0
 800c466:	2b00      	cmp	r3, #0
 800c468:	d000      	beq.n	800c46c <thd1_execute+0xcc>
 800c46a:	bf00      	nop
}
 800c46c:	b002      	add	sp, #8
 800c46e:	bd10      	pop	{r4, pc}
 800c470:	0801ad70 	.word	0x0801ad70
 800c474:	0801af80 	.word	0x0801af80
 800c478:	0800c381 	.word	0x0800c381
 800c47c:	20003e3c 	.word	0x20003e3c
 800c480:	0801af84 	.word	0x0801af84
 800c484:	0801af88 	.word	0x0801af88
 800c488:	0801af8c 	.word	0x0801af8c
 800c48c:	0801af90 	.word	0x0801af90
 800c490:	0801af94 	.word	0x0801af94
 800c494:	f3af 8000 	nop.w
 800c498:	f3af 8000 	nop.w
 800c49c:	f3af 8000 	nop.w

0800c4a0 <thd2_execute>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 800c4a0:	b510      	push	{r4, lr}
 800c4a2:	b082      	sub	sp, #8

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800c4a4:	4b37      	ldr	r3, [pc, #220]	; (800c584 <thd2_execute+0xe4>)
 800c4a6:	685c      	ldr	r4, [r3, #4]
 800c4a8:	f7ff ff62 	bl	800c370 <chThdGetPriorityX>
 800c4ac:	4603      	mov	r3, r0
 800c4ae:	3b04      	subs	r3, #4
 800c4b0:	4a35      	ldr	r2, [pc, #212]	; (800c588 <thd2_execute+0xe8>)
 800c4b2:	9200      	str	r2, [sp, #0]
 800c4b4:	4620      	mov	r0, r4
 800c4b6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c4ba:	461a      	mov	r2, r3
 800c4bc:	4b33      	ldr	r3, [pc, #204]	; (800c58c <thd2_execute+0xec>)
 800c4be:	f7f4 fe8f 	bl	80011e0 <chThdCreateStatic>
 800c4c2:	4602      	mov	r2, r0
 800c4c4:	4b32      	ldr	r3, [pc, #200]	; (800c590 <thd2_execute+0xf0>)
 800c4c6:	605a      	str	r2, [r3, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800c4c8:	4b2e      	ldr	r3, [pc, #184]	; (800c584 <thd2_execute+0xe4>)
 800c4ca:	681c      	ldr	r4, [r3, #0]
 800c4cc:	f7ff ff50 	bl	800c370 <chThdGetPriorityX>
 800c4d0:	4603      	mov	r3, r0
 800c4d2:	3b05      	subs	r3, #5
 800c4d4:	4a2f      	ldr	r2, [pc, #188]	; (800c594 <thd2_execute+0xf4>)
 800c4d6:	9200      	str	r2, [sp, #0]
 800c4d8:	4620      	mov	r0, r4
 800c4da:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c4de:	461a      	mov	r2, r3
 800c4e0:	4b2a      	ldr	r3, [pc, #168]	; (800c58c <thd2_execute+0xec>)
 800c4e2:	f7f4 fe7d 	bl	80011e0 <chThdCreateStatic>
 800c4e6:	4602      	mov	r2, r0
 800c4e8:	4b29      	ldr	r3, [pc, #164]	; (800c590 <thd2_execute+0xf0>)
 800c4ea:	601a      	str	r2, [r3, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800c4ec:	4b25      	ldr	r3, [pc, #148]	; (800c584 <thd2_execute+0xe4>)
 800c4ee:	691c      	ldr	r4, [r3, #16]
 800c4f0:	f7ff ff3e 	bl	800c370 <chThdGetPriorityX>
 800c4f4:	4603      	mov	r3, r0
 800c4f6:	3b01      	subs	r3, #1
 800c4f8:	4a27      	ldr	r2, [pc, #156]	; (800c598 <thd2_execute+0xf8>)
 800c4fa:	9200      	str	r2, [sp, #0]
 800c4fc:	4620      	mov	r0, r4
 800c4fe:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c502:	461a      	mov	r2, r3
 800c504:	4b21      	ldr	r3, [pc, #132]	; (800c58c <thd2_execute+0xec>)
 800c506:	f7f4 fe6b 	bl	80011e0 <chThdCreateStatic>
 800c50a:	4602      	mov	r2, r0
 800c50c:	4b20      	ldr	r3, [pc, #128]	; (800c590 <thd2_execute+0xf0>)
 800c50e:	611a      	str	r2, [r3, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800c510:	4b1c      	ldr	r3, [pc, #112]	; (800c584 <thd2_execute+0xe4>)
 800c512:	68dc      	ldr	r4, [r3, #12]
 800c514:	f7ff ff2c 	bl	800c370 <chThdGetPriorityX>
 800c518:	4603      	mov	r3, r0
 800c51a:	3b02      	subs	r3, #2
 800c51c:	4a1f      	ldr	r2, [pc, #124]	; (800c59c <thd2_execute+0xfc>)
 800c51e:	9200      	str	r2, [sp, #0]
 800c520:	4620      	mov	r0, r4
 800c522:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c526:	461a      	mov	r2, r3
 800c528:	4b18      	ldr	r3, [pc, #96]	; (800c58c <thd2_execute+0xec>)
 800c52a:	f7f4 fe59 	bl	80011e0 <chThdCreateStatic>
 800c52e:	4602      	mov	r2, r0
 800c530:	4b17      	ldr	r3, [pc, #92]	; (800c590 <thd2_execute+0xf0>)
 800c532:	60da      	str	r2, [r3, #12]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
 800c534:	f7ff feec 	bl	800c310 <chSysLock>
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800c538:	4b12      	ldr	r3, [pc, #72]	; (800c584 <thd2_execute+0xe4>)
 800c53a:	689c      	ldr	r4, [r3, #8]
 800c53c:	f7ff ff18 	bl	800c370 <chThdGetPriorityX>
 800c540:	4603      	mov	r3, r0
 800c542:	3b03      	subs	r3, #3
 800c544:	4a16      	ldr	r2, [pc, #88]	; (800c5a0 <thd2_execute+0x100>)
 800c546:	9200      	str	r2, [sp, #0]
 800c548:	4620      	mov	r0, r4
 800c54a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c54e:	461a      	mov	r2, r3
 800c550:	4b0e      	ldr	r3, [pc, #56]	; (800c58c <thd2_execute+0xec>)
 800c552:	f7f4 fe1d 	bl	8001190 <chThdCreateI>
 800c556:	4602      	mov	r2, r0
 800c558:	4b0d      	ldr	r3, [pc, #52]	; (800c590 <thd2_execute+0xf0>)
 800c55a:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 800c55c:	f7ff fee0 	bl	800c320 <chSysUnlock>
  chThdStart(threads[2]);
 800c560:	4b0b      	ldr	r3, [pc, #44]	; (800c590 <thd2_execute+0xf0>)
 800c562:	689b      	ldr	r3, [r3, #8]
 800c564:	4618      	mov	r0, r3
 800c566:	f7f4 fe5b 	bl	8001220 <chThdStart>
  test_wait_threads();
 800c56a:	f7ff fcf1 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800c56e:	2001      	movs	r0, #1
 800c570:	490c      	ldr	r1, [pc, #48]	; (800c5a4 <thd2_execute+0x104>)
 800c572:	f7ff fc85 	bl	800be80 <_test_assert_sequence>
 800c576:	4603      	mov	r3, r0
 800c578:	2b00      	cmp	r3, #0
 800c57a:	d000      	beq.n	800c57e <thd2_execute+0xde>
 800c57c:	bf00      	nop
}
 800c57e:	b002      	add	sp, #8
 800c580:	bd10      	pop	{r4, pc}
 800c582:	bf00      	nop
 800c584:	0801ad70 	.word	0x0801ad70
 800c588:	0801af84 	.word	0x0801af84
 800c58c:	0800c381 	.word	0x0800c381
 800c590:	20003e3c 	.word	0x20003e3c
 800c594:	0801af80 	.word	0x0801af80
 800c598:	0801af90 	.word	0x0801af90
 800c59c:	0801af8c 	.word	0x0801af8c
 800c5a0:	0801af88 	.word	0x0801af88
 800c5a4:	0801af94 	.word	0x0801af94
 800c5a8:	f3af 8000 	nop.w
 800c5ac:	f3af 8000 	nop.w

0800c5b0 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 800c5b0:	b500      	push	{lr}
 800c5b2:	b083      	sub	sp, #12
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
 800c5b4:	f7ff fedc 	bl	800c370 <chThdGetPriorityX>
 800c5b8:	9001      	str	r0, [sp, #4]
  p1 = chThdSetPriority(prio + 1);
 800c5ba:	9b01      	ldr	r3, [sp, #4]
 800c5bc:	3301      	adds	r3, #1
 800c5be:	4618      	mov	r0, r3
 800c5c0:	f7f4 fe3e 	bl	8001240 <chThdSetPriority>
 800c5c4:	9000      	str	r0, [sp, #0]
  test_assert(1, p1 == prio,
 800c5c6:	9a00      	ldr	r2, [sp, #0]
 800c5c8:	9b01      	ldr	r3, [sp, #4]
 800c5ca:	429a      	cmp	r2, r3
 800c5cc:	bf14      	ite	ne
 800c5ce:	2300      	movne	r3, #0
 800c5d0:	2301      	moveq	r3, #1
 800c5d2:	b2db      	uxtb	r3, r3
 800c5d4:	2001      	movs	r0, #1
 800c5d6:	4619      	mov	r1, r3
 800c5d8:	f7ff fc3a 	bl	800be50 <_test_assert>
 800c5dc:	4603      	mov	r3, r0
 800c5de:	2b00      	cmp	r3, #0
 800c5e0:	d000      	beq.n	800c5e4 <thd3_execute+0x34>
 800c5e2:	e0d7      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 800c5e4:	f7ff fec4 	bl	800c370 <chThdGetPriorityX>
 800c5e8:	4602      	mov	r2, r0
 800c5ea:	9b01      	ldr	r3, [sp, #4]
 800c5ec:	3301      	adds	r3, #1
 800c5ee:	429a      	cmp	r2, r3
 800c5f0:	bf14      	ite	ne
 800c5f2:	2300      	movne	r3, #0
 800c5f4:	2301      	moveq	r3, #1
 800c5f6:	b2db      	uxtb	r3, r3
 800c5f8:	2002      	movs	r0, #2
 800c5fa:	4619      	mov	r1, r3
 800c5fc:	f7ff fc28 	bl	800be50 <_test_assert>
 800c600:	4603      	mov	r3, r0
 800c602:	2b00      	cmp	r3, #0
 800c604:	d000      	beq.n	800c608 <thd3_execute+0x58>
 800c606:	e0c5      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 800c608:	9800      	ldr	r0, [sp, #0]
 800c60a:	f7f4 fe19 	bl	8001240 <chThdSetPriority>
 800c60e:	9000      	str	r0, [sp, #0]
  test_assert(3, p1 == prio + 1,
 800c610:	9b01      	ldr	r3, [sp, #4]
 800c612:	1c5a      	adds	r2, r3, #1
 800c614:	9b00      	ldr	r3, [sp, #0]
 800c616:	429a      	cmp	r2, r3
 800c618:	bf14      	ite	ne
 800c61a:	2300      	movne	r3, #0
 800c61c:	2301      	moveq	r3, #1
 800c61e:	b2db      	uxtb	r3, r3
 800c620:	2003      	movs	r0, #3
 800c622:	4619      	mov	r1, r3
 800c624:	f7ff fc14 	bl	800be50 <_test_assert>
 800c628:	4603      	mov	r3, r0
 800c62a:	2b00      	cmp	r3, #0
 800c62c:	d000      	beq.n	800c630 <thd3_execute+0x80>
 800c62e:	e0b1      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 800c630:	f7ff fe9e 	bl	800c370 <chThdGetPriorityX>
 800c634:	4602      	mov	r2, r0
 800c636:	9b01      	ldr	r3, [sp, #4]
 800c638:	429a      	cmp	r2, r3
 800c63a:	bf14      	ite	ne
 800c63c:	2300      	movne	r3, #0
 800c63e:	2301      	moveq	r3, #1
 800c640:	b2db      	uxtb	r3, r3
 800c642:	2004      	movs	r0, #4
 800c644:	4619      	mov	r1, r3
 800c646:	f7ff fc03 	bl	800be50 <_test_assert>
 800c64a:	4603      	mov	r3, r0
 800c64c:	2b00      	cmp	r3, #0
 800c64e:	d000      	beq.n	800c652 <thd3_execute+0xa2>
 800c650:	e0a0      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
 800c652:	f7ff fe5d 	bl	800c310 <chSysLock>
  chThdGetSelfX()->p_prio += 2;
 800c656:	f7ff fe83 	bl	800c360 <chThdGetSelfX>
 800c65a:	4603      	mov	r3, r0
 800c65c:	689a      	ldr	r2, [r3, #8]
 800c65e:	3202      	adds	r2, #2
 800c660:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 800c662:	f7ff fe5d 	bl	800c320 <chSysUnlock>
  test_assert(5, chThdGetPriorityX() == prio + 2,
 800c666:	f7ff fe83 	bl	800c370 <chThdGetPriorityX>
 800c66a:	4602      	mov	r2, r0
 800c66c:	9b01      	ldr	r3, [sp, #4]
 800c66e:	3302      	adds	r3, #2
 800c670:	429a      	cmp	r2, r3
 800c672:	bf14      	ite	ne
 800c674:	2300      	movne	r3, #0
 800c676:	2301      	moveq	r3, #1
 800c678:	b2db      	uxtb	r3, r3
 800c67a:	2005      	movs	r0, #5
 800c67c:	4619      	mov	r1, r3
 800c67e:	f7ff fbe7 	bl	800be50 <_test_assert>
 800c682:	4603      	mov	r3, r0
 800c684:	2b00      	cmp	r3, #0
 800c686:	d000      	beq.n	800c68a <thd3_execute+0xda>
 800c688:	e084      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 800c68a:	9b01      	ldr	r3, [sp, #4]
 800c68c:	3301      	adds	r3, #1
 800c68e:	4618      	mov	r0, r3
 800c690:	f7f4 fdd6 	bl	8001240 <chThdSetPriority>
 800c694:	9000      	str	r0, [sp, #0]
  test_assert(6, p1 == prio,
 800c696:	9a00      	ldr	r2, [sp, #0]
 800c698:	9b01      	ldr	r3, [sp, #4]
 800c69a:	429a      	cmp	r2, r3
 800c69c:	bf14      	ite	ne
 800c69e:	2300      	movne	r3, #0
 800c6a0:	2301      	moveq	r3, #1
 800c6a2:	b2db      	uxtb	r3, r3
 800c6a4:	2006      	movs	r0, #6
 800c6a6:	4619      	mov	r1, r3
 800c6a8:	f7ff fbd2 	bl	800be50 <_test_assert>
 800c6ac:	4603      	mov	r3, r0
 800c6ae:	2b00      	cmp	r3, #0
 800c6b0:	d000      	beq.n	800c6b4 <thd3_execute+0x104>
 800c6b2:	e06f      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 800c6b4:	f7ff fe54 	bl	800c360 <chThdGetSelfX>
 800c6b8:	4603      	mov	r3, r0
 800c6ba:	689a      	ldr	r2, [r3, #8]
 800c6bc:	9b01      	ldr	r3, [sp, #4]
 800c6be:	3302      	adds	r3, #2
 800c6c0:	429a      	cmp	r2, r3
 800c6c2:	bf14      	ite	ne
 800c6c4:	2300      	movne	r3, #0
 800c6c6:	2301      	moveq	r3, #1
 800c6c8:	b2db      	uxtb	r3, r3
 800c6ca:	2007      	movs	r0, #7
 800c6cc:	4619      	mov	r1, r3
 800c6ce:	f7ff fbbf 	bl	800be50 <_test_assert>
 800c6d2:	4603      	mov	r3, r0
 800c6d4:	2b00      	cmp	r3, #0
 800c6d6:	d000      	beq.n	800c6da <thd3_execute+0x12a>
 800c6d8:	e05c      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 800c6da:	f7ff fe41 	bl	800c360 <chThdGetSelfX>
 800c6de:	4603      	mov	r3, r0
 800c6e0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c6e2:	9b01      	ldr	r3, [sp, #4]
 800c6e4:	3301      	adds	r3, #1
 800c6e6:	429a      	cmp	r2, r3
 800c6e8:	bf14      	ite	ne
 800c6ea:	2300      	movne	r3, #0
 800c6ec:	2301      	moveq	r3, #1
 800c6ee:	b2db      	uxtb	r3, r3
 800c6f0:	2008      	movs	r0, #8
 800c6f2:	4619      	mov	r1, r3
 800c6f4:	f7ff fbac 	bl	800be50 <_test_assert>
 800c6f8:	4603      	mov	r3, r0
 800c6fa:	2b00      	cmp	r3, #0
 800c6fc:	d000      	beq.n	800c700 <thd3_execute+0x150>
 800c6fe:	e049      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 800c700:	9b01      	ldr	r3, [sp, #4]
 800c702:	3303      	adds	r3, #3
 800c704:	4618      	mov	r0, r3
 800c706:	f7f4 fd9b 	bl	8001240 <chThdSetPriority>
 800c70a:	9000      	str	r0, [sp, #0]
  test_assert(9, p1 == prio + 1,
 800c70c:	9b01      	ldr	r3, [sp, #4]
 800c70e:	1c5a      	adds	r2, r3, #1
 800c710:	9b00      	ldr	r3, [sp, #0]
 800c712:	429a      	cmp	r2, r3
 800c714:	bf14      	ite	ne
 800c716:	2300      	movne	r3, #0
 800c718:	2301      	moveq	r3, #1
 800c71a:	b2db      	uxtb	r3, r3
 800c71c:	2009      	movs	r0, #9
 800c71e:	4619      	mov	r1, r3
 800c720:	f7ff fb96 	bl	800be50 <_test_assert>
 800c724:	4603      	mov	r3, r0
 800c726:	2b00      	cmp	r3, #0
 800c728:	d000      	beq.n	800c72c <thd3_execute+0x17c>
 800c72a:	e033      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 800c72c:	f7ff fe18 	bl	800c360 <chThdGetSelfX>
 800c730:	4603      	mov	r3, r0
 800c732:	689a      	ldr	r2, [r3, #8]
 800c734:	9b01      	ldr	r3, [sp, #4]
 800c736:	3303      	adds	r3, #3
 800c738:	429a      	cmp	r2, r3
 800c73a:	bf14      	ite	ne
 800c73c:	2300      	movne	r3, #0
 800c73e:	2301      	moveq	r3, #1
 800c740:	b2db      	uxtb	r3, r3
 800c742:	200a      	movs	r0, #10
 800c744:	4619      	mov	r1, r3
 800c746:	f7ff fb83 	bl	800be50 <_test_assert>
 800c74a:	4603      	mov	r3, r0
 800c74c:	2b00      	cmp	r3, #0
 800c74e:	d000      	beq.n	800c752 <thd3_execute+0x1a2>
 800c750:	e020      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 800c752:	f7ff fe05 	bl	800c360 <chThdGetSelfX>
 800c756:	4603      	mov	r3, r0
 800c758:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c75a:	9b01      	ldr	r3, [sp, #4]
 800c75c:	3303      	adds	r3, #3
 800c75e:	429a      	cmp	r2, r3
 800c760:	bf14      	ite	ne
 800c762:	2300      	movne	r3, #0
 800c764:	2301      	moveq	r3, #1
 800c766:	b2db      	uxtb	r3, r3
 800c768:	200b      	movs	r0, #11
 800c76a:	4619      	mov	r1, r3
 800c76c:	f7ff fb70 	bl	800be50 <_test_assert>
 800c770:	4603      	mov	r3, r0
 800c772:	2b00      	cmp	r3, #0
 800c774:	d000      	beq.n	800c778 <thd3_execute+0x1c8>
 800c776:	e00d      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected real priority level");

  chSysLock();
 800c778:	f7ff fdca 	bl	800c310 <chSysLock>
  chThdGetSelfX()->p_prio = prio;
 800c77c:	f7ff fdf0 	bl	800c360 <chThdGetSelfX>
 800c780:	4603      	mov	r3, r0
 800c782:	9a01      	ldr	r2, [sp, #4]
 800c784:	609a      	str	r2, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 800c786:	f7ff fdeb 	bl	800c360 <chThdGetSelfX>
 800c78a:	4603      	mov	r3, r0
 800c78c:	9a01      	ldr	r2, [sp, #4]
 800c78e:	63da      	str	r2, [r3, #60]	; 0x3c
  chSysUnlock();
 800c790:	f7ff fdc6 	bl	800c320 <chSysUnlock>
#endif
}
 800c794:	b003      	add	sp, #12
 800c796:	f85d fb04 	ldr.w	pc, [sp], #4
 800c79a:	bf00      	nop
 800c79c:	f3af 8000 	nop.w

0800c7a0 <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 800c7a0:	b500      	push	{lr}
 800c7a2:	b083      	sub	sp, #12
  systime_t time;

  test_wait_tick();
 800c7a4:	f7ff fbfc 	bl	800bfa0 <test_wait_tick>

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
 800c7a8:	f7ff fdca 	bl	800c340 <chVTGetSystemTime>
 800c7ac:	9001      	str	r0, [sp, #4]
  chThdSleepMicroseconds(100000);
 800c7ae:	f240 5083 	movw	r0, #1411	; 0x583
 800c7b2:	f7f4 fd8d 	bl	80012d0 <chThdSleep>
  test_assert_time_window(1,
 800c7b6:	9b01      	ldr	r3, [sp, #4]
 800c7b8:	f203 5283 	addw	r2, r3, #1411	; 0x583
 800c7bc:	9b01      	ldr	r3, [sp, #4]
 800c7be:	f203 5384 	addw	r3, r3, #1412	; 0x584
 800c7c2:	2001      	movs	r0, #1
 800c7c4:	4611      	mov	r1, r2
 800c7c6:	461a      	mov	r2, r3
 800c7c8:	f7ff fb8a 	bl	800bee0 <_test_assert_time_window>
 800c7cc:	4603      	mov	r3, r0
 800c7ce:	2b00      	cmp	r3, #0
 800c7d0:	d000      	beq.n	800c7d4 <thd4_execute+0x34>
 800c7d2:	e043      	b.n	800c85c <thd4_execute+0xbc>
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
 800c7d4:	f7ff fdb4 	bl	800c340 <chVTGetSystemTime>
 800c7d8:	9001      	str	r0, [sp, #4]
  chThdSleepMilliseconds(100);
 800c7da:	f242 7010 	movw	r0, #10000	; 0x2710
 800c7de:	f7f4 fd77 	bl	80012d0 <chThdSleep>
  test_assert_time_window(2,
 800c7e2:	9b01      	ldr	r3, [sp, #4]
 800c7e4:	f503 521c 	add.w	r2, r3, #9984	; 0x2700
 800c7e8:	3210      	adds	r2, #16
 800c7ea:	9b01      	ldr	r3, [sp, #4]
 800c7ec:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800c7f0:	3311      	adds	r3, #17
 800c7f2:	2002      	movs	r0, #2
 800c7f4:	4611      	mov	r1, r2
 800c7f6:	461a      	mov	r2, r3
 800c7f8:	f7ff fb72 	bl	800bee0 <_test_assert_time_window>
 800c7fc:	4603      	mov	r3, r0
 800c7fe:	2b00      	cmp	r3, #0
 800c800:	d000      	beq.n	800c804 <thd4_execute+0x64>
 800c802:	e02b      	b.n	800c85c <thd4_execute+0xbc>
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
 800c804:	f7ff fd9c 	bl	800c340 <chVTGetSystemTime>
 800c808:	9001      	str	r0, [sp, #4]
  chThdSleepSeconds(1);
 800c80a:	4816      	ldr	r0, [pc, #88]	; (800c864 <thd4_execute+0xc4>)
 800c80c:	f7f4 fd60 	bl	80012d0 <chThdSleep>
  test_assert_time_window(3,
 800c810:	9b01      	ldr	r3, [sp, #4]
 800c812:	f503 32c3 	add.w	r2, r3, #99840	; 0x18600
 800c816:	32a0      	adds	r2, #160	; 0xa0
 800c818:	9b01      	ldr	r3, [sp, #4]
 800c81a:	f503 33c3 	add.w	r3, r3, #99840	; 0x18600
 800c81e:	33a1      	adds	r3, #161	; 0xa1
 800c820:	2003      	movs	r0, #3
 800c822:	4611      	mov	r1, r2
 800c824:	461a      	mov	r2, r3
 800c826:	f7ff fb5b 	bl	800bee0 <_test_assert_time_window>
 800c82a:	4603      	mov	r3, r0
 800c82c:	2b00      	cmp	r3, #0
 800c82e:	d000      	beq.n	800c832 <thd4_execute+0x92>
 800c830:	e014      	b.n	800c85c <thd4_execute+0xbc>
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 800c832:	f7ff fd85 	bl	800c340 <chVTGetSystemTime>
 800c836:	4603      	mov	r3, r0
 800c838:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800c83c:	3310      	adds	r3, #16
 800c83e:	9301      	str	r3, [sp, #4]
  chThdSleepUntil(time);
 800c840:	9801      	ldr	r0, [sp, #4]
 800c842:	f7f4 fd55 	bl	80012f0 <chThdSleepUntil>
  test_assert_time_window(4,
 800c846:	9b01      	ldr	r3, [sp, #4]
 800c848:	3301      	adds	r3, #1
 800c84a:	2004      	movs	r0, #4
 800c84c:	9901      	ldr	r1, [sp, #4]
 800c84e:	461a      	mov	r2, r3
 800c850:	f7ff fb46 	bl	800bee0 <_test_assert_time_window>
 800c854:	4603      	mov	r3, r0
 800c856:	2b00      	cmp	r3, #0
 800c858:	d000      	beq.n	800c85c <thd4_execute+0xbc>
 800c85a:	bf00      	nop
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 800c85c:	b003      	add	sp, #12
 800c85e:	f85d fb04 	ldr.w	pc, [sp], #4
 800c862:	bf00      	nop
 800c864:	000186a0 	.word	0x000186a0
 800c868:	f3af 8000 	nop.w
 800c86c:	f3af 8000 	nop.w

0800c870 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c870:	b082      	sub	sp, #8
 800c872:	2320      	movs	r3, #32
 800c874:	9301      	str	r3, [sp, #4]
 800c876:	9b01      	ldr	r3, [sp, #4]
 800c878:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c87c:	b002      	add	sp, #8
 800c87e:	4770      	bx	lr

0800c880 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c880:	b082      	sub	sp, #8
 800c882:	2300      	movs	r3, #0
 800c884:	9301      	str	r3, [sp, #4]
 800c886:	9b01      	ldr	r3, [sp, #4]
 800c888:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c88c:	b002      	add	sp, #8
 800c88e:	4770      	bx	lr

0800c890 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800c890:	b082      	sub	sp, #8
 800c892:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800c894:	9b01      	ldr	r3, [sp, #4]
 800c896:	681a      	ldr	r2, [r3, #0]
 800c898:	9b01      	ldr	r3, [sp, #4]
 800c89a:	429a      	cmp	r2, r3
 800c89c:	bf14      	ite	ne
 800c89e:	2300      	movne	r3, #0
 800c8a0:	2301      	moveq	r3, #1
 800c8a2:	b2db      	uxtb	r3, r3
}
 800c8a4:	4618      	mov	r0, r3
 800c8a6:	b002      	add	sp, #8
 800c8a8:	4770      	bx	lr
 800c8aa:	bf00      	nop
 800c8ac:	f3af 8000 	nop.w

0800c8b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c8b0:	b508      	push	{r3, lr}

  port_lock();
 800c8b2:	f7ff ffdd 	bl	800c870 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800c8b6:	bd08      	pop	{r3, pc}
 800c8b8:	f3af 8000 	nop.w
 800c8bc:	f3af 8000 	nop.w

0800c8c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c8c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800c8c2:	f7ff ffdd 	bl	800c880 <port_unlock>
}
 800c8c6:	bd08      	pop	{r3, pc}
 800c8c8:	f3af 8000 	nop.w
 800c8cc:	f3af 8000 	nop.w

0800c8d0 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800c8d0:	4b01      	ldr	r3, [pc, #4]	; (800c8d8 <chVTGetSystemTimeX+0x8>)
 800c8d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c8d4:	4618      	mov	r0, r3
 800c8d6:	4770      	bx	lr
 800c8d8:	200039a8 	.word	0x200039a8
 800c8dc:	f3af 8000 	nop.w

0800c8e0 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800c8e0:	b500      	push	{lr}
 800c8e2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800c8e4:	f7ff ffe4 	bl	800c8b0 <chSysLock>
  systime = chVTGetSystemTimeX();
 800c8e8:	f7ff fff2 	bl	800c8d0 <chVTGetSystemTimeX>
 800c8ec:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800c8ee:	f7ff ffe7 	bl	800c8c0 <chSysUnlock>

  return systime;
 800c8f2:	9b01      	ldr	r3, [sp, #4]
}
 800c8f4:	4618      	mov	r0, r3
 800c8f6:	b003      	add	sp, #12
 800c8f8:	f85d fb04 	ldr.w	pc, [sp], #4
 800c8fc:	f3af 8000 	nop.w

0800c900 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800c900:	4b01      	ldr	r3, [pc, #4]	; (800c908 <chThdGetSelfX+0x8>)
 800c902:	699b      	ldr	r3, [r3, #24]
}
 800c904:	4618      	mov	r0, r3
 800c906:	4770      	bx	lr
 800c908:	200039a8 	.word	0x200039a8
 800c90c:	f3af 8000 	nop.w

0800c910 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800c910:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800c912:	f7ff fff5 	bl	800c900 <chThdGetSelfX>
 800c916:	4603      	mov	r3, r0
 800c918:	689b      	ldr	r3, [r3, #8]
}
 800c91a:	4618      	mov	r0, r3
 800c91c:	bd08      	pop	{r3, pc}
 800c91e:	bf00      	nop

0800c920 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 800c920:	b082      	sub	sp, #8
 800c922:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 800c924:	9b01      	ldr	r3, [sp, #4]
 800c926:	689b      	ldr	r3, [r3, #8]
}
 800c928:	4618      	mov	r0, r3
 800c92a:	b002      	add	sp, #8
 800c92c:	4770      	bx	lr
 800c92e:	bf00      	nop

0800c930 <chBSemObjectInit>:
 *                      - @a true, the initial state is taken.
 *                      .
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {
 800c930:	b500      	push	{lr}
 800c932:	b083      	sub	sp, #12
 800c934:	9001      	str	r0, [sp, #4]
 800c936:	460b      	mov	r3, r1
 800c938:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemObjectInit(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800c93c:	9a01      	ldr	r2, [sp, #4]
 800c93e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c942:	2b00      	cmp	r3, #0
 800c944:	d001      	beq.n	800c94a <chBSemObjectInit+0x1a>
 800c946:	2300      	movs	r3, #0
 800c948:	e000      	b.n	800c94c <chBSemObjectInit+0x1c>
 800c94a:	2301      	movs	r3, #1
 800c94c:	4610      	mov	r0, r2
 800c94e:	4619      	mov	r1, r3
 800c950:	f7f5 f8b6 	bl	8001ac0 <chSemObjectInit>
}
 800c954:	b003      	add	sp, #12
 800c956:	f85d fb04 	ldr.w	pc, [sp], #4
 800c95a:	bf00      	nop
 800c95c:	f3af 8000 	nop.w

0800c960 <chBSemWait>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p bsemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
 800c960:	b500      	push	{lr}
 800c962:	b083      	sub	sp, #12
 800c964:	9001      	str	r0, [sp, #4]

  return chSemWait(&bsp->bs_sem);
 800c966:	9b01      	ldr	r3, [sp, #4]
 800c968:	4618      	mov	r0, r3
 800c96a:	f7f5 f8f1 	bl	8001b50 <chSemWait>
 800c96e:	4603      	mov	r3, r0
}
 800c970:	4618      	mov	r0, r3
 800c972:	b003      	add	sp, #12
 800c974:	f85d fb04 	ldr.w	pc, [sp], #4
 800c978:	f3af 8000 	nop.w
 800c97c:	f3af 8000 	nop.w

0800c980 <chBSemReset>:
 *                      - @a true, the new state is taken.
 *                      .
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {
 800c980:	b500      	push	{lr}
 800c982:	b083      	sub	sp, #12
 800c984:	9001      	str	r0, [sp, #4]
 800c986:	460b      	mov	r3, r1
 800c988:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemReset(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800c98c:	9a01      	ldr	r2, [sp, #4]
 800c98e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c992:	2b00      	cmp	r3, #0
 800c994:	d001      	beq.n	800c99a <chBSemReset+0x1a>
 800c996:	2300      	movs	r3, #0
 800c998:	e000      	b.n	800c99c <chBSemReset+0x1c>
 800c99a:	2301      	movs	r3, #1
 800c99c:	4610      	mov	r0, r2
 800c99e:	4619      	mov	r1, r3
 800c9a0:	f7f5 f89e 	bl	8001ae0 <chSemReset>
}
 800c9a4:	b003      	add	sp, #12
 800c9a6:	f85d fb04 	ldr.w	pc, [sp], #4
 800c9aa:	bf00      	nop
 800c9ac:	f3af 8000 	nop.w

0800c9b0 <chBSemSignalI>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
 800c9b0:	b500      	push	{lr}
 800c9b2:	b083      	sub	sp, #12
 800c9b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 800c9b6:	9b01      	ldr	r3, [sp, #4]
 800c9b8:	689b      	ldr	r3, [r3, #8]
 800c9ba:	2b00      	cmp	r3, #0
 800c9bc:	dc03      	bgt.n	800c9c6 <chBSemSignalI+0x16>
    chSemSignalI(&bsp->bs_sem);
 800c9be:	9b01      	ldr	r3, [sp, #4]
 800c9c0:	4618      	mov	r0, r3
 800c9c2:	f7f5 f965 	bl	8001c90 <chSemSignalI>
  }
}
 800c9c6:	b003      	add	sp, #12
 800c9c8:	f85d fb04 	ldr.w	pc, [sp], #4
 800c9cc:	f3af 8000 	nop.w

0800c9d0 <chBSemSignal>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @api
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {
 800c9d0:	b500      	push	{lr}
 800c9d2:	b083      	sub	sp, #12
 800c9d4:	9001      	str	r0, [sp, #4]

  chSysLock();
 800c9d6:	f7ff ff6b 	bl	800c8b0 <chSysLock>
  chBSemSignalI(bsp);
 800c9da:	9801      	ldr	r0, [sp, #4]
 800c9dc:	f7ff ffe8 	bl	800c9b0 <chBSemSignalI>
  chSchRescheduleS();
 800c9e0:	f7f4 f9ce 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800c9e4:	f7ff ff6c 	bl	800c8c0 <chSysUnlock>
}
 800c9e8:	b003      	add	sp, #12
 800c9ea:	f85d fb04 	ldr.w	pc, [sp], #4
 800c9ee:	bf00      	nop

0800c9f0 <chBSemGetStateI>:
 * @retval false        if the binary semaphore is not taken.
 * @retval true         if the binary semaphore is taken.
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {
 800c9f0:	b082      	sub	sp, #8
 800c9f2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 800c9f4:	9b01      	ldr	r3, [sp, #4]
 800c9f6:	689b      	ldr	r3, [r3, #8]
 800c9f8:	2b00      	cmp	r3, #0
 800c9fa:	bfcc      	ite	gt
 800c9fc:	2300      	movgt	r3, #0
 800c9fe:	2301      	movle	r3, #1
 800ca00:	b2db      	uxtb	r3, r3
}
 800ca02:	4618      	mov	r0, r3
 800ca04:	b002      	add	sp, #8
 800ca06:	4770      	bx	lr
 800ca08:	f3af 8000 	nop.w
 800ca0c:	f3af 8000 	nop.w

0800ca10 <sem1_setup>:
 * The test expects that the threads reach their goal in FIFO order or
 * priority order depending on the CH_CFG_USE_SEMAPHORES_PRIORITY configuration
 * setting.
 */

static void sem1_setup(void) {
 800ca10:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800ca12:	4802      	ldr	r0, [pc, #8]	; (800ca1c <sem1_setup+0xc>)
 800ca14:	2100      	movs	r1, #0
 800ca16:	f7f5 f853 	bl	8001ac0 <chSemObjectInit>
}
 800ca1a:	bd08      	pop	{r3, pc}
 800ca1c:	20000838 	.word	0x20000838

0800ca20 <thread1>:

static THD_FUNCTION(thread1, p) {
 800ca20:	b500      	push	{lr}
 800ca22:	b083      	sub	sp, #12
 800ca24:	9001      	str	r0, [sp, #4]

  chSemWait(&sem1);
 800ca26:	4805      	ldr	r0, [pc, #20]	; (800ca3c <thread1+0x1c>)
 800ca28:	f7f5 f892 	bl	8001b50 <chSemWait>
  test_emit_token(*(char *)p);
 800ca2c:	9b01      	ldr	r3, [sp, #4]
 800ca2e:	781b      	ldrb	r3, [r3, #0]
 800ca30:	4618      	mov	r0, r3
 800ca32:	f7ff f9dd 	bl	800bdf0 <test_emit_token>
}
 800ca36:	b003      	add	sp, #12
 800ca38:	f85d fb04 	ldr.w	pc, [sp], #4
 800ca3c:	20000838 	.word	0x20000838

0800ca40 <sem1_execute>:

static void sem1_execute(void) {
 800ca40:	b510      	push	{r4, lr}
 800ca42:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800ca44:	4b54      	ldr	r3, [pc, #336]	; (800cb98 <sem1_execute+0x158>)
 800ca46:	681c      	ldr	r4, [r3, #0]
 800ca48:	f7ff ff62 	bl	800c910 <chThdGetPriorityX>
 800ca4c:	4603      	mov	r3, r0
 800ca4e:	3305      	adds	r3, #5
 800ca50:	4a52      	ldr	r2, [pc, #328]	; (800cb9c <sem1_execute+0x15c>)
 800ca52:	9200      	str	r2, [sp, #0]
 800ca54:	4620      	mov	r0, r4
 800ca56:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ca5a:	461a      	mov	r2, r3
 800ca5c:	4b50      	ldr	r3, [pc, #320]	; (800cba0 <sem1_execute+0x160>)
 800ca5e:	f7f4 fbbf 	bl	80011e0 <chThdCreateStatic>
 800ca62:	4602      	mov	r2, r0
 800ca64:	4b4f      	ldr	r3, [pc, #316]	; (800cba4 <sem1_execute+0x164>)
 800ca66:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800ca68:	4b4b      	ldr	r3, [pc, #300]	; (800cb98 <sem1_execute+0x158>)
 800ca6a:	685c      	ldr	r4, [r3, #4]
 800ca6c:	f7ff ff50 	bl	800c910 <chThdGetPriorityX>
 800ca70:	4603      	mov	r3, r0
 800ca72:	3301      	adds	r3, #1
 800ca74:	4a4c      	ldr	r2, [pc, #304]	; (800cba8 <sem1_execute+0x168>)
 800ca76:	9200      	str	r2, [sp, #0]
 800ca78:	4620      	mov	r0, r4
 800ca7a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ca7e:	461a      	mov	r2, r3
 800ca80:	4b47      	ldr	r3, [pc, #284]	; (800cba0 <sem1_execute+0x160>)
 800ca82:	f7f4 fbad 	bl	80011e0 <chThdCreateStatic>
 800ca86:	4602      	mov	r2, r0
 800ca88:	4b46      	ldr	r3, [pc, #280]	; (800cba4 <sem1_execute+0x164>)
 800ca8a:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800ca8c:	4b42      	ldr	r3, [pc, #264]	; (800cb98 <sem1_execute+0x158>)
 800ca8e:	689c      	ldr	r4, [r3, #8]
 800ca90:	f7ff ff3e 	bl	800c910 <chThdGetPriorityX>
 800ca94:	4603      	mov	r3, r0
 800ca96:	3303      	adds	r3, #3
 800ca98:	4a44      	ldr	r2, [pc, #272]	; (800cbac <sem1_execute+0x16c>)
 800ca9a:	9200      	str	r2, [sp, #0]
 800ca9c:	4620      	mov	r0, r4
 800ca9e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800caa2:	461a      	mov	r2, r3
 800caa4:	4b3e      	ldr	r3, [pc, #248]	; (800cba0 <sem1_execute+0x160>)
 800caa6:	f7f4 fb9b 	bl	80011e0 <chThdCreateStatic>
 800caaa:	4602      	mov	r2, r0
 800caac:	4b3d      	ldr	r3, [pc, #244]	; (800cba4 <sem1_execute+0x164>)
 800caae:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800cab0:	4b39      	ldr	r3, [pc, #228]	; (800cb98 <sem1_execute+0x158>)
 800cab2:	68dc      	ldr	r4, [r3, #12]
 800cab4:	f7ff ff2c 	bl	800c910 <chThdGetPriorityX>
 800cab8:	4603      	mov	r3, r0
 800caba:	3304      	adds	r3, #4
 800cabc:	4a3c      	ldr	r2, [pc, #240]	; (800cbb0 <sem1_execute+0x170>)
 800cabe:	9200      	str	r2, [sp, #0]
 800cac0:	4620      	mov	r0, r4
 800cac2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cac6:	461a      	mov	r2, r3
 800cac8:	4b35      	ldr	r3, [pc, #212]	; (800cba0 <sem1_execute+0x160>)
 800caca:	f7f4 fb89 	bl	80011e0 <chThdCreateStatic>
 800cace:	4602      	mov	r2, r0
 800cad0:	4b34      	ldr	r3, [pc, #208]	; (800cba4 <sem1_execute+0x164>)
 800cad2:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800cad4:	4b30      	ldr	r3, [pc, #192]	; (800cb98 <sem1_execute+0x158>)
 800cad6:	691c      	ldr	r4, [r3, #16]
 800cad8:	f7ff ff1a 	bl	800c910 <chThdGetPriorityX>
 800cadc:	4603      	mov	r3, r0
 800cade:	3302      	adds	r3, #2
 800cae0:	4a34      	ldr	r2, [pc, #208]	; (800cbb4 <sem1_execute+0x174>)
 800cae2:	9200      	str	r2, [sp, #0]
 800cae4:	4620      	mov	r0, r4
 800cae6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800caea:	461a      	mov	r2, r3
 800caec:	4b2c      	ldr	r3, [pc, #176]	; (800cba0 <sem1_execute+0x160>)
 800caee:	f7f4 fb77 	bl	80011e0 <chThdCreateStatic>
 800caf2:	4602      	mov	r2, r0
 800caf4:	4b2b      	ldr	r3, [pc, #172]	; (800cba4 <sem1_execute+0x164>)
 800caf6:	611a      	str	r2, [r3, #16]
  chSemSignal(&sem1);
 800caf8:	482f      	ldr	r0, [pc, #188]	; (800cbb8 <sem1_execute+0x178>)
 800cafa:	f7f5 f8a9 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cafe:	482e      	ldr	r0, [pc, #184]	; (800cbb8 <sem1_execute+0x178>)
 800cb00:	f7f5 f8a6 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cb04:	482c      	ldr	r0, [pc, #176]	; (800cbb8 <sem1_execute+0x178>)
 800cb06:	f7f5 f8a3 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cb0a:	482b      	ldr	r0, [pc, #172]	; (800cbb8 <sem1_execute+0x178>)
 800cb0c:	f7f5 f8a0 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cb10:	4829      	ldr	r0, [pc, #164]	; (800cbb8 <sem1_execute+0x178>)
 800cb12:	f7f5 f89d 	bl	8001c50 <chSemSignal>
  test_wait_threads();
 800cb16:	f7ff fa1b 	bl	800bf50 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 800cb1a:	2001      	movs	r0, #1
 800cb1c:	4927      	ldr	r1, [pc, #156]	; (800cbbc <sem1_execute+0x17c>)
 800cb1e:	f7ff f9af 	bl	800be80 <_test_assert_sequence>
 800cb22:	4603      	mov	r3, r0
 800cb24:	2b00      	cmp	r3, #0
 800cb26:	d000      	beq.n	800cb2a <sem1_execute+0xea>
 800cb28:	e034      	b.n	800cb94 <sem1_execute+0x154>
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800cb2a:	4b1b      	ldr	r3, [pc, #108]	; (800cb98 <sem1_execute+0x158>)
 800cb2c:	681c      	ldr	r4, [r3, #0]
 800cb2e:	f7ff feef 	bl	800c910 <chThdGetPriorityX>
 800cb32:	4603      	mov	r3, r0
 800cb34:	3305      	adds	r3, #5
 800cb36:	4a19      	ldr	r2, [pc, #100]	; (800cb9c <sem1_execute+0x15c>)
 800cb38:	9200      	str	r2, [sp, #0]
 800cb3a:	4620      	mov	r0, r4
 800cb3c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cb40:	461a      	mov	r2, r3
 800cb42:	4b17      	ldr	r3, [pc, #92]	; (800cba0 <sem1_execute+0x160>)
 800cb44:	f7f4 fb4c 	bl	80011e0 <chThdCreateStatic>
 800cb48:	4602      	mov	r2, r0
 800cb4a:	4b16      	ldr	r3, [pc, #88]	; (800cba4 <sem1_execute+0x164>)
 800cb4c:	601a      	str	r2, [r3, #0]
  chSysLock();
 800cb4e:	f7ff feaf 	bl	800c8b0 <chSysLock>
  chSemAddCounterI(&sem1, 2);
 800cb52:	4819      	ldr	r0, [pc, #100]	; (800cbb8 <sem1_execute+0x178>)
 800cb54:	2102      	movs	r1, #2
 800cb56:	f7f5 f8bb 	bl	8001cd0 <chSemAddCounterI>
  chSchRescheduleS();
 800cb5a:	f7f4 f911 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800cb5e:	f7ff feaf 	bl	800c8c0 <chSysUnlock>
  test_wait_threads();
 800cb62:	f7ff f9f5 	bl	800bf50 <test_wait_threads>
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 800cb66:	f7ff fea3 	bl	800c8b0 <chSysLock>
 800cb6a:	4813      	ldr	r0, [pc, #76]	; (800cbb8 <sem1_execute+0x178>)
 800cb6c:	f7ff fed8 	bl	800c920 <chSemGetCounterI>
 800cb70:	4603      	mov	r3, r0
 800cb72:	2b01      	cmp	r3, #1
 800cb74:	bf14      	ite	ne
 800cb76:	2300      	movne	r3, #0
 800cb78:	2301      	moveq	r3, #1
 800cb7a:	b2db      	uxtb	r3, r3
 800cb7c:	2002      	movs	r0, #2
 800cb7e:	4619      	mov	r1, r3
 800cb80:	f7ff f966 	bl	800be50 <_test_assert>
 800cb84:	4603      	mov	r3, r0
 800cb86:	2b00      	cmp	r3, #0
 800cb88:	d002      	beq.n	800cb90 <sem1_execute+0x150>
 800cb8a:	f7ff fe99 	bl	800c8c0 <chSysUnlock>
 800cb8e:	e001      	b.n	800cb94 <sem1_execute+0x154>
 800cb90:	f7ff fe96 	bl	800c8c0 <chSysUnlock>
}
 800cb94:	b002      	add	sp, #8
 800cb96:	bd10      	pop	{r4, pc}
 800cb98:	0801ad70 	.word	0x0801ad70
 800cb9c:	0801b060 	.word	0x0801b060
 800cba0:	0800ca21 	.word	0x0800ca21
 800cba4:	20003e3c 	.word	0x20003e3c
 800cba8:	0801b064 	.word	0x0801b064
 800cbac:	0801b068 	.word	0x0801b068
 800cbb0:	0801b06c 	.word	0x0801b06c
 800cbb4:	0801b070 	.word	0x0801b070
 800cbb8:	20000838 	.word	0x20000838
 800cbbc:	0801b074 	.word	0x0801b074

0800cbc0 <sem2_setup>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem2_setup(void) {
 800cbc0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800cbc2:	4802      	ldr	r0, [pc, #8]	; (800cbcc <sem2_setup+0xc>)
 800cbc4:	2100      	movs	r1, #0
 800cbc6:	f7f4 ff7b 	bl	8001ac0 <chSemObjectInit>
}
 800cbca:	bd08      	pop	{r3, pc}
 800cbcc:	20000838 	.word	0x20000838

0800cbd0 <thread2>:

static THD_FUNCTION(thread2, p) {
 800cbd0:	b500      	push	{lr}
 800cbd2:	b083      	sub	sp, #12
 800cbd4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 800cbd6:	f241 3088 	movw	r0, #5000	; 0x1388
 800cbda:	f7f4 fb79 	bl	80012d0 <chThdSleep>
  chSysLock();
 800cbde:	f7ff fe67 	bl	800c8b0 <chSysLock>
  chSemSignalI(&sem1); /* For coverage reasons */
 800cbe2:	4805      	ldr	r0, [pc, #20]	; (800cbf8 <thread2+0x28>)
 800cbe4:	f7f5 f854 	bl	8001c90 <chSemSignalI>
  chSchRescheduleS();
 800cbe8:	f7f4 f8ca 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800cbec:	f7ff fe68 	bl	800c8c0 <chSysUnlock>
}
 800cbf0:	b003      	add	sp, #12
 800cbf2:	f85d fb04 	ldr.w	pc, [sp], #4
 800cbf6:	bf00      	nop
 800cbf8:	20000838 	.word	0x20000838
 800cbfc:	f3af 8000 	nop.w

0800cc00 <sem2_execute>:

static void sem2_execute(void) {
 800cc00:	b510      	push	{r4, lr}
 800cc02:	b086      	sub	sp, #24
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 800cc04:	4867      	ldr	r0, [pc, #412]	; (800cda4 <sem2_execute+0x1a4>)
 800cc06:	2100      	movs	r1, #0
 800cc08:	f7f4 ffda 	bl	8001bc0 <chSemWaitTimeout>
 800cc0c:	9004      	str	r0, [sp, #16]
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 800cc0e:	9b04      	ldr	r3, [sp, #16]
 800cc10:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cc14:	bf14      	ite	ne
 800cc16:	2300      	movne	r3, #0
 800cc18:	2301      	moveq	r3, #1
 800cc1a:	b2db      	uxtb	r3, r3
 800cc1c:	2001      	movs	r0, #1
 800cc1e:	4619      	mov	r1, r3
 800cc20:	f7ff f916 	bl	800be50 <_test_assert>
 800cc24:	4603      	mov	r3, r0
 800cc26:	2b00      	cmp	r3, #0
 800cc28:	d000      	beq.n	800cc2c <sem2_execute+0x2c>
 800cc2a:	e0b9      	b.n	800cda0 <sem2_execute+0x1a0>
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 800cc2c:	485d      	ldr	r0, [pc, #372]	; (800cda4 <sem2_execute+0x1a4>)
 800cc2e:	f7ff fe2f 	bl	800c890 <queue_isempty>
 800cc32:	4603      	mov	r3, r0
 800cc34:	2002      	movs	r0, #2
 800cc36:	4619      	mov	r1, r3
 800cc38:	f7ff f90a 	bl	800be50 <_test_assert>
 800cc3c:	4603      	mov	r3, r0
 800cc3e:	2b00      	cmp	r3, #0
 800cc40:	d000      	beq.n	800cc44 <sem2_execute+0x44>
 800cc42:	e0ad      	b.n	800cda0 <sem2_execute+0x1a0>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 800cc44:	4b57      	ldr	r3, [pc, #348]	; (800cda4 <sem2_execute+0x1a4>)
 800cc46:	689b      	ldr	r3, [r3, #8]
 800cc48:	2b00      	cmp	r3, #0
 800cc4a:	bf14      	ite	ne
 800cc4c:	2300      	movne	r3, #0
 800cc4e:	2301      	moveq	r3, #1
 800cc50:	b2db      	uxtb	r3, r3
 800cc52:	2003      	movs	r0, #3
 800cc54:	4619      	mov	r1, r3
 800cc56:	f7ff f8fb 	bl	800be50 <_test_assert>
 800cc5a:	4603      	mov	r3, r0
 800cc5c:	2b00      	cmp	r3, #0
 800cc5e:	d000      	beq.n	800cc62 <sem2_execute+0x62>
 800cc60:	e09e      	b.n	800cda0 <sem2_execute+0x1a0>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800cc62:	4b51      	ldr	r3, [pc, #324]	; (800cda8 <sem2_execute+0x1a8>)
 800cc64:	681c      	ldr	r4, [r3, #0]
 800cc66:	f7ff fe53 	bl	800c910 <chThdGetPriorityX>
 800cc6a:	4603      	mov	r3, r0
 800cc6c:	3b01      	subs	r3, #1
 800cc6e:	2200      	movs	r2, #0
 800cc70:	9200      	str	r2, [sp, #0]
 800cc72:	4620      	mov	r0, r4
 800cc74:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cc78:	461a      	mov	r2, r3
 800cc7a:	4b4c      	ldr	r3, [pc, #304]	; (800cdac <sem2_execute+0x1ac>)
 800cc7c:	f7f4 fab0 	bl	80011e0 <chThdCreateStatic>
 800cc80:	4602      	mov	r2, r0
 800cc82:	4b4b      	ldr	r3, [pc, #300]	; (800cdb0 <sem2_execute+0x1b0>)
 800cc84:	601a      	str	r2, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 800cc86:	4847      	ldr	r0, [pc, #284]	; (800cda4 <sem2_execute+0x1a4>)
 800cc88:	f24c 3150 	movw	r1, #50000	; 0xc350
 800cc8c:	f7f4 ff98 	bl	8001bc0 <chSemWaitTimeout>
 800cc90:	9004      	str	r0, [sp, #16]
  test_wait_threads();
 800cc92:	f7ff f95d 	bl	800bf50 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 800cc96:	9b04      	ldr	r3, [sp, #16]
 800cc98:	2b00      	cmp	r3, #0
 800cc9a:	bf14      	ite	ne
 800cc9c:	2300      	movne	r3, #0
 800cc9e:	2301      	moveq	r3, #1
 800cca0:	b2db      	uxtb	r3, r3
 800cca2:	2004      	movs	r0, #4
 800cca4:	4619      	mov	r1, r3
 800cca6:	f7ff f8d3 	bl	800be50 <_test_assert>
 800ccaa:	4603      	mov	r3, r0
 800ccac:	2b00      	cmp	r3, #0
 800ccae:	d000      	beq.n	800ccb2 <sem2_execute+0xb2>
 800ccb0:	e076      	b.n	800cda0 <sem2_execute+0x1a0>
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 800ccb2:	483c      	ldr	r0, [pc, #240]	; (800cda4 <sem2_execute+0x1a4>)
 800ccb4:	f7ff fdec 	bl	800c890 <queue_isempty>
 800ccb8:	4603      	mov	r3, r0
 800ccba:	2005      	movs	r0, #5
 800ccbc:	4619      	mov	r1, r3
 800ccbe:	f7ff f8c7 	bl	800be50 <_test_assert>
 800ccc2:	4603      	mov	r3, r0
 800ccc4:	2b00      	cmp	r3, #0
 800ccc6:	d000      	beq.n	800ccca <sem2_execute+0xca>
 800ccc8:	e06a      	b.n	800cda0 <sem2_execute+0x1a0>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 800ccca:	4b36      	ldr	r3, [pc, #216]	; (800cda4 <sem2_execute+0x1a4>)
 800cccc:	689b      	ldr	r3, [r3, #8]
 800ccce:	2b00      	cmp	r3, #0
 800ccd0:	bf14      	ite	ne
 800ccd2:	2300      	movne	r3, #0
 800ccd4:	2301      	moveq	r3, #1
 800ccd6:	b2db      	uxtb	r3, r3
 800ccd8:	2006      	movs	r0, #6
 800ccda:	4619      	mov	r1, r3
 800ccdc:	f7ff f8b8 	bl	800be50 <_test_assert>
 800cce0:	4603      	mov	r3, r0
 800cce2:	2b00      	cmp	r3, #0
 800cce4:	d000      	beq.n	800cce8 <sem2_execute+0xe8>
 800cce6:	e05b      	b.n	800cda0 <sem2_execute+0x1a0>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 800cce8:	f7ff f95a 	bl	800bfa0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 800ccec:	f7ff fdf8 	bl	800c8e0 <chVTGetSystemTime>
 800ccf0:	4603      	mov	r3, r0
 800ccf2:	f503 43c3 	add.w	r3, r3, #24960	; 0x6180
 800ccf6:	3328      	adds	r3, #40	; 0x28
 800ccf8:	9303      	str	r3, [sp, #12]
  for (i = 0; i < 5; i++) {
 800ccfa:	2300      	movs	r3, #0
 800ccfc:	9305      	str	r3, [sp, #20]
 800ccfe:	e039      	b.n	800cd74 <sem2_execute+0x174>
    test_emit_token('A' + i);
 800cd00:	9b05      	ldr	r3, [sp, #20]
 800cd02:	b2db      	uxtb	r3, r3
 800cd04:	3341      	adds	r3, #65	; 0x41
 800cd06:	b2db      	uxtb	r3, r3
 800cd08:	4618      	mov	r0, r3
 800cd0a:	f7ff f871 	bl	800bdf0 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 800cd0e:	4825      	ldr	r0, [pc, #148]	; (800cda4 <sem2_execute+0x1a4>)
 800cd10:	f241 3188 	movw	r1, #5000	; 0x1388
 800cd14:	f7f4 ff54 	bl	8001bc0 <chSemWaitTimeout>
 800cd18:	9004      	str	r0, [sp, #16]
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 800cd1a:	9b04      	ldr	r3, [sp, #16]
 800cd1c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cd20:	bf14      	ite	ne
 800cd22:	2300      	movne	r3, #0
 800cd24:	2301      	moveq	r3, #1
 800cd26:	b2db      	uxtb	r3, r3
 800cd28:	2007      	movs	r0, #7
 800cd2a:	4619      	mov	r1, r3
 800cd2c:	f7ff f890 	bl	800be50 <_test_assert>
 800cd30:	4603      	mov	r3, r0
 800cd32:	2b00      	cmp	r3, #0
 800cd34:	d000      	beq.n	800cd38 <sem2_execute+0x138>
 800cd36:	e033      	b.n	800cda0 <sem2_execute+0x1a0>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 800cd38:	481a      	ldr	r0, [pc, #104]	; (800cda4 <sem2_execute+0x1a4>)
 800cd3a:	f7ff fda9 	bl	800c890 <queue_isempty>
 800cd3e:	4603      	mov	r3, r0
 800cd40:	2008      	movs	r0, #8
 800cd42:	4619      	mov	r1, r3
 800cd44:	f7ff f884 	bl	800be50 <_test_assert>
 800cd48:	4603      	mov	r3, r0
 800cd4a:	2b00      	cmp	r3, #0
 800cd4c:	d000      	beq.n	800cd50 <sem2_execute+0x150>
 800cd4e:	e027      	b.n	800cda0 <sem2_execute+0x1a0>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 800cd50:	4b14      	ldr	r3, [pc, #80]	; (800cda4 <sem2_execute+0x1a4>)
 800cd52:	689b      	ldr	r3, [r3, #8]
 800cd54:	2b00      	cmp	r3, #0
 800cd56:	bf14      	ite	ne
 800cd58:	2300      	movne	r3, #0
 800cd5a:	2301      	moveq	r3, #1
 800cd5c:	b2db      	uxtb	r3, r3
 800cd5e:	2009      	movs	r0, #9
 800cd60:	4619      	mov	r1, r3
 800cd62:	f7ff f875 	bl	800be50 <_test_assert>
 800cd66:	4603      	mov	r3, r0
 800cd68:	2b00      	cmp	r3, #0
 800cd6a:	d000      	beq.n	800cd6e <sem2_execute+0x16e>
 800cd6c:	e018      	b.n	800cda0 <sem2_execute+0x1a0>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 800cd6e:	9b05      	ldr	r3, [sp, #20]
 800cd70:	3301      	adds	r3, #1
 800cd72:	9305      	str	r3, [sp, #20]
 800cd74:	9b05      	ldr	r3, [sp, #20]
 800cd76:	2b04      	cmp	r3, #4
 800cd78:	ddc2      	ble.n	800cd00 <sem2_execute+0x100>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 800cd7a:	200a      	movs	r0, #10
 800cd7c:	490d      	ldr	r1, [pc, #52]	; (800cdb4 <sem2_execute+0x1b4>)
 800cd7e:	f7ff f87f 	bl	800be80 <_test_assert_sequence>
 800cd82:	4603      	mov	r3, r0
 800cd84:	2b00      	cmp	r3, #0
 800cd86:	d000      	beq.n	800cd8a <sem2_execute+0x18a>
 800cd88:	e00a      	b.n	800cda0 <sem2_execute+0x1a0>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 800cd8a:	9b03      	ldr	r3, [sp, #12]
 800cd8c:	33c8      	adds	r3, #200	; 0xc8
 800cd8e:	200b      	movs	r0, #11
 800cd90:	9903      	ldr	r1, [sp, #12]
 800cd92:	461a      	mov	r2, r3
 800cd94:	f7ff f8a4 	bl	800bee0 <_test_assert_time_window>
 800cd98:	4603      	mov	r3, r0
 800cd9a:	2b00      	cmp	r3, #0
 800cd9c:	d000      	beq.n	800cda0 <sem2_execute+0x1a0>
 800cd9e:	bf00      	nop
}
 800cda0:	b006      	add	sp, #24
 800cda2:	bd10      	pop	{r4, pc}
 800cda4:	20000838 	.word	0x20000838
 800cda8:	0801ad70 	.word	0x0801ad70
 800cdac:	0800cbd1 	.word	0x0800cbd1
 800cdb0:	20003e3c 	.word	0x20003e3c
 800cdb4:	0801b074 	.word	0x0801b074
 800cdb8:	f3af 8000 	nop.w
 800cdbc:	f3af 8000 	nop.w

0800cdc0 <sem3_setup>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem3_setup(void) {
 800cdc0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800cdc2:	4802      	ldr	r0, [pc, #8]	; (800cdcc <sem3_setup+0xc>)
 800cdc4:	2100      	movs	r1, #0
 800cdc6:	f7f4 fe7b 	bl	8001ac0 <chSemObjectInit>
}
 800cdca:	bd08      	pop	{r3, pc}
 800cdcc:	20000838 	.word	0x20000838

0800cdd0 <thread3>:

static THD_FUNCTION(thread3, p) {
 800cdd0:	b500      	push	{lr}
 800cdd2:	b083      	sub	sp, #12
 800cdd4:	9001      	str	r0, [sp, #4]

  (void)p;
  chSemWait(&sem1);
 800cdd6:	4804      	ldr	r0, [pc, #16]	; (800cde8 <thread3+0x18>)
 800cdd8:	f7f4 feba 	bl	8001b50 <chSemWait>
  chSemSignal(&sem1);
 800cddc:	4802      	ldr	r0, [pc, #8]	; (800cde8 <thread3+0x18>)
 800cdde:	f7f4 ff37 	bl	8001c50 <chSemSignal>
}
 800cde2:	b003      	add	sp, #12
 800cde4:	f85d fb04 	ldr.w	pc, [sp], #4
 800cde8:	20000838 	.word	0x20000838
 800cdec:	f3af 8000 	nop.w

0800cdf0 <sem3_execute>:

static void sem3_execute(void) {
 800cdf0:	b510      	push	{r4, lr}
 800cdf2:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800cdf4:	4b28      	ldr	r3, [pc, #160]	; (800ce98 <sem3_execute+0xa8>)
 800cdf6:	681c      	ldr	r4, [r3, #0]
 800cdf8:	f7ff fd8a 	bl	800c910 <chThdGetPriorityX>
 800cdfc:	4603      	mov	r3, r0
 800cdfe:	3301      	adds	r3, #1
 800ce00:	2200      	movs	r2, #0
 800ce02:	9200      	str	r2, [sp, #0]
 800ce04:	4620      	mov	r0, r4
 800ce06:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ce0a:	461a      	mov	r2, r3
 800ce0c:	4b23      	ldr	r3, [pc, #140]	; (800ce9c <sem3_execute+0xac>)
 800ce0e:	f7f4 f9e7 	bl	80011e0 <chThdCreateStatic>
 800ce12:	4602      	mov	r2, r0
 800ce14:	4b22      	ldr	r3, [pc, #136]	; (800cea0 <sem3_execute+0xb0>)
 800ce16:	601a      	str	r2, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 800ce18:	4822      	ldr	r0, [pc, #136]	; (800cea4 <sem3_execute+0xb4>)
 800ce1a:	4922      	ldr	r1, [pc, #136]	; (800cea4 <sem3_execute+0xb4>)
 800ce1c:	f7f4 ff80 	bl	8001d20 <chSemSignalWait>
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 800ce20:	4820      	ldr	r0, [pc, #128]	; (800cea4 <sem3_execute+0xb4>)
 800ce22:	f7ff fd35 	bl	800c890 <queue_isempty>
 800ce26:	4603      	mov	r3, r0
 800ce28:	2001      	movs	r0, #1
 800ce2a:	4619      	mov	r1, r3
 800ce2c:	f7ff f810 	bl	800be50 <_test_assert>
 800ce30:	4603      	mov	r3, r0
 800ce32:	2b00      	cmp	r3, #0
 800ce34:	d000      	beq.n	800ce38 <sem3_execute+0x48>
 800ce36:	e02d      	b.n	800ce94 <sem3_execute+0xa4>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 800ce38:	4b1a      	ldr	r3, [pc, #104]	; (800cea4 <sem3_execute+0xb4>)
 800ce3a:	689b      	ldr	r3, [r3, #8]
 800ce3c:	2b00      	cmp	r3, #0
 800ce3e:	bf14      	ite	ne
 800ce40:	2300      	movne	r3, #0
 800ce42:	2301      	moveq	r3, #1
 800ce44:	b2db      	uxtb	r3, r3
 800ce46:	2002      	movs	r0, #2
 800ce48:	4619      	mov	r1, r3
 800ce4a:	f7ff f801 	bl	800be50 <_test_assert>
 800ce4e:	4603      	mov	r3, r0
 800ce50:	2b00      	cmp	r3, #0
 800ce52:	d000      	beq.n	800ce56 <sem3_execute+0x66>
 800ce54:	e01e      	b.n	800ce94 <sem3_execute+0xa4>

  chSemSignalWait(&sem1, &sem1);
 800ce56:	4813      	ldr	r0, [pc, #76]	; (800cea4 <sem3_execute+0xb4>)
 800ce58:	4912      	ldr	r1, [pc, #72]	; (800cea4 <sem3_execute+0xb4>)
 800ce5a:	f7f4 ff61 	bl	8001d20 <chSemSignalWait>
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 800ce5e:	4811      	ldr	r0, [pc, #68]	; (800cea4 <sem3_execute+0xb4>)
 800ce60:	f7ff fd16 	bl	800c890 <queue_isempty>
 800ce64:	4603      	mov	r3, r0
 800ce66:	2003      	movs	r0, #3
 800ce68:	4619      	mov	r1, r3
 800ce6a:	f7fe fff1 	bl	800be50 <_test_assert>
 800ce6e:	4603      	mov	r3, r0
 800ce70:	2b00      	cmp	r3, #0
 800ce72:	d000      	beq.n	800ce76 <sem3_execute+0x86>
 800ce74:	e00e      	b.n	800ce94 <sem3_execute+0xa4>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 800ce76:	4b0b      	ldr	r3, [pc, #44]	; (800cea4 <sem3_execute+0xb4>)
 800ce78:	689b      	ldr	r3, [r3, #8]
 800ce7a:	2b00      	cmp	r3, #0
 800ce7c:	bf14      	ite	ne
 800ce7e:	2300      	movne	r3, #0
 800ce80:	2301      	moveq	r3, #1
 800ce82:	b2db      	uxtb	r3, r3
 800ce84:	2004      	movs	r0, #4
 800ce86:	4619      	mov	r1, r3
 800ce88:	f7fe ffe2 	bl	800be50 <_test_assert>
 800ce8c:	4603      	mov	r3, r0
 800ce8e:	2b00      	cmp	r3, #0
 800ce90:	d000      	beq.n	800ce94 <sem3_execute+0xa4>
 800ce92:	bf00      	nop
}
 800ce94:	b002      	add	sp, #8
 800ce96:	bd10      	pop	{r4, pc}
 800ce98:	0801ad70 	.word	0x0801ad70
 800ce9c:	0800cdd1 	.word	0x0800cdd1
 800cea0:	20003e3c 	.word	0x20003e3c
 800cea4:	20000838 	.word	0x20000838
 800cea8:	f3af 8000 	nop.w
 800ceac:	f3af 8000 	nop.w

0800ceb0 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 800ceb0:	b500      	push	{lr}
 800ceb2:	b083      	sub	sp, #12
 800ceb4:	9001      	str	r0, [sp, #4]

  chBSemSignal((binary_semaphore_t *)p);
 800ceb6:	9801      	ldr	r0, [sp, #4]
 800ceb8:	f7ff fd8a 	bl	800c9d0 <chBSemSignal>
}
 800cebc:	b003      	add	sp, #12
 800cebe:	f85d fb04 	ldr.w	pc, [sp], #4
 800cec2:	bf00      	nop
 800cec4:	f3af 8000 	nop.w
 800cec8:	f3af 8000 	nop.w
 800cecc:	f3af 8000 	nop.w

0800ced0 <sem4_execute>:

static void sem4_execute(void) {
 800ced0:	b510      	push	{r4, lr}
 800ced2:	b086      	sub	sp, #24
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
 800ced4:	ab03      	add	r3, sp, #12
 800ced6:	4618      	mov	r0, r3
 800ced8:	2101      	movs	r1, #1
 800ceda:	f7ff fd29 	bl	800c930 <chBSemObjectInit>
  chBSemReset(&bsem, TRUE);
 800cede:	ab03      	add	r3, sp, #12
 800cee0:	4618      	mov	r0, r3
 800cee2:	2101      	movs	r1, #1
 800cee4:	f7ff fd4c 	bl	800c980 <chBSemReset>
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800cee8:	f7ff fce2 	bl	800c8b0 <chSysLock>
 800ceec:	ab03      	add	r3, sp, #12
 800ceee:	4618      	mov	r0, r3
 800cef0:	f7ff fd7e 	bl	800c9f0 <chBSemGetStateI>
 800cef4:	4603      	mov	r3, r0
 800cef6:	2b00      	cmp	r3, #0
 800cef8:	bf0c      	ite	eq
 800cefa:	2300      	moveq	r3, #0
 800cefc:	2301      	movne	r3, #1
 800cefe:	b2db      	uxtb	r3, r3
 800cf00:	2001      	movs	r0, #1
 800cf02:	4619      	mov	r1, r3
 800cf04:	f7fe ffa4 	bl	800be50 <_test_assert>
 800cf08:	4603      	mov	r3, r0
 800cf0a:	2b00      	cmp	r3, #0
 800cf0c:	d002      	beq.n	800cf14 <sem4_execute+0x44>
 800cf0e:	f7ff fcd7 	bl	800c8c0 <chSysUnlock>
 800cf12:	e0a3      	b.n	800d05c <sem4_execute+0x18c>
 800cf14:	f7ff fcd4 	bl	800c8c0 <chSysUnlock>

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800cf18:	4b51      	ldr	r3, [pc, #324]	; (800d060 <sem4_execute+0x190>)
 800cf1a:	681c      	ldr	r4, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
 800cf1c:	f7ff fcf8 	bl	800c910 <chThdGetPriorityX>
 800cf20:	4603      	mov	r3, r0
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800cf22:	3b01      	subs	r3, #1
 800cf24:	aa03      	add	r2, sp, #12
 800cf26:	9200      	str	r2, [sp, #0]
 800cf28:	4620      	mov	r0, r4
 800cf2a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cf2e:	461a      	mov	r2, r3
 800cf30:	4b4c      	ldr	r3, [pc, #304]	; (800d064 <sem4_execute+0x194>)
 800cf32:	f7f4 f955 	bl	80011e0 <chThdCreateStatic>
 800cf36:	4602      	mov	r2, r0
 800cf38:	4b4b      	ldr	r3, [pc, #300]	; (800d068 <sem4_execute+0x198>)
 800cf3a:	601a      	str	r2, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
 800cf3c:	ab03      	add	r3, sp, #12
 800cf3e:	4618      	mov	r0, r3
 800cf40:	f7ff fd0e 	bl	800c960 <chBSemWait>
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800cf44:	f7ff fcb4 	bl	800c8b0 <chSysLock>
 800cf48:	ab03      	add	r3, sp, #12
 800cf4a:	4618      	mov	r0, r3
 800cf4c:	f7ff fd50 	bl	800c9f0 <chBSemGetStateI>
 800cf50:	4603      	mov	r3, r0
 800cf52:	2b00      	cmp	r3, #0
 800cf54:	bf0c      	ite	eq
 800cf56:	2300      	moveq	r3, #0
 800cf58:	2301      	movne	r3, #1
 800cf5a:	b2db      	uxtb	r3, r3
 800cf5c:	2002      	movs	r0, #2
 800cf5e:	4619      	mov	r1, r3
 800cf60:	f7fe ff76 	bl	800be50 <_test_assert>
 800cf64:	4603      	mov	r3, r0
 800cf66:	2b00      	cmp	r3, #0
 800cf68:	d002      	beq.n	800cf70 <sem4_execute+0xa0>
 800cf6a:	f7ff fca9 	bl	800c8c0 <chSysUnlock>
 800cf6e:	e075      	b.n	800d05c <sem4_execute+0x18c>
 800cf70:	f7ff fca6 	bl	800c8c0 <chSysUnlock>

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
 800cf74:	ab03      	add	r3, sp, #12
 800cf76:	4618      	mov	r0, r3
 800cf78:	f7ff fd2a 	bl	800c9d0 <chBSemSignal>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 800cf7c:	f7ff fc98 	bl	800c8b0 <chSysLock>
 800cf80:	ab03      	add	r3, sp, #12
 800cf82:	4618      	mov	r0, r3
 800cf84:	f7ff fd34 	bl	800c9f0 <chBSemGetStateI>
 800cf88:	4603      	mov	r3, r0
 800cf8a:	2b00      	cmp	r3, #0
 800cf8c:	bf0c      	ite	eq
 800cf8e:	2300      	moveq	r3, #0
 800cf90:	2301      	movne	r3, #1
 800cf92:	b2db      	uxtb	r3, r3
 800cf94:	f083 0301 	eor.w	r3, r3, #1
 800cf98:	b2db      	uxtb	r3, r3
 800cf9a:	f003 0301 	and.w	r3, r3, #1
 800cf9e:	b2db      	uxtb	r3, r3
 800cfa0:	2003      	movs	r0, #3
 800cfa2:	4619      	mov	r1, r3
 800cfa4:	f7fe ff54 	bl	800be50 <_test_assert>
 800cfa8:	4603      	mov	r3, r0
 800cfaa:	2b00      	cmp	r3, #0
 800cfac:	d002      	beq.n	800cfb4 <sem4_execute+0xe4>
 800cfae:	f7ff fc87 	bl	800c8c0 <chSysUnlock>
 800cfb2:	e053      	b.n	800d05c <sem4_execute+0x18c>
 800cfb4:	f7ff fc84 	bl	800c8c0 <chSysUnlock>
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800cfb8:	f7ff fc7a 	bl	800c8b0 <chSysLock>
 800cfbc:	ab03      	add	r3, sp, #12
 800cfbe:	4618      	mov	r0, r3
 800cfc0:	f7ff fcae 	bl	800c920 <chSemGetCounterI>
 800cfc4:	4603      	mov	r3, r0
 800cfc6:	2b01      	cmp	r3, #1
 800cfc8:	bf14      	ite	ne
 800cfca:	2300      	movne	r3, #0
 800cfcc:	2301      	moveq	r3, #1
 800cfce:	b2db      	uxtb	r3, r3
 800cfd0:	2004      	movs	r0, #4
 800cfd2:	4619      	mov	r1, r3
 800cfd4:	f7fe ff3c 	bl	800be50 <_test_assert>
 800cfd8:	4603      	mov	r3, r0
 800cfda:	2b00      	cmp	r3, #0
 800cfdc:	d002      	beq.n	800cfe4 <sem4_execute+0x114>
 800cfde:	f7ff fc6f 	bl	800c8c0 <chSysUnlock>
 800cfe2:	e03b      	b.n	800d05c <sem4_execute+0x18c>
 800cfe4:	f7ff fc6c 	bl	800c8c0 <chSysUnlock>

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
 800cfe8:	ab03      	add	r3, sp, #12
 800cfea:	4618      	mov	r0, r3
 800cfec:	f7ff fcf0 	bl	800c9d0 <chBSemSignal>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 800cff0:	f7ff fc5e 	bl	800c8b0 <chSysLock>
 800cff4:	ab03      	add	r3, sp, #12
 800cff6:	4618      	mov	r0, r3
 800cff8:	f7ff fcfa 	bl	800c9f0 <chBSemGetStateI>
 800cffc:	4603      	mov	r3, r0
 800cffe:	2b00      	cmp	r3, #0
 800d000:	bf0c      	ite	eq
 800d002:	2300      	moveq	r3, #0
 800d004:	2301      	movne	r3, #1
 800d006:	b2db      	uxtb	r3, r3
 800d008:	f083 0301 	eor.w	r3, r3, #1
 800d00c:	b2db      	uxtb	r3, r3
 800d00e:	f003 0301 	and.w	r3, r3, #1
 800d012:	b2db      	uxtb	r3, r3
 800d014:	2003      	movs	r0, #3
 800d016:	4619      	mov	r1, r3
 800d018:	f7fe ff1a 	bl	800be50 <_test_assert>
 800d01c:	4603      	mov	r3, r0
 800d01e:	2b00      	cmp	r3, #0
 800d020:	d002      	beq.n	800d028 <sem4_execute+0x158>
 800d022:	f7ff fc4d 	bl	800c8c0 <chSysUnlock>
 800d026:	e019      	b.n	800d05c <sem4_execute+0x18c>
 800d028:	f7ff fc4a 	bl	800c8c0 <chSysUnlock>
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800d02c:	f7ff fc40 	bl	800c8b0 <chSysLock>
 800d030:	ab03      	add	r3, sp, #12
 800d032:	4618      	mov	r0, r3
 800d034:	f7ff fc74 	bl	800c920 <chSemGetCounterI>
 800d038:	4603      	mov	r3, r0
 800d03a:	2b01      	cmp	r3, #1
 800d03c:	bf14      	ite	ne
 800d03e:	2300      	movne	r3, #0
 800d040:	2301      	moveq	r3, #1
 800d042:	b2db      	uxtb	r3, r3
 800d044:	2005      	movs	r0, #5
 800d046:	4619      	mov	r1, r3
 800d048:	f7fe ff02 	bl	800be50 <_test_assert>
 800d04c:	4603      	mov	r3, r0
 800d04e:	2b00      	cmp	r3, #0
 800d050:	d002      	beq.n	800d058 <sem4_execute+0x188>
 800d052:	f7ff fc35 	bl	800c8c0 <chSysUnlock>
 800d056:	e001      	b.n	800d05c <sem4_execute+0x18c>
 800d058:	f7ff fc32 	bl	800c8c0 <chSysUnlock>
}
 800d05c:	b006      	add	sp, #24
 800d05e:	bd10      	pop	{r4, pc}
 800d060:	0801ad70 	.word	0x0801ad70
 800d064:	0800ceb1 	.word	0x0800ceb1
 800d068:	20003e3c 	.word	0x20003e3c
 800d06c:	f3af 8000 	nop.w

0800d070 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800d070:	b082      	sub	sp, #8
 800d072:	2320      	movs	r3, #32
 800d074:	9301      	str	r3, [sp, #4]
 800d076:	9b01      	ldr	r3, [sp, #4]
 800d078:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d07c:	b002      	add	sp, #8
 800d07e:	4770      	bx	lr

0800d080 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800d080:	b082      	sub	sp, #8
 800d082:	2300      	movs	r3, #0
 800d084:	9301      	str	r3, [sp, #4]
 800d086:	9b01      	ldr	r3, [sp, #4]
 800d088:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d08c:	b002      	add	sp, #8
 800d08e:	4770      	bx	lr

0800d090 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800d090:	b082      	sub	sp, #8
 800d092:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800d094:	9b01      	ldr	r3, [sp, #4]
 800d096:	681a      	ldr	r2, [r3, #0]
 800d098:	9b01      	ldr	r3, [sp, #4]
 800d09a:	429a      	cmp	r2, r3
 800d09c:	bf14      	ite	ne
 800d09e:	2300      	movne	r3, #0
 800d0a0:	2301      	moveq	r3, #1
 800d0a2:	b2db      	uxtb	r3, r3
}
 800d0a4:	4618      	mov	r0, r3
 800d0a6:	b002      	add	sp, #8
 800d0a8:	4770      	bx	lr
 800d0aa:	bf00      	nop
 800d0ac:	f3af 8000 	nop.w

0800d0b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800d0b0:	b508      	push	{r3, lr}

  port_lock();
 800d0b2:	f7ff ffdd 	bl	800d070 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800d0b6:	bd08      	pop	{r3, pc}
 800d0b8:	f3af 8000 	nop.w
 800d0bc:	f3af 8000 	nop.w

0800d0c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800d0c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800d0c2:	f7ff ffdd 	bl	800d080 <port_unlock>
}
 800d0c6:	bd08      	pop	{r3, pc}
 800d0c8:	f3af 8000 	nop.w
 800d0cc:	f3af 8000 	nop.w

0800d0d0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800d0d0:	4b01      	ldr	r3, [pc, #4]	; (800d0d8 <chThdGetSelfX+0x8>)
 800d0d2:	699b      	ldr	r3, [r3, #24]
}
 800d0d4:	4618      	mov	r0, r3
 800d0d6:	4770      	bx	lr
 800d0d8:	200039a8 	.word	0x200039a8
 800d0dc:	f3af 8000 	nop.w

0800d0e0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800d0e0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800d0e2:	f7ff fff5 	bl	800d0d0 <chThdGetSelfX>
 800d0e6:	4603      	mov	r3, r0
 800d0e8:	689b      	ldr	r3, [r3, #8]
}
 800d0ea:	4618      	mov	r0, r3
 800d0ec:	bd08      	pop	{r3, pc}
 800d0ee:	bf00      	nop

0800d0f0 <mtx1_setup>:
 * the mutex is unlocked.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {
 800d0f0:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800d0f2:	4802      	ldr	r0, [pc, #8]	; (800d0fc <mtx1_setup+0xc>)
 800d0f4:	f7f4 fefc 	bl	8001ef0 <chMtxObjectInit>
}
 800d0f8:	bd08      	pop	{r3, pc}
 800d0fa:	bf00      	nop
 800d0fc:	20000844 	.word	0x20000844

0800d100 <thread1>:

static THD_FUNCTION(thread1, p) {
 800d100:	b500      	push	{lr}
 800d102:	b083      	sub	sp, #12
 800d104:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 800d106:	4807      	ldr	r0, [pc, #28]	; (800d124 <thread1+0x24>)
 800d108:	f7f4 ff02 	bl	8001f10 <chMtxLock>
  test_emit_token(*(char *)p);
 800d10c:	9b01      	ldr	r3, [sp, #4]
 800d10e:	781b      	ldrb	r3, [r3, #0]
 800d110:	4618      	mov	r0, r3
 800d112:	f7fe fe6d 	bl	800bdf0 <test_emit_token>
  chMtxUnlock(&m1);
 800d116:	4803      	ldr	r0, [pc, #12]	; (800d124 <thread1+0x24>)
 800d118:	f7f4 ffa2 	bl	8002060 <chMtxUnlock>
}
 800d11c:	b003      	add	sp, #12
 800d11e:	f85d fb04 	ldr.w	pc, [sp], #4
 800d122:	bf00      	nop
 800d124:	20000844 	.word	0x20000844
 800d128:	f3af 8000 	nop.w
 800d12c:	f3af 8000 	nop.w

0800d130 <mtx1_execute>:

static void mtx1_execute(void) {
 800d130:	b500      	push	{lr}
 800d132:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
 800d134:	f7ff ffd4 	bl	800d0e0 <chThdGetPriorityX>
 800d138:	9003      	str	r0, [sp, #12]
  chMtxLock(&m1);
 800d13a:	483a      	ldr	r0, [pc, #232]	; (800d224 <mtx1_execute+0xf4>)
 800d13c:	f7f4 fee8 	bl	8001f10 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800d140:	4b39      	ldr	r3, [pc, #228]	; (800d228 <mtx1_execute+0xf8>)
 800d142:	681a      	ldr	r2, [r3, #0]
 800d144:	9b03      	ldr	r3, [sp, #12]
 800d146:	3301      	adds	r3, #1
 800d148:	4938      	ldr	r1, [pc, #224]	; (800d22c <mtx1_execute+0xfc>)
 800d14a:	9100      	str	r1, [sp, #0]
 800d14c:	4610      	mov	r0, r2
 800d14e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d152:	461a      	mov	r2, r3
 800d154:	4b36      	ldr	r3, [pc, #216]	; (800d230 <mtx1_execute+0x100>)
 800d156:	f7f4 f843 	bl	80011e0 <chThdCreateStatic>
 800d15a:	4602      	mov	r2, r0
 800d15c:	4b35      	ldr	r3, [pc, #212]	; (800d234 <mtx1_execute+0x104>)
 800d15e:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800d160:	4b31      	ldr	r3, [pc, #196]	; (800d228 <mtx1_execute+0xf8>)
 800d162:	685a      	ldr	r2, [r3, #4]
 800d164:	9b03      	ldr	r3, [sp, #12]
 800d166:	3302      	adds	r3, #2
 800d168:	4933      	ldr	r1, [pc, #204]	; (800d238 <mtx1_execute+0x108>)
 800d16a:	9100      	str	r1, [sp, #0]
 800d16c:	4610      	mov	r0, r2
 800d16e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d172:	461a      	mov	r2, r3
 800d174:	4b2e      	ldr	r3, [pc, #184]	; (800d230 <mtx1_execute+0x100>)
 800d176:	f7f4 f833 	bl	80011e0 <chThdCreateStatic>
 800d17a:	4602      	mov	r2, r0
 800d17c:	4b2d      	ldr	r3, [pc, #180]	; (800d234 <mtx1_execute+0x104>)
 800d17e:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800d180:	4b29      	ldr	r3, [pc, #164]	; (800d228 <mtx1_execute+0xf8>)
 800d182:	689a      	ldr	r2, [r3, #8]
 800d184:	9b03      	ldr	r3, [sp, #12]
 800d186:	3303      	adds	r3, #3
 800d188:	492c      	ldr	r1, [pc, #176]	; (800d23c <mtx1_execute+0x10c>)
 800d18a:	9100      	str	r1, [sp, #0]
 800d18c:	4610      	mov	r0, r2
 800d18e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d192:	461a      	mov	r2, r3
 800d194:	4b26      	ldr	r3, [pc, #152]	; (800d230 <mtx1_execute+0x100>)
 800d196:	f7f4 f823 	bl	80011e0 <chThdCreateStatic>
 800d19a:	4602      	mov	r2, r0
 800d19c:	4b25      	ldr	r3, [pc, #148]	; (800d234 <mtx1_execute+0x104>)
 800d19e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800d1a0:	4b21      	ldr	r3, [pc, #132]	; (800d228 <mtx1_execute+0xf8>)
 800d1a2:	68da      	ldr	r2, [r3, #12]
 800d1a4:	9b03      	ldr	r3, [sp, #12]
 800d1a6:	3304      	adds	r3, #4
 800d1a8:	4925      	ldr	r1, [pc, #148]	; (800d240 <mtx1_execute+0x110>)
 800d1aa:	9100      	str	r1, [sp, #0]
 800d1ac:	4610      	mov	r0, r2
 800d1ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d1b2:	461a      	mov	r2, r3
 800d1b4:	4b1e      	ldr	r3, [pc, #120]	; (800d230 <mtx1_execute+0x100>)
 800d1b6:	f7f4 f813 	bl	80011e0 <chThdCreateStatic>
 800d1ba:	4602      	mov	r2, r0
 800d1bc:	4b1d      	ldr	r3, [pc, #116]	; (800d234 <mtx1_execute+0x104>)
 800d1be:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800d1c0:	4b19      	ldr	r3, [pc, #100]	; (800d228 <mtx1_execute+0xf8>)
 800d1c2:	691a      	ldr	r2, [r3, #16]
 800d1c4:	9b03      	ldr	r3, [sp, #12]
 800d1c6:	3305      	adds	r3, #5
 800d1c8:	491e      	ldr	r1, [pc, #120]	; (800d244 <mtx1_execute+0x114>)
 800d1ca:	9100      	str	r1, [sp, #0]
 800d1cc:	4610      	mov	r0, r2
 800d1ce:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d1d2:	461a      	mov	r2, r3
 800d1d4:	4b16      	ldr	r3, [pc, #88]	; (800d230 <mtx1_execute+0x100>)
 800d1d6:	f7f4 f803 	bl	80011e0 <chThdCreateStatic>
 800d1da:	4602      	mov	r2, r0
 800d1dc:	4b15      	ldr	r3, [pc, #84]	; (800d234 <mtx1_execute+0x104>)
 800d1de:	611a      	str	r2, [r3, #16]
  chMtxUnlock(&m1);
 800d1e0:	4810      	ldr	r0, [pc, #64]	; (800d224 <mtx1_execute+0xf4>)
 800d1e2:	f7f4 ff3d 	bl	8002060 <chMtxUnlock>
  test_wait_threads();
 800d1e6:	f7fe feb3 	bl	800bf50 <test_wait_threads>
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 800d1ea:	f7ff ff79 	bl	800d0e0 <chThdGetPriorityX>
 800d1ee:	4602      	mov	r2, r0
 800d1f0:	9b03      	ldr	r3, [sp, #12]
 800d1f2:	429a      	cmp	r2, r3
 800d1f4:	bf14      	ite	ne
 800d1f6:	2300      	movne	r3, #0
 800d1f8:	2301      	moveq	r3, #1
 800d1fa:	b2db      	uxtb	r3, r3
 800d1fc:	2001      	movs	r0, #1
 800d1fe:	4619      	mov	r1, r3
 800d200:	f7fe fe26 	bl	800be50 <_test_assert>
 800d204:	4603      	mov	r3, r0
 800d206:	2b00      	cmp	r3, #0
 800d208:	d000      	beq.n	800d20c <mtx1_execute+0xdc>
 800d20a:	e007      	b.n	800d21c <mtx1_execute+0xec>
  test_assert_sequence(2, "ABCDE");
 800d20c:	2002      	movs	r0, #2
 800d20e:	490e      	ldr	r1, [pc, #56]	; (800d248 <mtx1_execute+0x118>)
 800d210:	f7fe fe36 	bl	800be80 <_test_assert_sequence>
 800d214:	4603      	mov	r3, r0
 800d216:	2b00      	cmp	r3, #0
 800d218:	d000      	beq.n	800d21c <mtx1_execute+0xec>
 800d21a:	bf00      	nop
}
 800d21c:	b005      	add	sp, #20
 800d21e:	f85d fb04 	ldr.w	pc, [sp], #4
 800d222:	bf00      	nop
 800d224:	20000844 	.word	0x20000844
 800d228:	0801ad70 	.word	0x0801ad70
 800d22c:	0801b140 	.word	0x0801b140
 800d230:	0800d101 	.word	0x0800d101
 800d234:	20003e3c 	.word	0x20003e3c
 800d238:	0801b144 	.word	0x0801b144
 800d23c:	0801b148 	.word	0x0801b148
 800d240:	0801b14c 	.word	0x0801b14c
 800d244:	0801b150 	.word	0x0801b150
 800d248:	0801b154 	.word	0x0801b154
 800d24c:	f3af 8000 	nop.w

0800d250 <mtx4_setup>:
 * thread with precise timing.<br>
 * The test expects that the priority changes caused by the priority
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {
 800d250:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800d252:	4803      	ldr	r0, [pc, #12]	; (800d260 <mtx4_setup+0x10>)
 800d254:	f7f4 fe4c 	bl	8001ef0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800d258:	4802      	ldr	r0, [pc, #8]	; (800d264 <mtx4_setup+0x14>)
 800d25a:	f7f4 fe49 	bl	8001ef0 <chMtxObjectInit>
}
 800d25e:	bd08      	pop	{r3, pc}
 800d260:	20000844 	.word	0x20000844
 800d264:	20000854 	.word	0x20000854
 800d268:	f3af 8000 	nop.w
 800d26c:	f3af 8000 	nop.w

0800d270 <thread4a>:

static THD_FUNCTION(thread4a, p) {
 800d270:	b500      	push	{lr}
 800d272:	b083      	sub	sp, #12
 800d274:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 800d276:	f241 3088 	movw	r0, #5000	; 0x1388
 800d27a:	f7f4 f829 	bl	80012d0 <chThdSleep>
  chMtxLock(&m2);
 800d27e:	4804      	ldr	r0, [pc, #16]	; (800d290 <thread4a+0x20>)
 800d280:	f7f4 fe46 	bl	8001f10 <chMtxLock>
  chMtxUnlock(&m2);
 800d284:	4802      	ldr	r0, [pc, #8]	; (800d290 <thread4a+0x20>)
 800d286:	f7f4 feeb 	bl	8002060 <chMtxUnlock>
}
 800d28a:	b003      	add	sp, #12
 800d28c:	f85d fb04 	ldr.w	pc, [sp], #4
 800d290:	20000854 	.word	0x20000854
 800d294:	f3af 8000 	nop.w
 800d298:	f3af 8000 	nop.w
 800d29c:	f3af 8000 	nop.w

0800d2a0 <thread4b>:

static THD_FUNCTION(thread4b, p) {
 800d2a0:	b500      	push	{lr}
 800d2a2:	b083      	sub	sp, #12
 800d2a4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(150);
 800d2a6:	f643 2098 	movw	r0, #15000	; 0x3a98
 800d2aa:	f7f4 f811 	bl	80012d0 <chThdSleep>
  chMtxLock(&m1);
 800d2ae:	4804      	ldr	r0, [pc, #16]	; (800d2c0 <thread4b+0x20>)
 800d2b0:	f7f4 fe2e 	bl	8001f10 <chMtxLock>
  chMtxUnlock(&m1);
 800d2b4:	4802      	ldr	r0, [pc, #8]	; (800d2c0 <thread4b+0x20>)
 800d2b6:	f7f4 fed3 	bl	8002060 <chMtxUnlock>
}
 800d2ba:	b003      	add	sp, #12
 800d2bc:	f85d fb04 	ldr.w	pc, [sp], #4
 800d2c0:	20000844 	.word	0x20000844
 800d2c4:	f3af 8000 	nop.w
 800d2c8:	f3af 8000 	nop.w
 800d2cc:	f3af 8000 	nop.w

0800d2d0 <mtx4_execute>:

static void mtx4_execute(void) {
 800d2d0:	b500      	push	{lr}
 800d2d2:	b087      	sub	sp, #28
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
 800d2d4:	f7ff ff04 	bl	800d0e0 <chThdGetPriorityX>
 800d2d8:	9005      	str	r0, [sp, #20]
  p1 = p + 1;
 800d2da:	9b05      	ldr	r3, [sp, #20]
 800d2dc:	3301      	adds	r3, #1
 800d2de:	9304      	str	r3, [sp, #16]
  p2 = p + 2;
 800d2e0:	9b05      	ldr	r3, [sp, #20]
 800d2e2:	3302      	adds	r3, #2
 800d2e4:	9303      	str	r3, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 800d2e6:	4ba4      	ldr	r3, [pc, #656]	; (800d578 <mtx4_execute+0x2a8>)
 800d2e8:	681b      	ldr	r3, [r3, #0]
 800d2ea:	4aa4      	ldr	r2, [pc, #656]	; (800d57c <mtx4_execute+0x2ac>)
 800d2ec:	9200      	str	r2, [sp, #0]
 800d2ee:	4618      	mov	r0, r3
 800d2f0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d2f4:	9a04      	ldr	r2, [sp, #16]
 800d2f6:	4ba2      	ldr	r3, [pc, #648]	; (800d580 <mtx4_execute+0x2b0>)
 800d2f8:	f7f3 ff72 	bl	80011e0 <chThdCreateStatic>
 800d2fc:	4602      	mov	r2, r0
 800d2fe:	4ba1      	ldr	r3, [pc, #644]	; (800d584 <mtx4_execute+0x2b4>)
 800d300:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 800d302:	4b9d      	ldr	r3, [pc, #628]	; (800d578 <mtx4_execute+0x2a8>)
 800d304:	685b      	ldr	r3, [r3, #4]
 800d306:	4aa0      	ldr	r2, [pc, #640]	; (800d588 <mtx4_execute+0x2b8>)
 800d308:	9200      	str	r2, [sp, #0]
 800d30a:	4618      	mov	r0, r3
 800d30c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d310:	9a03      	ldr	r2, [sp, #12]
 800d312:	4b9e      	ldr	r3, [pc, #632]	; (800d58c <mtx4_execute+0x2bc>)
 800d314:	f7f3 ff64 	bl	80011e0 <chThdCreateStatic>
 800d318:	4602      	mov	r2, r0
 800d31a:	4b9a      	ldr	r3, [pc, #616]	; (800d584 <mtx4_execute+0x2b4>)
 800d31c:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 800d31e:	489c      	ldr	r0, [pc, #624]	; (800d590 <mtx4_execute+0x2c0>)
 800d320:	f7f4 fdf6 	bl	8001f10 <chMtxLock>
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 800d324:	f7ff fedc 	bl	800d0e0 <chThdGetPriorityX>
 800d328:	4602      	mov	r2, r0
 800d32a:	9b05      	ldr	r3, [sp, #20]
 800d32c:	429a      	cmp	r2, r3
 800d32e:	bf14      	ite	ne
 800d330:	2300      	movne	r3, #0
 800d332:	2301      	moveq	r3, #1
 800d334:	b2db      	uxtb	r3, r3
 800d336:	2001      	movs	r0, #1
 800d338:	4619      	mov	r1, r3
 800d33a:	f7fe fd89 	bl	800be50 <_test_assert>
 800d33e:	4603      	mov	r3, r0
 800d340:	2b00      	cmp	r3, #0
 800d342:	d000      	beq.n	800d346 <mtx4_execute+0x76>
 800d344:	e141      	b.n	800d5ca <mtx4_execute+0x2fa>
  chThdSleepMilliseconds(100);
 800d346:	f242 7010 	movw	r0, #10000	; 0x2710
 800d34a:	f7f3 ffc1 	bl	80012d0 <chThdSleep>
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 800d34e:	f7ff fec7 	bl	800d0e0 <chThdGetPriorityX>
 800d352:	4602      	mov	r2, r0
 800d354:	9b04      	ldr	r3, [sp, #16]
 800d356:	429a      	cmp	r2, r3
 800d358:	bf14      	ite	ne
 800d35a:	2300      	movne	r3, #0
 800d35c:	2301      	moveq	r3, #1
 800d35e:	b2db      	uxtb	r3, r3
 800d360:	2002      	movs	r0, #2
 800d362:	4619      	mov	r1, r3
 800d364:	f7fe fd74 	bl	800be50 <_test_assert>
 800d368:	4603      	mov	r3, r0
 800d36a:	2b00      	cmp	r3, #0
 800d36c:	d000      	beq.n	800d370 <mtx4_execute+0xa0>
 800d36e:	e12c      	b.n	800d5ca <mtx4_execute+0x2fa>
  chMtxLock(&m1);
 800d370:	4888      	ldr	r0, [pc, #544]	; (800d594 <mtx4_execute+0x2c4>)
 800d372:	f7f4 fdcd 	bl	8001f10 <chMtxLock>
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 800d376:	f7ff feb3 	bl	800d0e0 <chThdGetPriorityX>
 800d37a:	4602      	mov	r2, r0
 800d37c:	9b04      	ldr	r3, [sp, #16]
 800d37e:	429a      	cmp	r2, r3
 800d380:	bf14      	ite	ne
 800d382:	2300      	movne	r3, #0
 800d384:	2301      	moveq	r3, #1
 800d386:	b2db      	uxtb	r3, r3
 800d388:	2003      	movs	r0, #3
 800d38a:	4619      	mov	r1, r3
 800d38c:	f7fe fd60 	bl	800be50 <_test_assert>
 800d390:	4603      	mov	r3, r0
 800d392:	2b00      	cmp	r3, #0
 800d394:	d000      	beq.n	800d398 <mtx4_execute+0xc8>
 800d396:	e118      	b.n	800d5ca <mtx4_execute+0x2fa>
  chThdSleepMilliseconds(100);
 800d398:	f242 7010 	movw	r0, #10000	; 0x2710
 800d39c:	f7f3 ff98 	bl	80012d0 <chThdSleep>
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 800d3a0:	f7ff fe9e 	bl	800d0e0 <chThdGetPriorityX>
 800d3a4:	4602      	mov	r2, r0
 800d3a6:	9b03      	ldr	r3, [sp, #12]
 800d3a8:	429a      	cmp	r2, r3
 800d3aa:	bf14      	ite	ne
 800d3ac:	2300      	movne	r3, #0
 800d3ae:	2301      	moveq	r3, #1
 800d3b0:	b2db      	uxtb	r3, r3
 800d3b2:	2004      	movs	r0, #4
 800d3b4:	4619      	mov	r1, r3
 800d3b6:	f7fe fd4b 	bl	800be50 <_test_assert>
 800d3ba:	4603      	mov	r3, r0
 800d3bc:	2b00      	cmp	r3, #0
 800d3be:	d000      	beq.n	800d3c2 <mtx4_execute+0xf2>
 800d3c0:	e103      	b.n	800d5ca <mtx4_execute+0x2fa>
  chMtxUnlock(&m1);
 800d3c2:	4874      	ldr	r0, [pc, #464]	; (800d594 <mtx4_execute+0x2c4>)
 800d3c4:	f7f4 fe4c 	bl	8002060 <chMtxUnlock>
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 800d3c8:	f7ff fe8a 	bl	800d0e0 <chThdGetPriorityX>
 800d3cc:	4602      	mov	r2, r0
 800d3ce:	9b04      	ldr	r3, [sp, #16]
 800d3d0:	429a      	cmp	r2, r3
 800d3d2:	bf14      	ite	ne
 800d3d4:	2300      	movne	r3, #0
 800d3d6:	2301      	moveq	r3, #1
 800d3d8:	b2db      	uxtb	r3, r3
 800d3da:	2005      	movs	r0, #5
 800d3dc:	4619      	mov	r1, r3
 800d3de:	f7fe fd37 	bl	800be50 <_test_assert>
 800d3e2:	4603      	mov	r3, r0
 800d3e4:	2b00      	cmp	r3, #0
 800d3e6:	d000      	beq.n	800d3ea <mtx4_execute+0x11a>
 800d3e8:	e0ef      	b.n	800d5ca <mtx4_execute+0x2fa>
  chThdSleepMilliseconds(100);
 800d3ea:	f242 7010 	movw	r0, #10000	; 0x2710
 800d3ee:	f7f3 ff6f 	bl	80012d0 <chThdSleep>
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 800d3f2:	f7ff fe75 	bl	800d0e0 <chThdGetPriorityX>
 800d3f6:	4602      	mov	r2, r0
 800d3f8:	9b04      	ldr	r3, [sp, #16]
 800d3fa:	429a      	cmp	r2, r3
 800d3fc:	bf14      	ite	ne
 800d3fe:	2300      	movne	r3, #0
 800d400:	2301      	moveq	r3, #1
 800d402:	b2db      	uxtb	r3, r3
 800d404:	2006      	movs	r0, #6
 800d406:	4619      	mov	r1, r3
 800d408:	f7fe fd22 	bl	800be50 <_test_assert>
 800d40c:	4603      	mov	r3, r0
 800d40e:	2b00      	cmp	r3, #0
 800d410:	d000      	beq.n	800d414 <mtx4_execute+0x144>
 800d412:	e0da      	b.n	800d5ca <mtx4_execute+0x2fa>
  chMtxUnlockAll();
 800d414:	f7f4 fecc 	bl	80021b0 <chMtxUnlockAll>
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 800d418:	f7ff fe62 	bl	800d0e0 <chThdGetPriorityX>
 800d41c:	4602      	mov	r2, r0
 800d41e:	9b05      	ldr	r3, [sp, #20]
 800d420:	429a      	cmp	r2, r3
 800d422:	bf14      	ite	ne
 800d424:	2300      	movne	r3, #0
 800d426:	2301      	moveq	r3, #1
 800d428:	b2db      	uxtb	r3, r3
 800d42a:	2007      	movs	r0, #7
 800d42c:	4619      	mov	r1, r3
 800d42e:	f7fe fd0f 	bl	800be50 <_test_assert>
 800d432:	4603      	mov	r3, r0
 800d434:	2b00      	cmp	r3, #0
 800d436:	d000      	beq.n	800d43a <mtx4_execute+0x16a>
 800d438:	e0c7      	b.n	800d5ca <mtx4_execute+0x2fa>
  test_wait_threads();
 800d43a:	f7fe fd89 	bl	800bf50 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 800d43e:	4b4e      	ldr	r3, [pc, #312]	; (800d578 <mtx4_execute+0x2a8>)
 800d440:	681b      	ldr	r3, [r3, #0]
 800d442:	4a55      	ldr	r2, [pc, #340]	; (800d598 <mtx4_execute+0x2c8>)
 800d444:	9200      	str	r2, [sp, #0]
 800d446:	4618      	mov	r0, r3
 800d448:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d44c:	9a04      	ldr	r2, [sp, #16]
 800d44e:	4b4c      	ldr	r3, [pc, #304]	; (800d580 <mtx4_execute+0x2b0>)
 800d450:	f7f3 fec6 	bl	80011e0 <chThdCreateStatic>
 800d454:	4602      	mov	r2, r0
 800d456:	4b4b      	ldr	r3, [pc, #300]	; (800d584 <mtx4_execute+0x2b4>)
 800d458:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 800d45a:	4b47      	ldr	r3, [pc, #284]	; (800d578 <mtx4_execute+0x2a8>)
 800d45c:	685b      	ldr	r3, [r3, #4]
 800d45e:	4a4f      	ldr	r2, [pc, #316]	; (800d59c <mtx4_execute+0x2cc>)
 800d460:	9200      	str	r2, [sp, #0]
 800d462:	4618      	mov	r0, r3
 800d464:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d468:	9a03      	ldr	r2, [sp, #12]
 800d46a:	4b48      	ldr	r3, [pc, #288]	; (800d58c <mtx4_execute+0x2bc>)
 800d46c:	f7f3 feb8 	bl	80011e0 <chThdCreateStatic>
 800d470:	4602      	mov	r2, r0
 800d472:	4b44      	ldr	r3, [pc, #272]	; (800d584 <mtx4_execute+0x2b4>)
 800d474:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 800d476:	4846      	ldr	r0, [pc, #280]	; (800d590 <mtx4_execute+0x2c0>)
 800d478:	f7f4 fd4a 	bl	8001f10 <chMtxLock>
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 800d47c:	f7ff fe30 	bl	800d0e0 <chThdGetPriorityX>
 800d480:	4602      	mov	r2, r0
 800d482:	9b05      	ldr	r3, [sp, #20]
 800d484:	429a      	cmp	r2, r3
 800d486:	bf14      	ite	ne
 800d488:	2300      	movne	r3, #0
 800d48a:	2301      	moveq	r3, #1
 800d48c:	b2db      	uxtb	r3, r3
 800d48e:	2008      	movs	r0, #8
 800d490:	4619      	mov	r1, r3
 800d492:	f7fe fcdd 	bl	800be50 <_test_assert>
 800d496:	4603      	mov	r3, r0
 800d498:	2b00      	cmp	r3, #0
 800d49a:	d000      	beq.n	800d49e <mtx4_execute+0x1ce>
 800d49c:	e095      	b.n	800d5ca <mtx4_execute+0x2fa>
  chThdSleepMilliseconds(100);
 800d49e:	f242 7010 	movw	r0, #10000	; 0x2710
 800d4a2:	f7f3 ff15 	bl	80012d0 <chThdSleep>
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 800d4a6:	f7ff fe1b 	bl	800d0e0 <chThdGetPriorityX>
 800d4aa:	4602      	mov	r2, r0
 800d4ac:	9b04      	ldr	r3, [sp, #16]
 800d4ae:	429a      	cmp	r2, r3
 800d4b0:	bf14      	ite	ne
 800d4b2:	2300      	movne	r3, #0
 800d4b4:	2301      	moveq	r3, #1
 800d4b6:	b2db      	uxtb	r3, r3
 800d4b8:	2009      	movs	r0, #9
 800d4ba:	4619      	mov	r1, r3
 800d4bc:	f7fe fcc8 	bl	800be50 <_test_assert>
 800d4c0:	4603      	mov	r3, r0
 800d4c2:	2b00      	cmp	r3, #0
 800d4c4:	d000      	beq.n	800d4c8 <mtx4_execute+0x1f8>
 800d4c6:	e080      	b.n	800d5ca <mtx4_execute+0x2fa>
  chMtxLock(&m1);
 800d4c8:	4832      	ldr	r0, [pc, #200]	; (800d594 <mtx4_execute+0x2c4>)
 800d4ca:	f7f4 fd21 	bl	8001f10 <chMtxLock>
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 800d4ce:	f7ff fe07 	bl	800d0e0 <chThdGetPriorityX>
 800d4d2:	4602      	mov	r2, r0
 800d4d4:	9b04      	ldr	r3, [sp, #16]
 800d4d6:	429a      	cmp	r2, r3
 800d4d8:	bf14      	ite	ne
 800d4da:	2300      	movne	r3, #0
 800d4dc:	2301      	moveq	r3, #1
 800d4de:	b2db      	uxtb	r3, r3
 800d4e0:	200a      	movs	r0, #10
 800d4e2:	4619      	mov	r1, r3
 800d4e4:	f7fe fcb4 	bl	800be50 <_test_assert>
 800d4e8:	4603      	mov	r3, r0
 800d4ea:	2b00      	cmp	r3, #0
 800d4ec:	d000      	beq.n	800d4f0 <mtx4_execute+0x220>
 800d4ee:	e06c      	b.n	800d5ca <mtx4_execute+0x2fa>
  chThdSleepMilliseconds(100);
 800d4f0:	f242 7010 	movw	r0, #10000	; 0x2710
 800d4f4:	f7f3 feec 	bl	80012d0 <chThdSleep>
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 800d4f8:	f7ff fdf2 	bl	800d0e0 <chThdGetPriorityX>
 800d4fc:	4602      	mov	r2, r0
 800d4fe:	9b03      	ldr	r3, [sp, #12]
 800d500:	429a      	cmp	r2, r3
 800d502:	bf14      	ite	ne
 800d504:	2300      	movne	r3, #0
 800d506:	2301      	moveq	r3, #1
 800d508:	b2db      	uxtb	r3, r3
 800d50a:	200b      	movs	r0, #11
 800d50c:	4619      	mov	r1, r3
 800d50e:	f7fe fc9f 	bl	800be50 <_test_assert>
 800d512:	4603      	mov	r3, r0
 800d514:	2b00      	cmp	r3, #0
 800d516:	d000      	beq.n	800d51a <mtx4_execute+0x24a>
 800d518:	e057      	b.n	800d5ca <mtx4_execute+0x2fa>
  chSysLock();
 800d51a:	f7ff fdc9 	bl	800d0b0 <chSysLock>
  chMtxUnlockS(&m1);
 800d51e:	481d      	ldr	r0, [pc, #116]	; (800d594 <mtx4_execute+0x2c4>)
 800d520:	f7f4 fdf6 	bl	8002110 <chMtxUnlockS>
  chSchRescheduleS();
 800d524:	f7f3 fc2c 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800d528:	f7ff fdca 	bl	800d0c0 <chSysUnlock>
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 800d52c:	f7ff fdd8 	bl	800d0e0 <chThdGetPriorityX>
 800d530:	4602      	mov	r2, r0
 800d532:	9b04      	ldr	r3, [sp, #16]
 800d534:	429a      	cmp	r2, r3
 800d536:	bf14      	ite	ne
 800d538:	2300      	movne	r3, #0
 800d53a:	2301      	moveq	r3, #1
 800d53c:	b2db      	uxtb	r3, r3
 800d53e:	200c      	movs	r0, #12
 800d540:	4619      	mov	r1, r3
 800d542:	f7fe fc85 	bl	800be50 <_test_assert>
 800d546:	4603      	mov	r3, r0
 800d548:	2b00      	cmp	r3, #0
 800d54a:	d000      	beq.n	800d54e <mtx4_execute+0x27e>
 800d54c:	e03d      	b.n	800d5ca <mtx4_execute+0x2fa>
  chThdSleepMilliseconds(100);
 800d54e:	f242 7010 	movw	r0, #10000	; 0x2710
 800d552:	f7f3 febd 	bl	80012d0 <chThdSleep>
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 800d556:	f7ff fdc3 	bl	800d0e0 <chThdGetPriorityX>
 800d55a:	4602      	mov	r2, r0
 800d55c:	9b04      	ldr	r3, [sp, #16]
 800d55e:	429a      	cmp	r2, r3
 800d560:	bf14      	ite	ne
 800d562:	2300      	movne	r3, #0
 800d564:	2301      	moveq	r3, #1
 800d566:	b2db      	uxtb	r3, r3
 800d568:	200d      	movs	r0, #13
 800d56a:	4619      	mov	r1, r3
 800d56c:	f7fe fc70 	bl	800be50 <_test_assert>
 800d570:	4603      	mov	r3, r0
 800d572:	2b00      	cmp	r3, #0
 800d574:	d014      	beq.n	800d5a0 <mtx4_execute+0x2d0>
 800d576:	e028      	b.n	800d5ca <mtx4_execute+0x2fa>
 800d578:	0801ad70 	.word	0x0801ad70
 800d57c:	0801b14c 	.word	0x0801b14c
 800d580:	0800d271 	.word	0x0800d271
 800d584:	20003e3c 	.word	0x20003e3c
 800d588:	0801b150 	.word	0x0801b150
 800d58c:	0800d2a1 	.word	0x0800d2a1
 800d590:	20000854 	.word	0x20000854
 800d594:	20000844 	.word	0x20000844
 800d598:	0801b144 	.word	0x0801b144
 800d59c:	0801b148 	.word	0x0801b148
  chMtxUnlockAll();
 800d5a0:	f7f4 fe06 	bl	80021b0 <chMtxUnlockAll>
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 800d5a4:	f7ff fd9c 	bl	800d0e0 <chThdGetPriorityX>
 800d5a8:	4602      	mov	r2, r0
 800d5aa:	9b05      	ldr	r3, [sp, #20]
 800d5ac:	429a      	cmp	r2, r3
 800d5ae:	bf14      	ite	ne
 800d5b0:	2300      	movne	r3, #0
 800d5b2:	2301      	moveq	r3, #1
 800d5b4:	b2db      	uxtb	r3, r3
 800d5b6:	200e      	movs	r0, #14
 800d5b8:	4619      	mov	r1, r3
 800d5ba:	f7fe fc49 	bl	800be50 <_test_assert>
 800d5be:	4603      	mov	r3, r0
 800d5c0:	2b00      	cmp	r3, #0
 800d5c2:	d000      	beq.n	800d5c6 <mtx4_execute+0x2f6>
 800d5c4:	e001      	b.n	800d5ca <mtx4_execute+0x2fa>
  test_wait_threads();
 800d5c6:	f7fe fcc3 	bl	800bf50 <test_wait_threads>
}
 800d5ca:	b007      	add	sp, #28
 800d5cc:	f85d fb04 	ldr.w	pc, [sp], #4

0800d5d0 <mtx5_setup>:
 * unlock operations.<br>
 * The test expects that the internal mutex status is consistent after each
 * operation.
 */

static void mtx5_setup(void) {
 800d5d0:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800d5d2:	4802      	ldr	r0, [pc, #8]	; (800d5dc <mtx5_setup+0xc>)
 800d5d4:	f7f4 fc8c 	bl	8001ef0 <chMtxObjectInit>
}
 800d5d8:	bd08      	pop	{r3, pc}
 800d5da:	bf00      	nop
 800d5dc:	20000844 	.word	0x20000844

0800d5e0 <mtx5_execute>:

static void mtx5_execute(void) {
 800d5e0:	b500      	push	{lr}
 800d5e2:	b083      	sub	sp, #12

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();
 800d5e4:	f7ff fd7c 	bl	800d0e0 <chThdGetPriorityX>
 800d5e8:	9001      	str	r0, [sp, #4]

  b = chMtxTryLock(&m1);
 800d5ea:	4840      	ldr	r0, [pc, #256]	; (800d6ec <mtx5_execute+0x10c>)
 800d5ec:	f7f4 fd00 	bl	8001ff0 <chMtxTryLock>
 800d5f0:	4603      	mov	r3, r0
 800d5f2:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(1, b, "already locked");
 800d5f6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d5fa:	2001      	movs	r0, #1
 800d5fc:	4619      	mov	r1, r3
 800d5fe:	f7fe fc27 	bl	800be50 <_test_assert>
 800d602:	4603      	mov	r3, r0
 800d604:	2b00      	cmp	r3, #0
 800d606:	d000      	beq.n	800d60a <mtx5_execute+0x2a>
 800d608:	e06d      	b.n	800d6e6 <mtx5_execute+0x106>

  b = chMtxTryLock(&m1);
 800d60a:	4838      	ldr	r0, [pc, #224]	; (800d6ec <mtx5_execute+0x10c>)
 800d60c:	f7f4 fcf0 	bl	8001ff0 <chMtxTryLock>
 800d610:	4603      	mov	r3, r0
 800d612:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(2, !b, "not locked");
 800d616:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d61a:	2b00      	cmp	r3, #0
 800d61c:	bf0c      	ite	eq
 800d61e:	2300      	moveq	r3, #0
 800d620:	2301      	movne	r3, #1
 800d622:	b2db      	uxtb	r3, r3
 800d624:	f083 0301 	eor.w	r3, r3, #1
 800d628:	b2db      	uxtb	r3, r3
 800d62a:	f003 0301 	and.w	r3, r3, #1
 800d62e:	b2db      	uxtb	r3, r3
 800d630:	2002      	movs	r0, #2
 800d632:	4619      	mov	r1, r3
 800d634:	f7fe fc0c 	bl	800be50 <_test_assert>
 800d638:	4603      	mov	r3, r0
 800d63a:	2b00      	cmp	r3, #0
 800d63c:	d000      	beq.n	800d640 <mtx5_execute+0x60>
 800d63e:	e052      	b.n	800d6e6 <mtx5_execute+0x106>

  chSysLock();
 800d640:	f7ff fd36 	bl	800d0b0 <chSysLock>
  chMtxUnlockS(&m1);
 800d644:	4829      	ldr	r0, [pc, #164]	; (800d6ec <mtx5_execute+0x10c>)
 800d646:	f7f4 fd63 	bl	8002110 <chMtxUnlockS>
  chSysUnlock();
 800d64a:	f7ff fd39 	bl	800d0c0 <chSysUnlock>

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 800d64e:	4827      	ldr	r0, [pc, #156]	; (800d6ec <mtx5_execute+0x10c>)
 800d650:	f7ff fd1e 	bl	800d090 <queue_isempty>
 800d654:	4603      	mov	r3, r0
 800d656:	2003      	movs	r0, #3
 800d658:	4619      	mov	r1, r3
 800d65a:	f7fe fbf9 	bl	800be50 <_test_assert>
 800d65e:	4603      	mov	r3, r0
 800d660:	2b00      	cmp	r3, #0
 800d662:	d000      	beq.n	800d666 <mtx5_execute+0x86>
 800d664:	e03f      	b.n	800d6e6 <mtx5_execute+0x106>
  test_assert(4, m1.m_owner == NULL, "still owned");
 800d666:	4b21      	ldr	r3, [pc, #132]	; (800d6ec <mtx5_execute+0x10c>)
 800d668:	689b      	ldr	r3, [r3, #8]
 800d66a:	2b00      	cmp	r3, #0
 800d66c:	bf14      	ite	ne
 800d66e:	2300      	movne	r3, #0
 800d670:	2301      	moveq	r3, #1
 800d672:	b2db      	uxtb	r3, r3
 800d674:	2004      	movs	r0, #4
 800d676:	4619      	mov	r1, r3
 800d678:	f7fe fbea 	bl	800be50 <_test_assert>
 800d67c:	4603      	mov	r3, r0
 800d67e:	2b00      	cmp	r3, #0
 800d680:	d000      	beq.n	800d684 <mtx5_execute+0xa4>
 800d682:	e030      	b.n	800d6e6 <mtx5_execute+0x106>
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 800d684:	f7ff fd2c 	bl	800d0e0 <chThdGetPriorityX>
 800d688:	4602      	mov	r2, r0
 800d68a:	9b01      	ldr	r3, [sp, #4]
 800d68c:	429a      	cmp	r2, r3
 800d68e:	bf14      	ite	ne
 800d690:	2300      	movne	r3, #0
 800d692:	2301      	moveq	r3, #1
 800d694:	b2db      	uxtb	r3, r3
 800d696:	2005      	movs	r0, #5
 800d698:	4619      	mov	r1, r3
 800d69a:	f7fe fbd9 	bl	800be50 <_test_assert>
 800d69e:	4603      	mov	r3, r0
 800d6a0:	2b00      	cmp	r3, #0
 800d6a2:	d000      	beq.n	800d6a6 <mtx5_execute+0xc6>
 800d6a4:	e01f      	b.n	800d6e6 <mtx5_execute+0x106>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 800d6a6:	4811      	ldr	r0, [pc, #68]	; (800d6ec <mtx5_execute+0x10c>)
 800d6a8:	f7f4 fc32 	bl	8001f10 <chMtxLock>
  chMtxUnlockAll();
 800d6ac:	f7f4 fd80 	bl	80021b0 <chMtxUnlockAll>
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 800d6b0:	480e      	ldr	r0, [pc, #56]	; (800d6ec <mtx5_execute+0x10c>)
 800d6b2:	f7ff fced 	bl	800d090 <queue_isempty>
 800d6b6:	4603      	mov	r3, r0
 800d6b8:	2006      	movs	r0, #6
 800d6ba:	4619      	mov	r1, r3
 800d6bc:	f7fe fbc8 	bl	800be50 <_test_assert>
 800d6c0:	4603      	mov	r3, r0
 800d6c2:	2b00      	cmp	r3, #0
 800d6c4:	d000      	beq.n	800d6c8 <mtx5_execute+0xe8>
 800d6c6:	e00e      	b.n	800d6e6 <mtx5_execute+0x106>
  test_assert(7, m1.m_owner == NULL, "still owned");
 800d6c8:	4b08      	ldr	r3, [pc, #32]	; (800d6ec <mtx5_execute+0x10c>)
 800d6ca:	689b      	ldr	r3, [r3, #8]
 800d6cc:	2b00      	cmp	r3, #0
 800d6ce:	bf14      	ite	ne
 800d6d0:	2300      	movne	r3, #0
 800d6d2:	2301      	moveq	r3, #1
 800d6d4:	b2db      	uxtb	r3, r3
 800d6d6:	2007      	movs	r0, #7
 800d6d8:	4619      	mov	r1, r3
 800d6da:	f7fe fbb9 	bl	800be50 <_test_assert>
 800d6de:	4603      	mov	r3, r0
 800d6e0:	2b00      	cmp	r3, #0
 800d6e2:	d000      	beq.n	800d6e6 <mtx5_execute+0x106>
 800d6e4:	bf00      	nop
}
 800d6e6:	b003      	add	sp, #12
 800d6e8:	f85d fb04 	ldr.w	pc, [sp], #4
 800d6ec:	20000844 	.word	0x20000844

0800d6f0 <mtx6_setup>:
 * atomically.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {
 800d6f0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800d6f2:	4803      	ldr	r0, [pc, #12]	; (800d700 <mtx6_setup+0x10>)
 800d6f4:	f7f4 fe2c 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800d6f8:	4802      	ldr	r0, [pc, #8]	; (800d704 <mtx6_setup+0x14>)
 800d6fa:	f7f4 fbf9 	bl	8001ef0 <chMtxObjectInit>
}
 800d6fe:	bd08      	pop	{r3, pc}
 800d700:	20000864 	.word	0x20000864
 800d704:	20000844 	.word	0x20000844
 800d708:	f3af 8000 	nop.w
 800d70c:	f3af 8000 	nop.w

0800d710 <thread10>:

static THD_FUNCTION(thread10, p) {
 800d710:	b500      	push	{lr}
 800d712:	b083      	sub	sp, #12
 800d714:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 800d716:	4808      	ldr	r0, [pc, #32]	; (800d738 <thread10+0x28>)
 800d718:	f7f4 fbfa 	bl	8001f10 <chMtxLock>
  chCondWait(&c1);
 800d71c:	4807      	ldr	r0, [pc, #28]	; (800d73c <thread10+0x2c>)
 800d71e:	f7f4 fe8f 	bl	8002440 <chCondWait>
  test_emit_token(*(char *)p);
 800d722:	9b01      	ldr	r3, [sp, #4]
 800d724:	781b      	ldrb	r3, [r3, #0]
 800d726:	4618      	mov	r0, r3
 800d728:	f7fe fb62 	bl	800bdf0 <test_emit_token>
  chMtxUnlock(&m1);
 800d72c:	4802      	ldr	r0, [pc, #8]	; (800d738 <thread10+0x28>)
 800d72e:	f7f4 fc97 	bl	8002060 <chMtxUnlock>
}
 800d732:	b003      	add	sp, #12
 800d734:	f85d fb04 	ldr.w	pc, [sp], #4
 800d738:	20000844 	.word	0x20000844
 800d73c:	20000864 	.word	0x20000864

0800d740 <mtx6_execute>:

static void mtx6_execute(void) {
 800d740:	b500      	push	{lr}
 800d742:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800d744:	f7ff fccc 	bl	800d0e0 <chThdGetPriorityX>
 800d748:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800d74a:	4b39      	ldr	r3, [pc, #228]	; (800d830 <mtx6_execute+0xf0>)
 800d74c:	681a      	ldr	r2, [r3, #0]
 800d74e:	9b03      	ldr	r3, [sp, #12]
 800d750:	3301      	adds	r3, #1
 800d752:	4938      	ldr	r1, [pc, #224]	; (800d834 <mtx6_execute+0xf4>)
 800d754:	9100      	str	r1, [sp, #0]
 800d756:	4610      	mov	r0, r2
 800d758:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d75c:	461a      	mov	r2, r3
 800d75e:	4b36      	ldr	r3, [pc, #216]	; (800d838 <mtx6_execute+0xf8>)
 800d760:	f7f3 fd3e 	bl	80011e0 <chThdCreateStatic>
 800d764:	4602      	mov	r2, r0
 800d766:	4b35      	ldr	r3, [pc, #212]	; (800d83c <mtx6_execute+0xfc>)
 800d768:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800d76a:	4b31      	ldr	r3, [pc, #196]	; (800d830 <mtx6_execute+0xf0>)
 800d76c:	685a      	ldr	r2, [r3, #4]
 800d76e:	9b03      	ldr	r3, [sp, #12]
 800d770:	3302      	adds	r3, #2
 800d772:	4933      	ldr	r1, [pc, #204]	; (800d840 <mtx6_execute+0x100>)
 800d774:	9100      	str	r1, [sp, #0]
 800d776:	4610      	mov	r0, r2
 800d778:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d77c:	461a      	mov	r2, r3
 800d77e:	4b2e      	ldr	r3, [pc, #184]	; (800d838 <mtx6_execute+0xf8>)
 800d780:	f7f3 fd2e 	bl	80011e0 <chThdCreateStatic>
 800d784:	4602      	mov	r2, r0
 800d786:	4b2d      	ldr	r3, [pc, #180]	; (800d83c <mtx6_execute+0xfc>)
 800d788:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800d78a:	4b29      	ldr	r3, [pc, #164]	; (800d830 <mtx6_execute+0xf0>)
 800d78c:	689a      	ldr	r2, [r3, #8]
 800d78e:	9b03      	ldr	r3, [sp, #12]
 800d790:	3303      	adds	r3, #3
 800d792:	492c      	ldr	r1, [pc, #176]	; (800d844 <mtx6_execute+0x104>)
 800d794:	9100      	str	r1, [sp, #0]
 800d796:	4610      	mov	r0, r2
 800d798:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d79c:	461a      	mov	r2, r3
 800d79e:	4b26      	ldr	r3, [pc, #152]	; (800d838 <mtx6_execute+0xf8>)
 800d7a0:	f7f3 fd1e 	bl	80011e0 <chThdCreateStatic>
 800d7a4:	4602      	mov	r2, r0
 800d7a6:	4b25      	ldr	r3, [pc, #148]	; (800d83c <mtx6_execute+0xfc>)
 800d7a8:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800d7aa:	4b21      	ldr	r3, [pc, #132]	; (800d830 <mtx6_execute+0xf0>)
 800d7ac:	68da      	ldr	r2, [r3, #12]
 800d7ae:	9b03      	ldr	r3, [sp, #12]
 800d7b0:	3304      	adds	r3, #4
 800d7b2:	4925      	ldr	r1, [pc, #148]	; (800d848 <mtx6_execute+0x108>)
 800d7b4:	9100      	str	r1, [sp, #0]
 800d7b6:	4610      	mov	r0, r2
 800d7b8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d7bc:	461a      	mov	r2, r3
 800d7be:	4b1e      	ldr	r3, [pc, #120]	; (800d838 <mtx6_execute+0xf8>)
 800d7c0:	f7f3 fd0e 	bl	80011e0 <chThdCreateStatic>
 800d7c4:	4602      	mov	r2, r0
 800d7c6:	4b1d      	ldr	r3, [pc, #116]	; (800d83c <mtx6_execute+0xfc>)
 800d7c8:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800d7ca:	4b19      	ldr	r3, [pc, #100]	; (800d830 <mtx6_execute+0xf0>)
 800d7cc:	691a      	ldr	r2, [r3, #16]
 800d7ce:	9b03      	ldr	r3, [sp, #12]
 800d7d0:	3305      	adds	r3, #5
 800d7d2:	491e      	ldr	r1, [pc, #120]	; (800d84c <mtx6_execute+0x10c>)
 800d7d4:	9100      	str	r1, [sp, #0]
 800d7d6:	4610      	mov	r0, r2
 800d7d8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d7dc:	461a      	mov	r2, r3
 800d7de:	4b16      	ldr	r3, [pc, #88]	; (800d838 <mtx6_execute+0xf8>)
 800d7e0:	f7f3 fcfe 	bl	80011e0 <chThdCreateStatic>
 800d7e4:	4602      	mov	r2, r0
 800d7e6:	4b15      	ldr	r3, [pc, #84]	; (800d83c <mtx6_execute+0xfc>)
 800d7e8:	611a      	str	r2, [r3, #16]
  chSysLock();
 800d7ea:	f7ff fc61 	bl	800d0b0 <chSysLock>
  chCondSignalI(&c1);
 800d7ee:	4818      	ldr	r0, [pc, #96]	; (800d850 <mtx6_execute+0x110>)
 800d7f0:	f7f4 fdde 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d7f4:	4816      	ldr	r0, [pc, #88]	; (800d850 <mtx6_execute+0x110>)
 800d7f6:	f7f4 fddb 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d7fa:	4815      	ldr	r0, [pc, #84]	; (800d850 <mtx6_execute+0x110>)
 800d7fc:	f7f4 fdd8 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d800:	4813      	ldr	r0, [pc, #76]	; (800d850 <mtx6_execute+0x110>)
 800d802:	f7f4 fdd5 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d806:	4812      	ldr	r0, [pc, #72]	; (800d850 <mtx6_execute+0x110>)
 800d808:	f7f4 fdd2 	bl	80023b0 <chCondSignalI>
  chSchRescheduleS();
 800d80c:	f7f3 fab8 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800d810:	f7ff fc56 	bl	800d0c0 <chSysUnlock>
  test_wait_threads();
 800d814:	f7fe fb9c 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800d818:	2001      	movs	r0, #1
 800d81a:	490e      	ldr	r1, [pc, #56]	; (800d854 <mtx6_execute+0x114>)
 800d81c:	f7fe fb30 	bl	800be80 <_test_assert_sequence>
 800d820:	4603      	mov	r3, r0
 800d822:	2b00      	cmp	r3, #0
 800d824:	d000      	beq.n	800d828 <mtx6_execute+0xe8>
 800d826:	bf00      	nop
}
 800d828:	b005      	add	sp, #20
 800d82a:	f85d fb04 	ldr.w	pc, [sp], #4
 800d82e:	bf00      	nop
 800d830:	0801ad70 	.word	0x0801ad70
 800d834:	0801b140 	.word	0x0801b140
 800d838:	0800d711 	.word	0x0800d711
 800d83c:	20003e3c 	.word	0x20003e3c
 800d840:	0801b144 	.word	0x0801b144
 800d844:	0801b148 	.word	0x0801b148
 800d848:	0801b14c 	.word	0x0801b14c
 800d84c:	0801b150 	.word	0x0801b150
 800d850:	20000864 	.word	0x20000864
 800d854:	0801b154 	.word	0x0801b154
 800d858:	f3af 8000 	nop.w
 800d85c:	f3af 8000 	nop.w

0800d860 <mtx7_setup>:
 * tester thread then proceeds to broadcast the conditional variable.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {
 800d860:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800d862:	4803      	ldr	r0, [pc, #12]	; (800d870 <mtx7_setup+0x10>)
 800d864:	f7f4 fd74 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800d868:	4802      	ldr	r0, [pc, #8]	; (800d874 <mtx7_setup+0x14>)
 800d86a:	f7f4 fb41 	bl	8001ef0 <chMtxObjectInit>
}
 800d86e:	bd08      	pop	{r3, pc}
 800d870:	20000864 	.word	0x20000864
 800d874:	20000844 	.word	0x20000844
 800d878:	f3af 8000 	nop.w
 800d87c:	f3af 8000 	nop.w

0800d880 <mtx7_execute>:

static void mtx7_execute(void) {
 800d880:	b500      	push	{lr}
 800d882:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800d884:	f7ff fc2c 	bl	800d0e0 <chThdGetPriorityX>
 800d888:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800d88a:	4b30      	ldr	r3, [pc, #192]	; (800d94c <mtx7_execute+0xcc>)
 800d88c:	681a      	ldr	r2, [r3, #0]
 800d88e:	9b03      	ldr	r3, [sp, #12]
 800d890:	3301      	adds	r3, #1
 800d892:	492f      	ldr	r1, [pc, #188]	; (800d950 <mtx7_execute+0xd0>)
 800d894:	9100      	str	r1, [sp, #0]
 800d896:	4610      	mov	r0, r2
 800d898:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d89c:	461a      	mov	r2, r3
 800d89e:	4b2d      	ldr	r3, [pc, #180]	; (800d954 <mtx7_execute+0xd4>)
 800d8a0:	f7f3 fc9e 	bl	80011e0 <chThdCreateStatic>
 800d8a4:	4602      	mov	r2, r0
 800d8a6:	4b2c      	ldr	r3, [pc, #176]	; (800d958 <mtx7_execute+0xd8>)
 800d8a8:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800d8aa:	4b28      	ldr	r3, [pc, #160]	; (800d94c <mtx7_execute+0xcc>)
 800d8ac:	685a      	ldr	r2, [r3, #4]
 800d8ae:	9b03      	ldr	r3, [sp, #12]
 800d8b0:	3302      	adds	r3, #2
 800d8b2:	492a      	ldr	r1, [pc, #168]	; (800d95c <mtx7_execute+0xdc>)
 800d8b4:	9100      	str	r1, [sp, #0]
 800d8b6:	4610      	mov	r0, r2
 800d8b8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d8bc:	461a      	mov	r2, r3
 800d8be:	4b25      	ldr	r3, [pc, #148]	; (800d954 <mtx7_execute+0xd4>)
 800d8c0:	f7f3 fc8e 	bl	80011e0 <chThdCreateStatic>
 800d8c4:	4602      	mov	r2, r0
 800d8c6:	4b24      	ldr	r3, [pc, #144]	; (800d958 <mtx7_execute+0xd8>)
 800d8c8:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800d8ca:	4b20      	ldr	r3, [pc, #128]	; (800d94c <mtx7_execute+0xcc>)
 800d8cc:	689a      	ldr	r2, [r3, #8]
 800d8ce:	9b03      	ldr	r3, [sp, #12]
 800d8d0:	3303      	adds	r3, #3
 800d8d2:	4923      	ldr	r1, [pc, #140]	; (800d960 <mtx7_execute+0xe0>)
 800d8d4:	9100      	str	r1, [sp, #0]
 800d8d6:	4610      	mov	r0, r2
 800d8d8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d8dc:	461a      	mov	r2, r3
 800d8de:	4b1d      	ldr	r3, [pc, #116]	; (800d954 <mtx7_execute+0xd4>)
 800d8e0:	f7f3 fc7e 	bl	80011e0 <chThdCreateStatic>
 800d8e4:	4602      	mov	r2, r0
 800d8e6:	4b1c      	ldr	r3, [pc, #112]	; (800d958 <mtx7_execute+0xd8>)
 800d8e8:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800d8ea:	4b18      	ldr	r3, [pc, #96]	; (800d94c <mtx7_execute+0xcc>)
 800d8ec:	68da      	ldr	r2, [r3, #12]
 800d8ee:	9b03      	ldr	r3, [sp, #12]
 800d8f0:	3304      	adds	r3, #4
 800d8f2:	491c      	ldr	r1, [pc, #112]	; (800d964 <mtx7_execute+0xe4>)
 800d8f4:	9100      	str	r1, [sp, #0]
 800d8f6:	4610      	mov	r0, r2
 800d8f8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d8fc:	461a      	mov	r2, r3
 800d8fe:	4b15      	ldr	r3, [pc, #84]	; (800d954 <mtx7_execute+0xd4>)
 800d900:	f7f3 fc6e 	bl	80011e0 <chThdCreateStatic>
 800d904:	4602      	mov	r2, r0
 800d906:	4b14      	ldr	r3, [pc, #80]	; (800d958 <mtx7_execute+0xd8>)
 800d908:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800d90a:	4b10      	ldr	r3, [pc, #64]	; (800d94c <mtx7_execute+0xcc>)
 800d90c:	691a      	ldr	r2, [r3, #16]
 800d90e:	9b03      	ldr	r3, [sp, #12]
 800d910:	3305      	adds	r3, #5
 800d912:	4915      	ldr	r1, [pc, #84]	; (800d968 <mtx7_execute+0xe8>)
 800d914:	9100      	str	r1, [sp, #0]
 800d916:	4610      	mov	r0, r2
 800d918:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d91c:	461a      	mov	r2, r3
 800d91e:	4b0d      	ldr	r3, [pc, #52]	; (800d954 <mtx7_execute+0xd4>)
 800d920:	f7f3 fc5e 	bl	80011e0 <chThdCreateStatic>
 800d924:	4602      	mov	r2, r0
 800d926:	4b0c      	ldr	r3, [pc, #48]	; (800d958 <mtx7_execute+0xd8>)
 800d928:	611a      	str	r2, [r3, #16]
  chCondBroadcast(&c1);
 800d92a:	4810      	ldr	r0, [pc, #64]	; (800d96c <mtx7_execute+0xec>)
 800d92c:	f7f4 fd58 	bl	80023e0 <chCondBroadcast>
  test_wait_threads();
 800d930:	f7fe fb0e 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800d934:	2001      	movs	r0, #1
 800d936:	490e      	ldr	r1, [pc, #56]	; (800d970 <mtx7_execute+0xf0>)
 800d938:	f7fe faa2 	bl	800be80 <_test_assert_sequence>
 800d93c:	4603      	mov	r3, r0
 800d93e:	2b00      	cmp	r3, #0
 800d940:	d000      	beq.n	800d944 <mtx7_execute+0xc4>
 800d942:	bf00      	nop
}
 800d944:	b005      	add	sp, #20
 800d946:	f85d fb04 	ldr.w	pc, [sp], #4
 800d94a:	bf00      	nop
 800d94c:	0801ad70 	.word	0x0801ad70
 800d950:	0801b140 	.word	0x0801b140
 800d954:	0800d711 	.word	0x0800d711
 800d958:	20003e3c 	.word	0x20003e3c
 800d95c:	0801b144 	.word	0x0801b144
 800d960:	0801b148 	.word	0x0801b148
 800d964:	0801b14c 	.word	0x0801b14c
 800d968:	0801b150 	.word	0x0801b150
 800d96c:	20000864 	.word	0x20000864
 800d970:	0801b154 	.word	0x0801b154
 800d974:	f3af 8000 	nop.w
 800d978:	f3af 8000 	nop.w
 800d97c:	f3af 8000 	nop.w

0800d980 <mtx8_setup>:
 * This test case verifies the priority boost of a thread waiting on a
 * conditional variable queue. It tests this very specific situation in order
 * to complete the code coverage.
 */

static void mtx8_setup(void) {
 800d980:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800d982:	4805      	ldr	r0, [pc, #20]	; (800d998 <mtx8_setup+0x18>)
 800d984:	f7f4 fce4 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800d988:	4804      	ldr	r0, [pc, #16]	; (800d99c <mtx8_setup+0x1c>)
 800d98a:	f7f4 fab1 	bl	8001ef0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800d98e:	4804      	ldr	r0, [pc, #16]	; (800d9a0 <mtx8_setup+0x20>)
 800d990:	f7f4 faae 	bl	8001ef0 <chMtxObjectInit>
}
 800d994:	bd08      	pop	{r3, pc}
 800d996:	bf00      	nop
 800d998:	20000864 	.word	0x20000864
 800d99c:	20000844 	.word	0x20000844
 800d9a0:	20000854 	.word	0x20000854
 800d9a4:	f3af 8000 	nop.w
 800d9a8:	f3af 8000 	nop.w
 800d9ac:	f3af 8000 	nop.w

0800d9b0 <thread11>:

static THD_FUNCTION(thread11, p) {
 800d9b0:	b500      	push	{lr}
 800d9b2:	b083      	sub	sp, #12
 800d9b4:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 800d9b6:	480c      	ldr	r0, [pc, #48]	; (800d9e8 <thread11+0x38>)
 800d9b8:	f7f4 faaa 	bl	8001f10 <chMtxLock>
  chMtxLock(&m1);
 800d9bc:	480b      	ldr	r0, [pc, #44]	; (800d9ec <thread11+0x3c>)
 800d9be:	f7f4 faa7 	bl	8001f10 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 800d9c2:	480b      	ldr	r0, [pc, #44]	; (800d9f0 <thread11+0x40>)
 800d9c4:	f04f 31ff 	mov.w	r1, #4294967295
 800d9c8:	f7f4 fd72 	bl	80024b0 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 800d9cc:	9b01      	ldr	r3, [sp, #4]
 800d9ce:	781b      	ldrb	r3, [r3, #0]
 800d9d0:	4618      	mov	r0, r3
 800d9d2:	f7fe fa0d 	bl	800bdf0 <test_emit_token>
  chMtxUnlock(&m1);
 800d9d6:	4805      	ldr	r0, [pc, #20]	; (800d9ec <thread11+0x3c>)
 800d9d8:	f7f4 fb42 	bl	8002060 <chMtxUnlock>
  chMtxUnlock(&m2);
 800d9dc:	4802      	ldr	r0, [pc, #8]	; (800d9e8 <thread11+0x38>)
 800d9de:	f7f4 fb3f 	bl	8002060 <chMtxUnlock>
}
 800d9e2:	b003      	add	sp, #12
 800d9e4:	f85d fb04 	ldr.w	pc, [sp], #4
 800d9e8:	20000854 	.word	0x20000854
 800d9ec:	20000844 	.word	0x20000844
 800d9f0:	20000864 	.word	0x20000864
 800d9f4:	f3af 8000 	nop.w
 800d9f8:	f3af 8000 	nop.w
 800d9fc:	f3af 8000 	nop.w

0800da00 <thread12>:

static THD_FUNCTION(thread12, p) {
 800da00:	b500      	push	{lr}
 800da02:	b083      	sub	sp, #12
 800da04:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 800da06:	4807      	ldr	r0, [pc, #28]	; (800da24 <thread12+0x24>)
 800da08:	f7f4 fa82 	bl	8001f10 <chMtxLock>
  test_emit_token(*(char *)p);
 800da0c:	9b01      	ldr	r3, [sp, #4]
 800da0e:	781b      	ldrb	r3, [r3, #0]
 800da10:	4618      	mov	r0, r3
 800da12:	f7fe f9ed 	bl	800bdf0 <test_emit_token>
  chMtxUnlock(&m2);
 800da16:	4803      	ldr	r0, [pc, #12]	; (800da24 <thread12+0x24>)
 800da18:	f7f4 fb22 	bl	8002060 <chMtxUnlock>
}
 800da1c:	b003      	add	sp, #12
 800da1e:	f85d fb04 	ldr.w	pc, [sp], #4
 800da22:	bf00      	nop
 800da24:	20000854 	.word	0x20000854
 800da28:	f3af 8000 	nop.w
 800da2c:	f3af 8000 	nop.w

0800da30 <mtx8_execute>:

static void mtx8_execute(void) {
 800da30:	b500      	push	{lr}
 800da32:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800da34:	f7ff fb54 	bl	800d0e0 <chThdGetPriorityX>
 800da38:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 800da3a:	4b21      	ldr	r3, [pc, #132]	; (800dac0 <mtx8_execute+0x90>)
 800da3c:	681a      	ldr	r2, [r3, #0]
 800da3e:	9b03      	ldr	r3, [sp, #12]
 800da40:	3301      	adds	r3, #1
 800da42:	4920      	ldr	r1, [pc, #128]	; (800dac4 <mtx8_execute+0x94>)
 800da44:	9100      	str	r1, [sp, #0]
 800da46:	4610      	mov	r0, r2
 800da48:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800da4c:	461a      	mov	r2, r3
 800da4e:	4b1e      	ldr	r3, [pc, #120]	; (800dac8 <mtx8_execute+0x98>)
 800da50:	f7f3 fbc6 	bl	80011e0 <chThdCreateStatic>
 800da54:	4602      	mov	r2, r0
 800da56:	4b1d      	ldr	r3, [pc, #116]	; (800dacc <mtx8_execute+0x9c>)
 800da58:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 800da5a:	4b19      	ldr	r3, [pc, #100]	; (800dac0 <mtx8_execute+0x90>)
 800da5c:	685a      	ldr	r2, [r3, #4]
 800da5e:	9b03      	ldr	r3, [sp, #12]
 800da60:	3302      	adds	r3, #2
 800da62:	491b      	ldr	r1, [pc, #108]	; (800dad0 <mtx8_execute+0xa0>)
 800da64:	9100      	str	r1, [sp, #0]
 800da66:	4610      	mov	r0, r2
 800da68:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800da6c:	461a      	mov	r2, r3
 800da6e:	4b19      	ldr	r3, [pc, #100]	; (800dad4 <mtx8_execute+0xa4>)
 800da70:	f7f3 fbb6 	bl	80011e0 <chThdCreateStatic>
 800da74:	4602      	mov	r2, r0
 800da76:	4b15      	ldr	r3, [pc, #84]	; (800dacc <mtx8_execute+0x9c>)
 800da78:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 800da7a:	4b11      	ldr	r3, [pc, #68]	; (800dac0 <mtx8_execute+0x90>)
 800da7c:	689a      	ldr	r2, [r3, #8]
 800da7e:	9b03      	ldr	r3, [sp, #12]
 800da80:	3303      	adds	r3, #3
 800da82:	4915      	ldr	r1, [pc, #84]	; (800dad8 <mtx8_execute+0xa8>)
 800da84:	9100      	str	r1, [sp, #0]
 800da86:	4610      	mov	r0, r2
 800da88:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800da8c:	461a      	mov	r2, r3
 800da8e:	4b13      	ldr	r3, [pc, #76]	; (800dadc <mtx8_execute+0xac>)
 800da90:	f7f3 fba6 	bl	80011e0 <chThdCreateStatic>
 800da94:	4602      	mov	r2, r0
 800da96:	4b0d      	ldr	r3, [pc, #52]	; (800dacc <mtx8_execute+0x9c>)
 800da98:	609a      	str	r2, [r3, #8]
  chCondSignal(&c1);
 800da9a:	4811      	ldr	r0, [pc, #68]	; (800dae0 <mtx8_execute+0xb0>)
 800da9c:	f7f4 fc68 	bl	8002370 <chCondSignal>
  chCondSignal(&c1);
 800daa0:	480f      	ldr	r0, [pc, #60]	; (800dae0 <mtx8_execute+0xb0>)
 800daa2:	f7f4 fc65 	bl	8002370 <chCondSignal>
  test_wait_threads();
 800daa6:	f7fe fa53 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 800daaa:	2001      	movs	r0, #1
 800daac:	490d      	ldr	r1, [pc, #52]	; (800dae4 <mtx8_execute+0xb4>)
 800daae:	f7fe f9e7 	bl	800be80 <_test_assert_sequence>
 800dab2:	4603      	mov	r3, r0
 800dab4:	2b00      	cmp	r3, #0
 800dab6:	d000      	beq.n	800daba <mtx8_execute+0x8a>
 800dab8:	bf00      	nop
}
 800daba:	b005      	add	sp, #20
 800dabc:	f85d fb04 	ldr.w	pc, [sp], #4
 800dac0:	0801ad70 	.word	0x0801ad70
 800dac4:	0801b150 	.word	0x0801b150
 800dac8:	0800d9b1 	.word	0x0800d9b1
 800dacc:	20003e3c 	.word	0x20003e3c
 800dad0:	0801b148 	.word	0x0801b148
 800dad4:	0800d711 	.word	0x0800d711
 800dad8:	0801b14c 	.word	0x0801b14c
 800dadc:	0800da01 	.word	0x0800da01
 800dae0:	20000864 	.word	0x20000864
 800dae4:	0801b22c 	.word	0x0801b22c
 800dae8:	f3af 8000 	nop.w
 800daec:	f3af 8000 	nop.w

0800daf0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800daf0:	4b01      	ldr	r3, [pc, #4]	; (800daf8 <chThdGetSelfX+0x8>)
 800daf2:	699b      	ldr	r3, [r3, #24]
}
 800daf4:	4618      	mov	r0, r3
 800daf6:	4770      	bx	lr
 800daf8:	200039a8 	.word	0x200039a8
 800dafc:	f3af 8000 	nop.w

0800db00 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800db00:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800db02:	f7ff fff5 	bl	800daf0 <chThdGetSelfX>
 800db06:	4603      	mov	r3, r0
 800db08:	689b      	ldr	r3, [r3, #8]
}
 800db0a:	4618      	mov	r0, r3
 800db0c:	bd08      	pop	{r3, pc}
 800db0e:	bf00      	nop

0800db10 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 800db10:	b082      	sub	sp, #8
 800db12:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 800db14:	9b01      	ldr	r3, [sp, #4]
 800db16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 800db18:	4618      	mov	r0, r3
 800db1a:	b002      	add	sp, #8
 800db1c:	4770      	bx	lr
 800db1e:	bf00      	nop

0800db20 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 800db20:	b500      	push	{lr}
 800db22:	b083      	sub	sp, #12
 800db24:	9001      	str	r0, [sp, #4]

  chMsgSend(p, 'A');
 800db26:	9801      	ldr	r0, [sp, #4]
 800db28:	2141      	movs	r1, #65	; 0x41
 800db2a:	f7f5 f839 	bl	8002ba0 <chMsgSend>
  chMsgSend(p, 'B');
 800db2e:	9801      	ldr	r0, [sp, #4]
 800db30:	2142      	movs	r1, #66	; 0x42
 800db32:	f7f5 f835 	bl	8002ba0 <chMsgSend>
  chMsgSend(p, 'C');
 800db36:	9801      	ldr	r0, [sp, #4]
 800db38:	2143      	movs	r1, #67	; 0x43
 800db3a:	f7f5 f831 	bl	8002ba0 <chMsgSend>
}
 800db3e:	b003      	add	sp, #12
 800db40:	f85d fb04 	ldr.w	pc, [sp], #4
 800db44:	f3af 8000 	nop.w
 800db48:	f3af 8000 	nop.w
 800db4c:	f3af 8000 	nop.w

0800db50 <msg1_execute>:

static void msg1_execute(void) {
 800db50:	b530      	push	{r4, r5, lr}
 800db52:	b085      	sub	sp, #20
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800db54:	4b26      	ldr	r3, [pc, #152]	; (800dbf0 <msg1_execute+0xa0>)
 800db56:	681d      	ldr	r5, [r3, #0]
 800db58:	f7ff ffd2 	bl	800db00 <chThdGetPriorityX>
 800db5c:	4603      	mov	r3, r0
 800db5e:	1c5c      	adds	r4, r3, #1
                                 thread, chThdGetSelfX());
 800db60:	f7ff ffc6 	bl	800daf0 <chThdGetSelfX>
 800db64:	4603      	mov	r3, r0
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800db66:	9300      	str	r3, [sp, #0]
 800db68:	4628      	mov	r0, r5
 800db6a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800db6e:	4622      	mov	r2, r4
 800db70:	4b20      	ldr	r3, [pc, #128]	; (800dbf4 <msg1_execute+0xa4>)
 800db72:	f7f3 fb35 	bl	80011e0 <chThdCreateStatic>
 800db76:	4602      	mov	r2, r0
 800db78:	4b1f      	ldr	r3, [pc, #124]	; (800dbf8 <msg1_execute+0xa8>)
 800db7a:	601a      	str	r2, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 800db7c:	f7f5 f840 	bl	8002c00 <chMsgWait>
 800db80:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800db82:	9803      	ldr	r0, [sp, #12]
 800db84:	f7ff ffc4 	bl	800db10 <chMsgGet>
 800db88:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800db8a:	9803      	ldr	r0, [sp, #12]
 800db8c:	9902      	ldr	r1, [sp, #8]
 800db8e:	f7f5 f85f 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800db92:	9b02      	ldr	r3, [sp, #8]
 800db94:	b2db      	uxtb	r3, r3
 800db96:	4618      	mov	r0, r3
 800db98:	f7fe f92a 	bl	800bdf0 <test_emit_token>
  tp = chMsgWait();
 800db9c:	f7f5 f830 	bl	8002c00 <chMsgWait>
 800dba0:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800dba2:	9803      	ldr	r0, [sp, #12]
 800dba4:	f7ff ffb4 	bl	800db10 <chMsgGet>
 800dba8:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800dbaa:	9803      	ldr	r0, [sp, #12]
 800dbac:	9902      	ldr	r1, [sp, #8]
 800dbae:	f7f5 f84f 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800dbb2:	9b02      	ldr	r3, [sp, #8]
 800dbb4:	b2db      	uxtb	r3, r3
 800dbb6:	4618      	mov	r0, r3
 800dbb8:	f7fe f91a 	bl	800bdf0 <test_emit_token>
  tp = chMsgWait();
 800dbbc:	f7f5 f820 	bl	8002c00 <chMsgWait>
 800dbc0:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800dbc2:	9803      	ldr	r0, [sp, #12]
 800dbc4:	f7ff ffa4 	bl	800db10 <chMsgGet>
 800dbc8:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800dbca:	9803      	ldr	r0, [sp, #12]
 800dbcc:	9902      	ldr	r1, [sp, #8]
 800dbce:	f7f5 f83f 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800dbd2:	9b02      	ldr	r3, [sp, #8]
 800dbd4:	b2db      	uxtb	r3, r3
 800dbd6:	4618      	mov	r0, r3
 800dbd8:	f7fe f90a 	bl	800bdf0 <test_emit_token>
  test_assert_sequence(1, "ABC");
 800dbdc:	2001      	movs	r0, #1
 800dbde:	4907      	ldr	r1, [pc, #28]	; (800dbfc <msg1_execute+0xac>)
 800dbe0:	f7fe f94e 	bl	800be80 <_test_assert_sequence>
 800dbe4:	4603      	mov	r3, r0
 800dbe6:	2b00      	cmp	r3, #0
 800dbe8:	d000      	beq.n	800dbec <msg1_execute+0x9c>
 800dbea:	bf00      	nop
}
 800dbec:	b005      	add	sp, #20
 800dbee:	bd30      	pop	{r4, r5, pc}
 800dbf0:	0801ad70 	.word	0x0801ad70
 800dbf4:	0800db21 	.word	0x0800db21
 800dbf8:	20003e3c 	.word	0x20003e3c
 800dbfc:	0801b270 	.word	0x0801b270

0800dc00 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800dc00:	b082      	sub	sp, #8
 800dc02:	2320      	movs	r3, #32
 800dc04:	9301      	str	r3, [sp, #4]
 800dc06:	9b01      	ldr	r3, [sp, #4]
 800dc08:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800dc0c:	b002      	add	sp, #8
 800dc0e:	4770      	bx	lr

0800dc10 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800dc10:	b082      	sub	sp, #8
 800dc12:	2300      	movs	r3, #0
 800dc14:	9301      	str	r3, [sp, #4]
 800dc16:	9b01      	ldr	r3, [sp, #4]
 800dc18:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800dc1c:	b002      	add	sp, #8
 800dc1e:	4770      	bx	lr

0800dc20 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800dc20:	b508      	push	{r3, lr}

  port_lock();
 800dc22:	f7ff ffed 	bl	800dc00 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800dc26:	bd08      	pop	{r3, pc}
 800dc28:	f3af 8000 	nop.w
 800dc2c:	f3af 8000 	nop.w

0800dc30 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800dc30:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800dc32:	f7ff ffed 	bl	800dc10 <port_unlock>
}
 800dc36:	bd08      	pop	{r3, pc}
 800dc38:	f3af 8000 	nop.w
 800dc3c:	f3af 8000 	nop.w

0800dc40 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 800dc40:	b082      	sub	sp, #8
 800dc42:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 800dc44:	9b01      	ldr	r3, [sp, #4]
 800dc46:	689b      	ldr	r3, [r3, #8]
}
 800dc48:	4618      	mov	r0, r3
 800dc4a:	b002      	add	sp, #8
 800dc4c:	4770      	bx	lr
 800dc4e:	bf00      	nop

0800dc50 <chMBGetFreeCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {
 800dc50:	b500      	push	{lr}
 800dc52:	b083      	sub	sp, #12
 800dc54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_emptysem);
 800dc56:	9b01      	ldr	r3, [sp, #4]
 800dc58:	331c      	adds	r3, #28
 800dc5a:	4618      	mov	r0, r3
 800dc5c:	f7ff fff0 	bl	800dc40 <chSemGetCounterI>
 800dc60:	4603      	mov	r3, r0
}
 800dc62:	4618      	mov	r0, r3
 800dc64:	b003      	add	sp, #12
 800dc66:	f85d fb04 	ldr.w	pc, [sp], #4
 800dc6a:	bf00      	nop
 800dc6c:	f3af 8000 	nop.w

0800dc70 <chMBGetUsedCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of queued messages.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {
 800dc70:	b500      	push	{lr}
 800dc72:	b083      	sub	sp, #12
 800dc74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_fullsem);
 800dc76:	9b01      	ldr	r3, [sp, #4]
 800dc78:	3310      	adds	r3, #16
 800dc7a:	4618      	mov	r0, r3
 800dc7c:	f7ff ffe0 	bl	800dc40 <chSemGetCounterI>
 800dc80:	4603      	mov	r3, r0
}
 800dc82:	4618      	mov	r0, r3
 800dc84:	b003      	add	sp, #12
 800dc86:	f85d fb04 	ldr.w	pc, [sp], #4
 800dc8a:	bf00      	nop
 800dc8c:	f3af 8000 	nop.w

0800dc90 <mbox1_setup>:
 * Messages are posted/fetched from a mailbox in carefully designed sequences
 * in order to stimulate all the possible code paths inside the mailbox.<br>
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {
 800dc90:	b508      	push	{r3, lr}

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
 800dc92:	4803      	ldr	r0, [pc, #12]	; (800dca0 <mbox1_setup+0x10>)
 800dc94:	4903      	ldr	r1, [pc, #12]	; (800dca4 <mbox1_setup+0x14>)
 800dc96:	2205      	movs	r2, #5
 800dc98:	f7f5 f822 	bl	8002ce0 <chMBObjectInit>
}
 800dc9c:	bd08      	pop	{r3, pc}
 800dc9e:	bf00      	nop
 800dca0:	2000086c 	.word	0x2000086c
 800dca4:	20003e50 	.word	0x20003e50
 800dca8:	f3af 8000 	nop.w
 800dcac:	f3af 8000 	nop.w

0800dcb0 <mbox1_execute>:

static void mbox1_execute(void) {
 800dcb0:	b500      	push	{lr}
 800dcb2:	b085      	sub	sp, #20
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800dcb4:	f7ff ffb4 	bl	800dc20 <chSysLock>
 800dcb8:	48a9      	ldr	r0, [pc, #676]	; (800df60 <mbox1_execute+0x2b0>)
 800dcba:	f7ff ffc9 	bl	800dc50 <chMBGetFreeCountI>
 800dcbe:	4603      	mov	r3, r0
 800dcc0:	2b05      	cmp	r3, #5
 800dcc2:	bf14      	ite	ne
 800dcc4:	2300      	movne	r3, #0
 800dcc6:	2301      	moveq	r3, #1
 800dcc8:	b2db      	uxtb	r3, r3
 800dcca:	2001      	movs	r0, #1
 800dccc:	4619      	mov	r1, r3
 800dcce:	f7fe f8bf 	bl	800be50 <_test_assert>
 800dcd2:	4603      	mov	r3, r0
 800dcd4:	2b00      	cmp	r3, #0
 800dcd6:	d002      	beq.n	800dcde <mbox1_execute+0x2e>
 800dcd8:	f7ff ffaa 	bl	800dc30 <chSysUnlock>
 800dcdc:	e3ef      	b.n	800e4be <mbox1_execute+0x80e>
 800dcde:	f7ff ffa7 	bl	800dc30 <chSysUnlock>

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800dce2:	2300      	movs	r3, #0
 800dce4:	9303      	str	r3, [sp, #12]
 800dce6:	e019      	b.n	800dd1c <mbox1_execute+0x6c>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800dce8:	9b03      	ldr	r3, [sp, #12]
 800dcea:	3342      	adds	r3, #66	; 0x42
 800dcec:	489c      	ldr	r0, [pc, #624]	; (800df60 <mbox1_execute+0x2b0>)
 800dcee:	4619      	mov	r1, r3
 800dcf0:	f04f 32ff 	mov.w	r2, #4294967295
 800dcf4:	f7f5 f854 	bl	8002da0 <chMBPost>
 800dcf8:	9002      	str	r0, [sp, #8]
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 800dcfa:	9b02      	ldr	r3, [sp, #8]
 800dcfc:	2b00      	cmp	r3, #0
 800dcfe:	bf14      	ite	ne
 800dd00:	2300      	movne	r3, #0
 800dd02:	2301      	moveq	r3, #1
 800dd04:	b2db      	uxtb	r3, r3
 800dd06:	2002      	movs	r0, #2
 800dd08:	4619      	mov	r1, r3
 800dd0a:	f7fe f8a1 	bl	800be50 <_test_assert>
 800dd0e:	4603      	mov	r3, r0
 800dd10:	2b00      	cmp	r3, #0
 800dd12:	d000      	beq.n	800dd16 <mbox1_execute+0x66>
 800dd14:	e3d3      	b.n	800e4be <mbox1_execute+0x80e>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800dd16:	9b03      	ldr	r3, [sp, #12]
 800dd18:	3301      	adds	r3, #1
 800dd1a:	9303      	str	r3, [sp, #12]
 800dd1c:	9b03      	ldr	r3, [sp, #12]
 800dd1e:	2b03      	cmp	r3, #3
 800dd20:	d9e2      	bls.n	800dce8 <mbox1_execute+0x38>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 800dd22:	488f      	ldr	r0, [pc, #572]	; (800df60 <mbox1_execute+0x2b0>)
 800dd24:	2141      	movs	r1, #65	; 0x41
 800dd26:	f04f 32ff 	mov.w	r2, #4294967295
 800dd2a:	f7f5 f8b1 	bl	8002e90 <chMBPostAhead>
 800dd2e:	9002      	str	r0, [sp, #8]
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 800dd30:	9b02      	ldr	r3, [sp, #8]
 800dd32:	2b00      	cmp	r3, #0
 800dd34:	bf14      	ite	ne
 800dd36:	2300      	movne	r3, #0
 800dd38:	2301      	moveq	r3, #1
 800dd3a:	b2db      	uxtb	r3, r3
 800dd3c:	2003      	movs	r0, #3
 800dd3e:	4619      	mov	r1, r3
 800dd40:	f7fe f886 	bl	800be50 <_test_assert>
 800dd44:	4603      	mov	r3, r0
 800dd46:	2b00      	cmp	r3, #0
 800dd48:	d000      	beq.n	800dd4c <mbox1_execute+0x9c>
 800dd4a:	e3b8      	b.n	800e4be <mbox1_execute+0x80e>

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 800dd4c:	4884      	ldr	r0, [pc, #528]	; (800df60 <mbox1_execute+0x2b0>)
 800dd4e:	2158      	movs	r1, #88	; 0x58
 800dd50:	2201      	movs	r2, #1
 800dd52:	f7f5 f825 	bl	8002da0 <chMBPost>
 800dd56:	9002      	str	r0, [sp, #8]
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800dd58:	9b02      	ldr	r3, [sp, #8]
 800dd5a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dd5e:	bf14      	ite	ne
 800dd60:	2300      	movne	r3, #0
 800dd62:	2301      	moveq	r3, #1
 800dd64:	b2db      	uxtb	r3, r3
 800dd66:	2004      	movs	r0, #4
 800dd68:	4619      	mov	r1, r3
 800dd6a:	f7fe f871 	bl	800be50 <_test_assert>
 800dd6e:	4603      	mov	r3, r0
 800dd70:	2b00      	cmp	r3, #0
 800dd72:	d000      	beq.n	800dd76 <mbox1_execute+0xc6>
 800dd74:	e3a3      	b.n	800e4be <mbox1_execute+0x80e>
  chSysLock();
 800dd76:	f7ff ff53 	bl	800dc20 <chSysLock>
  msg1 = chMBPostI(&mb1, 'X');
 800dd7a:	4879      	ldr	r0, [pc, #484]	; (800df60 <mbox1_execute+0x2b0>)
 800dd7c:	2158      	movs	r1, #88	; 0x58
 800dd7e:	f7f5 f857 	bl	8002e30 <chMBPostI>
 800dd82:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800dd84:	f7ff ff54 	bl	800dc30 <chSysUnlock>
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800dd88:	9b02      	ldr	r3, [sp, #8]
 800dd8a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dd8e:	bf14      	ite	ne
 800dd90:	2300      	movne	r3, #0
 800dd92:	2301      	moveq	r3, #1
 800dd94:	b2db      	uxtb	r3, r3
 800dd96:	2005      	movs	r0, #5
 800dd98:	4619      	mov	r1, r3
 800dd9a:	f7fe f859 	bl	800be50 <_test_assert>
 800dd9e:	4603      	mov	r3, r0
 800dda0:	2b00      	cmp	r3, #0
 800dda2:	d000      	beq.n	800dda6 <mbox1_execute+0xf6>
 800dda4:	e38b      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 800dda6:	486e      	ldr	r0, [pc, #440]	; (800df60 <mbox1_execute+0x2b0>)
 800dda8:	2158      	movs	r1, #88	; 0x58
 800ddaa:	2201      	movs	r2, #1
 800ddac:	f7f5 f870 	bl	8002e90 <chMBPostAhead>
 800ddb0:	9002      	str	r0, [sp, #8]
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800ddb2:	9b02      	ldr	r3, [sp, #8]
 800ddb4:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ddb8:	bf14      	ite	ne
 800ddba:	2300      	movne	r3, #0
 800ddbc:	2301      	moveq	r3, #1
 800ddbe:	b2db      	uxtb	r3, r3
 800ddc0:	2006      	movs	r0, #6
 800ddc2:	4619      	mov	r1, r3
 800ddc4:	f7fe f844 	bl	800be50 <_test_assert>
 800ddc8:	4603      	mov	r3, r0
 800ddca:	2b00      	cmp	r3, #0
 800ddcc:	d000      	beq.n	800ddd0 <mbox1_execute+0x120>
 800ddce:	e376      	b.n	800e4be <mbox1_execute+0x80e>
  chSysLock();
 800ddd0:	f7ff ff26 	bl	800dc20 <chSysLock>
  msg1 = chMBPostAheadI(&mb1, 'X');
 800ddd4:	4862      	ldr	r0, [pc, #392]	; (800df60 <mbox1_execute+0x2b0>)
 800ddd6:	2158      	movs	r1, #88	; 0x58
 800ddd8:	f7f5 f8a2 	bl	8002f20 <chMBPostAheadI>
 800dddc:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800ddde:	f7ff ff27 	bl	800dc30 <chSysUnlock>
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800dde2:	9b02      	ldr	r3, [sp, #8]
 800dde4:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dde8:	bf14      	ite	ne
 800ddea:	2300      	movne	r3, #0
 800ddec:	2301      	moveq	r3, #1
 800ddee:	b2db      	uxtb	r3, r3
 800ddf0:	2007      	movs	r0, #7
 800ddf2:	4619      	mov	r1, r3
 800ddf4:	f7fe f82c 	bl	800be50 <_test_assert>
 800ddf8:	4603      	mov	r3, r0
 800ddfa:	2b00      	cmp	r3, #0
 800ddfc:	d000      	beq.n	800de00 <mbox1_execute+0x150>
 800ddfe:	e35e      	b.n	800e4be <mbox1_execute+0x80e>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800de00:	f7ff ff0e 	bl	800dc20 <chSysLock>
 800de04:	4856      	ldr	r0, [pc, #344]	; (800df60 <mbox1_execute+0x2b0>)
 800de06:	f7ff ff23 	bl	800dc50 <chMBGetFreeCountI>
 800de0a:	4603      	mov	r3, r0
 800de0c:	2b00      	cmp	r3, #0
 800de0e:	bf14      	ite	ne
 800de10:	2300      	movne	r3, #0
 800de12:	2301      	moveq	r3, #1
 800de14:	b2db      	uxtb	r3, r3
 800de16:	2008      	movs	r0, #8
 800de18:	4619      	mov	r1, r3
 800de1a:	f7fe f819 	bl	800be50 <_test_assert>
 800de1e:	4603      	mov	r3, r0
 800de20:	2b00      	cmp	r3, #0
 800de22:	d002      	beq.n	800de2a <mbox1_execute+0x17a>
 800de24:	f7ff ff04 	bl	800dc30 <chSysUnlock>
 800de28:	e349      	b.n	800e4be <mbox1_execute+0x80e>
 800de2a:	f7ff ff01 	bl	800dc30 <chSysUnlock>
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800de2e:	f7ff fef7 	bl	800dc20 <chSysLock>
 800de32:	484b      	ldr	r0, [pc, #300]	; (800df60 <mbox1_execute+0x2b0>)
 800de34:	f7ff ff1c 	bl	800dc70 <chMBGetUsedCountI>
 800de38:	4603      	mov	r3, r0
 800de3a:	2b05      	cmp	r3, #5
 800de3c:	bf14      	ite	ne
 800de3e:	2300      	movne	r3, #0
 800de40:	2301      	moveq	r3, #1
 800de42:	b2db      	uxtb	r3, r3
 800de44:	2009      	movs	r0, #9
 800de46:	4619      	mov	r1, r3
 800de48:	f7fe f802 	bl	800be50 <_test_assert>
 800de4c:	4603      	mov	r3, r0
 800de4e:	2b00      	cmp	r3, #0
 800de50:	d002      	beq.n	800de58 <mbox1_execute+0x1a8>
 800de52:	f7ff feed 	bl	800dc30 <chSysUnlock>
 800de56:	e332      	b.n	800e4be <mbox1_execute+0x80e>
 800de58:	f7ff feea 	bl	800dc30 <chSysUnlock>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800de5c:	f7ff fee0 	bl	800dc20 <chSysLock>
 800de60:	4b3f      	ldr	r3, [pc, #252]	; (800df60 <mbox1_execute+0x2b0>)
 800de62:	68da      	ldr	r2, [r3, #12]
 800de64:	4b3e      	ldr	r3, [pc, #248]	; (800df60 <mbox1_execute+0x2b0>)
 800de66:	689b      	ldr	r3, [r3, #8]
 800de68:	429a      	cmp	r2, r3
 800de6a:	bf14      	ite	ne
 800de6c:	2300      	movne	r3, #0
 800de6e:	2301      	moveq	r3, #1
 800de70:	b2db      	uxtb	r3, r3
 800de72:	200a      	movs	r0, #10
 800de74:	4619      	mov	r1, r3
 800de76:	f7fd ffeb 	bl	800be50 <_test_assert>
 800de7a:	4603      	mov	r3, r0
 800de7c:	2b00      	cmp	r3, #0
 800de7e:	d002      	beq.n	800de86 <mbox1_execute+0x1d6>
 800de80:	f7ff fed6 	bl	800dc30 <chSysUnlock>
 800de84:	e31b      	b.n	800e4be <mbox1_execute+0x80e>
 800de86:	f7ff fed3 	bl	800dc30 <chSysUnlock>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800de8a:	2300      	movs	r3, #0
 800de8c:	9303      	str	r3, [sp, #12]
 800de8e:	e01d      	b.n	800decc <mbox1_execute+0x21c>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800de90:	ab01      	add	r3, sp, #4
 800de92:	4833      	ldr	r0, [pc, #204]	; (800df60 <mbox1_execute+0x2b0>)
 800de94:	4619      	mov	r1, r3
 800de96:	f04f 32ff 	mov.w	r2, #4294967295
 800de9a:	f7f5 f879 	bl	8002f90 <chMBFetch>
 800de9e:	9002      	str	r0, [sp, #8]
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 800dea0:	9b02      	ldr	r3, [sp, #8]
 800dea2:	2b00      	cmp	r3, #0
 800dea4:	bf14      	ite	ne
 800dea6:	2300      	movne	r3, #0
 800dea8:	2301      	moveq	r3, #1
 800deaa:	b2db      	uxtb	r3, r3
 800deac:	200b      	movs	r0, #11
 800deae:	4619      	mov	r1, r3
 800deb0:	f7fd ffce 	bl	800be50 <_test_assert>
 800deb4:	4603      	mov	r3, r0
 800deb6:	2b00      	cmp	r3, #0
 800deb8:	d000      	beq.n	800debc <mbox1_execute+0x20c>
 800deba:	e300      	b.n	800e4be <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800debc:	9b01      	ldr	r3, [sp, #4]
 800debe:	b2db      	uxtb	r3, r3
 800dec0:	4618      	mov	r0, r3
 800dec2:	f7fd ff95 	bl	800bdf0 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800dec6:	9b03      	ldr	r3, [sp, #12]
 800dec8:	3301      	adds	r3, #1
 800deca:	9303      	str	r3, [sp, #12]
 800decc:	9b03      	ldr	r3, [sp, #12]
 800dece:	2b04      	cmp	r3, #4
 800ded0:	d9de      	bls.n	800de90 <mbox1_execute+0x1e0>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 800ded2:	200c      	movs	r0, #12
 800ded4:	4923      	ldr	r1, [pc, #140]	; (800df64 <mbox1_execute+0x2b4>)
 800ded6:	f7fd ffd3 	bl	800be80 <_test_assert_sequence>
 800deda:	4603      	mov	r3, r0
 800dedc:	2b00      	cmp	r3, #0
 800dede:	d000      	beq.n	800dee2 <mbox1_execute+0x232>
 800dee0:	e2ed      	b.n	800e4be <mbox1_execute+0x80e>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800dee2:	9b03      	ldr	r3, [sp, #12]
 800dee4:	3342      	adds	r3, #66	; 0x42
 800dee6:	481e      	ldr	r0, [pc, #120]	; (800df60 <mbox1_execute+0x2b0>)
 800dee8:	4619      	mov	r1, r3
 800deea:	f04f 32ff 	mov.w	r2, #4294967295
 800deee:	f7f4 ff57 	bl	8002da0 <chMBPost>
 800def2:	9002      	str	r0, [sp, #8]
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 800def4:	9b02      	ldr	r3, [sp, #8]
 800def6:	2b00      	cmp	r3, #0
 800def8:	bf14      	ite	ne
 800defa:	2300      	movne	r3, #0
 800defc:	2301      	moveq	r3, #1
 800defe:	b2db      	uxtb	r3, r3
 800df00:	200d      	movs	r0, #13
 800df02:	4619      	mov	r1, r3
 800df04:	f7fd ffa4 	bl	800be50 <_test_assert>
 800df08:	4603      	mov	r3, r0
 800df0a:	2b00      	cmp	r3, #0
 800df0c:	d000      	beq.n	800df10 <mbox1_execute+0x260>
 800df0e:	e2d6      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800df10:	ab01      	add	r3, sp, #4
 800df12:	4813      	ldr	r0, [pc, #76]	; (800df60 <mbox1_execute+0x2b0>)
 800df14:	4619      	mov	r1, r3
 800df16:	f04f 32ff 	mov.w	r2, #4294967295
 800df1a:	f7f5 f839 	bl	8002f90 <chMBFetch>
 800df1e:	9002      	str	r0, [sp, #8]
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 800df20:	9b02      	ldr	r3, [sp, #8]
 800df22:	2b00      	cmp	r3, #0
 800df24:	bf14      	ite	ne
 800df26:	2300      	movne	r3, #0
 800df28:	2301      	moveq	r3, #1
 800df2a:	b2db      	uxtb	r3, r3
 800df2c:	200e      	movs	r0, #14
 800df2e:	4619      	mov	r1, r3
 800df30:	f7fd ff8e 	bl	800be50 <_test_assert>
 800df34:	4603      	mov	r3, r0
 800df36:	2b00      	cmp	r3, #0
 800df38:	d000      	beq.n	800df3c <mbox1_execute+0x28c>
 800df3a:	e2c0      	b.n	800e4be <mbox1_execute+0x80e>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800df3c:	4b08      	ldr	r3, [pc, #32]	; (800df60 <mbox1_execute+0x2b0>)
 800df3e:	681a      	ldr	r2, [r3, #0]
 800df40:	4b07      	ldr	r3, [pc, #28]	; (800df60 <mbox1_execute+0x2b0>)
 800df42:	689b      	ldr	r3, [r3, #8]
 800df44:	429a      	cmp	r2, r3
 800df46:	bf14      	ite	ne
 800df48:	2300      	movne	r3, #0
 800df4a:	2301      	moveq	r3, #1
 800df4c:	b2db      	uxtb	r3, r3
 800df4e:	200f      	movs	r0, #15
 800df50:	4619      	mov	r1, r3
 800df52:	f7fd ff7d 	bl	800be50 <_test_assert>
 800df56:	4603      	mov	r3, r0
 800df58:	2b00      	cmp	r3, #0
 800df5a:	d005      	beq.n	800df68 <mbox1_execute+0x2b8>
 800df5c:	e2af      	b.n	800e4be <mbox1_execute+0x80e>
 800df5e:	bf00      	nop
 800df60:	2000086c 	.word	0x2000086c
 800df64:	0801b2a0 	.word	0x0801b2a0
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 800df68:	4ba9      	ldr	r3, [pc, #676]	; (800e210 <mbox1_execute+0x560>)
 800df6a:	681a      	ldr	r2, [r3, #0]
 800df6c:	4ba8      	ldr	r3, [pc, #672]	; (800e210 <mbox1_execute+0x560>)
 800df6e:	68db      	ldr	r3, [r3, #12]
 800df70:	429a      	cmp	r2, r3
 800df72:	bf14      	ite	ne
 800df74:	2300      	movne	r3, #0
 800df76:	2301      	moveq	r3, #1
 800df78:	b2db      	uxtb	r3, r3
 800df7a:	2010      	movs	r0, #16
 800df7c:	4619      	mov	r1, r3
 800df7e:	f7fd ff67 	bl	800be50 <_test_assert>
 800df82:	4603      	mov	r3, r0
 800df84:	2b00      	cmp	r3, #0
 800df86:	d000      	beq.n	800df8a <mbox1_execute+0x2da>
 800df88:	e299      	b.n	800e4be <mbox1_execute+0x80e>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 800df8a:	ab01      	add	r3, sp, #4
 800df8c:	48a0      	ldr	r0, [pc, #640]	; (800e210 <mbox1_execute+0x560>)
 800df8e:	4619      	mov	r1, r3
 800df90:	2201      	movs	r2, #1
 800df92:	f7f4 fffd 	bl	8002f90 <chMBFetch>
 800df96:	9002      	str	r0, [sp, #8]
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800df98:	9b02      	ldr	r3, [sp, #8]
 800df9a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800df9e:	bf14      	ite	ne
 800dfa0:	2300      	movne	r3, #0
 800dfa2:	2301      	moveq	r3, #1
 800dfa4:	b2db      	uxtb	r3, r3
 800dfa6:	2011      	movs	r0, #17
 800dfa8:	4619      	mov	r1, r3
 800dfaa:	f7fd ff51 	bl	800be50 <_test_assert>
 800dfae:	4603      	mov	r3, r0
 800dfb0:	2b00      	cmp	r3, #0
 800dfb2:	d000      	beq.n	800dfb6 <mbox1_execute+0x306>
 800dfb4:	e283      	b.n	800e4be <mbox1_execute+0x80e>
  chSysLock();
 800dfb6:	f7ff fe33 	bl	800dc20 <chSysLock>
  msg1 = chMBFetchI(&mb1, &msg2);
 800dfba:	ab01      	add	r3, sp, #4
 800dfbc:	4894      	ldr	r0, [pc, #592]	; (800e210 <mbox1_execute+0x560>)
 800dfbe:	4619      	mov	r1, r3
 800dfc0:	f7f5 f82e 	bl	8003020 <chMBFetchI>
 800dfc4:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800dfc6:	f7ff fe33 	bl	800dc30 <chSysUnlock>
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800dfca:	9b02      	ldr	r3, [sp, #8]
 800dfcc:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dfd0:	bf14      	ite	ne
 800dfd2:	2300      	movne	r3, #0
 800dfd4:	2301      	moveq	r3, #1
 800dfd6:	b2db      	uxtb	r3, r3
 800dfd8:	2012      	movs	r0, #18
 800dfda:	4619      	mov	r1, r3
 800dfdc:	f7fd ff38 	bl	800be50 <_test_assert>
 800dfe0:	4603      	mov	r3, r0
 800dfe2:	2b00      	cmp	r3, #0
 800dfe4:	d000      	beq.n	800dfe8 <mbox1_execute+0x338>
 800dfe6:	e26a      	b.n	800e4be <mbox1_execute+0x80e>

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800dfe8:	f7ff fe1a 	bl	800dc20 <chSysLock>
 800dfec:	4888      	ldr	r0, [pc, #544]	; (800e210 <mbox1_execute+0x560>)
 800dfee:	f7ff fe2f 	bl	800dc50 <chMBGetFreeCountI>
 800dff2:	4603      	mov	r3, r0
 800dff4:	2b05      	cmp	r3, #5
 800dff6:	bf14      	ite	ne
 800dff8:	2300      	movne	r3, #0
 800dffa:	2301      	moveq	r3, #1
 800dffc:	b2db      	uxtb	r3, r3
 800dffe:	2013      	movs	r0, #19
 800e000:	4619      	mov	r1, r3
 800e002:	f7fd ff25 	bl	800be50 <_test_assert>
 800e006:	4603      	mov	r3, r0
 800e008:	2b00      	cmp	r3, #0
 800e00a:	d002      	beq.n	800e012 <mbox1_execute+0x362>
 800e00c:	f7ff fe10 	bl	800dc30 <chSysUnlock>
 800e010:	e255      	b.n	800e4be <mbox1_execute+0x80e>
 800e012:	f7ff fe0d 	bl	800dc30 <chSysUnlock>
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e016:	f7ff fe03 	bl	800dc20 <chSysLock>
 800e01a:	487d      	ldr	r0, [pc, #500]	; (800e210 <mbox1_execute+0x560>)
 800e01c:	f7ff fe28 	bl	800dc70 <chMBGetUsedCountI>
 800e020:	4603      	mov	r3, r0
 800e022:	2b00      	cmp	r3, #0
 800e024:	bf14      	ite	ne
 800e026:	2300      	movne	r3, #0
 800e028:	2301      	moveq	r3, #1
 800e02a:	b2db      	uxtb	r3, r3
 800e02c:	2014      	movs	r0, #20
 800e02e:	4619      	mov	r1, r3
 800e030:	f7fd ff0e 	bl	800be50 <_test_assert>
 800e034:	4603      	mov	r3, r0
 800e036:	2b00      	cmp	r3, #0
 800e038:	d002      	beq.n	800e040 <mbox1_execute+0x390>
 800e03a:	f7ff fdf9 	bl	800dc30 <chSysUnlock>
 800e03e:	e23e      	b.n	800e4be <mbox1_execute+0x80e>
 800e040:	f7ff fdf6 	bl	800dc30 <chSysUnlock>
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e044:	f7ff fdec 	bl	800dc20 <chSysLock>
 800e048:	4b71      	ldr	r3, [pc, #452]	; (800e210 <mbox1_execute+0x560>)
 800e04a:	68da      	ldr	r2, [r3, #12]
 800e04c:	4b70      	ldr	r3, [pc, #448]	; (800e210 <mbox1_execute+0x560>)
 800e04e:	689b      	ldr	r3, [r3, #8]
 800e050:	429a      	cmp	r2, r3
 800e052:	bf14      	ite	ne
 800e054:	2300      	movne	r3, #0
 800e056:	2301      	moveq	r3, #1
 800e058:	b2db      	uxtb	r3, r3
 800e05a:	2015      	movs	r0, #21
 800e05c:	4619      	mov	r1, r3
 800e05e:	f7fd fef7 	bl	800be50 <_test_assert>
 800e062:	4603      	mov	r3, r0
 800e064:	2b00      	cmp	r3, #0
 800e066:	d002      	beq.n	800e06e <mbox1_execute+0x3be>
 800e068:	f7ff fde2 	bl	800dc30 <chSysUnlock>
 800e06c:	e227      	b.n	800e4be <mbox1_execute+0x80e>
 800e06e:	f7ff fddf 	bl	800dc30 <chSysUnlock>

  /*
   * Testing I-Class.
   */
  chSysLock();
 800e072:	f7ff fdd5 	bl	800dc20 <chSysLock>
  msg1 = chMBPostI(&mb1, 'A');
 800e076:	4866      	ldr	r0, [pc, #408]	; (800e210 <mbox1_execute+0x560>)
 800e078:	2141      	movs	r1, #65	; 0x41
 800e07a:	f7f4 fed9 	bl	8002e30 <chMBPostI>
 800e07e:	9002      	str	r0, [sp, #8]
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 800e080:	9b02      	ldr	r3, [sp, #8]
 800e082:	2b00      	cmp	r3, #0
 800e084:	bf14      	ite	ne
 800e086:	2300      	movne	r3, #0
 800e088:	2301      	moveq	r3, #1
 800e08a:	b2db      	uxtb	r3, r3
 800e08c:	2016      	movs	r0, #22
 800e08e:	4619      	mov	r1, r3
 800e090:	f7fd fede 	bl	800be50 <_test_assert>
 800e094:	4603      	mov	r3, r0
 800e096:	2b00      	cmp	r3, #0
 800e098:	d000      	beq.n	800e09c <mbox1_execute+0x3ec>
 800e09a:	e210      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'B');
 800e09c:	485c      	ldr	r0, [pc, #368]	; (800e210 <mbox1_execute+0x560>)
 800e09e:	2142      	movs	r1, #66	; 0x42
 800e0a0:	f7f4 fec6 	bl	8002e30 <chMBPostI>
 800e0a4:	9002      	str	r0, [sp, #8]
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 800e0a6:	9b02      	ldr	r3, [sp, #8]
 800e0a8:	2b00      	cmp	r3, #0
 800e0aa:	bf14      	ite	ne
 800e0ac:	2300      	movne	r3, #0
 800e0ae:	2301      	moveq	r3, #1
 800e0b0:	b2db      	uxtb	r3, r3
 800e0b2:	2017      	movs	r0, #23
 800e0b4:	4619      	mov	r1, r3
 800e0b6:	f7fd fecb 	bl	800be50 <_test_assert>
 800e0ba:	4603      	mov	r3, r0
 800e0bc:	2b00      	cmp	r3, #0
 800e0be:	d000      	beq.n	800e0c2 <mbox1_execute+0x412>
 800e0c0:	e1fd      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'C');
 800e0c2:	4853      	ldr	r0, [pc, #332]	; (800e210 <mbox1_execute+0x560>)
 800e0c4:	2143      	movs	r1, #67	; 0x43
 800e0c6:	f7f4 feb3 	bl	8002e30 <chMBPostI>
 800e0ca:	9002      	str	r0, [sp, #8]
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 800e0cc:	9b02      	ldr	r3, [sp, #8]
 800e0ce:	2b00      	cmp	r3, #0
 800e0d0:	bf14      	ite	ne
 800e0d2:	2300      	movne	r3, #0
 800e0d4:	2301      	moveq	r3, #1
 800e0d6:	b2db      	uxtb	r3, r3
 800e0d8:	2018      	movs	r0, #24
 800e0da:	4619      	mov	r1, r3
 800e0dc:	f7fd feb8 	bl	800be50 <_test_assert>
 800e0e0:	4603      	mov	r3, r0
 800e0e2:	2b00      	cmp	r3, #0
 800e0e4:	d000      	beq.n	800e0e8 <mbox1_execute+0x438>
 800e0e6:	e1ea      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'D');
 800e0e8:	4849      	ldr	r0, [pc, #292]	; (800e210 <mbox1_execute+0x560>)
 800e0ea:	2144      	movs	r1, #68	; 0x44
 800e0ec:	f7f4 fea0 	bl	8002e30 <chMBPostI>
 800e0f0:	9002      	str	r0, [sp, #8]
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 800e0f2:	9b02      	ldr	r3, [sp, #8]
 800e0f4:	2b00      	cmp	r3, #0
 800e0f6:	bf14      	ite	ne
 800e0f8:	2300      	movne	r3, #0
 800e0fa:	2301      	moveq	r3, #1
 800e0fc:	b2db      	uxtb	r3, r3
 800e0fe:	2019      	movs	r0, #25
 800e100:	4619      	mov	r1, r3
 800e102:	f7fd fea5 	bl	800be50 <_test_assert>
 800e106:	4603      	mov	r3, r0
 800e108:	2b00      	cmp	r3, #0
 800e10a:	d000      	beq.n	800e10e <mbox1_execute+0x45e>
 800e10c:	e1d7      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'E');
 800e10e:	4840      	ldr	r0, [pc, #256]	; (800e210 <mbox1_execute+0x560>)
 800e110:	2145      	movs	r1, #69	; 0x45
 800e112:	f7f4 fe8d 	bl	8002e30 <chMBPostI>
 800e116:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800e118:	f7ff fd8a 	bl	800dc30 <chSysUnlock>
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 800e11c:	9b02      	ldr	r3, [sp, #8]
 800e11e:	2b00      	cmp	r3, #0
 800e120:	bf14      	ite	ne
 800e122:	2300      	movne	r3, #0
 800e124:	2301      	moveq	r3, #1
 800e126:	b2db      	uxtb	r3, r3
 800e128:	201a      	movs	r0, #26
 800e12a:	4619      	mov	r1, r3
 800e12c:	f7fd fe90 	bl	800be50 <_test_assert>
 800e130:	4603      	mov	r3, r0
 800e132:	2b00      	cmp	r3, #0
 800e134:	d000      	beq.n	800e138 <mbox1_execute+0x488>
 800e136:	e1c2      	b.n	800e4be <mbox1_execute+0x80e>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e138:	4b35      	ldr	r3, [pc, #212]	; (800e210 <mbox1_execute+0x560>)
 800e13a:	68da      	ldr	r2, [r3, #12]
 800e13c:	4b34      	ldr	r3, [pc, #208]	; (800e210 <mbox1_execute+0x560>)
 800e13e:	689b      	ldr	r3, [r3, #8]
 800e140:	429a      	cmp	r2, r3
 800e142:	bf14      	ite	ne
 800e144:	2300      	movne	r3, #0
 800e146:	2301      	moveq	r3, #1
 800e148:	b2db      	uxtb	r3, r3
 800e14a:	201b      	movs	r0, #27
 800e14c:	4619      	mov	r1, r3
 800e14e:	f7fd fe7f 	bl	800be50 <_test_assert>
 800e152:	4603      	mov	r3, r0
 800e154:	2b00      	cmp	r3, #0
 800e156:	d000      	beq.n	800e15a <mbox1_execute+0x4aa>
 800e158:	e1b1      	b.n	800e4be <mbox1_execute+0x80e>
  for (i = 0; i < MB_SIZE; i++) {
 800e15a:	2300      	movs	r3, #0
 800e15c:	9303      	str	r3, [sp, #12]
 800e15e:	e01f      	b.n	800e1a0 <mbox1_execute+0x4f0>
    chSysLock();
 800e160:	f7ff fd5e 	bl	800dc20 <chSysLock>
    msg1 = chMBFetchI(&mb1, &msg2);
 800e164:	ab01      	add	r3, sp, #4
 800e166:	482a      	ldr	r0, [pc, #168]	; (800e210 <mbox1_execute+0x560>)
 800e168:	4619      	mov	r1, r3
 800e16a:	f7f4 ff59 	bl	8003020 <chMBFetchI>
 800e16e:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800e170:	f7ff fd5e 	bl	800dc30 <chSysUnlock>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 800e174:	9b02      	ldr	r3, [sp, #8]
 800e176:	2b00      	cmp	r3, #0
 800e178:	bf14      	ite	ne
 800e17a:	2300      	movne	r3, #0
 800e17c:	2301      	moveq	r3, #1
 800e17e:	b2db      	uxtb	r3, r3
 800e180:	201c      	movs	r0, #28
 800e182:	4619      	mov	r1, r3
 800e184:	f7fd fe64 	bl	800be50 <_test_assert>
 800e188:	4603      	mov	r3, r0
 800e18a:	2b00      	cmp	r3, #0
 800e18c:	d000      	beq.n	800e190 <mbox1_execute+0x4e0>
 800e18e:	e196      	b.n	800e4be <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800e190:	9b01      	ldr	r3, [sp, #4]
 800e192:	b2db      	uxtb	r3, r3
 800e194:	4618      	mov	r0, r3
 800e196:	f7fd fe2b 	bl	800bdf0 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800e19a:	9b03      	ldr	r3, [sp, #12]
 800e19c:	3301      	adds	r3, #1
 800e19e:	9303      	str	r3, [sp, #12]
 800e1a0:	9b03      	ldr	r3, [sp, #12]
 800e1a2:	2b04      	cmp	r3, #4
 800e1a4:	d9dc      	bls.n	800e160 <mbox1_execute+0x4b0>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 800e1a6:	201d      	movs	r0, #29
 800e1a8:	491a      	ldr	r1, [pc, #104]	; (800e214 <mbox1_execute+0x564>)
 800e1aa:	f7fd fe69 	bl	800be80 <_test_assert_sequence>
 800e1ae:	4603      	mov	r3, r0
 800e1b0:	2b00      	cmp	r3, #0
 800e1b2:	d000      	beq.n	800e1b6 <mbox1_execute+0x506>
 800e1b4:	e183      	b.n	800e4be <mbox1_execute+0x80e>
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e1b6:	f7ff fd33 	bl	800dc20 <chSysLock>
 800e1ba:	4815      	ldr	r0, [pc, #84]	; (800e210 <mbox1_execute+0x560>)
 800e1bc:	f7ff fd48 	bl	800dc50 <chMBGetFreeCountI>
 800e1c0:	4603      	mov	r3, r0
 800e1c2:	2b05      	cmp	r3, #5
 800e1c4:	bf14      	ite	ne
 800e1c6:	2300      	movne	r3, #0
 800e1c8:	2301      	moveq	r3, #1
 800e1ca:	b2db      	uxtb	r3, r3
 800e1cc:	201e      	movs	r0, #30
 800e1ce:	4619      	mov	r1, r3
 800e1d0:	f7fd fe3e 	bl	800be50 <_test_assert>
 800e1d4:	4603      	mov	r3, r0
 800e1d6:	2b00      	cmp	r3, #0
 800e1d8:	d002      	beq.n	800e1e0 <mbox1_execute+0x530>
 800e1da:	f7ff fd29 	bl	800dc30 <chSysUnlock>
 800e1de:	e16e      	b.n	800e4be <mbox1_execute+0x80e>
 800e1e0:	f7ff fd26 	bl	800dc30 <chSysUnlock>
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e1e4:	f7ff fd1c 	bl	800dc20 <chSysLock>
 800e1e8:	4809      	ldr	r0, [pc, #36]	; (800e210 <mbox1_execute+0x560>)
 800e1ea:	f7ff fd41 	bl	800dc70 <chMBGetUsedCountI>
 800e1ee:	4603      	mov	r3, r0
 800e1f0:	2b00      	cmp	r3, #0
 800e1f2:	bf14      	ite	ne
 800e1f4:	2300      	movne	r3, #0
 800e1f6:	2301      	moveq	r3, #1
 800e1f8:	b2db      	uxtb	r3, r3
 800e1fa:	201f      	movs	r0, #31
 800e1fc:	4619      	mov	r1, r3
 800e1fe:	f7fd fe27 	bl	800be50 <_test_assert>
 800e202:	4603      	mov	r3, r0
 800e204:	2b00      	cmp	r3, #0
 800e206:	d007      	beq.n	800e218 <mbox1_execute+0x568>
 800e208:	f7ff fd12 	bl	800dc30 <chSysUnlock>
 800e20c:	e157      	b.n	800e4be <mbox1_execute+0x80e>
 800e20e:	bf00      	nop
 800e210:	2000086c 	.word	0x2000086c
 800e214:	0801b2a0 	.word	0x0801b2a0
 800e218:	f7ff fd0a 	bl	800dc30 <chSysUnlock>
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e21c:	4ba9      	ldr	r3, [pc, #676]	; (800e4c4 <mbox1_execute+0x814>)
 800e21e:	68da      	ldr	r2, [r3, #12]
 800e220:	4ba8      	ldr	r3, [pc, #672]	; (800e4c4 <mbox1_execute+0x814>)
 800e222:	689b      	ldr	r3, [r3, #8]
 800e224:	429a      	cmp	r2, r3
 800e226:	bf14      	ite	ne
 800e228:	2300      	movne	r3, #0
 800e22a:	2301      	moveq	r3, #1
 800e22c:	b2db      	uxtb	r3, r3
 800e22e:	2020      	movs	r0, #32
 800e230:	4619      	mov	r1, r3
 800e232:	f7fd fe0d 	bl	800be50 <_test_assert>
 800e236:	4603      	mov	r3, r0
 800e238:	2b00      	cmp	r3, #0
 800e23a:	d000      	beq.n	800e23e <mbox1_execute+0x58e>
 800e23c:	e13f      	b.n	800e4be <mbox1_execute+0x80e>

  chSysLock();
 800e23e:	f7ff fcef 	bl	800dc20 <chSysLock>
  msg1 = chMBPostAheadI(&mb1, 'E');
 800e242:	48a0      	ldr	r0, [pc, #640]	; (800e4c4 <mbox1_execute+0x814>)
 800e244:	2145      	movs	r1, #69	; 0x45
 800e246:	f7f4 fe6b 	bl	8002f20 <chMBPostAheadI>
 800e24a:	9002      	str	r0, [sp, #8]
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 800e24c:	9b02      	ldr	r3, [sp, #8]
 800e24e:	2b00      	cmp	r3, #0
 800e250:	bf14      	ite	ne
 800e252:	2300      	movne	r3, #0
 800e254:	2301      	moveq	r3, #1
 800e256:	b2db      	uxtb	r3, r3
 800e258:	2021      	movs	r0, #33	; 0x21
 800e25a:	4619      	mov	r1, r3
 800e25c:	f7fd fdf8 	bl	800be50 <_test_assert>
 800e260:	4603      	mov	r3, r0
 800e262:	2b00      	cmp	r3, #0
 800e264:	d000      	beq.n	800e268 <mbox1_execute+0x5b8>
 800e266:	e12a      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'D');
 800e268:	4896      	ldr	r0, [pc, #600]	; (800e4c4 <mbox1_execute+0x814>)
 800e26a:	2144      	movs	r1, #68	; 0x44
 800e26c:	f7f4 fe58 	bl	8002f20 <chMBPostAheadI>
 800e270:	9002      	str	r0, [sp, #8]
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 800e272:	9b02      	ldr	r3, [sp, #8]
 800e274:	2b00      	cmp	r3, #0
 800e276:	bf14      	ite	ne
 800e278:	2300      	movne	r3, #0
 800e27a:	2301      	moveq	r3, #1
 800e27c:	b2db      	uxtb	r3, r3
 800e27e:	2022      	movs	r0, #34	; 0x22
 800e280:	4619      	mov	r1, r3
 800e282:	f7fd fde5 	bl	800be50 <_test_assert>
 800e286:	4603      	mov	r3, r0
 800e288:	2b00      	cmp	r3, #0
 800e28a:	d000      	beq.n	800e28e <mbox1_execute+0x5de>
 800e28c:	e117      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'C');
 800e28e:	488d      	ldr	r0, [pc, #564]	; (800e4c4 <mbox1_execute+0x814>)
 800e290:	2143      	movs	r1, #67	; 0x43
 800e292:	f7f4 fe45 	bl	8002f20 <chMBPostAheadI>
 800e296:	9002      	str	r0, [sp, #8]
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 800e298:	9b02      	ldr	r3, [sp, #8]
 800e29a:	2b00      	cmp	r3, #0
 800e29c:	bf14      	ite	ne
 800e29e:	2300      	movne	r3, #0
 800e2a0:	2301      	moveq	r3, #1
 800e2a2:	b2db      	uxtb	r3, r3
 800e2a4:	2023      	movs	r0, #35	; 0x23
 800e2a6:	4619      	mov	r1, r3
 800e2a8:	f7fd fdd2 	bl	800be50 <_test_assert>
 800e2ac:	4603      	mov	r3, r0
 800e2ae:	2b00      	cmp	r3, #0
 800e2b0:	d000      	beq.n	800e2b4 <mbox1_execute+0x604>
 800e2b2:	e104      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'B');
 800e2b4:	4883      	ldr	r0, [pc, #524]	; (800e4c4 <mbox1_execute+0x814>)
 800e2b6:	2142      	movs	r1, #66	; 0x42
 800e2b8:	f7f4 fe32 	bl	8002f20 <chMBPostAheadI>
 800e2bc:	9002      	str	r0, [sp, #8]
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 800e2be:	9b02      	ldr	r3, [sp, #8]
 800e2c0:	2b00      	cmp	r3, #0
 800e2c2:	bf14      	ite	ne
 800e2c4:	2300      	movne	r3, #0
 800e2c6:	2301      	moveq	r3, #1
 800e2c8:	b2db      	uxtb	r3, r3
 800e2ca:	2024      	movs	r0, #36	; 0x24
 800e2cc:	4619      	mov	r1, r3
 800e2ce:	f7fd fdbf 	bl	800be50 <_test_assert>
 800e2d2:	4603      	mov	r3, r0
 800e2d4:	2b00      	cmp	r3, #0
 800e2d6:	d000      	beq.n	800e2da <mbox1_execute+0x62a>
 800e2d8:	e0f1      	b.n	800e4be <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'A');
 800e2da:	487a      	ldr	r0, [pc, #488]	; (800e4c4 <mbox1_execute+0x814>)
 800e2dc:	2141      	movs	r1, #65	; 0x41
 800e2de:	f7f4 fe1f 	bl	8002f20 <chMBPostAheadI>
 800e2e2:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800e2e4:	f7ff fca4 	bl	800dc30 <chSysUnlock>
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 800e2e8:	9b02      	ldr	r3, [sp, #8]
 800e2ea:	2b00      	cmp	r3, #0
 800e2ec:	bf14      	ite	ne
 800e2ee:	2300      	movne	r3, #0
 800e2f0:	2301      	moveq	r3, #1
 800e2f2:	b2db      	uxtb	r3, r3
 800e2f4:	2025      	movs	r0, #37	; 0x25
 800e2f6:	4619      	mov	r1, r3
 800e2f8:	f7fd fdaa 	bl	800be50 <_test_assert>
 800e2fc:	4603      	mov	r3, r0
 800e2fe:	2b00      	cmp	r3, #0
 800e300:	d000      	beq.n	800e304 <mbox1_execute+0x654>
 800e302:	e0dc      	b.n	800e4be <mbox1_execute+0x80e>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e304:	4b6f      	ldr	r3, [pc, #444]	; (800e4c4 <mbox1_execute+0x814>)
 800e306:	68da      	ldr	r2, [r3, #12]
 800e308:	4b6e      	ldr	r3, [pc, #440]	; (800e4c4 <mbox1_execute+0x814>)
 800e30a:	689b      	ldr	r3, [r3, #8]
 800e30c:	429a      	cmp	r2, r3
 800e30e:	bf14      	ite	ne
 800e310:	2300      	movne	r3, #0
 800e312:	2301      	moveq	r3, #1
 800e314:	b2db      	uxtb	r3, r3
 800e316:	2026      	movs	r0, #38	; 0x26
 800e318:	4619      	mov	r1, r3
 800e31a:	f7fd fd99 	bl	800be50 <_test_assert>
 800e31e:	4603      	mov	r3, r0
 800e320:	2b00      	cmp	r3, #0
 800e322:	d000      	beq.n	800e326 <mbox1_execute+0x676>
 800e324:	e0cb      	b.n	800e4be <mbox1_execute+0x80e>
  for (i = 0; i < MB_SIZE; i++) {
 800e326:	2300      	movs	r3, #0
 800e328:	9303      	str	r3, [sp, #12]
 800e32a:	e01f      	b.n	800e36c <mbox1_execute+0x6bc>
    chSysLock();
 800e32c:	f7ff fc78 	bl	800dc20 <chSysLock>
    msg1 = chMBFetchI(&mb1, &msg2);
 800e330:	ab01      	add	r3, sp, #4
 800e332:	4864      	ldr	r0, [pc, #400]	; (800e4c4 <mbox1_execute+0x814>)
 800e334:	4619      	mov	r1, r3
 800e336:	f7f4 fe73 	bl	8003020 <chMBFetchI>
 800e33a:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800e33c:	f7ff fc78 	bl	800dc30 <chSysUnlock>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 800e340:	9b02      	ldr	r3, [sp, #8]
 800e342:	2b00      	cmp	r3, #0
 800e344:	bf14      	ite	ne
 800e346:	2300      	movne	r3, #0
 800e348:	2301      	moveq	r3, #1
 800e34a:	b2db      	uxtb	r3, r3
 800e34c:	2027      	movs	r0, #39	; 0x27
 800e34e:	4619      	mov	r1, r3
 800e350:	f7fd fd7e 	bl	800be50 <_test_assert>
 800e354:	4603      	mov	r3, r0
 800e356:	2b00      	cmp	r3, #0
 800e358:	d000      	beq.n	800e35c <mbox1_execute+0x6ac>
 800e35a:	e0b0      	b.n	800e4be <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800e35c:	9b01      	ldr	r3, [sp, #4]
 800e35e:	b2db      	uxtb	r3, r3
 800e360:	4618      	mov	r0, r3
 800e362:	f7fd fd45 	bl	800bdf0 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800e366:	9b03      	ldr	r3, [sp, #12]
 800e368:	3301      	adds	r3, #1
 800e36a:	9303      	str	r3, [sp, #12]
 800e36c:	9b03      	ldr	r3, [sp, #12]
 800e36e:	2b04      	cmp	r3, #4
 800e370:	d9dc      	bls.n	800e32c <mbox1_execute+0x67c>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 800e372:	2028      	movs	r0, #40	; 0x28
 800e374:	4954      	ldr	r1, [pc, #336]	; (800e4c8 <mbox1_execute+0x818>)
 800e376:	f7fd fd83 	bl	800be80 <_test_assert_sequence>
 800e37a:	4603      	mov	r3, r0
 800e37c:	2b00      	cmp	r3, #0
 800e37e:	d000      	beq.n	800e382 <mbox1_execute+0x6d2>
 800e380:	e09d      	b.n	800e4be <mbox1_execute+0x80e>
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e382:	f7ff fc4d 	bl	800dc20 <chSysLock>
 800e386:	484f      	ldr	r0, [pc, #316]	; (800e4c4 <mbox1_execute+0x814>)
 800e388:	f7ff fc62 	bl	800dc50 <chMBGetFreeCountI>
 800e38c:	4603      	mov	r3, r0
 800e38e:	2b05      	cmp	r3, #5
 800e390:	bf14      	ite	ne
 800e392:	2300      	movne	r3, #0
 800e394:	2301      	moveq	r3, #1
 800e396:	b2db      	uxtb	r3, r3
 800e398:	2029      	movs	r0, #41	; 0x29
 800e39a:	4619      	mov	r1, r3
 800e39c:	f7fd fd58 	bl	800be50 <_test_assert>
 800e3a0:	4603      	mov	r3, r0
 800e3a2:	2b00      	cmp	r3, #0
 800e3a4:	d002      	beq.n	800e3ac <mbox1_execute+0x6fc>
 800e3a6:	f7ff fc43 	bl	800dc30 <chSysUnlock>
 800e3aa:	e088      	b.n	800e4be <mbox1_execute+0x80e>
 800e3ac:	f7ff fc40 	bl	800dc30 <chSysUnlock>
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e3b0:	f7ff fc36 	bl	800dc20 <chSysLock>
 800e3b4:	4843      	ldr	r0, [pc, #268]	; (800e4c4 <mbox1_execute+0x814>)
 800e3b6:	f7ff fc5b 	bl	800dc70 <chMBGetUsedCountI>
 800e3ba:	4603      	mov	r3, r0
 800e3bc:	2b00      	cmp	r3, #0
 800e3be:	bf14      	ite	ne
 800e3c0:	2300      	movne	r3, #0
 800e3c2:	2301      	moveq	r3, #1
 800e3c4:	b2db      	uxtb	r3, r3
 800e3c6:	202a      	movs	r0, #42	; 0x2a
 800e3c8:	4619      	mov	r1, r3
 800e3ca:	f7fd fd41 	bl	800be50 <_test_assert>
 800e3ce:	4603      	mov	r3, r0
 800e3d0:	2b00      	cmp	r3, #0
 800e3d2:	d002      	beq.n	800e3da <mbox1_execute+0x72a>
 800e3d4:	f7ff fc2c 	bl	800dc30 <chSysUnlock>
 800e3d8:	e071      	b.n	800e4be <mbox1_execute+0x80e>
 800e3da:	f7ff fc29 	bl	800dc30 <chSysUnlock>
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e3de:	4b39      	ldr	r3, [pc, #228]	; (800e4c4 <mbox1_execute+0x814>)
 800e3e0:	68da      	ldr	r2, [r3, #12]
 800e3e2:	4b38      	ldr	r3, [pc, #224]	; (800e4c4 <mbox1_execute+0x814>)
 800e3e4:	689b      	ldr	r3, [r3, #8]
 800e3e6:	429a      	cmp	r2, r3
 800e3e8:	bf14      	ite	ne
 800e3ea:	2300      	movne	r3, #0
 800e3ec:	2301      	moveq	r3, #1
 800e3ee:	b2db      	uxtb	r3, r3
 800e3f0:	202b      	movs	r0, #43	; 0x2b
 800e3f2:	4619      	mov	r1, r3
 800e3f4:	f7fd fd2c 	bl	800be50 <_test_assert>
 800e3f8:	4603      	mov	r3, r0
 800e3fa:	2b00      	cmp	r3, #0
 800e3fc:	d000      	beq.n	800e400 <mbox1_execute+0x750>
 800e3fe:	e05e      	b.n	800e4be <mbox1_execute+0x80e>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
 800e400:	4830      	ldr	r0, [pc, #192]	; (800e4c4 <mbox1_execute+0x814>)
 800e402:	f7f4 fc95 	bl	8002d30 <chMBReset>

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e406:	f7ff fc0b 	bl	800dc20 <chSysLock>
 800e40a:	482e      	ldr	r0, [pc, #184]	; (800e4c4 <mbox1_execute+0x814>)
 800e40c:	f7ff fc20 	bl	800dc50 <chMBGetFreeCountI>
 800e410:	4603      	mov	r3, r0
 800e412:	2b05      	cmp	r3, #5
 800e414:	bf14      	ite	ne
 800e416:	2300      	movne	r3, #0
 800e418:	2301      	moveq	r3, #1
 800e41a:	b2db      	uxtb	r3, r3
 800e41c:	202c      	movs	r0, #44	; 0x2c
 800e41e:	4619      	mov	r1, r3
 800e420:	f7fd fd16 	bl	800be50 <_test_assert>
 800e424:	4603      	mov	r3, r0
 800e426:	2b00      	cmp	r3, #0
 800e428:	d002      	beq.n	800e430 <mbox1_execute+0x780>
 800e42a:	f7ff fc01 	bl	800dc30 <chSysUnlock>
 800e42e:	e046      	b.n	800e4be <mbox1_execute+0x80e>
 800e430:	f7ff fbfe 	bl	800dc30 <chSysUnlock>
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e434:	f7ff fbf4 	bl	800dc20 <chSysLock>
 800e438:	4822      	ldr	r0, [pc, #136]	; (800e4c4 <mbox1_execute+0x814>)
 800e43a:	f7ff fc19 	bl	800dc70 <chMBGetUsedCountI>
 800e43e:	4603      	mov	r3, r0
 800e440:	2b00      	cmp	r3, #0
 800e442:	bf14      	ite	ne
 800e444:	2300      	movne	r3, #0
 800e446:	2301      	moveq	r3, #1
 800e448:	b2db      	uxtb	r3, r3
 800e44a:	202d      	movs	r0, #45	; 0x2d
 800e44c:	4619      	mov	r1, r3
 800e44e:	f7fd fcff 	bl	800be50 <_test_assert>
 800e452:	4603      	mov	r3, r0
 800e454:	2b00      	cmp	r3, #0
 800e456:	d002      	beq.n	800e45e <mbox1_execute+0x7ae>
 800e458:	f7ff fbea 	bl	800dc30 <chSysUnlock>
 800e45c:	e02f      	b.n	800e4be <mbox1_execute+0x80e>
 800e45e:	f7ff fbe7 	bl	800dc30 <chSysUnlock>
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800e462:	f7ff fbdd 	bl	800dc20 <chSysLock>
 800e466:	4b17      	ldr	r3, [pc, #92]	; (800e4c4 <mbox1_execute+0x814>)
 800e468:	681a      	ldr	r2, [r3, #0]
 800e46a:	4b16      	ldr	r3, [pc, #88]	; (800e4c4 <mbox1_execute+0x814>)
 800e46c:	689b      	ldr	r3, [r3, #8]
 800e46e:	429a      	cmp	r2, r3
 800e470:	bf14      	ite	ne
 800e472:	2300      	movne	r3, #0
 800e474:	2301      	moveq	r3, #1
 800e476:	b2db      	uxtb	r3, r3
 800e478:	202e      	movs	r0, #46	; 0x2e
 800e47a:	4619      	mov	r1, r3
 800e47c:	f7fd fce8 	bl	800be50 <_test_assert>
 800e480:	4603      	mov	r3, r0
 800e482:	2b00      	cmp	r3, #0
 800e484:	d002      	beq.n	800e48c <mbox1_execute+0x7dc>
 800e486:	f7ff fbd3 	bl	800dc30 <chSysUnlock>
 800e48a:	e018      	b.n	800e4be <mbox1_execute+0x80e>
 800e48c:	f7ff fbd0 	bl	800dc30 <chSysUnlock>
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 800e490:	f7ff fbc6 	bl	800dc20 <chSysLock>
 800e494:	4b0b      	ldr	r3, [pc, #44]	; (800e4c4 <mbox1_execute+0x814>)
 800e496:	681a      	ldr	r2, [r3, #0]
 800e498:	4b0a      	ldr	r3, [pc, #40]	; (800e4c4 <mbox1_execute+0x814>)
 800e49a:	68db      	ldr	r3, [r3, #12]
 800e49c:	429a      	cmp	r2, r3
 800e49e:	bf14      	ite	ne
 800e4a0:	2300      	movne	r3, #0
 800e4a2:	2301      	moveq	r3, #1
 800e4a4:	b2db      	uxtb	r3, r3
 800e4a6:	202f      	movs	r0, #47	; 0x2f
 800e4a8:	4619      	mov	r1, r3
 800e4aa:	f7fd fcd1 	bl	800be50 <_test_assert>
 800e4ae:	4603      	mov	r3, r0
 800e4b0:	2b00      	cmp	r3, #0
 800e4b2:	d002      	beq.n	800e4ba <mbox1_execute+0x80a>
 800e4b4:	f7ff fbbc 	bl	800dc30 <chSysUnlock>
 800e4b8:	e001      	b.n	800e4be <mbox1_execute+0x80e>
 800e4ba:	f7ff fbb9 	bl	800dc30 <chSysUnlock>
}
 800e4be:	b005      	add	sp, #20
 800e4c0:	f85d fb04 	ldr.w	pc, [sp], #4
 800e4c4:	2000086c 	.word	0x2000086c
 800e4c8:	0801b2a0 	.word	0x0801b2a0
 800e4cc:	f3af 8000 	nop.w

0800e4d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800e4d0:	b082      	sub	sp, #8
 800e4d2:	2320      	movs	r3, #32
 800e4d4:	9301      	str	r3, [sp, #4]
 800e4d6:	9b01      	ldr	r3, [sp, #4]
 800e4d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e4dc:	b002      	add	sp, #8
 800e4de:	4770      	bx	lr

0800e4e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800e4e0:	b082      	sub	sp, #8
 800e4e2:	2300      	movs	r3, #0
 800e4e4:	9301      	str	r3, [sp, #4]
 800e4e6:	9b01      	ldr	r3, [sp, #4]
 800e4e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e4ec:	b002      	add	sp, #8
 800e4ee:	4770      	bx	lr

0800e4f0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800e4f0:	b508      	push	{r3, lr}

  port_lock();
 800e4f2:	f7ff ffed 	bl	800e4d0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800e4f6:	bd08      	pop	{r3, pc}
 800e4f8:	f3af 8000 	nop.w
 800e4fc:	f3af 8000 	nop.w

0800e500 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800e500:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800e502:	f7ff ffed 	bl	800e4e0 <port_unlock>
}
 800e506:	bd08      	pop	{r3, pc}
 800e508:	f3af 8000 	nop.w
 800e50c:	f3af 8000 	nop.w

0800e510 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800e510:	4b01      	ldr	r3, [pc, #4]	; (800e518 <chVTGetSystemTimeX+0x8>)
 800e512:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800e514:	4618      	mov	r0, r3
 800e516:	4770      	bx	lr
 800e518:	200039a8 	.word	0x200039a8
 800e51c:	f3af 8000 	nop.w

0800e520 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800e520:	b500      	push	{lr}
 800e522:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800e524:	f7ff ffe4 	bl	800e4f0 <chSysLock>
  systime = chVTGetSystemTimeX();
 800e528:	f7ff fff2 	bl	800e510 <chVTGetSystemTimeX>
 800e52c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800e52e:	f7ff ffe7 	bl	800e500 <chSysUnlock>

  return systime;
 800e532:	9b01      	ldr	r3, [sp, #4]
}
 800e534:	4618      	mov	r0, r3
 800e536:	b003      	add	sp, #12
 800e538:	f85d fb04 	ldr.w	pc, [sp], #4
 800e53c:	f3af 8000 	nop.w

0800e540 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800e540:	4b01      	ldr	r3, [pc, #4]	; (800e548 <chThdGetSelfX+0x8>)
 800e542:	699b      	ldr	r3, [r3, #24]
}
 800e544:	4618      	mov	r0, r3
 800e546:	4770      	bx	lr
 800e548:	200039a8 	.word	0x200039a8
 800e54c:	f3af 8000 	nop.w

0800e550 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800e550:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800e552:	f7ff fff5 	bl	800e540 <chThdGetSelfX>
 800e556:	4603      	mov	r3, r0
 800e558:	689b      	ldr	r3, [r3, #8]
}
 800e55a:	4618      	mov	r0, r3
 800e55c:	bd08      	pop	{r3, pc}
 800e55e:	bf00      	nop

0800e560 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 800e560:	b082      	sub	sp, #8
 800e562:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 800e564:	9b01      	ldr	r3, [sp, #4]
 800e566:	9a01      	ldr	r2, [sp, #4]
 800e568:	601a      	str	r2, [r3, #0]
}
 800e56a:	b002      	add	sp, #8
 800e56c:	4770      	bx	lr
 800e56e:	bf00      	nop

0800e570 <chEvtRegisterMask>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 800e570:	b500      	push	{lr}
 800e572:	b085      	sub	sp, #20
 800e574:	9003      	str	r0, [sp, #12]
 800e576:	9102      	str	r1, [sp, #8]
 800e578:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 800e57a:	9803      	ldr	r0, [sp, #12]
 800e57c:	9902      	ldr	r1, [sp, #8]
 800e57e:	9a01      	ldr	r2, [sp, #4]
 800e580:	f04f 33ff 	mov.w	r3, #4294967295
 800e584:	f7f3 fff4 	bl	8002570 <chEvtRegisterMaskWithFlags>
}
 800e588:	b005      	add	sp, #20
 800e58a:	f85d fb04 	ldr.w	pc, [sp], #4
 800e58e:	bf00      	nop

0800e590 <chEvtIsListeningI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @return              The event source status.
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {
 800e590:	b082      	sub	sp, #8
 800e592:	9001      	str	r0, [sp, #4]

  return (bool)(esp != (event_source_t *)esp->es_next);
 800e594:	9b01      	ldr	r3, [sp, #4]
 800e596:	681a      	ldr	r2, [r3, #0]
 800e598:	9b01      	ldr	r3, [sp, #4]
 800e59a:	429a      	cmp	r2, r3
 800e59c:	bf0c      	ite	eq
 800e59e:	2300      	moveq	r3, #0
 800e5a0:	2301      	movne	r3, #1
 800e5a2:	b2db      	uxtb	r3, r3
}
 800e5a4:	4618      	mov	r0, r3
 800e5a6:	b002      	add	sp, #8
 800e5a8:	4770      	bx	lr
 800e5aa:	bf00      	nop
 800e5ac:	f3af 8000 	nop.w

0800e5b0 <chEvtBroadcast>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {
 800e5b0:	b500      	push	{lr}
 800e5b2:	b083      	sub	sp, #12
 800e5b4:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 800e5b6:	9801      	ldr	r0, [sp, #4]
 800e5b8:	2100      	movs	r1, #0
 800e5ba:	f7f4 f8f1 	bl	80027a0 <chEvtBroadcastFlags>
}
 800e5be:	b003      	add	sp, #12
 800e5c0:	f85d fb04 	ldr.w	pc, [sp], #4
 800e5c4:	f3af 8000 	nop.w
 800e5c8:	f3af 8000 	nop.w
 800e5cc:	f3af 8000 	nop.w

0800e5d0 <evt1_setup>:
 * the test expects no more listeners.<br>
 * In the second part the test dispatches three event flags and verifies that
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {
 800e5d0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800e5d2:	f04f 30ff 	mov.w	r0, #4294967295
 800e5d6:	f7f4 f813 	bl	8002600 <chEvtGetAndClearEvents>
}
 800e5da:	bd08      	pop	{r3, pc}
 800e5dc:	f3af 8000 	nop.w

0800e5e0 <h1>:

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 800e5e0:	b500      	push	{lr}
 800e5e2:	b083      	sub	sp, #12
 800e5e4:	9001      	str	r0, [sp, #4]
 800e5e6:	2041      	movs	r0, #65	; 0x41
 800e5e8:	f7fd fc02 	bl	800bdf0 <test_emit_token>
 800e5ec:	b003      	add	sp, #12
 800e5ee:	f85d fb04 	ldr.w	pc, [sp], #4
 800e5f2:	bf00      	nop
 800e5f4:	f3af 8000 	nop.w
 800e5f8:	f3af 8000 	nop.w
 800e5fc:	f3af 8000 	nop.w

0800e600 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 800e600:	b500      	push	{lr}
 800e602:	b083      	sub	sp, #12
 800e604:	9001      	str	r0, [sp, #4]
 800e606:	2042      	movs	r0, #66	; 0x42
 800e608:	f7fd fbf2 	bl	800bdf0 <test_emit_token>
 800e60c:	b003      	add	sp, #12
 800e60e:	f85d fb04 	ldr.w	pc, [sp], #4
 800e612:	bf00      	nop
 800e614:	f3af 8000 	nop.w
 800e618:	f3af 8000 	nop.w
 800e61c:	f3af 8000 	nop.w

0800e620 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 800e620:	b500      	push	{lr}
 800e622:	b083      	sub	sp, #12
 800e624:	9001      	str	r0, [sp, #4]
 800e626:	2043      	movs	r0, #67	; 0x43
 800e628:	f7fd fbe2 	bl	800bdf0 <test_emit_token>
 800e62c:	b003      	add	sp, #12
 800e62e:	f85d fb04 	ldr.w	pc, [sp], #4
 800e632:	bf00      	nop
 800e634:	f3af 8000 	nop.w
 800e638:	f3af 8000 	nop.w
 800e63c:	f3af 8000 	nop.w

0800e640 <evt1_execute>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 800e640:	b500      	push	{lr}
 800e642:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;

  /*
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
 800e644:	482b      	ldr	r0, [pc, #172]	; (800e6f4 <evt1_execute+0xb4>)
 800e646:	f7ff ff8b 	bl	800e560 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 800e64a:	ab05      	add	r3, sp, #20
 800e64c:	4829      	ldr	r0, [pc, #164]	; (800e6f4 <evt1_execute+0xb4>)
 800e64e:	4619      	mov	r1, r3
 800e650:	2201      	movs	r2, #1
 800e652:	f7ff ff8d 	bl	800e570 <chEvtRegisterMask>
  chEvtRegisterMask(&es1, &el2, 2);
 800e656:	466b      	mov	r3, sp
 800e658:	4826      	ldr	r0, [pc, #152]	; (800e6f4 <evt1_execute+0xb4>)
 800e65a:	4619      	mov	r1, r3
 800e65c:	2202      	movs	r2, #2
 800e65e:	f7ff ff87 	bl	800e570 <chEvtRegisterMask>
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 800e662:	4824      	ldr	r0, [pc, #144]	; (800e6f4 <evt1_execute+0xb4>)
 800e664:	f7ff ff94 	bl	800e590 <chEvtIsListeningI>
 800e668:	4603      	mov	r3, r0
 800e66a:	2001      	movs	r0, #1
 800e66c:	4619      	mov	r1, r3
 800e66e:	f7fd fbef 	bl	800be50 <_test_assert>
 800e672:	4603      	mov	r3, r0
 800e674:	2b00      	cmp	r3, #0
 800e676:	d000      	beq.n	800e67a <evt1_execute+0x3a>
 800e678:	e038      	b.n	800e6ec <evt1_execute+0xac>
  chEvtUnregister(&es1, &el1);
 800e67a:	ab05      	add	r3, sp, #20
 800e67c:	481d      	ldr	r0, [pc, #116]	; (800e6f4 <evt1_execute+0xb4>)
 800e67e:	4619      	mov	r1, r3
 800e680:	f7f3 ff9e 	bl	80025c0 <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 800e684:	481b      	ldr	r0, [pc, #108]	; (800e6f4 <evt1_execute+0xb4>)
 800e686:	f7ff ff83 	bl	800e590 <chEvtIsListeningI>
 800e68a:	4603      	mov	r3, r0
 800e68c:	2002      	movs	r0, #2
 800e68e:	4619      	mov	r1, r3
 800e690:	f7fd fbde 	bl	800be50 <_test_assert>
 800e694:	4603      	mov	r3, r0
 800e696:	2b00      	cmp	r3, #0
 800e698:	d000      	beq.n	800e69c <evt1_execute+0x5c>
 800e69a:	e027      	b.n	800e6ec <evt1_execute+0xac>
  chEvtUnregister(&es1, &el2);
 800e69c:	466b      	mov	r3, sp
 800e69e:	4815      	ldr	r0, [pc, #84]	; (800e6f4 <evt1_execute+0xb4>)
 800e6a0:	4619      	mov	r1, r3
 800e6a2:	f7f3 ff8d 	bl	80025c0 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 800e6a6:	4813      	ldr	r0, [pc, #76]	; (800e6f4 <evt1_execute+0xb4>)
 800e6a8:	f7ff ff72 	bl	800e590 <chEvtIsListeningI>
 800e6ac:	4603      	mov	r3, r0
 800e6ae:	2b00      	cmp	r3, #0
 800e6b0:	bf0c      	ite	eq
 800e6b2:	2300      	moveq	r3, #0
 800e6b4:	2301      	movne	r3, #1
 800e6b6:	b2db      	uxtb	r3, r3
 800e6b8:	f083 0301 	eor.w	r3, r3, #1
 800e6bc:	b2db      	uxtb	r3, r3
 800e6be:	f003 0301 	and.w	r3, r3, #1
 800e6c2:	b2db      	uxtb	r3, r3
 800e6c4:	2003      	movs	r0, #3
 800e6c6:	4619      	mov	r1, r3
 800e6c8:	f7fd fbc2 	bl	800be50 <_test_assert>
 800e6cc:	4603      	mov	r3, r0
 800e6ce:	2b00      	cmp	r3, #0
 800e6d0:	d000      	beq.n	800e6d4 <evt1_execute+0x94>
 800e6d2:	e00b      	b.n	800e6ec <evt1_execute+0xac>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
 800e6d4:	4808      	ldr	r0, [pc, #32]	; (800e6f8 <evt1_execute+0xb8>)
 800e6d6:	2107      	movs	r1, #7
 800e6d8:	f7f4 f88a 	bl	80027f0 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
 800e6dc:	2004      	movs	r0, #4
 800e6de:	4907      	ldr	r1, [pc, #28]	; (800e6fc <evt1_execute+0xbc>)
 800e6e0:	f7fd fbce 	bl	800be80 <_test_assert_sequence>
 800e6e4:	4603      	mov	r3, r0
 800e6e6:	2b00      	cmp	r3, #0
 800e6e8:	d000      	beq.n	800e6ec <evt1_execute+0xac>
 800e6ea:	bf00      	nop
}
 800e6ec:	b00b      	add	sp, #44	; 0x2c
 800e6ee:	f85d fb04 	ldr.w	pc, [sp], #4
 800e6f2:	bf00      	nop
 800e6f4:	20000894 	.word	0x20000894
 800e6f8:	0801b2e0 	.word	0x0801b2e0
 800e6fc:	0801b2ec 	.word	0x0801b2ec

0800e700 <evt2_setup>:
 * .
 * After each test phase the test verifies that the events have been served at
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {
 800e700:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800e702:	f04f 30ff 	mov.w	r0, #4294967295
 800e706:	f7f3 ff7b 	bl	8002600 <chEvtGetAndClearEvents>
}
 800e70a:	bd08      	pop	{r3, pc}
 800e70c:	f3af 8000 	nop.w

0800e710 <thread1>:

static THD_FUNCTION(thread1, p) {
 800e710:	b500      	push	{lr}
 800e712:	b083      	sub	sp, #12
 800e714:	9001      	str	r0, [sp, #4]

  chThdSleepMilliseconds(50);
 800e716:	f241 3088 	movw	r0, #5000	; 0x1388
 800e71a:	f7f2 fdd9 	bl	80012d0 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 800e71e:	9801      	ldr	r0, [sp, #4]
 800e720:	2101      	movs	r1, #1
 800e722:	f7f3 fff5 	bl	8002710 <chEvtSignal>
}
 800e726:	b003      	add	sp, #12
 800e728:	f85d fb04 	ldr.w	pc, [sp], #4
 800e72c:	f3af 8000 	nop.w

0800e730 <thread2>:

static THD_FUNCTION(thread2, p) {
 800e730:	b500      	push	{lr}
 800e732:	b083      	sub	sp, #12
 800e734:	9001      	str	r0, [sp, #4]

  (void)p;
  chEvtBroadcast(&es1);
 800e736:	4806      	ldr	r0, [pc, #24]	; (800e750 <thread2+0x20>)
 800e738:	f7ff ff3a 	bl	800e5b0 <chEvtBroadcast>
  chThdSleepMilliseconds(50);
 800e73c:	f241 3088 	movw	r0, #5000	; 0x1388
 800e740:	f7f2 fdc6 	bl	80012d0 <chThdSleep>
  chEvtBroadcast(&es2);
 800e744:	4803      	ldr	r0, [pc, #12]	; (800e754 <thread2+0x24>)
 800e746:	f7ff ff33 	bl	800e5b0 <chEvtBroadcast>
}
 800e74a:	b003      	add	sp, #12
 800e74c:	f85d fb04 	ldr.w	pc, [sp], #4
 800e750:	20000894 	.word	0x20000894
 800e754:	20000898 	.word	0x20000898
 800e758:	f3af 8000 	nop.w
 800e75c:	f3af 8000 	nop.w

0800e760 <evt2_execute>:

static void evt2_execute(void) {
 800e760:	b530      	push	{r4, r5, lr}
 800e762:	b08f      	sub	sp, #60	; 0x3c
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 800e764:	2007      	movs	r0, #7
 800e766:	f7f3 ff6b 	bl	8002640 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
 800e76a:	f04f 30ff 	mov.w	r0, #4294967295
 800e76e:	f7f4 f867 	bl	8002840 <chEvtWaitOne>
 800e772:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(1, m == 1, "single event error");
 800e774:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e776:	2b01      	cmp	r3, #1
 800e778:	bf14      	ite	ne
 800e77a:	2300      	movne	r3, #0
 800e77c:	2301      	moveq	r3, #1
 800e77e:	b2db      	uxtb	r3, r3
 800e780:	2001      	movs	r0, #1
 800e782:	4619      	mov	r1, r3
 800e784:	f7fd fb64 	bl	800be50 <_test_assert>
 800e788:	4603      	mov	r3, r0
 800e78a:	2b00      	cmp	r3, #0
 800e78c:	d000      	beq.n	800e790 <evt2_execute+0x30>
 800e78e:	e18d      	b.n	800eaac <evt2_execute+0x34c>
  m = chEvtWaitOne(ALL_EVENTS);
 800e790:	f04f 30ff 	mov.w	r0, #4294967295
 800e794:	f7f4 f854 	bl	8002840 <chEvtWaitOne>
 800e798:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(2, m == 2, "single event error");
 800e79a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e79c:	2b02      	cmp	r3, #2
 800e79e:	bf14      	ite	ne
 800e7a0:	2300      	movne	r3, #0
 800e7a2:	2301      	moveq	r3, #1
 800e7a4:	b2db      	uxtb	r3, r3
 800e7a6:	2002      	movs	r0, #2
 800e7a8:	4619      	mov	r1, r3
 800e7aa:	f7fd fb51 	bl	800be50 <_test_assert>
 800e7ae:	4603      	mov	r3, r0
 800e7b0:	2b00      	cmp	r3, #0
 800e7b2:	d000      	beq.n	800e7b6 <evt2_execute+0x56>
 800e7b4:	e17a      	b.n	800eaac <evt2_execute+0x34c>
  m = chEvtWaitOne(ALL_EVENTS);
 800e7b6:	f04f 30ff 	mov.w	r0, #4294967295
 800e7ba:	f7f4 f841 	bl	8002840 <chEvtWaitOne>
 800e7be:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(3, m == 4, "single event error");
 800e7c0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e7c2:	2b04      	cmp	r3, #4
 800e7c4:	bf14      	ite	ne
 800e7c6:	2300      	movne	r3, #0
 800e7c8:	2301      	moveq	r3, #1
 800e7ca:	b2db      	uxtb	r3, r3
 800e7cc:	2003      	movs	r0, #3
 800e7ce:	4619      	mov	r1, r3
 800e7d0:	f7fd fb3e 	bl	800be50 <_test_assert>
 800e7d4:	4603      	mov	r3, r0
 800e7d6:	2b00      	cmp	r3, #0
 800e7d8:	d000      	beq.n	800e7dc <evt2_execute+0x7c>
 800e7da:	e167      	b.n	800eaac <evt2_execute+0x34c>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e7dc:	f04f 30ff 	mov.w	r0, #4294967295
 800e7e0:	f7f3 ff0e 	bl	8002600 <chEvtGetAndClearEvents>
 800e7e4:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(4, m == 0, "stuck event");
 800e7e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e7e8:	2b00      	cmp	r3, #0
 800e7ea:	bf14      	ite	ne
 800e7ec:	2300      	movne	r3, #0
 800e7ee:	2301      	moveq	r3, #1
 800e7f0:	b2db      	uxtb	r3, r3
 800e7f2:	2004      	movs	r0, #4
 800e7f4:	4619      	mov	r1, r3
 800e7f6:	f7fd fb2b 	bl	800be50 <_test_assert>
 800e7fa:	4603      	mov	r3, r0
 800e7fc:	2b00      	cmp	r3, #0
 800e7fe:	d000      	beq.n	800e802 <evt2_execute+0xa2>
 800e800:	e154      	b.n	800eaac <evt2_execute+0x34c>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 800e802:	f7fd fbcd 	bl	800bfa0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800e806:	f7ff fe8b 	bl	800e520 <chVTGetSystemTime>
 800e80a:	4603      	mov	r3, r0
 800e80c:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 800e810:	3308      	adds	r3, #8
 800e812:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e814:	4ba6      	ldr	r3, [pc, #664]	; (800eab0 <evt2_execute+0x350>)
 800e816:	681d      	ldr	r5, [r3, #0]
 800e818:	f7ff fe9a 	bl	800e550 <chThdGetPriorityX>
 800e81c:	4603      	mov	r3, r0
 800e81e:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 800e820:	f7ff fe8e 	bl	800e540 <chThdGetSelfX>
 800e824:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e826:	9300      	str	r3, [sp, #0]
 800e828:	4628      	mov	r0, r5
 800e82a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e82e:	4622      	mov	r2, r4
 800e830:	4ba0      	ldr	r3, [pc, #640]	; (800eab4 <evt2_execute+0x354>)
 800e832:	f7f2 fcd5 	bl	80011e0 <chThdCreateStatic>
 800e836:	4602      	mov	r2, r0
 800e838:	4b9f      	ldr	r3, [pc, #636]	; (800eab8 <evt2_execute+0x358>)
 800e83a:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 800e83c:	f04f 30ff 	mov.w	r0, #4294967295
 800e840:	f7f3 fffe 	bl	8002840 <chEvtWaitOne>
 800e844:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 800e846:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e848:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800e84c:	2005      	movs	r0, #5
 800e84e:	990c      	ldr	r1, [sp, #48]	; 0x30
 800e850:	461a      	mov	r2, r3
 800e852:	f7fd fb45 	bl	800bee0 <_test_assert_time_window>
 800e856:	4603      	mov	r3, r0
 800e858:	2b00      	cmp	r3, #0
 800e85a:	d000      	beq.n	800e85e <evt2_execute+0xfe>
 800e85c:	e126      	b.n	800eaac <evt2_execute+0x34c>
  test_assert(6, m == 1, "single event error");
 800e85e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e860:	2b01      	cmp	r3, #1
 800e862:	bf14      	ite	ne
 800e864:	2300      	movne	r3, #0
 800e866:	2301      	moveq	r3, #1
 800e868:	b2db      	uxtb	r3, r3
 800e86a:	2006      	movs	r0, #6
 800e86c:	4619      	mov	r1, r3
 800e86e:	f7fd faef 	bl	800be50 <_test_assert>
 800e872:	4603      	mov	r3, r0
 800e874:	2b00      	cmp	r3, #0
 800e876:	d000      	beq.n	800e87a <evt2_execute+0x11a>
 800e878:	e118      	b.n	800eaac <evt2_execute+0x34c>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e87a:	f04f 30ff 	mov.w	r0, #4294967295
 800e87e:	f7f3 febf 	bl	8002600 <chEvtGetAndClearEvents>
 800e882:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(7, m == 0, "stuck event");
 800e884:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e886:	2b00      	cmp	r3, #0
 800e888:	bf14      	ite	ne
 800e88a:	2300      	movne	r3, #0
 800e88c:	2301      	moveq	r3, #1
 800e88e:	b2db      	uxtb	r3, r3
 800e890:	2007      	movs	r0, #7
 800e892:	4619      	mov	r1, r3
 800e894:	f7fd fadc 	bl	800be50 <_test_assert>
 800e898:	4603      	mov	r3, r0
 800e89a:	2b00      	cmp	r3, #0
 800e89c:	d000      	beq.n	800e8a0 <evt2_execute+0x140>
 800e89e:	e105      	b.n	800eaac <evt2_execute+0x34c>
  test_wait_threads();
 800e8a0:	f7fd fb56 	bl	800bf50 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
 800e8a4:	2005      	movs	r0, #5
 800e8a6:	f7f3 fecb 	bl	8002640 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
 800e8aa:	f04f 30ff 	mov.w	r0, #4294967295
 800e8ae:	f7f3 fff7 	bl	80028a0 <chEvtWaitAny>
 800e8b2:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(8, m == 5, "unexpected pending bit");
 800e8b4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e8b6:	2b05      	cmp	r3, #5
 800e8b8:	bf14      	ite	ne
 800e8ba:	2300      	movne	r3, #0
 800e8bc:	2301      	moveq	r3, #1
 800e8be:	b2db      	uxtb	r3, r3
 800e8c0:	2008      	movs	r0, #8
 800e8c2:	4619      	mov	r1, r3
 800e8c4:	f7fd fac4 	bl	800be50 <_test_assert>
 800e8c8:	4603      	mov	r3, r0
 800e8ca:	2b00      	cmp	r3, #0
 800e8cc:	d000      	beq.n	800e8d0 <evt2_execute+0x170>
 800e8ce:	e0ed      	b.n	800eaac <evt2_execute+0x34c>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e8d0:	f04f 30ff 	mov.w	r0, #4294967295
 800e8d4:	f7f3 fe94 	bl	8002600 <chEvtGetAndClearEvents>
 800e8d8:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(9, m == 0, "stuck event");
 800e8da:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e8dc:	2b00      	cmp	r3, #0
 800e8de:	bf14      	ite	ne
 800e8e0:	2300      	movne	r3, #0
 800e8e2:	2301      	moveq	r3, #1
 800e8e4:	b2db      	uxtb	r3, r3
 800e8e6:	2009      	movs	r0, #9
 800e8e8:	4619      	mov	r1, r3
 800e8ea:	f7fd fab1 	bl	800be50 <_test_assert>
 800e8ee:	4603      	mov	r3, r0
 800e8f0:	2b00      	cmp	r3, #0
 800e8f2:	d000      	beq.n	800e8f6 <evt2_execute+0x196>
 800e8f4:	e0da      	b.n	800eaac <evt2_execute+0x34c>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 800e8f6:	f7fd fb53 	bl	800bfa0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800e8fa:	f7ff fe11 	bl	800e520 <chVTGetSystemTime>
 800e8fe:	4603      	mov	r3, r0
 800e900:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 800e904:	3308      	adds	r3, #8
 800e906:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e908:	4b69      	ldr	r3, [pc, #420]	; (800eab0 <evt2_execute+0x350>)
 800e90a:	681d      	ldr	r5, [r3, #0]
 800e90c:	f7ff fe20 	bl	800e550 <chThdGetPriorityX>
 800e910:	4603      	mov	r3, r0
 800e912:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 800e914:	f7ff fe14 	bl	800e540 <chThdGetSelfX>
 800e918:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e91a:	9300      	str	r3, [sp, #0]
 800e91c:	4628      	mov	r0, r5
 800e91e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e922:	4622      	mov	r2, r4
 800e924:	4b63      	ldr	r3, [pc, #396]	; (800eab4 <evt2_execute+0x354>)
 800e926:	f7f2 fc5b 	bl	80011e0 <chThdCreateStatic>
 800e92a:	4602      	mov	r2, r0
 800e92c:	4b62      	ldr	r3, [pc, #392]	; (800eab8 <evt2_execute+0x358>)
 800e92e:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 800e930:	f04f 30ff 	mov.w	r0, #4294967295
 800e934:	f7f3 ffb4 	bl	80028a0 <chEvtWaitAny>
 800e938:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 800e93a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e93c:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800e940:	200a      	movs	r0, #10
 800e942:	990c      	ldr	r1, [sp, #48]	; 0x30
 800e944:	461a      	mov	r2, r3
 800e946:	f7fd facb 	bl	800bee0 <_test_assert_time_window>
 800e94a:	4603      	mov	r3, r0
 800e94c:	2b00      	cmp	r3, #0
 800e94e:	d000      	beq.n	800e952 <evt2_execute+0x1f2>
 800e950:	e0ac      	b.n	800eaac <evt2_execute+0x34c>
  test_assert(11, m == 1, "single event error");
 800e952:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e954:	2b01      	cmp	r3, #1
 800e956:	bf14      	ite	ne
 800e958:	2300      	movne	r3, #0
 800e95a:	2301      	moveq	r3, #1
 800e95c:	b2db      	uxtb	r3, r3
 800e95e:	200b      	movs	r0, #11
 800e960:	4619      	mov	r1, r3
 800e962:	f7fd fa75 	bl	800be50 <_test_assert>
 800e966:	4603      	mov	r3, r0
 800e968:	2b00      	cmp	r3, #0
 800e96a:	d000      	beq.n	800e96e <evt2_execute+0x20e>
 800e96c:	e09e      	b.n	800eaac <evt2_execute+0x34c>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e96e:	f04f 30ff 	mov.w	r0, #4294967295
 800e972:	f7f3 fe45 	bl	8002600 <chEvtGetAndClearEvents>
 800e976:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(12, m == 0, "stuck event");
 800e978:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e97a:	2b00      	cmp	r3, #0
 800e97c:	bf14      	ite	ne
 800e97e:	2300      	movne	r3, #0
 800e980:	2301      	moveq	r3, #1
 800e982:	b2db      	uxtb	r3, r3
 800e984:	200c      	movs	r0, #12
 800e986:	4619      	mov	r1, r3
 800e988:	f7fd fa62 	bl	800be50 <_test_assert>
 800e98c:	4603      	mov	r3, r0
 800e98e:	2b00      	cmp	r3, #0
 800e990:	d000      	beq.n	800e994 <evt2_execute+0x234>
 800e992:	e08b      	b.n	800eaac <evt2_execute+0x34c>
  test_wait_threads();
 800e994:	f7fd fadc 	bl	800bf50 <test_wait_threads>

  /*
   * Test on chEvtWaitAll().
   */
  chEvtObjectInit(&es1);
 800e998:	4848      	ldr	r0, [pc, #288]	; (800eabc <evt2_execute+0x35c>)
 800e99a:	f7ff fde1 	bl	800e560 <chEvtObjectInit>
  chEvtObjectInit(&es2);
 800e99e:	4848      	ldr	r0, [pc, #288]	; (800eac0 <evt2_execute+0x360>)
 800e9a0:	f7ff fdde 	bl	800e560 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 800e9a4:	ab07      	add	r3, sp, #28
 800e9a6:	4845      	ldr	r0, [pc, #276]	; (800eabc <evt2_execute+0x35c>)
 800e9a8:	4619      	mov	r1, r3
 800e9aa:	2201      	movs	r2, #1
 800e9ac:	f7ff fde0 	bl	800e570 <chEvtRegisterMask>
  chEvtRegisterMask(&es2, &el2, 4);
 800e9b0:	ab02      	add	r3, sp, #8
 800e9b2:	4843      	ldr	r0, [pc, #268]	; (800eac0 <evt2_execute+0x360>)
 800e9b4:	4619      	mov	r1, r3
 800e9b6:	2204      	movs	r2, #4
 800e9b8:	f7ff fdda 	bl	800e570 <chEvtRegisterMask>
  test_wait_tick();
 800e9bc:	f7fd faf0 	bl	800bfa0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800e9c0:	f7ff fdae 	bl	800e520 <chVTGetSystemTime>
 800e9c4:	4603      	mov	r3, r0
 800e9c6:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 800e9ca:	3308      	adds	r3, #8
 800e9cc:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e9ce:	4b38      	ldr	r3, [pc, #224]	; (800eab0 <evt2_execute+0x350>)
 800e9d0:	681c      	ldr	r4, [r3, #0]
 800e9d2:	f7ff fdbd 	bl	800e550 <chThdGetPriorityX>
 800e9d6:	4603      	mov	r3, r0
 800e9d8:	3b01      	subs	r3, #1
 800e9da:	4a3a      	ldr	r2, [pc, #232]	; (800eac4 <evt2_execute+0x364>)
 800e9dc:	9200      	str	r2, [sp, #0]
 800e9de:	4620      	mov	r0, r4
 800e9e0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e9e4:	461a      	mov	r2, r3
 800e9e6:	4b38      	ldr	r3, [pc, #224]	; (800eac8 <evt2_execute+0x368>)
 800e9e8:	f7f2 fbfa 	bl	80011e0 <chThdCreateStatic>
 800e9ec:	4602      	mov	r2, r0
 800e9ee:	4b32      	ldr	r3, [pc, #200]	; (800eab8 <evt2_execute+0x358>)
 800e9f0:	601a      	str	r2, [r3, #0]
                                 thread2, "A");
  m = chEvtWaitAll(5);
 800e9f2:	2005      	movs	r0, #5
 800e9f4:	f7f3 ff84 	bl	8002900 <chEvtWaitAll>
 800e9f8:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 800e9fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e9fc:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800ea00:	200d      	movs	r0, #13
 800ea02:	990c      	ldr	r1, [sp, #48]	; 0x30
 800ea04:	461a      	mov	r2, r3
 800ea06:	f7fd fa6b 	bl	800bee0 <_test_assert_time_window>
 800ea0a:	4603      	mov	r3, r0
 800ea0c:	2b00      	cmp	r3, #0
 800ea0e:	d000      	beq.n	800ea12 <evt2_execute+0x2b2>
 800ea10:	e04c      	b.n	800eaac <evt2_execute+0x34c>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800ea12:	f04f 30ff 	mov.w	r0, #4294967295
 800ea16:	f7f3 fdf3 	bl	8002600 <chEvtGetAndClearEvents>
 800ea1a:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(14, m == 0, "stuck event");
 800ea1c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ea1e:	2b00      	cmp	r3, #0
 800ea20:	bf14      	ite	ne
 800ea22:	2300      	movne	r3, #0
 800ea24:	2301      	moveq	r3, #1
 800ea26:	b2db      	uxtb	r3, r3
 800ea28:	200e      	movs	r0, #14
 800ea2a:	4619      	mov	r1, r3
 800ea2c:	f7fd fa10 	bl	800be50 <_test_assert>
 800ea30:	4603      	mov	r3, r0
 800ea32:	2b00      	cmp	r3, #0
 800ea34:	d000      	beq.n	800ea38 <evt2_execute+0x2d8>
 800ea36:	e039      	b.n	800eaac <evt2_execute+0x34c>
  test_wait_threads();
 800ea38:	f7fd fa8a 	bl	800bf50 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 800ea3c:	ab07      	add	r3, sp, #28
 800ea3e:	481f      	ldr	r0, [pc, #124]	; (800eabc <evt2_execute+0x35c>)
 800ea40:	4619      	mov	r1, r3
 800ea42:	f7f3 fdbd 	bl	80025c0 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 800ea46:	ab02      	add	r3, sp, #8
 800ea48:	481d      	ldr	r0, [pc, #116]	; (800eac0 <evt2_execute+0x360>)
 800ea4a:	4619      	mov	r1, r3
 800ea4c:	f7f3 fdb8 	bl	80025c0 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 800ea50:	481a      	ldr	r0, [pc, #104]	; (800eabc <evt2_execute+0x35c>)
 800ea52:	f7ff fd9d 	bl	800e590 <chEvtIsListeningI>
 800ea56:	4603      	mov	r3, r0
 800ea58:	2b00      	cmp	r3, #0
 800ea5a:	bf0c      	ite	eq
 800ea5c:	2300      	moveq	r3, #0
 800ea5e:	2301      	movne	r3, #1
 800ea60:	b2db      	uxtb	r3, r3
 800ea62:	f083 0301 	eor.w	r3, r3, #1
 800ea66:	b2db      	uxtb	r3, r3
 800ea68:	f003 0301 	and.w	r3, r3, #1
 800ea6c:	b2db      	uxtb	r3, r3
 800ea6e:	200f      	movs	r0, #15
 800ea70:	4619      	mov	r1, r3
 800ea72:	f7fd f9ed 	bl	800be50 <_test_assert>
 800ea76:	4603      	mov	r3, r0
 800ea78:	2b00      	cmp	r3, #0
 800ea7a:	d000      	beq.n	800ea7e <evt2_execute+0x31e>
 800ea7c:	e016      	b.n	800eaac <evt2_execute+0x34c>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 800ea7e:	4810      	ldr	r0, [pc, #64]	; (800eac0 <evt2_execute+0x360>)
 800ea80:	f7ff fd86 	bl	800e590 <chEvtIsListeningI>
 800ea84:	4603      	mov	r3, r0
 800ea86:	2b00      	cmp	r3, #0
 800ea88:	bf0c      	ite	eq
 800ea8a:	2300      	moveq	r3, #0
 800ea8c:	2301      	movne	r3, #1
 800ea8e:	b2db      	uxtb	r3, r3
 800ea90:	f083 0301 	eor.w	r3, r3, #1
 800ea94:	b2db      	uxtb	r3, r3
 800ea96:	f003 0301 	and.w	r3, r3, #1
 800ea9a:	b2db      	uxtb	r3, r3
 800ea9c:	2010      	movs	r0, #16
 800ea9e:	4619      	mov	r1, r3
 800eaa0:	f7fd f9d6 	bl	800be50 <_test_assert>
 800eaa4:	4603      	mov	r3, r0
 800eaa6:	2b00      	cmp	r3, #0
 800eaa8:	d000      	beq.n	800eaac <evt2_execute+0x34c>
 800eaaa:	bf00      	nop
}
 800eaac:	b00f      	add	sp, #60	; 0x3c
 800eaae:	bd30      	pop	{r4, r5, pc}
 800eab0:	0801ad70 	.word	0x0801ad70
 800eab4:	0800e711 	.word	0x0800e711
 800eab8:	20003e3c 	.word	0x20003e3c
 800eabc:	20000894 	.word	0x20000894
 800eac0:	20000898 	.word	0x20000898
 800eac4:	0801b324 	.word	0x0801b324
 800eac8:	0800e731 	.word	0x0800e731
 800eacc:	f3af 8000 	nop.w

0800ead0 <evt3_setup>:
 * - @p chEvtWaitAllTimeout()
 * .
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {
 800ead0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800ead2:	f04f 30ff 	mov.w	r0, #4294967295
 800ead6:	f7f3 fd93 	bl	8002600 <chEvtGetAndClearEvents>
}
 800eada:	bd08      	pop	{r3, pc}
 800eadc:	f3af 8000 	nop.w

0800eae0 <evt3_execute>:

static void evt3_execute(void) {
 800eae0:	b500      	push	{lr}
 800eae2:	b083      	sub	sp, #12
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800eae4:	f04f 30ff 	mov.w	r0, #4294967295
 800eae8:	2100      	movs	r1, #0
 800eaea:	f7f3 ff31 	bl	8002950 <chEvtWaitOneTimeout>
 800eaee:	9001      	str	r0, [sp, #4]
  test_assert(1, m == 0, "spurious event");
 800eaf0:	9b01      	ldr	r3, [sp, #4]
 800eaf2:	2b00      	cmp	r3, #0
 800eaf4:	bf14      	ite	ne
 800eaf6:	2300      	movne	r3, #0
 800eaf8:	2301      	moveq	r3, #1
 800eafa:	b2db      	uxtb	r3, r3
 800eafc:	2001      	movs	r0, #1
 800eafe:	4619      	mov	r1, r3
 800eb00:	f7fd f9a6 	bl	800be50 <_test_assert>
 800eb04:	4603      	mov	r3, r0
 800eb06:	2b00      	cmp	r3, #0
 800eb08:	d000      	beq.n	800eb0c <evt3_execute+0x2c>
 800eb0a:	e063      	b.n	800ebd4 <evt3_execute+0xf4>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800eb0c:	f04f 30ff 	mov.w	r0, #4294967295
 800eb10:	2100      	movs	r1, #0
 800eb12:	f7f3 ff5d 	bl	80029d0 <chEvtWaitAnyTimeout>
 800eb16:	9001      	str	r0, [sp, #4]
  test_assert(2, m == 0, "spurious event");
 800eb18:	9b01      	ldr	r3, [sp, #4]
 800eb1a:	2b00      	cmp	r3, #0
 800eb1c:	bf14      	ite	ne
 800eb1e:	2300      	movne	r3, #0
 800eb20:	2301      	moveq	r3, #1
 800eb22:	b2db      	uxtb	r3, r3
 800eb24:	2002      	movs	r0, #2
 800eb26:	4619      	mov	r1, r3
 800eb28:	f7fd f992 	bl	800be50 <_test_assert>
 800eb2c:	4603      	mov	r3, r0
 800eb2e:	2b00      	cmp	r3, #0
 800eb30:	d000      	beq.n	800eb34 <evt3_execute+0x54>
 800eb32:	e04f      	b.n	800ebd4 <evt3_execute+0xf4>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800eb34:	f04f 30ff 	mov.w	r0, #4294967295
 800eb38:	2100      	movs	r1, #0
 800eb3a:	f7f3 ff89 	bl	8002a50 <chEvtWaitAllTimeout>
 800eb3e:	9001      	str	r0, [sp, #4]
  test_assert(3, m == 0, "spurious event");
 800eb40:	9b01      	ldr	r3, [sp, #4]
 800eb42:	2b00      	cmp	r3, #0
 800eb44:	bf14      	ite	ne
 800eb46:	2300      	movne	r3, #0
 800eb48:	2301      	moveq	r3, #1
 800eb4a:	b2db      	uxtb	r3, r3
 800eb4c:	2003      	movs	r0, #3
 800eb4e:	4619      	mov	r1, r3
 800eb50:	f7fd f97e 	bl	800be50 <_test_assert>
 800eb54:	4603      	mov	r3, r0
 800eb56:	2b00      	cmp	r3, #0
 800eb58:	d000      	beq.n	800eb5c <evt3_execute+0x7c>
 800eb5a:	e03b      	b.n	800ebd4 <evt3_execute+0xf4>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 800eb5c:	f04f 30ff 	mov.w	r0, #4294967295
 800eb60:	210a      	movs	r1, #10
 800eb62:	f7f3 fef5 	bl	8002950 <chEvtWaitOneTimeout>
 800eb66:	9001      	str	r0, [sp, #4]
  test_assert(4, m == 0, "spurious event");
 800eb68:	9b01      	ldr	r3, [sp, #4]
 800eb6a:	2b00      	cmp	r3, #0
 800eb6c:	bf14      	ite	ne
 800eb6e:	2300      	movne	r3, #0
 800eb70:	2301      	moveq	r3, #1
 800eb72:	b2db      	uxtb	r3, r3
 800eb74:	2004      	movs	r0, #4
 800eb76:	4619      	mov	r1, r3
 800eb78:	f7fd f96a 	bl	800be50 <_test_assert>
 800eb7c:	4603      	mov	r3, r0
 800eb7e:	2b00      	cmp	r3, #0
 800eb80:	d000      	beq.n	800eb84 <evt3_execute+0xa4>
 800eb82:	e027      	b.n	800ebd4 <evt3_execute+0xf4>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 800eb84:	f04f 30ff 	mov.w	r0, #4294967295
 800eb88:	210a      	movs	r1, #10
 800eb8a:	f7f3 ff21 	bl	80029d0 <chEvtWaitAnyTimeout>
 800eb8e:	9001      	str	r0, [sp, #4]
  test_assert(5, m == 0, "spurious event");
 800eb90:	9b01      	ldr	r3, [sp, #4]
 800eb92:	2b00      	cmp	r3, #0
 800eb94:	bf14      	ite	ne
 800eb96:	2300      	movne	r3, #0
 800eb98:	2301      	moveq	r3, #1
 800eb9a:	b2db      	uxtb	r3, r3
 800eb9c:	2005      	movs	r0, #5
 800eb9e:	4619      	mov	r1, r3
 800eba0:	f7fd f956 	bl	800be50 <_test_assert>
 800eba4:	4603      	mov	r3, r0
 800eba6:	2b00      	cmp	r3, #0
 800eba8:	d000      	beq.n	800ebac <evt3_execute+0xcc>
 800ebaa:	e013      	b.n	800ebd4 <evt3_execute+0xf4>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 800ebac:	f04f 30ff 	mov.w	r0, #4294967295
 800ebb0:	210a      	movs	r1, #10
 800ebb2:	f7f3 ff4d 	bl	8002a50 <chEvtWaitAllTimeout>
 800ebb6:	9001      	str	r0, [sp, #4]
  test_assert(6, m == 0, "spurious event");
 800ebb8:	9b01      	ldr	r3, [sp, #4]
 800ebba:	2b00      	cmp	r3, #0
 800ebbc:	bf14      	ite	ne
 800ebbe:	2300      	movne	r3, #0
 800ebc0:	2301      	moveq	r3, #1
 800ebc2:	b2db      	uxtb	r3, r3
 800ebc4:	2006      	movs	r0, #6
 800ebc6:	4619      	mov	r1, r3
 800ebc8:	f7fd f942 	bl	800be50 <_test_assert>
 800ebcc:	4603      	mov	r3, r0
 800ebce:	2b00      	cmp	r3, #0
 800ebd0:	d000      	beq.n	800ebd4 <evt3_execute+0xf4>
 800ebd2:	bf00      	nop
}
 800ebd4:	b003      	add	sp, #12
 800ebd6:	f85d fb04 	ldr.w	pc, [sp], #4
 800ebda:	bf00      	nop
 800ebdc:	f3af 8000 	nop.w

0800ebe0 <heap1_setup>:
 * allocator.<br>
 * The test expects to find the heap back to the initial status after each
 * sequence.
 */

static void heap1_setup(void) {
 800ebe0:	b508      	push	{r3, lr}

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
 800ebe2:	4803      	ldr	r0, [pc, #12]	; (800ebf0 <heap1_setup+0x10>)
 800ebe4:	4903      	ldr	r1, [pc, #12]	; (800ebf4 <heap1_setup+0x14>)
 800ebe6:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800ebea:	f7f4 fd99 	bl	8003720 <chHeapObjectInit>
}
 800ebee:	bd08      	pop	{r3, pc}
 800ebf0:	200014a0 	.word	0x200014a0
 800ebf4:	20003e50 	.word	0x20003e50
 800ebf8:	f3af 8000 	nop.w
 800ebfc:	f3af 8000 	nop.w

0800ec00 <heap1_execute>:

static void heap1_execute(void) {
 800ec00:	b500      	push	{lr}
 800ec02:	b087      	sub	sp, #28
  void *p1, *p2, *p3;
  size_t n, sz;

  /* Unrelated, for coverage only.*/
  (void)chCoreGetStatusX();
 800ec04:	f7f4 fd64 	bl	80036d0 <chCoreGetStatusX>

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 800ec08:	ab01      	add	r3, sp, #4
 800ec0a:	2000      	movs	r0, #0
 800ec0c:	4619      	mov	r1, r3
 800ec0e:	f7f4 fe87 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 800ec12:	2000      	movs	r0, #0
 800ec14:	2110      	movs	r1, #16
 800ec16:	f7f4 fda3 	bl	8003760 <chHeapAlloc>
 800ec1a:	9005      	str	r0, [sp, #20]
  test_assert(1, p1 != NULL, "allocation failed");
 800ec1c:	9b05      	ldr	r3, [sp, #20]
 800ec1e:	2b00      	cmp	r3, #0
 800ec20:	bf0c      	ite	eq
 800ec22:	2300      	moveq	r3, #0
 800ec24:	2301      	movne	r3, #1
 800ec26:	b2db      	uxtb	r3, r3
 800ec28:	2001      	movs	r0, #1
 800ec2a:	4619      	mov	r1, r3
 800ec2c:	f7fd f910 	bl	800be50 <_test_assert>
 800ec30:	4603      	mov	r3, r0
 800ec32:	2b00      	cmp	r3, #0
 800ec34:	d000      	beq.n	800ec38 <heap1_execute+0x38>
 800ec36:	e14e      	b.n	800eed6 <heap1_execute+0x2d6>
  chHeapFree(p1);
 800ec38:	9805      	ldr	r0, [sp, #20]
 800ec3a:	f7f4 fe09 	bl	8003850 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 800ec3e:	2000      	movs	r0, #0
 800ec40:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 800ec44:	f7f4 fd8c 	bl	8003760 <chHeapAlloc>
 800ec48:	9005      	str	r0, [sp, #20]
  test_assert(2, p1 == NULL, "allocation not failed");
 800ec4a:	9b05      	ldr	r3, [sp, #20]
 800ec4c:	2b00      	cmp	r3, #0
 800ec4e:	bf14      	ite	ne
 800ec50:	2300      	movne	r3, #0
 800ec52:	2301      	moveq	r3, #1
 800ec54:	b2db      	uxtb	r3, r3
 800ec56:	2002      	movs	r0, #2
 800ec58:	4619      	mov	r1, r3
 800ec5a:	f7fd f8f9 	bl	800be50 <_test_assert>
 800ec5e:	4603      	mov	r3, r0
 800ec60:	2b00      	cmp	r3, #0
 800ec62:	d000      	beq.n	800ec66 <heap1_execute+0x66>
 800ec64:	e137      	b.n	800eed6 <heap1_execute+0x2d6>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 800ec66:	ab01      	add	r3, sp, #4
 800ec68:	489c      	ldr	r0, [pc, #624]	; (800eedc <heap1_execute+0x2dc>)
 800ec6a:	4619      	mov	r1, r3
 800ec6c:	f7f4 fe58 	bl	8003920 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800ec70:	489a      	ldr	r0, [pc, #616]	; (800eedc <heap1_execute+0x2dc>)
 800ec72:	2110      	movs	r1, #16
 800ec74:	f7f4 fd74 	bl	8003760 <chHeapAlloc>
 800ec78:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800ec7a:	4898      	ldr	r0, [pc, #608]	; (800eedc <heap1_execute+0x2dc>)
 800ec7c:	2110      	movs	r1, #16
 800ec7e:	f7f4 fd6f 	bl	8003760 <chHeapAlloc>
 800ec82:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 800ec84:	4895      	ldr	r0, [pc, #596]	; (800eedc <heap1_execute+0x2dc>)
 800ec86:	2110      	movs	r1, #16
 800ec88:	f7f4 fd6a 	bl	8003760 <chHeapAlloc>
 800ec8c:	9003      	str	r0, [sp, #12]
  chHeapFree(p1);                               /* Does not merge.*/
 800ec8e:	9805      	ldr	r0, [sp, #20]
 800ec90:	f7f4 fdde 	bl	8003850 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 800ec94:	9804      	ldr	r0, [sp, #16]
 800ec96:	f7f4 fddb 	bl	8003850 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 800ec9a:	9803      	ldr	r0, [sp, #12]
 800ec9c:	f7f4 fdd8 	bl	8003850 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800eca0:	ab02      	add	r3, sp, #8
 800eca2:	488e      	ldr	r0, [pc, #568]	; (800eedc <heap1_execute+0x2dc>)
 800eca4:	4619      	mov	r1, r3
 800eca6:	f7f4 fe3b 	bl	8003920 <chHeapStatus>
 800ecaa:	4603      	mov	r3, r0
 800ecac:	2b01      	cmp	r3, #1
 800ecae:	bf14      	ite	ne
 800ecb0:	2300      	movne	r3, #0
 800ecb2:	2301      	moveq	r3, #1
 800ecb4:	b2db      	uxtb	r3, r3
 800ecb6:	2003      	movs	r0, #3
 800ecb8:	4619      	mov	r1, r3
 800ecba:	f7fd f8c9 	bl	800be50 <_test_assert>
 800ecbe:	4603      	mov	r3, r0
 800ecc0:	2b00      	cmp	r3, #0
 800ecc2:	d000      	beq.n	800ecc6 <heap1_execute+0xc6>
 800ecc4:	e107      	b.n	800eed6 <heap1_execute+0x2d6>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800ecc6:	4885      	ldr	r0, [pc, #532]	; (800eedc <heap1_execute+0x2dc>)
 800ecc8:	2110      	movs	r1, #16
 800ecca:	f7f4 fd49 	bl	8003760 <chHeapAlloc>
 800ecce:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800ecd0:	4882      	ldr	r0, [pc, #520]	; (800eedc <heap1_execute+0x2dc>)
 800ecd2:	2110      	movs	r1, #16
 800ecd4:	f7f4 fd44 	bl	8003760 <chHeapAlloc>
 800ecd8:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 800ecda:	4880      	ldr	r0, [pc, #512]	; (800eedc <heap1_execute+0x2dc>)
 800ecdc:	2110      	movs	r1, #16
 800ecde:	f7f4 fd3f 	bl	8003760 <chHeapAlloc>
 800ece2:	9003      	str	r0, [sp, #12]
  chHeapFree(p3);                               /* Merges forward.*/
 800ece4:	9803      	ldr	r0, [sp, #12]
 800ece6:	f7f4 fdb3 	bl	8003850 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 800ecea:	9804      	ldr	r0, [sp, #16]
 800ecec:	f7f4 fdb0 	bl	8003850 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 800ecf0:	9805      	ldr	r0, [sp, #20]
 800ecf2:	f7f4 fdad 	bl	8003850 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ecf6:	ab02      	add	r3, sp, #8
 800ecf8:	4878      	ldr	r0, [pc, #480]	; (800eedc <heap1_execute+0x2dc>)
 800ecfa:	4619      	mov	r1, r3
 800ecfc:	f7f4 fe10 	bl	8003920 <chHeapStatus>
 800ed00:	4603      	mov	r3, r0
 800ed02:	2b01      	cmp	r3, #1
 800ed04:	bf14      	ite	ne
 800ed06:	2300      	movne	r3, #0
 800ed08:	2301      	moveq	r3, #1
 800ed0a:	b2db      	uxtb	r3, r3
 800ed0c:	2004      	movs	r0, #4
 800ed0e:	4619      	mov	r1, r3
 800ed10:	f7fd f89e 	bl	800be50 <_test_assert>
 800ed14:	4603      	mov	r3, r0
 800ed16:	2b00      	cmp	r3, #0
 800ed18:	d000      	beq.n	800ed1c <heap1_execute+0x11c>
 800ed1a:	e0dc      	b.n	800eed6 <heap1_execute+0x2d6>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 800ed1c:	486f      	ldr	r0, [pc, #444]	; (800eedc <heap1_execute+0x2dc>)
 800ed1e:	2111      	movs	r1, #17
 800ed20:	f7f4 fd1e 	bl	8003760 <chHeapAlloc>
 800ed24:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800ed26:	486d      	ldr	r0, [pc, #436]	; (800eedc <heap1_execute+0x2dc>)
 800ed28:	2110      	movs	r1, #16
 800ed2a:	f7f4 fd19 	bl	8003760 <chHeapAlloc>
 800ed2e:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 800ed30:	9805      	ldr	r0, [sp, #20]
 800ed32:	f7f4 fd8d 	bl	8003850 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800ed36:	ab02      	add	r3, sp, #8
 800ed38:	4868      	ldr	r0, [pc, #416]	; (800eedc <heap1_execute+0x2dc>)
 800ed3a:	4619      	mov	r1, r3
 800ed3c:	f7f4 fdf0 	bl	8003920 <chHeapStatus>
 800ed40:	4603      	mov	r3, r0
 800ed42:	2b02      	cmp	r3, #2
 800ed44:	bf14      	ite	ne
 800ed46:	2300      	movne	r3, #0
 800ed48:	2301      	moveq	r3, #1
 800ed4a:	b2db      	uxtb	r3, r3
 800ed4c:	2005      	movs	r0, #5
 800ed4e:	4619      	mov	r1, r3
 800ed50:	f7fd f87e 	bl	800be50 <_test_assert>
 800ed54:	4603      	mov	r3, r0
 800ed56:	2b00      	cmp	r3, #0
 800ed58:	d000      	beq.n	800ed5c <heap1_execute+0x15c>
 800ed5a:	e0bc      	b.n	800eed6 <heap1_execute+0x2d6>
  p1 = chHeapAlloc(&test_heap, SIZE);
 800ed5c:	485f      	ldr	r0, [pc, #380]	; (800eedc <heap1_execute+0x2dc>)
 800ed5e:	2110      	movs	r1, #16
 800ed60:	f7f4 fcfe 	bl	8003760 <chHeapAlloc>
 800ed64:	9005      	str	r0, [sp, #20]
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 800ed66:	ab02      	add	r3, sp, #8
 800ed68:	485c      	ldr	r0, [pc, #368]	; (800eedc <heap1_execute+0x2dc>)
 800ed6a:	4619      	mov	r1, r3
 800ed6c:	f7f4 fdd8 	bl	8003920 <chHeapStatus>
 800ed70:	4603      	mov	r3, r0
 800ed72:	2b01      	cmp	r3, #1
 800ed74:	d007      	beq.n	800ed86 <heap1_execute+0x186>
 800ed76:	ab02      	add	r3, sp, #8
 800ed78:	4858      	ldr	r0, [pc, #352]	; (800eedc <heap1_execute+0x2dc>)
 800ed7a:	4619      	mov	r1, r3
 800ed7c:	f7f4 fdd0 	bl	8003920 <chHeapStatus>
 800ed80:	4603      	mov	r3, r0
 800ed82:	2b02      	cmp	r3, #2
 800ed84:	d101      	bne.n	800ed8a <heap1_execute+0x18a>
 800ed86:	2301      	movs	r3, #1
 800ed88:	e000      	b.n	800ed8c <heap1_execute+0x18c>
 800ed8a:	2300      	movs	r3, #0
 800ed8c:	f003 0301 	and.w	r3, r3, #1
 800ed90:	b2db      	uxtb	r3, r3
 800ed92:	2006      	movs	r0, #6
 800ed94:	4619      	mov	r1, r3
 800ed96:	f7fd f85b 	bl	800be50 <_test_assert>
 800ed9a:	4603      	mov	r3, r0
 800ed9c:	2b00      	cmp	r3, #0
 800ed9e:	d000      	beq.n	800eda2 <heap1_execute+0x1a2>
 800eda0:	e099      	b.n	800eed6 <heap1_execute+0x2d6>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 800eda2:	9804      	ldr	r0, [sp, #16]
 800eda4:	f7f4 fd54 	bl	8003850 <chHeapFree>
  chHeapFree(p1);
 800eda8:	9805      	ldr	r0, [sp, #20]
 800edaa:	f7f4 fd51 	bl	8003850 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800edae:	ab02      	add	r3, sp, #8
 800edb0:	484a      	ldr	r0, [pc, #296]	; (800eedc <heap1_execute+0x2dc>)
 800edb2:	4619      	mov	r1, r3
 800edb4:	f7f4 fdb4 	bl	8003920 <chHeapStatus>
 800edb8:	4603      	mov	r3, r0
 800edba:	2b01      	cmp	r3, #1
 800edbc:	bf14      	ite	ne
 800edbe:	2300      	movne	r3, #0
 800edc0:	2301      	moveq	r3, #1
 800edc2:	b2db      	uxtb	r3, r3
 800edc4:	2007      	movs	r0, #7
 800edc6:	4619      	mov	r1, r3
 800edc8:	f7fd f842 	bl	800be50 <_test_assert>
 800edcc:	4603      	mov	r3, r0
 800edce:	2b00      	cmp	r3, #0
 800edd0:	d000      	beq.n	800edd4 <heap1_execute+0x1d4>
 800edd2:	e080      	b.n	800eed6 <heap1_execute+0x2d6>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800edd4:	4841      	ldr	r0, [pc, #260]	; (800eedc <heap1_execute+0x2dc>)
 800edd6:	2110      	movs	r1, #16
 800edd8:	f7f4 fcc2 	bl	8003760 <chHeapAlloc>
 800eddc:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800edde:	483f      	ldr	r0, [pc, #252]	; (800eedc <heap1_execute+0x2dc>)
 800ede0:	2110      	movs	r1, #16
 800ede2:	f7f4 fcbd 	bl	8003760 <chHeapAlloc>
 800ede6:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 800ede8:	9805      	ldr	r0, [sp, #20]
 800edea:	f7f4 fd31 	bl	8003850 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800edee:	ab02      	add	r3, sp, #8
 800edf0:	483a      	ldr	r0, [pc, #232]	; (800eedc <heap1_execute+0x2dc>)
 800edf2:	4619      	mov	r1, r3
 800edf4:	f7f4 fd94 	bl	8003920 <chHeapStatus>
 800edf8:	4603      	mov	r3, r0
 800edfa:	2b02      	cmp	r3, #2
 800edfc:	bf14      	ite	ne
 800edfe:	2300      	movne	r3, #0
 800ee00:	2301      	moveq	r3, #1
 800ee02:	b2db      	uxtb	r3, r3
 800ee04:	2008      	movs	r0, #8
 800ee06:	4619      	mov	r1, r3
 800ee08:	f7fd f822 	bl	800be50 <_test_assert>
 800ee0c:	4603      	mov	r3, r0
 800ee0e:	2b00      	cmp	r3, #0
 800ee10:	d000      	beq.n	800ee14 <heap1_execute+0x214>
 800ee12:	e060      	b.n	800eed6 <heap1_execute+0x2d6>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 800ee14:	4831      	ldr	r0, [pc, #196]	; (800eedc <heap1_execute+0x2dc>)
 800ee16:	2120      	movs	r1, #32
 800ee18:	f7f4 fca2 	bl	8003760 <chHeapAlloc>
 800ee1c:	9005      	str	r0, [sp, #20]
  chHeapFree(p1);
 800ee1e:	9805      	ldr	r0, [sp, #20]
 800ee20:	f7f4 fd16 	bl	8003850 <chHeapFree>
  chHeapFree(p2);
 800ee24:	9804      	ldr	r0, [sp, #16]
 800ee26:	f7f4 fd13 	bl	8003850 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ee2a:	ab02      	add	r3, sp, #8
 800ee2c:	482b      	ldr	r0, [pc, #172]	; (800eedc <heap1_execute+0x2dc>)
 800ee2e:	4619      	mov	r1, r3
 800ee30:	f7f4 fd76 	bl	8003920 <chHeapStatus>
 800ee34:	4603      	mov	r3, r0
 800ee36:	2b01      	cmp	r3, #1
 800ee38:	bf14      	ite	ne
 800ee3a:	2300      	movne	r3, #0
 800ee3c:	2301      	moveq	r3, #1
 800ee3e:	b2db      	uxtb	r3, r3
 800ee40:	2009      	movs	r0, #9
 800ee42:	4619      	mov	r1, r3
 800ee44:	f7fd f804 	bl	800be50 <_test_assert>
 800ee48:	4603      	mov	r3, r0
 800ee4a:	2b00      	cmp	r3, #0
 800ee4c:	d000      	beq.n	800ee50 <heap1_execute+0x250>
 800ee4e:	e042      	b.n	800eed6 <heap1_execute+0x2d6>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 800ee50:	ab02      	add	r3, sp, #8
 800ee52:	4822      	ldr	r0, [pc, #136]	; (800eedc <heap1_execute+0x2dc>)
 800ee54:	4619      	mov	r1, r3
 800ee56:	f7f4 fd63 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 800ee5a:	9b02      	ldr	r3, [sp, #8]
 800ee5c:	481f      	ldr	r0, [pc, #124]	; (800eedc <heap1_execute+0x2dc>)
 800ee5e:	4619      	mov	r1, r3
 800ee60:	f7f4 fc7e 	bl	8003760 <chHeapAlloc>
 800ee64:	9005      	str	r0, [sp, #20]
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 800ee66:	ab02      	add	r3, sp, #8
 800ee68:	481c      	ldr	r0, [pc, #112]	; (800eedc <heap1_execute+0x2dc>)
 800ee6a:	4619      	mov	r1, r3
 800ee6c:	f7f4 fd58 	bl	8003920 <chHeapStatus>
 800ee70:	4603      	mov	r3, r0
 800ee72:	2b00      	cmp	r3, #0
 800ee74:	bf14      	ite	ne
 800ee76:	2300      	movne	r3, #0
 800ee78:	2301      	moveq	r3, #1
 800ee7a:	b2db      	uxtb	r3, r3
 800ee7c:	200a      	movs	r0, #10
 800ee7e:	4619      	mov	r1, r3
 800ee80:	f7fc ffe6 	bl	800be50 <_test_assert>
 800ee84:	4603      	mov	r3, r0
 800ee86:	2b00      	cmp	r3, #0
 800ee88:	d000      	beq.n	800ee8c <heap1_execute+0x28c>
 800ee8a:	e024      	b.n	800eed6 <heap1_execute+0x2d6>
  chHeapFree(p1);
 800ee8c:	9805      	ldr	r0, [sp, #20]
 800ee8e:	f7f4 fcdf 	bl	8003850 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ee92:	ab02      	add	r3, sp, #8
 800ee94:	4811      	ldr	r0, [pc, #68]	; (800eedc <heap1_execute+0x2dc>)
 800ee96:	4619      	mov	r1, r3
 800ee98:	f7f4 fd42 	bl	8003920 <chHeapStatus>
 800ee9c:	4603      	mov	r3, r0
 800ee9e:	2b01      	cmp	r3, #1
 800eea0:	bf14      	ite	ne
 800eea2:	2300      	movne	r3, #0
 800eea4:	2301      	moveq	r3, #1
 800eea6:	b2db      	uxtb	r3, r3
 800eea8:	200b      	movs	r0, #11
 800eeaa:	4619      	mov	r1, r3
 800eeac:	f7fc ffd0 	bl	800be50 <_test_assert>
 800eeb0:	4603      	mov	r3, r0
 800eeb2:	2b00      	cmp	r3, #0
 800eeb4:	d000      	beq.n	800eeb8 <heap1_execute+0x2b8>
 800eeb6:	e00e      	b.n	800eed6 <heap1_execute+0x2d6>
  test_assert(12, n == sz, "size changed");
 800eeb8:	9a02      	ldr	r2, [sp, #8]
 800eeba:	9b01      	ldr	r3, [sp, #4]
 800eebc:	429a      	cmp	r2, r3
 800eebe:	bf14      	ite	ne
 800eec0:	2300      	movne	r3, #0
 800eec2:	2301      	moveq	r3, #1
 800eec4:	b2db      	uxtb	r3, r3
 800eec6:	200c      	movs	r0, #12
 800eec8:	4619      	mov	r1, r3
 800eeca:	f7fc ffc1 	bl	800be50 <_test_assert>
 800eece:	4603      	mov	r3, r0
 800eed0:	2b00      	cmp	r3, #0
 800eed2:	d000      	beq.n	800eed6 <heap1_execute+0x2d6>
 800eed4:	bf00      	nop
}
 800eed6:	b007      	add	sp, #28
 800eed8:	f85d fb04 	ldr.w	pc, [sp], #4
 800eedc:	200014a0 	.word	0x200014a0

0800eee0 <null_provider>:
 * Five memory blocks are added to a memory pool then removed.<br>
 * The test expects to find the pool queue in the proper status after each
 * operation.
 */

static void *null_provider(size_t size) {
 800eee0:	b082      	sub	sp, #8
 800eee2:	9001      	str	r0, [sp, #4]

  (void)size;
  return NULL;
 800eee4:	2300      	movs	r3, #0
}
 800eee6:	4618      	mov	r0, r3
 800eee8:	b002      	add	sp, #8
 800eeea:	4770      	bx	lr
 800eeec:	f3af 8000 	nop.w

0800eef0 <pools1_setup>:

static void pools1_setup(void) {
 800eef0:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 800eef2:	4803      	ldr	r0, [pc, #12]	; (800ef00 <pools1_setup+0x10>)
 800eef4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800eef8:	2200      	movs	r2, #0
 800eefa:	f7f4 fd79 	bl	80039f0 <chPoolObjectInit>
}
 800eefe:	bd08      	pop	{r3, pc}
 800ef00:	2000089c 	.word	0x2000089c
 800ef04:	f3af 8000 	nop.w
 800ef08:	f3af 8000 	nop.w
 800ef0c:	f3af 8000 	nop.w

0800ef10 <pools1_execute>:

static void pools1_execute(void) {
 800ef10:	b500      	push	{lr}
 800ef12:	b083      	sub	sp, #12
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 800ef14:	4b43      	ldr	r3, [pc, #268]	; (800f024 <pools1_execute+0x114>)
 800ef16:	681b      	ldr	r3, [r3, #0]
 800ef18:	4843      	ldr	r0, [pc, #268]	; (800f028 <pools1_execute+0x118>)
 800ef1a:	4619      	mov	r1, r3
 800ef1c:	2205      	movs	r2, #5
 800ef1e:	f7f4 fd77 	bl	8003a10 <chPoolLoadArray>

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef22:	2300      	movs	r3, #0
 800ef24:	9301      	str	r3, [sp, #4]
 800ef26:	e013      	b.n	800ef50 <pools1_execute+0x40>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 800ef28:	483f      	ldr	r0, [pc, #252]	; (800f028 <pools1_execute+0x118>)
 800ef2a:	f7f4 fda9 	bl	8003a80 <chPoolAlloc>
 800ef2e:	4603      	mov	r3, r0
 800ef30:	2b00      	cmp	r3, #0
 800ef32:	bf0c      	ite	eq
 800ef34:	2300      	moveq	r3, #0
 800ef36:	2301      	movne	r3, #1
 800ef38:	b2db      	uxtb	r3, r3
 800ef3a:	2001      	movs	r0, #1
 800ef3c:	4619      	mov	r1, r3
 800ef3e:	f7fc ff87 	bl	800be50 <_test_assert>
 800ef42:	4603      	mov	r3, r0
 800ef44:	2b00      	cmp	r3, #0
 800ef46:	d000      	beq.n	800ef4a <pools1_execute+0x3a>
 800ef48:	e068      	b.n	800f01c <pools1_execute+0x10c>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef4a:	9b01      	ldr	r3, [sp, #4]
 800ef4c:	3301      	adds	r3, #1
 800ef4e:	9301      	str	r3, [sp, #4]
 800ef50:	9b01      	ldr	r3, [sp, #4]
 800ef52:	2b04      	cmp	r3, #4
 800ef54:	dde8      	ble.n	800ef28 <pools1_execute+0x18>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 800ef56:	4834      	ldr	r0, [pc, #208]	; (800f028 <pools1_execute+0x118>)
 800ef58:	f7f4 fd92 	bl	8003a80 <chPoolAlloc>
 800ef5c:	4603      	mov	r3, r0
 800ef5e:	2b00      	cmp	r3, #0
 800ef60:	bf14      	ite	ne
 800ef62:	2300      	movne	r3, #0
 800ef64:	2301      	moveq	r3, #1
 800ef66:	b2db      	uxtb	r3, r3
 800ef68:	2002      	movs	r0, #2
 800ef6a:	4619      	mov	r1, r3
 800ef6c:	f7fc ff70 	bl	800be50 <_test_assert>
 800ef70:	4603      	mov	r3, r0
 800ef72:	2b00      	cmp	r3, #0
 800ef74:	d000      	beq.n	800ef78 <pools1_execute+0x68>
 800ef76:	e051      	b.n	800f01c <pools1_execute+0x10c>

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef78:	2300      	movs	r3, #0
 800ef7a:	9301      	str	r3, [sp, #4]
 800ef7c:	e00a      	b.n	800ef94 <pools1_execute+0x84>
    chPoolFree(&mp1, wa[i]);
 800ef7e:	4b29      	ldr	r3, [pc, #164]	; (800f024 <pools1_execute+0x114>)
 800ef80:	9a01      	ldr	r2, [sp, #4]
 800ef82:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ef86:	4828      	ldr	r0, [pc, #160]	; (800f028 <pools1_execute+0x118>)
 800ef88:	4619      	mov	r1, r3
 800ef8a:	f7f4 fd99 	bl	8003ac0 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef8e:	9b01      	ldr	r3, [sp, #4]
 800ef90:	3301      	adds	r3, #1
 800ef92:	9301      	str	r3, [sp, #4]
 800ef94:	9b01      	ldr	r3, [sp, #4]
 800ef96:	2b04      	cmp	r3, #4
 800ef98:	ddf1      	ble.n	800ef7e <pools1_execute+0x6e>
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef9a:	2300      	movs	r3, #0
 800ef9c:	9301      	str	r3, [sp, #4]
 800ef9e:	e013      	b.n	800efc8 <pools1_execute+0xb8>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 800efa0:	4821      	ldr	r0, [pc, #132]	; (800f028 <pools1_execute+0x118>)
 800efa2:	f7f4 fd6d 	bl	8003a80 <chPoolAlloc>
 800efa6:	4603      	mov	r3, r0
 800efa8:	2b00      	cmp	r3, #0
 800efaa:	bf0c      	ite	eq
 800efac:	2300      	moveq	r3, #0
 800efae:	2301      	movne	r3, #1
 800efb0:	b2db      	uxtb	r3, r3
 800efb2:	2003      	movs	r0, #3
 800efb4:	4619      	mov	r1, r3
 800efb6:	f7fc ff4b 	bl	800be50 <_test_assert>
 800efba:	4603      	mov	r3, r0
 800efbc:	2b00      	cmp	r3, #0
 800efbe:	d000      	beq.n	800efc2 <pools1_execute+0xb2>
 800efc0:	e02c      	b.n	800f01c <pools1_execute+0x10c>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 800efc2:	9b01      	ldr	r3, [sp, #4]
 800efc4:	3301      	adds	r3, #1
 800efc6:	9301      	str	r3, [sp, #4]
 800efc8:	9b01      	ldr	r3, [sp, #4]
 800efca:	2b04      	cmp	r3, #4
 800efcc:	dde8      	ble.n	800efa0 <pools1_execute+0x90>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 800efce:	4816      	ldr	r0, [pc, #88]	; (800f028 <pools1_execute+0x118>)
 800efd0:	f7f4 fd56 	bl	8003a80 <chPoolAlloc>
 800efd4:	4603      	mov	r3, r0
 800efd6:	2b00      	cmp	r3, #0
 800efd8:	bf14      	ite	ne
 800efda:	2300      	movne	r3, #0
 800efdc:	2301      	moveq	r3, #1
 800efde:	b2db      	uxtb	r3, r3
 800efe0:	2004      	movs	r0, #4
 800efe2:	4619      	mov	r1, r3
 800efe4:	f7fc ff34 	bl	800be50 <_test_assert>
 800efe8:	4603      	mov	r3, r0
 800efea:	2b00      	cmp	r3, #0
 800efec:	d000      	beq.n	800eff0 <pools1_execute+0xe0>
 800efee:	e015      	b.n	800f01c <pools1_execute+0x10c>

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
 800eff0:	480d      	ldr	r0, [pc, #52]	; (800f028 <pools1_execute+0x118>)
 800eff2:	2110      	movs	r1, #16
 800eff4:	4a0d      	ldr	r2, [pc, #52]	; (800f02c <pools1_execute+0x11c>)
 800eff6:	f7f4 fcfb 	bl	80039f0 <chPoolObjectInit>
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 800effa:	480b      	ldr	r0, [pc, #44]	; (800f028 <pools1_execute+0x118>)
 800effc:	f7f4 fd40 	bl	8003a80 <chPoolAlloc>
 800f000:	4603      	mov	r3, r0
 800f002:	2b00      	cmp	r3, #0
 800f004:	bf14      	ite	ne
 800f006:	2300      	movne	r3, #0
 800f008:	2301      	moveq	r3, #1
 800f00a:	b2db      	uxtb	r3, r3
 800f00c:	2005      	movs	r0, #5
 800f00e:	4619      	mov	r1, r3
 800f010:	f7fc ff1e 	bl	800be50 <_test_assert>
 800f014:	4603      	mov	r3, r0
 800f016:	2b00      	cmp	r3, #0
 800f018:	d000      	beq.n	800f01c <pools1_execute+0x10c>
 800f01a:	bf00      	nop
}
 800f01c:	b003      	add	sp, #12
 800f01e:	f85d fb04 	ldr.w	pc, [sp], #4
 800f022:	bf00      	nop
 800f024:	0801ad70 	.word	0x0801ad70
 800f028:	2000089c 	.word	0x2000089c
 800f02c:	0800eee1 	.word	0x0800eee1

0800f030 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800f030:	4b01      	ldr	r3, [pc, #4]	; (800f038 <chThdGetSelfX+0x8>)
 800f032:	699b      	ldr	r3, [r3, #24]
}
 800f034:	4618      	mov	r0, r3
 800f036:	4770      	bx	lr
 800f038:	200039a8 	.word	0x200039a8
 800f03c:	f3af 8000 	nop.w

0800f040 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800f040:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800f042:	f7ff fff5 	bl	800f030 <chThdGetSelfX>
 800f046:	4603      	mov	r3, r0
 800f048:	689b      	ldr	r3, [r3, #8]
}
 800f04a:	4618      	mov	r0, r3
 800f04c:	bd08      	pop	{r3, pc}
 800f04e:	bf00      	nop

0800f050 <thread>:
 * is attempted.<br>
 * The test expects the first two threads to successfully start and the last
 * one to fail.
 */

static THD_FUNCTION(thread, p) {
 800f050:	b500      	push	{lr}
 800f052:	b083      	sub	sp, #12
 800f054:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 800f056:	9b01      	ldr	r3, [sp, #4]
 800f058:	781b      	ldrb	r3, [r3, #0]
 800f05a:	4618      	mov	r0, r3
 800f05c:	f7fc fec8 	bl	800bdf0 <test_emit_token>
}
 800f060:	b003      	add	sp, #12
 800f062:	f85d fb04 	ldr.w	pc, [sp], #4
 800f066:	bf00      	nop
 800f068:	f3af 8000 	nop.w
 800f06c:	f3af 8000 	nop.w

0800f070 <dyn1_setup>:

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {
 800f070:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 800f072:	4803      	ldr	r0, [pc, #12]	; (800f080 <dyn1_setup+0x10>)
 800f074:	4903      	ldr	r1, [pc, #12]	; (800f084 <dyn1_setup+0x14>)
 800f076:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800f07a:	f7f4 fb51 	bl	8003720 <chHeapObjectInit>
}
 800f07e:	bd08      	pop	{r3, pc}
 800f080:	200014c0 	.word	0x200014c0
 800f084:	20003e50 	.word	0x20003e50
 800f088:	f3af 8000 	nop.w
 800f08c:	f3af 8000 	nop.w

0800f090 <dyn1_execute>:

static void dyn1_execute(void) {
 800f090:	b500      	push	{lr}
 800f092:	b087      	sub	sp, #28
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();
 800f094:	f7ff ffd4 	bl	800f040 <chThdGetPriorityX>
 800f098:	9005      	str	r0, [sp, #20]

  (void)chHeapStatus(&heap1, &sz);
 800f09a:	ab02      	add	r3, sp, #8
 800f09c:	4846      	ldr	r0, [pc, #280]	; (800f1b8 <dyn1_execute+0x128>)
 800f09e:	4619      	mov	r1, r3
 800f0a0:	f7f4 fc3e 	bl	8003920 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 800f0a4:	9b05      	ldr	r3, [sp, #20]
 800f0a6:	3b01      	subs	r3, #1
 800f0a8:	4a44      	ldr	r2, [pc, #272]	; (800f1bc <dyn1_execute+0x12c>)
 800f0aa:	9200      	str	r2, [sp, #0]
 800f0ac:	4842      	ldr	r0, [pc, #264]	; (800f1b8 <dyn1_execute+0x128>)
 800f0ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f0b2:	461a      	mov	r2, r3
 800f0b4:	4b42      	ldr	r3, [pc, #264]	; (800f1c0 <dyn1_execute+0x130>)
 800f0b6:	f7f2 fbcb 	bl	8001850 <chThdCreateFromHeap>
 800f0ba:	4602      	mov	r2, r0
 800f0bc:	4b41      	ldr	r3, [pc, #260]	; (800f1c4 <dyn1_execute+0x134>)
 800f0be:	601a      	str	r2, [r3, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 800f0c0:	9b05      	ldr	r3, [sp, #20]
 800f0c2:	3b02      	subs	r3, #2
 800f0c4:	4a40      	ldr	r2, [pc, #256]	; (800f1c8 <dyn1_execute+0x138>)
 800f0c6:	9200      	str	r2, [sp, #0]
 800f0c8:	483b      	ldr	r0, [pc, #236]	; (800f1b8 <dyn1_execute+0x128>)
 800f0ca:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f0ce:	461a      	mov	r2, r3
 800f0d0:	4b3b      	ldr	r3, [pc, #236]	; (800f1c0 <dyn1_execute+0x130>)
 800f0d2:	f7f2 fbbd 	bl	8001850 <chThdCreateFromHeap>
 800f0d6:	4602      	mov	r2, r0
 800f0d8:	4b3a      	ldr	r3, [pc, #232]	; (800f1c4 <dyn1_execute+0x134>)
 800f0da:	605a      	str	r2, [r3, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 800f0dc:	ab03      	add	r3, sp, #12
 800f0de:	4836      	ldr	r0, [pc, #216]	; (800f1b8 <dyn1_execute+0x128>)
 800f0e0:	4619      	mov	r1, r3
 800f0e2:	f7f4 fc1d 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 800f0e6:	9b03      	ldr	r3, [sp, #12]
 800f0e8:	4833      	ldr	r0, [pc, #204]	; (800f1b8 <dyn1_execute+0x128>)
 800f0ea:	4619      	mov	r1, r3
 800f0ec:	f7f4 fb38 	bl	8003760 <chHeapAlloc>
 800f0f0:	9004      	str	r0, [sp, #16]
  threads[2] = chThdCreateFromHeap(&heap1,
 800f0f2:	9b05      	ldr	r3, [sp, #20]
 800f0f4:	3b03      	subs	r3, #3
 800f0f6:	4a35      	ldr	r2, [pc, #212]	; (800f1cc <dyn1_execute+0x13c>)
 800f0f8:	9200      	str	r2, [sp, #0]
 800f0fa:	482f      	ldr	r0, [pc, #188]	; (800f1b8 <dyn1_execute+0x128>)
 800f0fc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f100:	461a      	mov	r2, r3
 800f102:	4b2f      	ldr	r3, [pc, #188]	; (800f1c0 <dyn1_execute+0x130>)
 800f104:	f7f2 fba4 	bl	8001850 <chThdCreateFromHeap>
 800f108:	4602      	mov	r2, r0
 800f10a:	4b2e      	ldr	r3, [pc, #184]	; (800f1c4 <dyn1_execute+0x134>)
 800f10c:	609a      	str	r2, [r3, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 800f10e:	9804      	ldr	r0, [sp, #16]
 800f110:	f7f4 fb9e 	bl	8003850 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 800f114:	4b2b      	ldr	r3, [pc, #172]	; (800f1c4 <dyn1_execute+0x134>)
 800f116:	681b      	ldr	r3, [r3, #0]
 800f118:	2b00      	cmp	r3, #0
 800f11a:	d011      	beq.n	800f140 <dyn1_execute+0xb0>
 800f11c:	4b29      	ldr	r3, [pc, #164]	; (800f1c4 <dyn1_execute+0x134>)
 800f11e:	685b      	ldr	r3, [r3, #4]
 800f120:	2b00      	cmp	r3, #0
 800f122:	d00d      	beq.n	800f140 <dyn1_execute+0xb0>
 800f124:	4b27      	ldr	r3, [pc, #156]	; (800f1c4 <dyn1_execute+0x134>)
 800f126:	689b      	ldr	r3, [r3, #8]
 800f128:	2b00      	cmp	r3, #0
 800f12a:	d109      	bne.n	800f140 <dyn1_execute+0xb0>
 800f12c:	4b25      	ldr	r3, [pc, #148]	; (800f1c4 <dyn1_execute+0x134>)
 800f12e:	68db      	ldr	r3, [r3, #12]
 800f130:	2b00      	cmp	r3, #0
 800f132:	d105      	bne.n	800f140 <dyn1_execute+0xb0>
 800f134:	4b23      	ldr	r3, [pc, #140]	; (800f1c4 <dyn1_execute+0x134>)
 800f136:	691b      	ldr	r3, [r3, #16]
 800f138:	2b00      	cmp	r3, #0
 800f13a:	d101      	bne.n	800f140 <dyn1_execute+0xb0>
 800f13c:	2301      	movs	r3, #1
 800f13e:	e000      	b.n	800f142 <dyn1_execute+0xb2>
 800f140:	2300      	movs	r3, #0
 800f142:	f003 0301 	and.w	r3, r3, #1
 800f146:	b2db      	uxtb	r3, r3
 800f148:	2001      	movs	r0, #1
 800f14a:	4619      	mov	r1, r3
 800f14c:	f7fc fe80 	bl	800be50 <_test_assert>
 800f150:	4603      	mov	r3, r0
 800f152:	2b00      	cmp	r3, #0
 800f154:	d000      	beq.n	800f158 <dyn1_execute+0xc8>
 800f156:	e02b      	b.n	800f1b0 <dyn1_execute+0x120>
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 800f158:	f7fc fefa 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(2, "AB");
 800f15c:	2002      	movs	r0, #2
 800f15e:	491c      	ldr	r1, [pc, #112]	; (800f1d0 <dyn1_execute+0x140>)
 800f160:	f7fc fe8e 	bl	800be80 <_test_assert_sequence>
 800f164:	4603      	mov	r3, r0
 800f166:	2b00      	cmp	r3, #0
 800f168:	d000      	beq.n	800f16c <dyn1_execute+0xdc>
 800f16a:	e021      	b.n	800f1b0 <dyn1_execute+0x120>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 800f16c:	ab03      	add	r3, sp, #12
 800f16e:	4812      	ldr	r0, [pc, #72]	; (800f1b8 <dyn1_execute+0x128>)
 800f170:	4619      	mov	r1, r3
 800f172:	f7f4 fbd5 	bl	8003920 <chHeapStatus>
 800f176:	4603      	mov	r3, r0
 800f178:	2b01      	cmp	r3, #1
 800f17a:	bf14      	ite	ne
 800f17c:	2300      	movne	r3, #0
 800f17e:	2301      	moveq	r3, #1
 800f180:	b2db      	uxtb	r3, r3
 800f182:	2003      	movs	r0, #3
 800f184:	4619      	mov	r1, r3
 800f186:	f7fc fe63 	bl	800be50 <_test_assert>
 800f18a:	4603      	mov	r3, r0
 800f18c:	2b00      	cmp	r3, #0
 800f18e:	d000      	beq.n	800f192 <dyn1_execute+0x102>
 800f190:	e00e      	b.n	800f1b0 <dyn1_execute+0x120>
  test_assert(4, n == sz, "heap size changed");
 800f192:	9a03      	ldr	r2, [sp, #12]
 800f194:	9b02      	ldr	r3, [sp, #8]
 800f196:	429a      	cmp	r2, r3
 800f198:	bf14      	ite	ne
 800f19a:	2300      	movne	r3, #0
 800f19c:	2301      	moveq	r3, #1
 800f19e:	b2db      	uxtb	r3, r3
 800f1a0:	2004      	movs	r0, #4
 800f1a2:	4619      	mov	r1, r3
 800f1a4:	f7fc fe54 	bl	800be50 <_test_assert>
 800f1a8:	4603      	mov	r3, r0
 800f1aa:	2b00      	cmp	r3, #0
 800f1ac:	d000      	beq.n	800f1b0 <dyn1_execute+0x120>
 800f1ae:	bf00      	nop
}
 800f1b0:	b007      	add	sp, #28
 800f1b2:	f85d fb04 	ldr.w	pc, [sp], #4
 800f1b6:	bf00      	nop
 800f1b8:	200014c0 	.word	0x200014c0
 800f1bc:	0801b410 	.word	0x0801b410
 800f1c0:	0800f051 	.word	0x0800f051
 800f1c4:	20003e3c 	.word	0x20003e3c
 800f1c8:	0801b414 	.word	0x0801b414
 800f1cc:	0801b418 	.word	0x0801b418
 800f1d0:	0801b41c 	.word	0x0801b41c
 800f1d4:	f3af 8000 	nop.w
 800f1d8:	f3af 8000 	nop.w
 800f1dc:	f3af 8000 	nop.w

0800f1e0 <dyn2_setup>:
 * elements.<br>
 * The test expects the first four threads to successfully start and the last
 * one to fail.
 */

static void dyn2_setup(void) {
 800f1e0:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 800f1e2:	4803      	ldr	r0, [pc, #12]	; (800f1f0 <dyn2_setup+0x10>)
 800f1e4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f1e8:	2200      	movs	r2, #0
 800f1ea:	f7f4 fc01 	bl	80039f0 <chPoolObjectInit>
}
 800f1ee:	bd08      	pop	{r3, pc}
 800f1f0:	200014e0 	.word	0x200014e0
 800f1f4:	f3af 8000 	nop.w
 800f1f8:	f3af 8000 	nop.w
 800f1fc:	f3af 8000 	nop.w

0800f200 <dyn2_execute>:

static void dyn2_execute(void) {
 800f200:	b500      	push	{lr}
 800f202:	b083      	sub	sp, #12
  int i;
  tprio_t prio = chThdGetPriorityX();
 800f204:	f7ff ff1c 	bl	800f040 <chThdGetPriorityX>
 800f208:	9000      	str	r0, [sp, #0]

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 800f20a:	2300      	movs	r3, #0
 800f20c:	9301      	str	r3, [sp, #4]
 800f20e:	e00a      	b.n	800f226 <dyn2_execute+0x26>
    chPoolFree(&mp1, wa[i]);
 800f210:	4b4f      	ldr	r3, [pc, #316]	; (800f350 <dyn2_execute+0x150>)
 800f212:	9a01      	ldr	r2, [sp, #4]
 800f214:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800f218:	484e      	ldr	r0, [pc, #312]	; (800f354 <dyn2_execute+0x154>)
 800f21a:	4619      	mov	r1, r3
 800f21c:	f7f4 fc50 	bl	8003ac0 <chPoolFree>
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 800f220:	9b01      	ldr	r3, [sp, #4]
 800f222:	3301      	adds	r3, #1
 800f224:	9301      	str	r3, [sp, #4]
 800f226:	9b01      	ldr	r3, [sp, #4]
 800f228:	2b03      	cmp	r3, #3
 800f22a:	ddf1      	ble.n	800f210 <dyn2_execute+0x10>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 800f22c:	9b00      	ldr	r3, [sp, #0]
 800f22e:	3b01      	subs	r3, #1
 800f230:	4848      	ldr	r0, [pc, #288]	; (800f354 <dyn2_execute+0x154>)
 800f232:	4619      	mov	r1, r3
 800f234:	4a48      	ldr	r2, [pc, #288]	; (800f358 <dyn2_execute+0x158>)
 800f236:	4b49      	ldr	r3, [pc, #292]	; (800f35c <dyn2_execute+0x15c>)
 800f238:	f7f2 fb3a 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f23c:	4602      	mov	r2, r0
 800f23e:	4b48      	ldr	r3, [pc, #288]	; (800f360 <dyn2_execute+0x160>)
 800f240:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 800f242:	9b00      	ldr	r3, [sp, #0]
 800f244:	3b02      	subs	r3, #2
 800f246:	4843      	ldr	r0, [pc, #268]	; (800f354 <dyn2_execute+0x154>)
 800f248:	4619      	mov	r1, r3
 800f24a:	4a43      	ldr	r2, [pc, #268]	; (800f358 <dyn2_execute+0x158>)
 800f24c:	4b45      	ldr	r3, [pc, #276]	; (800f364 <dyn2_execute+0x164>)
 800f24e:	f7f2 fb2f 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f252:	4602      	mov	r2, r0
 800f254:	4b42      	ldr	r3, [pc, #264]	; (800f360 <dyn2_execute+0x160>)
 800f256:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 800f258:	9b00      	ldr	r3, [sp, #0]
 800f25a:	3b03      	subs	r3, #3
 800f25c:	483d      	ldr	r0, [pc, #244]	; (800f354 <dyn2_execute+0x154>)
 800f25e:	4619      	mov	r1, r3
 800f260:	4a3d      	ldr	r2, [pc, #244]	; (800f358 <dyn2_execute+0x158>)
 800f262:	4b41      	ldr	r3, [pc, #260]	; (800f368 <dyn2_execute+0x168>)
 800f264:	f7f2 fb24 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f268:	4602      	mov	r2, r0
 800f26a:	4b3d      	ldr	r3, [pc, #244]	; (800f360 <dyn2_execute+0x160>)
 800f26c:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 800f26e:	9b00      	ldr	r3, [sp, #0]
 800f270:	3b04      	subs	r3, #4
 800f272:	4838      	ldr	r0, [pc, #224]	; (800f354 <dyn2_execute+0x154>)
 800f274:	4619      	mov	r1, r3
 800f276:	4a38      	ldr	r2, [pc, #224]	; (800f358 <dyn2_execute+0x158>)
 800f278:	4b3c      	ldr	r3, [pc, #240]	; (800f36c <dyn2_execute+0x16c>)
 800f27a:	f7f2 fb19 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f27e:	4602      	mov	r2, r0
 800f280:	4b37      	ldr	r3, [pc, #220]	; (800f360 <dyn2_execute+0x160>)
 800f282:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 800f284:	9b00      	ldr	r3, [sp, #0]
 800f286:	3b05      	subs	r3, #5
 800f288:	4832      	ldr	r0, [pc, #200]	; (800f354 <dyn2_execute+0x154>)
 800f28a:	4619      	mov	r1, r3
 800f28c:	4a32      	ldr	r2, [pc, #200]	; (800f358 <dyn2_execute+0x158>)
 800f28e:	4b38      	ldr	r3, [pc, #224]	; (800f370 <dyn2_execute+0x170>)
 800f290:	f7f2 fb0e 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f294:	4602      	mov	r2, r0
 800f296:	4b32      	ldr	r3, [pc, #200]	; (800f360 <dyn2_execute+0x160>)
 800f298:	611a      	str	r2, [r3, #16]

  test_assert(1, (threads[0] != NULL) &&
 800f29a:	4b31      	ldr	r3, [pc, #196]	; (800f360 <dyn2_execute+0x160>)
 800f29c:	681b      	ldr	r3, [r3, #0]
 800f29e:	2b00      	cmp	r3, #0
 800f2a0:	d011      	beq.n	800f2c6 <dyn2_execute+0xc6>
 800f2a2:	4b2f      	ldr	r3, [pc, #188]	; (800f360 <dyn2_execute+0x160>)
 800f2a4:	685b      	ldr	r3, [r3, #4]
 800f2a6:	2b00      	cmp	r3, #0
 800f2a8:	d00d      	beq.n	800f2c6 <dyn2_execute+0xc6>
 800f2aa:	4b2d      	ldr	r3, [pc, #180]	; (800f360 <dyn2_execute+0x160>)
 800f2ac:	689b      	ldr	r3, [r3, #8]
 800f2ae:	2b00      	cmp	r3, #0
 800f2b0:	d009      	beq.n	800f2c6 <dyn2_execute+0xc6>
 800f2b2:	4b2b      	ldr	r3, [pc, #172]	; (800f360 <dyn2_execute+0x160>)
 800f2b4:	68db      	ldr	r3, [r3, #12]
 800f2b6:	2b00      	cmp	r3, #0
 800f2b8:	d005      	beq.n	800f2c6 <dyn2_execute+0xc6>
 800f2ba:	4b29      	ldr	r3, [pc, #164]	; (800f360 <dyn2_execute+0x160>)
 800f2bc:	691b      	ldr	r3, [r3, #16]
 800f2be:	2b00      	cmp	r3, #0
 800f2c0:	d101      	bne.n	800f2c6 <dyn2_execute+0xc6>
 800f2c2:	2301      	movs	r3, #1
 800f2c4:	e000      	b.n	800f2c8 <dyn2_execute+0xc8>
 800f2c6:	2300      	movs	r3, #0
 800f2c8:	f003 0301 	and.w	r3, r3, #1
 800f2cc:	b2db      	uxtb	r3, r3
 800f2ce:	2001      	movs	r0, #1
 800f2d0:	4619      	mov	r1, r3
 800f2d2:	f7fc fdbd 	bl	800be50 <_test_assert>
 800f2d6:	4603      	mov	r3, r0
 800f2d8:	2b00      	cmp	r3, #0
 800f2da:	d000      	beq.n	800f2de <dyn2_execute+0xde>
 800f2dc:	e034      	b.n	800f348 <dyn2_execute+0x148>
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 800f2de:	f7fc fe37 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 800f2e2:	2002      	movs	r0, #2
 800f2e4:	4923      	ldr	r1, [pc, #140]	; (800f374 <dyn2_execute+0x174>)
 800f2e6:	f7fc fdcb 	bl	800be80 <_test_assert_sequence>
 800f2ea:	4603      	mov	r3, r0
 800f2ec:	2b00      	cmp	r3, #0
 800f2ee:	d000      	beq.n	800f2f2 <dyn2_execute+0xf2>
 800f2f0:	e02a      	b.n	800f348 <dyn2_execute+0x148>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800f2f2:	2300      	movs	r3, #0
 800f2f4:	9301      	str	r3, [sp, #4]
 800f2f6:	e013      	b.n	800f320 <dyn2_execute+0x120>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 800f2f8:	4816      	ldr	r0, [pc, #88]	; (800f354 <dyn2_execute+0x154>)
 800f2fa:	f7f4 fbc1 	bl	8003a80 <chPoolAlloc>
 800f2fe:	4603      	mov	r3, r0
 800f300:	2b00      	cmp	r3, #0
 800f302:	bf0c      	ite	eq
 800f304:	2300      	moveq	r3, #0
 800f306:	2301      	movne	r3, #1
 800f308:	b2db      	uxtb	r3, r3
 800f30a:	2003      	movs	r0, #3
 800f30c:	4619      	mov	r1, r3
 800f30e:	f7fc fd9f 	bl	800be50 <_test_assert>
 800f312:	4603      	mov	r3, r0
 800f314:	2b00      	cmp	r3, #0
 800f316:	d000      	beq.n	800f31a <dyn2_execute+0x11a>
 800f318:	e016      	b.n	800f348 <dyn2_execute+0x148>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800f31a:	9b01      	ldr	r3, [sp, #4]
 800f31c:	3301      	adds	r3, #1
 800f31e:	9301      	str	r3, [sp, #4]
 800f320:	9b01      	ldr	r3, [sp, #4]
 800f322:	2b03      	cmp	r3, #3
 800f324:	dde8      	ble.n	800f2f8 <dyn2_execute+0xf8>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800f326:	480b      	ldr	r0, [pc, #44]	; (800f354 <dyn2_execute+0x154>)
 800f328:	f7f4 fbaa 	bl	8003a80 <chPoolAlloc>
 800f32c:	4603      	mov	r3, r0
 800f32e:	2b00      	cmp	r3, #0
 800f330:	bf14      	ite	ne
 800f332:	2300      	movne	r3, #0
 800f334:	2301      	moveq	r3, #1
 800f336:	b2db      	uxtb	r3, r3
 800f338:	2004      	movs	r0, #4
 800f33a:	4619      	mov	r1, r3
 800f33c:	f7fc fd88 	bl	800be50 <_test_assert>
 800f340:	4603      	mov	r3, r0
 800f342:	2b00      	cmp	r3, #0
 800f344:	d000      	beq.n	800f348 <dyn2_execute+0x148>
 800f346:	bf00      	nop
}
 800f348:	b003      	add	sp, #12
 800f34a:	f85d fb04 	ldr.w	pc, [sp], #4
 800f34e:	bf00      	nop
 800f350:	0801ad70 	.word	0x0801ad70
 800f354:	200014e0 	.word	0x200014e0
 800f358:	0800f051 	.word	0x0800f051
 800f35c:	0801b410 	.word	0x0801b410
 800f360:	20003e3c 	.word	0x20003e3c
 800f364:	0801b414 	.word	0x0801b414
 800f368:	0801b418 	.word	0x0801b418
 800f36c:	0801b45c 	.word	0x0801b45c
 800f370:	0801b460 	.word	0x0801b460
 800f374:	0801b464 	.word	0x0801b464
 800f378:	f3af 8000 	nop.w
 800f37c:	f3af 8000 	nop.w

0800f380 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 800f380:	b500      	push	{lr}
 800f382:	b085      	sub	sp, #20
 800f384:	9001      	str	r0, [sp, #4]
  thread_t *ftp;
  bool found = false;
 800f386:	2300      	movs	r3, #0
 800f388:	f88d 300b 	strb.w	r3, [sp, #11]

  ftp = chRegFirstThread();
 800f38c:	f7f2 fae0 	bl	8001950 <chRegFirstThread>
 800f390:	9003      	str	r0, [sp, #12]
  do {
    found |= ftp == tp;
 800f392:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800f396:	9903      	ldr	r1, [sp, #12]
 800f398:	9b01      	ldr	r3, [sp, #4]
 800f39a:	4299      	cmp	r1, r3
 800f39c:	bf14      	ite	ne
 800f39e:	2300      	movne	r3, #0
 800f3a0:	2301      	moveq	r3, #1
 800f3a2:	b2db      	uxtb	r3, r3
 800f3a4:	4313      	orrs	r3, r2
 800f3a6:	2b00      	cmp	r3, #0
 800f3a8:	bf0c      	ite	eq
 800f3aa:	2300      	moveq	r3, #0
 800f3ac:	2301      	movne	r3, #1
 800f3ae:	f88d 300b 	strb.w	r3, [sp, #11]
    ftp = chRegNextThread(ftp);
 800f3b2:	9803      	ldr	r0, [sp, #12]
 800f3b4:	f7f2 fae4 	bl	8001980 <chRegNextThread>
 800f3b8:	9003      	str	r0, [sp, #12]
  } while (ftp != NULL);
 800f3ba:	9b03      	ldr	r3, [sp, #12]
 800f3bc:	2b00      	cmp	r3, #0
 800f3be:	d1e8      	bne.n	800f392 <regfind+0x12>
  return found;
 800f3c0:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800f3c4:	4618      	mov	r0, r3
 800f3c6:	b005      	add	sp, #20
 800f3c8:	f85d fb04 	ldr.w	pc, [sp], #4
 800f3cc:	f3af 8000 	nop.w

0800f3d0 <dyn3_setup>:

static void dyn3_setup(void) {
 800f3d0:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 800f3d2:	4803      	ldr	r0, [pc, #12]	; (800f3e0 <dyn3_setup+0x10>)
 800f3d4:	4903      	ldr	r1, [pc, #12]	; (800f3e4 <dyn3_setup+0x14>)
 800f3d6:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800f3da:	f7f4 f9a1 	bl	8003720 <chHeapObjectInit>
}
 800f3de:	bd08      	pop	{r3, pc}
 800f3e0:	200014c0 	.word	0x200014c0
 800f3e4:	20003e50 	.word	0x20003e50
 800f3e8:	f3af 8000 	nop.w
 800f3ec:	f3af 8000 	nop.w

0800f3f0 <dyn3_execute>:

static void dyn3_execute(void) {
 800f3f0:	b500      	push	{lr}
 800f3f2:	b085      	sub	sp, #20
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();
 800f3f4:	f7ff fe24 	bl	800f040 <chThdGetPriorityX>
 800f3f8:	9003      	str	r0, [sp, #12]

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 800f3fa:	9b03      	ldr	r3, [sp, #12]
 800f3fc:	3b01      	subs	r3, #1
 800f3fe:	4a63      	ldr	r2, [pc, #396]	; (800f58c <dyn3_execute+0x19c>)
 800f400:	9200      	str	r2, [sp, #0]
 800f402:	4863      	ldr	r0, [pc, #396]	; (800f590 <dyn3_execute+0x1a0>)
 800f404:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f408:	461a      	mov	r2, r3
 800f40a:	4b62      	ldr	r3, [pc, #392]	; (800f594 <dyn3_execute+0x1a4>)
 800f40c:	f7f2 fa20 	bl	8001850 <chThdCreateFromHeap>
 800f410:	9002      	str	r0, [sp, #8]
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 800f412:	9b02      	ldr	r3, [sp, #8]
 800f414:	7f9b      	ldrb	r3, [r3, #30]
 800f416:	2b01      	cmp	r3, #1
 800f418:	bf14      	ite	ne
 800f41a:	2300      	movne	r3, #0
 800f41c:	2301      	moveq	r3, #1
 800f41e:	b2db      	uxtb	r3, r3
 800f420:	2001      	movs	r0, #1
 800f422:	4619      	mov	r1, r3
 800f424:	f7fc fd14 	bl	800be50 <_test_assert>
 800f428:	4603      	mov	r3, r0
 800f42a:	2b00      	cmp	r3, #0
 800f42c:	d000      	beq.n	800f430 <dyn3_execute+0x40>
 800f42e:	e0aa      	b.n	800f586 <dyn3_execute+0x196>
  chThdAddRef(tp);
 800f430:	9802      	ldr	r0, [sp, #8]
 800f432:	f7f2 f9ad 	bl	8001790 <chThdAddRef>
  test_assert(2, tp->p_refs == 2, "references increase failure");
 800f436:	9b02      	ldr	r3, [sp, #8]
 800f438:	7f9b      	ldrb	r3, [r3, #30]
 800f43a:	2b02      	cmp	r3, #2
 800f43c:	bf14      	ite	ne
 800f43e:	2300      	movne	r3, #0
 800f440:	2301      	moveq	r3, #1
 800f442:	b2db      	uxtb	r3, r3
 800f444:	2002      	movs	r0, #2
 800f446:	4619      	mov	r1, r3
 800f448:	f7fc fd02 	bl	800be50 <_test_assert>
 800f44c:	4603      	mov	r3, r0
 800f44e:	2b00      	cmp	r3, #0
 800f450:	d000      	beq.n	800f454 <dyn3_execute+0x64>
 800f452:	e098      	b.n	800f586 <dyn3_execute+0x196>
  chThdRelease(tp);
 800f454:	9802      	ldr	r0, [sp, #8]
 800f456:	f7f2 f9b3 	bl	80017c0 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 800f45a:	9b02      	ldr	r3, [sp, #8]
 800f45c:	7f9b      	ldrb	r3, [r3, #30]
 800f45e:	2b01      	cmp	r3, #1
 800f460:	bf14      	ite	ne
 800f462:	2300      	movne	r3, #0
 800f464:	2301      	moveq	r3, #1
 800f466:	b2db      	uxtb	r3, r3
 800f468:	2003      	movs	r0, #3
 800f46a:	4619      	mov	r1, r3
 800f46c:	f7fc fcf0 	bl	800be50 <_test_assert>
 800f470:	4603      	mov	r3, r0
 800f472:	2b00      	cmp	r3, #0
 800f474:	d000      	beq.n	800f478 <dyn3_execute+0x88>
 800f476:	e086      	b.n	800f586 <dyn3_execute+0x196>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 800f478:	9802      	ldr	r0, [sp, #8]
 800f47a:	f7ff ff81 	bl	800f380 <regfind>
 800f47e:	4603      	mov	r3, r0
 800f480:	2004      	movs	r0, #4
 800f482:	4619      	mov	r1, r3
 800f484:	f7fc fce4 	bl	800be50 <_test_assert>
 800f488:	4603      	mov	r3, r0
 800f48a:	2b00      	cmp	r3, #0
 800f48c:	d000      	beq.n	800f490 <dyn3_execute+0xa0>
 800f48e:	e07a      	b.n	800f586 <dyn3_execute+0x196>
  test_assert(5, regfind(tp), "thread disappeared");
 800f490:	9802      	ldr	r0, [sp, #8]
 800f492:	f7ff ff75 	bl	800f380 <regfind>
 800f496:	4603      	mov	r3, r0
 800f498:	2005      	movs	r0, #5
 800f49a:	4619      	mov	r1, r3
 800f49c:	f7fc fcd8 	bl	800be50 <_test_assert>
 800f4a0:	4603      	mov	r3, r0
 800f4a2:	2b00      	cmp	r3, #0
 800f4a4:	d000      	beq.n	800f4a8 <dyn3_execute+0xb8>
 800f4a6:	e06e      	b.n	800f586 <dyn3_execute+0x196>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 800f4a8:	9802      	ldr	r0, [sp, #8]
 800f4aa:	f7f2 f989 	bl	80017c0 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 800f4ae:	9b02      	ldr	r3, [sp, #8]
 800f4b0:	7f9b      	ldrb	r3, [r3, #30]
 800f4b2:	2b00      	cmp	r3, #0
 800f4b4:	bf14      	ite	ne
 800f4b6:	2300      	movne	r3, #0
 800f4b8:	2301      	moveq	r3, #1
 800f4ba:	b2db      	uxtb	r3, r3
 800f4bc:	2006      	movs	r0, #6
 800f4be:	4619      	mov	r1, r3
 800f4c0:	f7fc fcc6 	bl	800be50 <_test_assert>
 800f4c4:	4603      	mov	r3, r0
 800f4c6:	2b00      	cmp	r3, #0
 800f4c8:	d000      	beq.n	800f4cc <dyn3_execute+0xdc>
 800f4ca:	e05c      	b.n	800f586 <dyn3_execute+0x196>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 800f4cc:	9b02      	ldr	r3, [sp, #8]
 800f4ce:	7f1b      	ldrb	r3, [r3, #28]
 800f4d0:	2b00      	cmp	r3, #0
 800f4d2:	bf14      	ite	ne
 800f4d4:	2300      	movne	r3, #0
 800f4d6:	2301      	moveq	r3, #1
 800f4d8:	b2db      	uxtb	r3, r3
 800f4da:	2007      	movs	r0, #7
 800f4dc:	4619      	mov	r1, r3
 800f4de:	f7fc fcb7 	bl	800be50 <_test_assert>
 800f4e2:	4603      	mov	r3, r0
 800f4e4:	2b00      	cmp	r3, #0
 800f4e6:	d000      	beq.n	800f4ea <dyn3_execute+0xfa>
 800f4e8:	e04d      	b.n	800f586 <dyn3_execute+0x196>
  test_assert(8, regfind(tp), "thread disappeared");
 800f4ea:	9802      	ldr	r0, [sp, #8]
 800f4ec:	f7ff ff48 	bl	800f380 <regfind>
 800f4f0:	4603      	mov	r3, r0
 800f4f2:	2008      	movs	r0, #8
 800f4f4:	4619      	mov	r1, r3
 800f4f6:	f7fc fcab 	bl	800be50 <_test_assert>
 800f4fa:	4603      	mov	r3, r0
 800f4fc:	2b00      	cmp	r3, #0
 800f4fe:	d000      	beq.n	800f502 <dyn3_execute+0x112>
 800f500:	e041      	b.n	800f586 <dyn3_execute+0x196>
  test_assert(9, regfind(tp), "thread disappeared");
 800f502:	9802      	ldr	r0, [sp, #8]
 800f504:	f7ff ff3c 	bl	800f380 <regfind>
 800f508:	4603      	mov	r3, r0
 800f50a:	2009      	movs	r0, #9
 800f50c:	4619      	mov	r1, r3
 800f50e:	f7fc fc9f 	bl	800be50 <_test_assert>
 800f512:	4603      	mov	r3, r0
 800f514:	2b00      	cmp	r3, #0
 800f516:	d000      	beq.n	800f51a <dyn3_execute+0x12a>
 800f518:	e035      	b.n	800f586 <dyn3_execute+0x196>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 800f51a:	f241 3088 	movw	r0, #5000	; 0x1388
 800f51e:	f7f1 fed7 	bl	80012d0 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 800f522:	9b02      	ldr	r3, [sp, #8]
 800f524:	7f1b      	ldrb	r3, [r3, #28]
 800f526:	2b0f      	cmp	r3, #15
 800f528:	bf14      	ite	ne
 800f52a:	2300      	movne	r3, #0
 800f52c:	2301      	moveq	r3, #1
 800f52e:	b2db      	uxtb	r3, r3
 800f530:	200a      	movs	r0, #10
 800f532:	4619      	mov	r1, r3
 800f534:	f7fc fc8c 	bl	800be50 <_test_assert>
 800f538:	4603      	mov	r3, r0
 800f53a:	2b00      	cmp	r3, #0
 800f53c:	d000      	beq.n	800f540 <dyn3_execute+0x150>
 800f53e:	e022      	b.n	800f586 <dyn3_execute+0x196>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 800f540:	9802      	ldr	r0, [sp, #8]
 800f542:	f7ff ff1d 	bl	800f380 <regfind>
 800f546:	4603      	mov	r3, r0
 800f548:	200b      	movs	r0, #11
 800f54a:	4619      	mov	r1, r3
 800f54c:	f7fc fc80 	bl	800be50 <_test_assert>
 800f550:	4603      	mov	r3, r0
 800f552:	2b00      	cmp	r3, #0
 800f554:	d000      	beq.n	800f558 <dyn3_execute+0x168>
 800f556:	e016      	b.n	800f586 <dyn3_execute+0x196>
  test_assert(12, !regfind(tp), "thread still in registry");
 800f558:	9802      	ldr	r0, [sp, #8]
 800f55a:	f7ff ff11 	bl	800f380 <regfind>
 800f55e:	4603      	mov	r3, r0
 800f560:	2b00      	cmp	r3, #0
 800f562:	bf0c      	ite	eq
 800f564:	2300      	moveq	r3, #0
 800f566:	2301      	movne	r3, #1
 800f568:	b2db      	uxtb	r3, r3
 800f56a:	f083 0301 	eor.w	r3, r3, #1
 800f56e:	b2db      	uxtb	r3, r3
 800f570:	f003 0301 	and.w	r3, r3, #1
 800f574:	b2db      	uxtb	r3, r3
 800f576:	200c      	movs	r0, #12
 800f578:	4619      	mov	r1, r3
 800f57a:	f7fc fc69 	bl	800be50 <_test_assert>
 800f57e:	4603      	mov	r3, r0
 800f580:	2b00      	cmp	r3, #0
 800f582:	d000      	beq.n	800f586 <dyn3_execute+0x196>
 800f584:	bf00      	nop
}
 800f586:	b005      	add	sp, #20
 800f588:	f85d fb04 	ldr.w	pc, [sp], #4
 800f58c:	0801b410 	.word	0x0801b410
 800f590:	200014c0 	.word	0x200014c0
 800f594:	0800f051 	.word	0x0800f051
 800f598:	f3af 8000 	nop.w
 800f59c:	f3af 8000 	nop.w

0800f5a0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800f5a0:	b082      	sub	sp, #8
 800f5a2:	2320      	movs	r3, #32
 800f5a4:	9301      	str	r3, [sp, #4]
 800f5a6:	9b01      	ldr	r3, [sp, #4]
 800f5a8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f5ac:	b002      	add	sp, #8
 800f5ae:	4770      	bx	lr

0800f5b0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800f5b0:	b082      	sub	sp, #8
 800f5b2:	2300      	movs	r3, #0
 800f5b4:	9301      	str	r3, [sp, #4]
 800f5b6:	9b01      	ldr	r3, [sp, #4]
 800f5b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f5bc:	b002      	add	sp, #8
 800f5be:	4770      	bx	lr

0800f5c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800f5c0:	b508      	push	{r3, lr}

  port_lock();
 800f5c2:	f7ff ffed 	bl	800f5a0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800f5c6:	bd08      	pop	{r3, pc}
 800f5c8:	f3af 8000 	nop.w
 800f5cc:	f3af 8000 	nop.w

0800f5d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800f5d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800f5d2:	f7ff ffed 	bl	800f5b0 <port_unlock>
}
 800f5d6:	bd08      	pop	{r3, pc}
 800f5d8:	f3af 8000 	nop.w
 800f5dc:	f3af 8000 	nop.w

0800f5e0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800f5e0:	4b01      	ldr	r3, [pc, #4]	; (800f5e8 <chThdGetSelfX+0x8>)
 800f5e2:	699b      	ldr	r3, [r3, #24]
}
 800f5e4:	4618      	mov	r0, r3
 800f5e6:	4770      	bx	lr
 800f5e8:	200039a8 	.word	0x200039a8
 800f5ec:	f3af 8000 	nop.w

0800f5f0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800f5f0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800f5f2:	f7ff fff5 	bl	800f5e0 <chThdGetSelfX>
 800f5f6:	4603      	mov	r3, r0
 800f5f8:	689b      	ldr	r3, [r3, #8]
}
 800f5fa:	4618      	mov	r0, r3
 800f5fc:	bd08      	pop	{r3, pc}
 800f5fe:	bf00      	nop

0800f600 <chIQGetFullI>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {
 800f600:	b082      	sub	sp, #8
 800f602:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (size_t)chQSpaceI(iqp);
 800f604:	9b01      	ldr	r3, [sp, #4]
 800f606:	689b      	ldr	r3, [r3, #8]
}
 800f608:	4618      	mov	r0, r3
 800f60a:	b002      	add	sp, #8
 800f60c:	4770      	bx	lr
 800f60e:	bf00      	nop

0800f610 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 800f610:	b082      	sub	sp, #8
 800f612:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800f614:	9b01      	ldr	r3, [sp, #4]
 800f616:	689b      	ldr	r3, [r3, #8]
 800f618:	2b00      	cmp	r3, #0
 800f61a:	bf14      	ite	ne
 800f61c:	2300      	movne	r3, #0
 800f61e:	2301      	moveq	r3, #1
 800f620:	b2db      	uxtb	r3, r3
}
 800f622:	4618      	mov	r0, r3
 800f624:	b002      	add	sp, #8
 800f626:	4770      	bx	lr
 800f628:	f3af 8000 	nop.w
 800f62c:	f3af 8000 	nop.w

0800f630 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 800f630:	b082      	sub	sp, #8
 800f632:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 800f634:	9b01      	ldr	r3, [sp, #4]
 800f636:	695a      	ldr	r2, [r3, #20]
 800f638:	9b01      	ldr	r3, [sp, #4]
 800f63a:	699b      	ldr	r3, [r3, #24]
 800f63c:	429a      	cmp	r2, r3
 800f63e:	d105      	bne.n	800f64c <chIQIsFullI+0x1c>
 800f640:	9b01      	ldr	r3, [sp, #4]
 800f642:	689b      	ldr	r3, [r3, #8]
 800f644:	2b00      	cmp	r3, #0
 800f646:	d001      	beq.n	800f64c <chIQIsFullI+0x1c>
 800f648:	2301      	movs	r3, #1
 800f64a:	e000      	b.n	800f64e <chIQIsFullI+0x1e>
 800f64c:	2300      	movs	r3, #0
 800f64e:	f003 0301 	and.w	r3, r3, #1
 800f652:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800f654:	4618      	mov	r0, r3
 800f656:	b002      	add	sp, #8
 800f658:	4770      	bx	lr
 800f65a:	bf00      	nop
 800f65c:	f3af 8000 	nop.w

0800f660 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 800f660:	b500      	push	{lr}
 800f662:	b083      	sub	sp, #12
 800f664:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 800f666:	9801      	ldr	r0, [sp, #4]
 800f668:	f04f 31ff 	mov.w	r1, #4294967295
 800f66c:	f7f3 fe08 	bl	8003280 <chIQGetTimeout>
 800f670:	4603      	mov	r3, r0
}
 800f672:	4618      	mov	r0, r3
 800f674:	b003      	add	sp, #12
 800f676:	f85d fb04 	ldr.w	pc, [sp], #4
 800f67a:	bf00      	nop
 800f67c:	f3af 8000 	nop.w

0800f680 <chOQGetFullI>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {
 800f680:	b082      	sub	sp, #8
 800f682:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800f684:	9b01      	ldr	r3, [sp, #4]
 800f686:	691b      	ldr	r3, [r3, #16]
 800f688:	461a      	mov	r2, r3
 800f68a:	9b01      	ldr	r3, [sp, #4]
 800f68c:	68db      	ldr	r3, [r3, #12]
 800f68e:	1ad3      	subs	r3, r2, r3
 800f690:	461a      	mov	r2, r3
 800f692:	9b01      	ldr	r3, [sp, #4]
 800f694:	689b      	ldr	r3, [r3, #8]
 800f696:	1ad3      	subs	r3, r2, r3
}
 800f698:	4618      	mov	r0, r3
 800f69a:	b002      	add	sp, #8
 800f69c:	4770      	bx	lr
 800f69e:	bf00      	nop

0800f6a0 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 800f6a0:	b082      	sub	sp, #8
 800f6a2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800f6a4:	9b01      	ldr	r3, [sp, #4]
 800f6a6:	695a      	ldr	r2, [r3, #20]
 800f6a8:	9b01      	ldr	r3, [sp, #4]
 800f6aa:	699b      	ldr	r3, [r3, #24]
 800f6ac:	429a      	cmp	r2, r3
 800f6ae:	d105      	bne.n	800f6bc <chOQIsEmptyI+0x1c>
 800f6b0:	9b01      	ldr	r3, [sp, #4]
 800f6b2:	689b      	ldr	r3, [r3, #8]
 800f6b4:	2b00      	cmp	r3, #0
 800f6b6:	d001      	beq.n	800f6bc <chOQIsEmptyI+0x1c>
 800f6b8:	2301      	movs	r3, #1
 800f6ba:	e000      	b.n	800f6be <chOQIsEmptyI+0x1e>
 800f6bc:	2300      	movs	r3, #0
 800f6be:	f003 0301 	and.w	r3, r3, #1
 800f6c2:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800f6c4:	4618      	mov	r0, r3
 800f6c6:	b002      	add	sp, #8
 800f6c8:	4770      	bx	lr
 800f6ca:	bf00      	nop
 800f6cc:	f3af 8000 	nop.w

0800f6d0 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 800f6d0:	b082      	sub	sp, #8
 800f6d2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800f6d4:	9b01      	ldr	r3, [sp, #4]
 800f6d6:	689b      	ldr	r3, [r3, #8]
 800f6d8:	2b00      	cmp	r3, #0
 800f6da:	bf14      	ite	ne
 800f6dc:	2300      	movne	r3, #0
 800f6de:	2301      	moveq	r3, #1
 800f6e0:	b2db      	uxtb	r3, r3
}
 800f6e2:	4618      	mov	r0, r3
 800f6e4:	b002      	add	sp, #8
 800f6e6:	4770      	bx	lr
 800f6e8:	f3af 8000 	nop.w
 800f6ec:	f3af 8000 	nop.w

0800f6f0 <chOQPut>:
 * @retval Q_OK         if the operation succeeded.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {
 800f6f0:	b500      	push	{lr}
 800f6f2:	b083      	sub	sp, #12
 800f6f4:	9001      	str	r0, [sp, #4]
 800f6f6:	460b      	mov	r3, r1
 800f6f8:	f88d 3003 	strb.w	r3, [sp, #3]

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 800f6fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800f700:	9801      	ldr	r0, [sp, #4]
 800f702:	4619      	mov	r1, r3
 800f704:	f04f 32ff 	mov.w	r2, #4294967295
 800f708:	f7f3 fea2 	bl	8003450 <chOQPutTimeout>
 800f70c:	4603      	mov	r3, r0
}
 800f70e:	4618      	mov	r0, r3
 800f710:	b003      	add	sp, #12
 800f712:	f85d fb04 	ldr.w	pc, [sp], #4
 800f716:	bf00      	nop
 800f718:	f3af 8000 	nop.w
 800f71c:	f3af 8000 	nop.w

0800f720 <notify>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 800f720:	b082      	sub	sp, #8
 800f722:	9001      	str	r0, [sp, #4]
  (void)qp;
}
 800f724:	b002      	add	sp, #8
 800f726:	4770      	bx	lr
 800f728:	f3af 8000 	nop.w
 800f72c:	f3af 8000 	nop.w

0800f730 <queues1_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 800f730:	b500      	push	{lr}
 800f732:	b083      	sub	sp, #12

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800f734:	4b06      	ldr	r3, [pc, #24]	; (800f750 <queues1_setup+0x20>)
 800f736:	681b      	ldr	r3, [r3, #0]
 800f738:	2200      	movs	r2, #0
 800f73a:	9200      	str	r2, [sp, #0]
 800f73c:	4805      	ldr	r0, [pc, #20]	; (800f754 <queues1_setup+0x24>)
 800f73e:	4619      	mov	r1, r3
 800f740:	2204      	movs	r2, #4
 800f742:	4b05      	ldr	r3, [pc, #20]	; (800f758 <queues1_setup+0x28>)
 800f744:	f7f3 fd2c 	bl	80031a0 <chIQObjectInit>
}
 800f748:	b003      	add	sp, #12
 800f74a:	f85d fb04 	ldr.w	pc, [sp], #4
 800f74e:	bf00      	nop
 800f750:	0801ad70 	.word	0x0801ad70
 800f754:	200008a8 	.word	0x200008a8
 800f758:	0800f721 	.word	0x0800f721
 800f75c:	f3af 8000 	nop.w

0800f760 <thread1>:

static THD_FUNCTION(thread1, p) {
 800f760:	b500      	push	{lr}
 800f762:	b083      	sub	sp, #12
 800f764:	9001      	str	r0, [sp, #4]

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 800f766:	4804      	ldr	r0, [pc, #16]	; (800f778 <thread1+0x18>)
 800f768:	f644 6120 	movw	r1, #20000	; 0x4e20
 800f76c:	f7f3 fd88 	bl	8003280 <chIQGetTimeout>
}
 800f770:	b003      	add	sp, #12
 800f772:	f85d fb04 	ldr.w	pc, [sp], #4
 800f776:	bf00      	nop
 800f778:	200008a8 	.word	0x200008a8
 800f77c:	f3af 8000 	nop.w

0800f780 <queues1_execute>:

static void queues1_execute(void) {
 800f780:	b510      	push	{r4, lr}
 800f782:	b084      	sub	sp, #16
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 800f784:	f7ff ff1c 	bl	800f5c0 <chSysLock>
 800f788:	48ab      	ldr	r0, [pc, #684]	; (800fa38 <queues1_execute+0x2b8>)
 800f78a:	f7ff ff41 	bl	800f610 <chIQIsEmptyI>
 800f78e:	4603      	mov	r3, r0
 800f790:	2001      	movs	r0, #1
 800f792:	4619      	mov	r1, r3
 800f794:	f7fc fb5c 	bl	800be50 <_test_assert>
 800f798:	4603      	mov	r3, r0
 800f79a:	2b00      	cmp	r3, #0
 800f79c:	d002      	beq.n	800f7a4 <queues1_execute+0x24>
 800f79e:	f7ff ff17 	bl	800f5d0 <chSysUnlock>
 800f7a2:	e16a      	b.n	800fa7a <queues1_execute+0x2fa>
 800f7a4:	f7ff ff14 	bl	800f5d0 <chSysUnlock>

  /* Queue filling */
  chSysLock();
 800f7a8:	f7ff ff0a 	bl	800f5c0 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f7ac:	2300      	movs	r3, #0
 800f7ae:	9303      	str	r3, [sp, #12]
 800f7b0:	e00a      	b.n	800f7c8 <queues1_execute+0x48>
    chIQPutI(&iq, 'A' + i);
 800f7b2:	9b03      	ldr	r3, [sp, #12]
 800f7b4:	b2db      	uxtb	r3, r3
 800f7b6:	3341      	adds	r3, #65	; 0x41
 800f7b8:	b2db      	uxtb	r3, r3
 800f7ba:	489f      	ldr	r0, [pc, #636]	; (800fa38 <queues1_execute+0x2b8>)
 800f7bc:	4619      	mov	r1, r3
 800f7be:	f7f3 fd2f 	bl	8003220 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f7c2:	9b03      	ldr	r3, [sp, #12]
 800f7c4:	3301      	adds	r3, #1
 800f7c6:	9303      	str	r3, [sp, #12]
 800f7c8:	9b03      	ldr	r3, [sp, #12]
 800f7ca:	2b03      	cmp	r3, #3
 800f7cc:	d9f1      	bls.n	800f7b2 <queues1_execute+0x32>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800f7ce:	f7ff feff 	bl	800f5d0 <chSysUnlock>
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 800f7d2:	f7ff fef5 	bl	800f5c0 <chSysLock>
 800f7d6:	4898      	ldr	r0, [pc, #608]	; (800fa38 <queues1_execute+0x2b8>)
 800f7d8:	f7ff ff2a 	bl	800f630 <chIQIsFullI>
 800f7dc:	4603      	mov	r3, r0
 800f7de:	2002      	movs	r0, #2
 800f7e0:	4619      	mov	r1, r3
 800f7e2:	f7fc fb35 	bl	800be50 <_test_assert>
 800f7e6:	4603      	mov	r3, r0
 800f7e8:	2b00      	cmp	r3, #0
 800f7ea:	d002      	beq.n	800f7f2 <queues1_execute+0x72>
 800f7ec:	f7ff fef0 	bl	800f5d0 <chSysUnlock>
 800f7f0:	e143      	b.n	800fa7a <queues1_execute+0x2fa>
 800f7f2:	f7ff feed 	bl	800f5d0 <chSysUnlock>
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 800f7f6:	f7ff fee3 	bl	800f5c0 <chSysLock>
 800f7fa:	488f      	ldr	r0, [pc, #572]	; (800fa38 <queues1_execute+0x2b8>)
 800f7fc:	2100      	movs	r1, #0
 800f7fe:	f7f3 fd0f 	bl	8003220 <chIQPutI>
 800f802:	4603      	mov	r3, r0
 800f804:	f113 0f04 	cmn.w	r3, #4
 800f808:	bf14      	ite	ne
 800f80a:	2300      	movne	r3, #0
 800f80c:	2301      	moveq	r3, #1
 800f80e:	b2db      	uxtb	r3, r3
 800f810:	2003      	movs	r0, #3
 800f812:	4619      	mov	r1, r3
 800f814:	f7fc fb1c 	bl	800be50 <_test_assert>
 800f818:	4603      	mov	r3, r0
 800f81a:	2b00      	cmp	r3, #0
 800f81c:	d002      	beq.n	800f824 <queues1_execute+0xa4>
 800f81e:	f7ff fed7 	bl	800f5d0 <chSysUnlock>
 800f822:	e12a      	b.n	800fa7a <queues1_execute+0x2fa>
 800f824:	f7ff fed4 	bl	800f5d0 <chSysUnlock>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f828:	2300      	movs	r3, #0
 800f82a:	9303      	str	r3, [sp, #12]
 800f82c:	e00a      	b.n	800f844 <queues1_execute+0xc4>
    test_emit_token(chIQGet(&iq));
 800f82e:	4882      	ldr	r0, [pc, #520]	; (800fa38 <queues1_execute+0x2b8>)
 800f830:	f7ff ff16 	bl	800f660 <chIQGet>
 800f834:	4603      	mov	r3, r0
 800f836:	b2db      	uxtb	r3, r3
 800f838:	4618      	mov	r0, r3
 800f83a:	f7fc fad9 	bl	800bdf0 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f83e:	9b03      	ldr	r3, [sp, #12]
 800f840:	3301      	adds	r3, #1
 800f842:	9303      	str	r3, [sp, #12]
 800f844:	9b03      	ldr	r3, [sp, #12]
 800f846:	2b03      	cmp	r3, #3
 800f848:	d9f1      	bls.n	800f82e <queues1_execute+0xae>
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 800f84a:	f7ff feb9 	bl	800f5c0 <chSysLock>
 800f84e:	487a      	ldr	r0, [pc, #488]	; (800fa38 <queues1_execute+0x2b8>)
 800f850:	f7ff fede 	bl	800f610 <chIQIsEmptyI>
 800f854:	4603      	mov	r3, r0
 800f856:	2004      	movs	r0, #4
 800f858:	4619      	mov	r1, r3
 800f85a:	f7fc faf9 	bl	800be50 <_test_assert>
 800f85e:	4603      	mov	r3, r0
 800f860:	2b00      	cmp	r3, #0
 800f862:	d002      	beq.n	800f86a <queues1_execute+0xea>
 800f864:	f7ff feb4 	bl	800f5d0 <chSysUnlock>
 800f868:	e107      	b.n	800fa7a <queues1_execute+0x2fa>
 800f86a:	f7ff feb1 	bl	800f5d0 <chSysUnlock>
  test_assert_sequence(5, "ABCD");
 800f86e:	2005      	movs	r0, #5
 800f870:	4972      	ldr	r1, [pc, #456]	; (800fa3c <queues1_execute+0x2bc>)
 800f872:	f7fc fb05 	bl	800be80 <_test_assert_sequence>
 800f876:	4603      	mov	r3, r0
 800f878:	2b00      	cmp	r3, #0
 800f87a:	d000      	beq.n	800f87e <queues1_execute+0xfe>
 800f87c:	e0fd      	b.n	800fa7a <queues1_execute+0x2fa>

  /* Queue filling again */
  chSysLock();
 800f87e:	f7ff fe9f 	bl	800f5c0 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f882:	2300      	movs	r3, #0
 800f884:	9303      	str	r3, [sp, #12]
 800f886:	e00a      	b.n	800f89e <queues1_execute+0x11e>
    chIQPutI(&iq, 'A' + i);
 800f888:	9b03      	ldr	r3, [sp, #12]
 800f88a:	b2db      	uxtb	r3, r3
 800f88c:	3341      	adds	r3, #65	; 0x41
 800f88e:	b2db      	uxtb	r3, r3
 800f890:	4869      	ldr	r0, [pc, #420]	; (800fa38 <queues1_execute+0x2b8>)
 800f892:	4619      	mov	r1, r3
 800f894:	f7f3 fcc4 	bl	8003220 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f898:	9b03      	ldr	r3, [sp, #12]
 800f89a:	3301      	adds	r3, #1
 800f89c:	9303      	str	r3, [sp, #12]
 800f89e:	9b03      	ldr	r3, [sp, #12]
 800f8a0:	2b03      	cmp	r3, #3
 800f8a2:	d9f1      	bls.n	800f888 <queues1_execute+0x108>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800f8a4:	f7ff fe94 	bl	800f5d0 <chSysUnlock>

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800f8a8:	4b65      	ldr	r3, [pc, #404]	; (800fa40 <queues1_execute+0x2c0>)
 800f8aa:	685b      	ldr	r3, [r3, #4]
 800f8ac:	4862      	ldr	r0, [pc, #392]	; (800fa38 <queues1_execute+0x2b8>)
 800f8ae:	4619      	mov	r1, r3
 800f8b0:	2208      	movs	r2, #8
 800f8b2:	2300      	movs	r3, #0
 800f8b4:	f7f3 fd2c 	bl	8003310 <chIQReadTimeout>
 800f8b8:	9002      	str	r0, [sp, #8]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800f8ba:	9b02      	ldr	r3, [sp, #8]
 800f8bc:	2b04      	cmp	r3, #4
 800f8be:	bf14      	ite	ne
 800f8c0:	2300      	movne	r3, #0
 800f8c2:	2301      	moveq	r3, #1
 800f8c4:	b2db      	uxtb	r3, r3
 800f8c6:	2006      	movs	r0, #6
 800f8c8:	4619      	mov	r1, r3
 800f8ca:	f7fc fac1 	bl	800be50 <_test_assert>
 800f8ce:	4603      	mov	r3, r0
 800f8d0:	2b00      	cmp	r3, #0
 800f8d2:	d000      	beq.n	800f8d6 <queues1_execute+0x156>
 800f8d4:	e0d1      	b.n	800fa7a <queues1_execute+0x2fa>
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 800f8d6:	f7ff fe73 	bl	800f5c0 <chSysLock>
 800f8da:	4857      	ldr	r0, [pc, #348]	; (800fa38 <queues1_execute+0x2b8>)
 800f8dc:	f7ff fe98 	bl	800f610 <chIQIsEmptyI>
 800f8e0:	4603      	mov	r3, r0
 800f8e2:	2007      	movs	r0, #7
 800f8e4:	4619      	mov	r1, r3
 800f8e6:	f7fc fab3 	bl	800be50 <_test_assert>
 800f8ea:	4603      	mov	r3, r0
 800f8ec:	2b00      	cmp	r3, #0
 800f8ee:	d002      	beq.n	800f8f6 <queues1_execute+0x176>
 800f8f0:	f7ff fe6e 	bl	800f5d0 <chSysUnlock>
 800f8f4:	e0c1      	b.n	800fa7a <queues1_execute+0x2fa>
 800f8f6:	f7ff fe6b 	bl	800f5d0 <chSysUnlock>

  /* Queue filling again */
  chSysLock();
 800f8fa:	f7ff fe61 	bl	800f5c0 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f8fe:	2300      	movs	r3, #0
 800f900:	9303      	str	r3, [sp, #12]
 800f902:	e00a      	b.n	800f91a <queues1_execute+0x19a>
    chIQPutI(&iq, 'A' + i);
 800f904:	9b03      	ldr	r3, [sp, #12]
 800f906:	b2db      	uxtb	r3, r3
 800f908:	3341      	adds	r3, #65	; 0x41
 800f90a:	b2db      	uxtb	r3, r3
 800f90c:	484a      	ldr	r0, [pc, #296]	; (800fa38 <queues1_execute+0x2b8>)
 800f90e:	4619      	mov	r1, r3
 800f910:	f7f3 fc86 	bl	8003220 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f914:	9b03      	ldr	r3, [sp, #12]
 800f916:	3301      	adds	r3, #1
 800f918:	9303      	str	r3, [sp, #12]
 800f91a:	9b03      	ldr	r3, [sp, #12]
 800f91c:	2b03      	cmp	r3, #3
 800f91e:	d9f1      	bls.n	800f904 <queues1_execute+0x184>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800f920:	f7ff fe56 	bl	800f5d0 <chSysUnlock>

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800f924:	4b46      	ldr	r3, [pc, #280]	; (800fa40 <queues1_execute+0x2c0>)
 800f926:	685b      	ldr	r3, [r3, #4]
 800f928:	4843      	ldr	r0, [pc, #268]	; (800fa38 <queues1_execute+0x2b8>)
 800f92a:	4619      	mov	r1, r3
 800f92c:	2202      	movs	r2, #2
 800f92e:	2300      	movs	r3, #0
 800f930:	f7f3 fcee 	bl	8003310 <chIQReadTimeout>
 800f934:	9002      	str	r0, [sp, #8]
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800f936:	9b02      	ldr	r3, [sp, #8]
 800f938:	2b02      	cmp	r3, #2
 800f93a:	bf14      	ite	ne
 800f93c:	2300      	movne	r3, #0
 800f93e:	2301      	moveq	r3, #1
 800f940:	b2db      	uxtb	r3, r3
 800f942:	2008      	movs	r0, #8
 800f944:	4619      	mov	r1, r3
 800f946:	f7fc fa83 	bl	800be50 <_test_assert>
 800f94a:	4603      	mov	r3, r0
 800f94c:	2b00      	cmp	r3, #0
 800f94e:	d000      	beq.n	800f952 <queues1_execute+0x1d2>
 800f950:	e093      	b.n	800fa7a <queues1_execute+0x2fa>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800f952:	4b3b      	ldr	r3, [pc, #236]	; (800fa40 <queues1_execute+0x2c0>)
 800f954:	685b      	ldr	r3, [r3, #4]
 800f956:	4838      	ldr	r0, [pc, #224]	; (800fa38 <queues1_execute+0x2b8>)
 800f958:	4619      	mov	r1, r3
 800f95a:	2202      	movs	r2, #2
 800f95c:	2300      	movs	r3, #0
 800f95e:	f7f3 fcd7 	bl	8003310 <chIQReadTimeout>
 800f962:	9002      	str	r0, [sp, #8]
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800f964:	9b02      	ldr	r3, [sp, #8]
 800f966:	2b02      	cmp	r3, #2
 800f968:	bf14      	ite	ne
 800f96a:	2300      	movne	r3, #0
 800f96c:	2301      	moveq	r3, #1
 800f96e:	b2db      	uxtb	r3, r3
 800f970:	2009      	movs	r0, #9
 800f972:	4619      	mov	r1, r3
 800f974:	f7fc fa6c 	bl	800be50 <_test_assert>
 800f978:	4603      	mov	r3, r0
 800f97a:	2b00      	cmp	r3, #0
 800f97c:	d000      	beq.n	800f980 <queues1_execute+0x200>
 800f97e:	e07c      	b.n	800fa7a <queues1_execute+0x2fa>
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 800f980:	f7ff fe1e 	bl	800f5c0 <chSysLock>
 800f984:	482c      	ldr	r0, [pc, #176]	; (800fa38 <queues1_execute+0x2b8>)
 800f986:	f7ff fe43 	bl	800f610 <chIQIsEmptyI>
 800f98a:	4603      	mov	r3, r0
 800f98c:	200a      	movs	r0, #10
 800f98e:	4619      	mov	r1, r3
 800f990:	f7fc fa5e 	bl	800be50 <_test_assert>
 800f994:	4603      	mov	r3, r0
 800f996:	2b00      	cmp	r3, #0
 800f998:	d002      	beq.n	800f9a0 <queues1_execute+0x220>
 800f99a:	f7ff fe19 	bl	800f5d0 <chSysUnlock>
 800f99e:	e06c      	b.n	800fa7a <queues1_execute+0x2fa>
 800f9a0:	f7ff fe16 	bl	800f5d0 <chSysUnlock>

  /* Testing reset */
  chSysLock();
 800f9a4:	f7ff fe0c 	bl	800f5c0 <chSysLock>
  chIQPutI(&iq, 0);
 800f9a8:	4823      	ldr	r0, [pc, #140]	; (800fa38 <queues1_execute+0x2b8>)
 800f9aa:	2100      	movs	r1, #0
 800f9ac:	f7f3 fc38 	bl	8003220 <chIQPutI>
  chIQResetI(&iq);
 800f9b0:	4821      	ldr	r0, [pc, #132]	; (800fa38 <queues1_execute+0x2b8>)
 800f9b2:	f7f3 fc1d 	bl	80031f0 <chIQResetI>
  chSysUnlock();
 800f9b6:	f7ff fe0b 	bl	800f5d0 <chSysUnlock>
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 800f9ba:	f7ff fe01 	bl	800f5c0 <chSysLock>
 800f9be:	481e      	ldr	r0, [pc, #120]	; (800fa38 <queues1_execute+0x2b8>)
 800f9c0:	f7ff fe1e 	bl	800f600 <chIQGetFullI>
 800f9c4:	4603      	mov	r3, r0
 800f9c6:	2b00      	cmp	r3, #0
 800f9c8:	bf14      	ite	ne
 800f9ca:	2300      	movne	r3, #0
 800f9cc:	2301      	moveq	r3, #1
 800f9ce:	b2db      	uxtb	r3, r3
 800f9d0:	200b      	movs	r0, #11
 800f9d2:	4619      	mov	r1, r3
 800f9d4:	f7fc fa3c 	bl	800be50 <_test_assert>
 800f9d8:	4603      	mov	r3, r0
 800f9da:	2b00      	cmp	r3, #0
 800f9dc:	d002      	beq.n	800f9e4 <queues1_execute+0x264>
 800f9de:	f7ff fdf7 	bl	800f5d0 <chSysUnlock>
 800f9e2:	e04a      	b.n	800fa7a <queues1_execute+0x2fa>
 800f9e4:	f7ff fdf4 	bl	800f5d0 <chSysUnlock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 800f9e8:	4b15      	ldr	r3, [pc, #84]	; (800fa40 <queues1_execute+0x2c0>)
 800f9ea:	681c      	ldr	r4, [r3, #0]
 800f9ec:	f7ff fe00 	bl	800f5f0 <chThdGetPriorityX>
 800f9f0:	4603      	mov	r3, r0
 800f9f2:	3301      	adds	r3, #1
 800f9f4:	2200      	movs	r2, #0
 800f9f6:	9200      	str	r2, [sp, #0]
 800f9f8:	4620      	mov	r0, r4
 800f9fa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f9fe:	461a      	mov	r2, r3
 800fa00:	4b10      	ldr	r3, [pc, #64]	; (800fa44 <queues1_execute+0x2c4>)
 800fa02:	f7f1 fbed 	bl	80011e0 <chThdCreateStatic>
 800fa06:	4602      	mov	r2, r0
 800fa08:	4b0f      	ldr	r3, [pc, #60]	; (800fa48 <queues1_execute+0x2c8>)
 800fa0a:	601a      	str	r2, [r3, #0]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 800fa0c:	f7ff fdd8 	bl	800f5c0 <chSysLock>
 800fa10:	4809      	ldr	r0, [pc, #36]	; (800fa38 <queues1_execute+0x2b8>)
 800fa12:	f7ff fdf5 	bl	800f600 <chIQGetFullI>
 800fa16:	4603      	mov	r3, r0
 800fa18:	2b00      	cmp	r3, #0
 800fa1a:	bf14      	ite	ne
 800fa1c:	2300      	movne	r3, #0
 800fa1e:	2301      	moveq	r3, #1
 800fa20:	b2db      	uxtb	r3, r3
 800fa22:	200c      	movs	r0, #12
 800fa24:	4619      	mov	r1, r3
 800fa26:	f7fc fa13 	bl	800be50 <_test_assert>
 800fa2a:	4603      	mov	r3, r0
 800fa2c:	2b00      	cmp	r3, #0
 800fa2e:	d00d      	beq.n	800fa4c <queues1_execute+0x2cc>
 800fa30:	f7ff fdce 	bl	800f5d0 <chSysUnlock>
 800fa34:	e021      	b.n	800fa7a <queues1_execute+0x2fa>
 800fa36:	bf00      	nop
 800fa38:	200008a8 	.word	0x200008a8
 800fa3c:	0801b500 	.word	0x0801b500
 800fa40:	0801ad70 	.word	0x0801ad70
 800fa44:	0800f761 	.word	0x0800f761
 800fa48:	20003e3c 	.word	0x20003e3c
 800fa4c:	f7ff fdc0 	bl	800f5d0 <chSysUnlock>
  test_wait_threads();
 800fa50:	f7fc fa7e 	bl	800bf50 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 800fa54:	480a      	ldr	r0, [pc, #40]	; (800fa80 <queues1_execute+0x300>)
 800fa56:	210a      	movs	r1, #10
 800fa58:	f7f3 fc12 	bl	8003280 <chIQGetTimeout>
 800fa5c:	4603      	mov	r3, r0
 800fa5e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fa62:	bf14      	ite	ne
 800fa64:	2300      	movne	r3, #0
 800fa66:	2301      	moveq	r3, #1
 800fa68:	b2db      	uxtb	r3, r3
 800fa6a:	200d      	movs	r0, #13
 800fa6c:	4619      	mov	r1, r3
 800fa6e:	f7fc f9ef 	bl	800be50 <_test_assert>
 800fa72:	4603      	mov	r3, r0
 800fa74:	2b00      	cmp	r3, #0
 800fa76:	d000      	beq.n	800fa7a <queues1_execute+0x2fa>
 800fa78:	bf00      	nop
}
 800fa7a:	b004      	add	sp, #16
 800fa7c:	bd10      	pop	{r4, pc}
 800fa7e:	bf00      	nop
 800fa80:	200008a8 	.word	0x200008a8
 800fa84:	f3af 8000 	nop.w
 800fa88:	f3af 8000 	nop.w
 800fa8c:	f3af 8000 	nop.w

0800fa90 <queues2_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 800fa90:	b500      	push	{lr}
 800fa92:	b083      	sub	sp, #12

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800fa94:	4b06      	ldr	r3, [pc, #24]	; (800fab0 <queues2_setup+0x20>)
 800fa96:	681b      	ldr	r3, [r3, #0]
 800fa98:	2200      	movs	r2, #0
 800fa9a:	9200      	str	r2, [sp, #0]
 800fa9c:	4805      	ldr	r0, [pc, #20]	; (800fab4 <queues2_setup+0x24>)
 800fa9e:	4619      	mov	r1, r3
 800faa0:	2204      	movs	r2, #4
 800faa2:	4b05      	ldr	r3, [pc, #20]	; (800fab8 <queues2_setup+0x28>)
 800faa4:	f7f3 fc8c 	bl	80033c0 <chOQObjectInit>
}
 800faa8:	b003      	add	sp, #12
 800faaa:	f85d fb04 	ldr.w	pc, [sp], #4
 800faae:	bf00      	nop
 800fab0:	0801ad70 	.word	0x0801ad70
 800fab4:	200008cc 	.word	0x200008cc
 800fab8:	0800f721 	.word	0x0800f721
 800fabc:	f3af 8000 	nop.w

0800fac0 <thread2>:

static THD_FUNCTION(thread2, p) {
 800fac0:	b500      	push	{lr}
 800fac2:	b083      	sub	sp, #12
 800fac4:	9001      	str	r0, [sp, #4]

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 800fac6:	4804      	ldr	r0, [pc, #16]	; (800fad8 <thread2+0x18>)
 800fac8:	2100      	movs	r1, #0
 800faca:	f644 6220 	movw	r2, #20000	; 0x4e20
 800face:	f7f3 fcbf 	bl	8003450 <chOQPutTimeout>
}
 800fad2:	b003      	add	sp, #12
 800fad4:	f85d fb04 	ldr.w	pc, [sp], #4
 800fad8:	200008cc 	.word	0x200008cc
 800fadc:	f3af 8000 	nop.w

0800fae0 <queues2_execute>:

static void queues2_execute(void) {
 800fae0:	b510      	push	{r4, lr}
 800fae2:	b086      	sub	sp, #24
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 800fae4:	f7ff fd6c 	bl	800f5c0 <chSysLock>
 800fae8:	48a2      	ldr	r0, [pc, #648]	; (800fd74 <queues2_execute+0x294>)
 800faea:	f7ff fdd9 	bl	800f6a0 <chOQIsEmptyI>
 800faee:	4603      	mov	r3, r0
 800faf0:	2001      	movs	r0, #1
 800faf2:	4619      	mov	r1, r3
 800faf4:	f7fc f9ac 	bl	800be50 <_test_assert>
 800faf8:	4603      	mov	r3, r0
 800fafa:	2b00      	cmp	r3, #0
 800fafc:	d002      	beq.n	800fb04 <queues2_execute+0x24>
 800fafe:	f7ff fd67 	bl	800f5d0 <chSysUnlock>
 800fb02:	e134      	b.n	800fd6e <queues2_execute+0x28e>
 800fb04:	f7ff fd64 	bl	800f5d0 <chSysUnlock>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800fb08:	2300      	movs	r3, #0
 800fb0a:	9305      	str	r3, [sp, #20]
 800fb0c:	e00a      	b.n	800fb24 <queues2_execute+0x44>
    chOQPut(&oq, 'A' + i);
 800fb0e:	9b05      	ldr	r3, [sp, #20]
 800fb10:	b2db      	uxtb	r3, r3
 800fb12:	3341      	adds	r3, #65	; 0x41
 800fb14:	b2db      	uxtb	r3, r3
 800fb16:	4897      	ldr	r0, [pc, #604]	; (800fd74 <queues2_execute+0x294>)
 800fb18:	4619      	mov	r1, r3
 800fb1a:	f7ff fde9 	bl	800f6f0 <chOQPut>

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800fb1e:	9b05      	ldr	r3, [sp, #20]
 800fb20:	3301      	adds	r3, #1
 800fb22:	9305      	str	r3, [sp, #20]
 800fb24:	9b05      	ldr	r3, [sp, #20]
 800fb26:	2b03      	cmp	r3, #3
 800fb28:	d9f1      	bls.n	800fb0e <queues2_execute+0x2e>
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 800fb2a:	f7ff fd49 	bl	800f5c0 <chSysLock>
 800fb2e:	4891      	ldr	r0, [pc, #580]	; (800fd74 <queues2_execute+0x294>)
 800fb30:	f7ff fdce 	bl	800f6d0 <chOQIsFullI>
 800fb34:	4603      	mov	r3, r0
 800fb36:	2002      	movs	r0, #2
 800fb38:	4619      	mov	r1, r3
 800fb3a:	f7fc f989 	bl	800be50 <_test_assert>
 800fb3e:	4603      	mov	r3, r0
 800fb40:	2b00      	cmp	r3, #0
 800fb42:	d002      	beq.n	800fb4a <queues2_execute+0x6a>
 800fb44:	f7ff fd44 	bl	800f5d0 <chSysUnlock>
 800fb48:	e111      	b.n	800fd6e <queues2_execute+0x28e>
 800fb4a:	f7ff fd41 	bl	800f5d0 <chSysUnlock>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800fb4e:	2300      	movs	r3, #0
 800fb50:	9305      	str	r3, [sp, #20]
 800fb52:	e011      	b.n	800fb78 <queues2_execute+0x98>
    char c;

    chSysLock();
 800fb54:	f7ff fd34 	bl	800f5c0 <chSysLock>
    c = chOQGetI(&oq);
 800fb58:	4886      	ldr	r0, [pc, #536]	; (800fd74 <queues2_execute+0x294>)
 800fb5a:	f7f3 fcc1 	bl	80034e0 <chOQGetI>
 800fb5e:	4603      	mov	r3, r0
 800fb60:	f88d 3013 	strb.w	r3, [sp, #19]
    chSysUnlock();
 800fb64:	f7ff fd34 	bl	800f5d0 <chSysUnlock>
    test_emit_token(c);
 800fb68:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800fb6c:	4618      	mov	r0, r3
 800fb6e:	f7fc f93f 	bl	800bdf0 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800fb72:	9b05      	ldr	r3, [sp, #20]
 800fb74:	3301      	adds	r3, #1
 800fb76:	9305      	str	r3, [sp, #20]
 800fb78:	9b05      	ldr	r3, [sp, #20]
 800fb7a:	2b03      	cmp	r3, #3
 800fb7c:	d9ea      	bls.n	800fb54 <queues2_execute+0x74>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 800fb7e:	f7ff fd1f 	bl	800f5c0 <chSysLock>
 800fb82:	487c      	ldr	r0, [pc, #496]	; (800fd74 <queues2_execute+0x294>)
 800fb84:	f7ff fd8c 	bl	800f6a0 <chOQIsEmptyI>
 800fb88:	4603      	mov	r3, r0
 800fb8a:	2003      	movs	r0, #3
 800fb8c:	4619      	mov	r1, r3
 800fb8e:	f7fc f95f 	bl	800be50 <_test_assert>
 800fb92:	4603      	mov	r3, r0
 800fb94:	2b00      	cmp	r3, #0
 800fb96:	d002      	beq.n	800fb9e <queues2_execute+0xbe>
 800fb98:	f7ff fd1a 	bl	800f5d0 <chSysUnlock>
 800fb9c:	e0e7      	b.n	800fd6e <queues2_execute+0x28e>
 800fb9e:	f7ff fd17 	bl	800f5d0 <chSysUnlock>
  test_assert_sequence(4, "ABCD");
 800fba2:	2004      	movs	r0, #4
 800fba4:	4974      	ldr	r1, [pc, #464]	; (800fd78 <queues2_execute+0x298>)
 800fba6:	f7fc f96b 	bl	800be80 <_test_assert_sequence>
 800fbaa:	4603      	mov	r3, r0
 800fbac:	2b00      	cmp	r3, #0
 800fbae:	d000      	beq.n	800fbb2 <queues2_execute+0xd2>
 800fbb0:	e0dd      	b.n	800fd6e <queues2_execute+0x28e>
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 800fbb2:	f7ff fd05 	bl	800f5c0 <chSysLock>
 800fbb6:	486f      	ldr	r0, [pc, #444]	; (800fd74 <queues2_execute+0x294>)
 800fbb8:	f7f3 fc92 	bl	80034e0 <chOQGetI>
 800fbbc:	4603      	mov	r3, r0
 800fbbe:	f113 0f03 	cmn.w	r3, #3
 800fbc2:	bf14      	ite	ne
 800fbc4:	2300      	movne	r3, #0
 800fbc6:	2301      	moveq	r3, #1
 800fbc8:	b2db      	uxtb	r3, r3
 800fbca:	2005      	movs	r0, #5
 800fbcc:	4619      	mov	r1, r3
 800fbce:	f7fc f93f 	bl	800be50 <_test_assert>
 800fbd2:	4603      	mov	r3, r0
 800fbd4:	2b00      	cmp	r3, #0
 800fbd6:	d002      	beq.n	800fbde <queues2_execute+0xfe>
 800fbd8:	f7ff fcfa 	bl	800f5d0 <chSysUnlock>
 800fbdc:	e0c7      	b.n	800fd6e <queues2_execute+0x28e>
 800fbde:	f7ff fcf7 	bl	800f5d0 <chSysUnlock>

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800fbe2:	4b66      	ldr	r3, [pc, #408]	; (800fd7c <queues2_execute+0x29c>)
 800fbe4:	685b      	ldr	r3, [r3, #4]
 800fbe6:	4863      	ldr	r0, [pc, #396]	; (800fd74 <queues2_execute+0x294>)
 800fbe8:	4619      	mov	r1, r3
 800fbea:	2208      	movs	r2, #8
 800fbec:	2300      	movs	r3, #0
 800fbee:	f7f3 fca7 	bl	8003540 <chOQWriteTimeout>
 800fbf2:	9003      	str	r0, [sp, #12]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800fbf4:	9b03      	ldr	r3, [sp, #12]
 800fbf6:	2b04      	cmp	r3, #4
 800fbf8:	bf14      	ite	ne
 800fbfa:	2300      	movne	r3, #0
 800fbfc:	2301      	moveq	r3, #1
 800fbfe:	b2db      	uxtb	r3, r3
 800fc00:	2006      	movs	r0, #6
 800fc02:	4619      	mov	r1, r3
 800fc04:	f7fc f924 	bl	800be50 <_test_assert>
 800fc08:	4603      	mov	r3, r0
 800fc0a:	2b00      	cmp	r3, #0
 800fc0c:	d000      	beq.n	800fc10 <queues2_execute+0x130>
 800fc0e:	e0ae      	b.n	800fd6e <queues2_execute+0x28e>
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 800fc10:	f7ff fcd6 	bl	800f5c0 <chSysLock>
 800fc14:	4857      	ldr	r0, [pc, #348]	; (800fd74 <queues2_execute+0x294>)
 800fc16:	f7ff fd5b 	bl	800f6d0 <chOQIsFullI>
 800fc1a:	4603      	mov	r3, r0
 800fc1c:	2007      	movs	r0, #7
 800fc1e:	4619      	mov	r1, r3
 800fc20:	f7fc f916 	bl	800be50 <_test_assert>
 800fc24:	4603      	mov	r3, r0
 800fc26:	2b00      	cmp	r3, #0
 800fc28:	d002      	beq.n	800fc30 <queues2_execute+0x150>
 800fc2a:	f7ff fcd1 	bl	800f5d0 <chSysUnlock>
 800fc2e:	e09e      	b.n	800fd6e <queues2_execute+0x28e>
 800fc30:	f7ff fcce 	bl	800f5d0 <chSysUnlock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 800fc34:	4b51      	ldr	r3, [pc, #324]	; (800fd7c <queues2_execute+0x29c>)
 800fc36:	681c      	ldr	r4, [r3, #0]
 800fc38:	f7ff fcda 	bl	800f5f0 <chThdGetPriorityX>
 800fc3c:	4603      	mov	r3, r0
 800fc3e:	3301      	adds	r3, #1
 800fc40:	2200      	movs	r2, #0
 800fc42:	9200      	str	r2, [sp, #0]
 800fc44:	4620      	mov	r0, r4
 800fc46:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fc4a:	461a      	mov	r2, r3
 800fc4c:	4b4c      	ldr	r3, [pc, #304]	; (800fd80 <queues2_execute+0x2a0>)
 800fc4e:	f7f1 fac7 	bl	80011e0 <chThdCreateStatic>
 800fc52:	4602      	mov	r2, r0
 800fc54:	4b4b      	ldr	r3, [pc, #300]	; (800fd84 <queues2_execute+0x2a4>)
 800fc56:	601a      	str	r2, [r3, #0]
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 800fc58:	f7ff fcb2 	bl	800f5c0 <chSysLock>
 800fc5c:	4845      	ldr	r0, [pc, #276]	; (800fd74 <queues2_execute+0x294>)
 800fc5e:	f7ff fd0f 	bl	800f680 <chOQGetFullI>
 800fc62:	4603      	mov	r3, r0
 800fc64:	2b04      	cmp	r3, #4
 800fc66:	bf14      	ite	ne
 800fc68:	2300      	movne	r3, #0
 800fc6a:	2301      	moveq	r3, #1
 800fc6c:	b2db      	uxtb	r3, r3
 800fc6e:	2008      	movs	r0, #8
 800fc70:	4619      	mov	r1, r3
 800fc72:	f7fc f8ed 	bl	800be50 <_test_assert>
 800fc76:	4603      	mov	r3, r0
 800fc78:	2b00      	cmp	r3, #0
 800fc7a:	d002      	beq.n	800fc82 <queues2_execute+0x1a2>
 800fc7c:	f7ff fca8 	bl	800f5d0 <chSysUnlock>
 800fc80:	e075      	b.n	800fd6e <queues2_execute+0x28e>
 800fc82:	f7ff fca5 	bl	800f5d0 <chSysUnlock>
  test_wait_threads();
 800fc86:	f7fc f963 	bl	800bf50 <test_wait_threads>

  /* Testing reset */
  chSysLock();
 800fc8a:	f7ff fc99 	bl	800f5c0 <chSysLock>
  chOQResetI(&oq);
 800fc8e:	4839      	ldr	r0, [pc, #228]	; (800fd74 <queues2_execute+0x294>)
 800fc90:	f7f3 fbbe 	bl	8003410 <chOQResetI>
  chSysUnlock();
 800fc94:	f7ff fc9c 	bl	800f5d0 <chSysUnlock>
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 800fc98:	f7ff fc92 	bl	800f5c0 <chSysLock>
 800fc9c:	4835      	ldr	r0, [pc, #212]	; (800fd74 <queues2_execute+0x294>)
 800fc9e:	f7ff fcef 	bl	800f680 <chOQGetFullI>
 800fca2:	4603      	mov	r3, r0
 800fca4:	2b00      	cmp	r3, #0
 800fca6:	bf14      	ite	ne
 800fca8:	2300      	movne	r3, #0
 800fcaa:	2301      	moveq	r3, #1
 800fcac:	b2db      	uxtb	r3, r3
 800fcae:	2009      	movs	r0, #9
 800fcb0:	4619      	mov	r1, r3
 800fcb2:	f7fc f8cd 	bl	800be50 <_test_assert>
 800fcb6:	4603      	mov	r3, r0
 800fcb8:	2b00      	cmp	r3, #0
 800fcba:	d002      	beq.n	800fcc2 <queues2_execute+0x1e2>
 800fcbc:	f7ff fc88 	bl	800f5d0 <chSysUnlock>
 800fcc0:	e055      	b.n	800fd6e <queues2_execute+0x28e>
 800fcc2:	f7ff fc85 	bl	800f5d0 <chSysUnlock>

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800fcc6:	4b2d      	ldr	r3, [pc, #180]	; (800fd7c <queues2_execute+0x29c>)
 800fcc8:	685b      	ldr	r3, [r3, #4]
 800fcca:	482a      	ldr	r0, [pc, #168]	; (800fd74 <queues2_execute+0x294>)
 800fccc:	4619      	mov	r1, r3
 800fcce:	2202      	movs	r2, #2
 800fcd0:	2300      	movs	r3, #0
 800fcd2:	f7f3 fc35 	bl	8003540 <chOQWriteTimeout>
 800fcd6:	9003      	str	r0, [sp, #12]
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800fcd8:	9b03      	ldr	r3, [sp, #12]
 800fcda:	2b02      	cmp	r3, #2
 800fcdc:	bf14      	ite	ne
 800fcde:	2300      	movne	r3, #0
 800fce0:	2301      	moveq	r3, #1
 800fce2:	b2db      	uxtb	r3, r3
 800fce4:	200a      	movs	r0, #10
 800fce6:	4619      	mov	r1, r3
 800fce8:	f7fc f8b2 	bl	800be50 <_test_assert>
 800fcec:	4603      	mov	r3, r0
 800fcee:	2b00      	cmp	r3, #0
 800fcf0:	d000      	beq.n	800fcf4 <queues2_execute+0x214>
 800fcf2:	e03c      	b.n	800fd6e <queues2_execute+0x28e>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800fcf4:	4b21      	ldr	r3, [pc, #132]	; (800fd7c <queues2_execute+0x29c>)
 800fcf6:	685b      	ldr	r3, [r3, #4]
 800fcf8:	481e      	ldr	r0, [pc, #120]	; (800fd74 <queues2_execute+0x294>)
 800fcfa:	4619      	mov	r1, r3
 800fcfc:	2202      	movs	r2, #2
 800fcfe:	2300      	movs	r3, #0
 800fd00:	f7f3 fc1e 	bl	8003540 <chOQWriteTimeout>
 800fd04:	9003      	str	r0, [sp, #12]
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800fd06:	9b03      	ldr	r3, [sp, #12]
 800fd08:	2b02      	cmp	r3, #2
 800fd0a:	bf14      	ite	ne
 800fd0c:	2300      	movne	r3, #0
 800fd0e:	2301      	moveq	r3, #1
 800fd10:	b2db      	uxtb	r3, r3
 800fd12:	200b      	movs	r0, #11
 800fd14:	4619      	mov	r1, r3
 800fd16:	f7fc f89b 	bl	800be50 <_test_assert>
 800fd1a:	4603      	mov	r3, r0
 800fd1c:	2b00      	cmp	r3, #0
 800fd1e:	d000      	beq.n	800fd22 <queues2_execute+0x242>
 800fd20:	e025      	b.n	800fd6e <queues2_execute+0x28e>
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 800fd22:	f7ff fc4d 	bl	800f5c0 <chSysLock>
 800fd26:	4813      	ldr	r0, [pc, #76]	; (800fd74 <queues2_execute+0x294>)
 800fd28:	f7ff fcd2 	bl	800f6d0 <chOQIsFullI>
 800fd2c:	4603      	mov	r3, r0
 800fd2e:	200c      	movs	r0, #12
 800fd30:	4619      	mov	r1, r3
 800fd32:	f7fc f88d 	bl	800be50 <_test_assert>
 800fd36:	4603      	mov	r3, r0
 800fd38:	2b00      	cmp	r3, #0
 800fd3a:	d002      	beq.n	800fd42 <queues2_execute+0x262>
 800fd3c:	f7ff fc48 	bl	800f5d0 <chSysUnlock>
 800fd40:	e015      	b.n	800fd6e <queues2_execute+0x28e>
 800fd42:	f7ff fc45 	bl	800f5d0 <chSysUnlock>

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 800fd46:	480b      	ldr	r0, [pc, #44]	; (800fd74 <queues2_execute+0x294>)
 800fd48:	2100      	movs	r1, #0
 800fd4a:	220a      	movs	r2, #10
 800fd4c:	f7f3 fb80 	bl	8003450 <chOQPutTimeout>
 800fd50:	4603      	mov	r3, r0
 800fd52:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fd56:	bf14      	ite	ne
 800fd58:	2300      	movne	r3, #0
 800fd5a:	2301      	moveq	r3, #1
 800fd5c:	b2db      	uxtb	r3, r3
 800fd5e:	200d      	movs	r0, #13
 800fd60:	4619      	mov	r1, r3
 800fd62:	f7fc f875 	bl	800be50 <_test_assert>
 800fd66:	4603      	mov	r3, r0
 800fd68:	2b00      	cmp	r3, #0
 800fd6a:	d000      	beq.n	800fd6e <queues2_execute+0x28e>
 800fd6c:	bf00      	nop
}
 800fd6e:	b006      	add	sp, #24
 800fd70:	bd10      	pop	{r4, pc}
 800fd72:	bf00      	nop
 800fd74:	200008cc 	.word	0x200008cc
 800fd78:	0801b500 	.word	0x0801b500
 800fd7c:	0801ad70 	.word	0x0801ad70
 800fd80:	0800fac1 	.word	0x0800fac1
 800fd84:	20003e3c 	.word	0x20003e3c
 800fd88:	f3af 8000 	nop.w
 800fd8c:	f3af 8000 	nop.w

0800fd90 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 800fd90:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fd92:	f3ef 8311 	mrs	r3, BASEPRI
 800fd96:	9300      	str	r3, [sp, #0]
  return(result);
 800fd98:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 800fd9a:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 800fd9c:	9b01      	ldr	r3, [sp, #4]
}
 800fd9e:	4618      	mov	r0, r3
 800fda0:	b002      	add	sp, #8
 800fda2:	4770      	bx	lr
 800fda4:	f3af 8000 	nop.w
 800fda8:	f3af 8000 	nop.w
 800fdac:	f3af 8000 	nop.w

0800fdb0 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 800fdb0:	b082      	sub	sp, #8
 800fdb2:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 800fdb4:	9b01      	ldr	r3, [sp, #4]
 800fdb6:	2b00      	cmp	r3, #0
 800fdb8:	bf14      	ite	ne
 800fdba:	2300      	movne	r3, #0
 800fdbc:	2301      	moveq	r3, #1
 800fdbe:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fdc0:	4618      	mov	r0, r3
 800fdc2:	b002      	add	sp, #8
 800fdc4:	4770      	bx	lr
 800fdc6:	bf00      	nop
 800fdc8:	f3af 8000 	nop.w
 800fdcc:	f3af 8000 	nop.w

0800fdd0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800fdd0:	b082      	sub	sp, #8
 800fdd2:	2320      	movs	r3, #32
 800fdd4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800fdd6:	9b01      	ldr	r3, [sp, #4]
 800fdd8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fddc:	b002      	add	sp, #8
 800fdde:	4770      	bx	lr

0800fde0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800fde0:	b082      	sub	sp, #8
 800fde2:	2300      	movs	r3, #0
 800fde4:	9301      	str	r3, [sp, #4]
 800fde6:	9b01      	ldr	r3, [sp, #4]
 800fde8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fdec:	b002      	add	sp, #8
 800fdee:	4770      	bx	lr

0800fdf0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800fdf0:	b508      	push	{r3, lr}

  port_lock();
 800fdf2:	f7ff ffed 	bl	800fdd0 <port_lock>
}
 800fdf6:	bd08      	pop	{r3, pc}
 800fdf8:	f3af 8000 	nop.w
 800fdfc:	f3af 8000 	nop.w

0800fe00 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800fe00:	b508      	push	{r3, lr}

  port_unlock();
 800fe02:	f7ff ffed 	bl	800fde0 <port_unlock>
}
 800fe06:	bd08      	pop	{r3, pc}
 800fe08:	f3af 8000 	nop.w
 800fe0c:	f3af 8000 	nop.w

0800fe10 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800fe10:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 800fe12:	4770      	bx	lr
 800fe14:	f3af 8000 	nop.w
 800fe18:	f3af 8000 	nop.w
 800fe1c:	f3af 8000 	nop.w

0800fe20 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 * @note    Interrupt sources above kernel level remains enabled.
 * @note    In this port it raises/lowers the base priority to kernel level.
 */
static inline void port_suspend(void) {
 800fe20:	b082      	sub	sp, #8
 800fe22:	2320      	movs	r3, #32
 800fe24:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800fe26:	9b01      	ldr	r3, [sp, #4]
 800fe28:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fe2c:	b662      	cpsie	i
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
  __enable_irq();
#else
  __disable_irq();
#endif
}
 800fe2e:	b002      	add	sp, #8
 800fe30:	4770      	bx	lr
 800fe32:	bf00      	nop
 800fe34:	f3af 8000 	nop.w
 800fe38:	f3af 8000 	nop.w
 800fe3c:	f3af 8000 	nop.w

0800fe40 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 800fe40:	b082      	sub	sp, #8
 800fe42:	2300      	movs	r3, #0
 800fe44:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800fe46:	9b01      	ldr	r3, [sp, #4]
 800fe48:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fe4c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800fe4e:	b002      	add	sp, #8
 800fe50:	4770      	bx	lr
 800fe52:	bf00      	nop
 800fe54:	f3af 8000 	nop.w
 800fe58:	f3af 8000 	nop.w
 800fe5c:	f3af 8000 	nop.w

0800fe60 <chSysDisable>:
 *          hardware priority.
 * @note    Do not invoke this API from within a kernel lock.
 *
 * @special
 */
static inline void chSysDisable(void) {
 800fe60:	b508      	push	{r3, lr}

  port_disable();
 800fe62:	f7ff ffd5 	bl	800fe10 <port_disable>
  _dbg_check_disable();
}
 800fe66:	bd08      	pop	{r3, pc}
 800fe68:	f3af 8000 	nop.w
 800fe6c:	f3af 8000 	nop.w

0800fe70 <chSysSuspend>:
 * @note    This API is no replacement for @p chSysLock(), the @p chSysLock()
 *          could do more than just disable the interrupts.
 *
 * @special
 */
static inline void chSysSuspend(void) {
 800fe70:	b508      	push	{r3, lr}

  port_suspend();
 800fe72:	f7ff ffd5 	bl	800fe20 <port_suspend>
  _dbg_check_suspend();
}
 800fe76:	bd08      	pop	{r3, pc}
 800fe78:	f3af 8000 	nop.w
 800fe7c:	f3af 8000 	nop.w

0800fe80 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 800fe80:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 800fe82:	f7ff ffdd 	bl	800fe40 <port_enable>
}
 800fe86:	bd08      	pop	{r3, pc}
 800fe88:	f3af 8000 	nop.w
 800fe8c:	f3af 8000 	nop.w

0800fe90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800fe90:	b508      	push	{r3, lr}

  port_lock();
 800fe92:	f7ff ff9d 	bl	800fdd0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800fe96:	bd08      	pop	{r3, pc}
 800fe98:	f3af 8000 	nop.w
 800fe9c:	f3af 8000 	nop.w

0800fea0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800fea0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800fea2:	f7ff ff9d 	bl	800fde0 <port_unlock>
}
 800fea6:	bd08      	pop	{r3, pc}
 800fea8:	f3af 8000 	nop.w
 800feac:	f3af 8000 	nop.w

0800feb0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800feb0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800feb2:	f7ff ff9d 	bl	800fdf0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800feb6:	bd08      	pop	{r3, pc}
 800feb8:	f3af 8000 	nop.w
 800febc:	f3af 8000 	nop.w

0800fec0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800fec0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800fec2:	f7ff ff9d 	bl	800fe00 <port_unlock_from_isr>
}
 800fec6:	bd08      	pop	{r3, pc}
 800fec8:	f3af 8000 	nop.w
 800fecc:	f3af 8000 	nop.w

0800fed0 <chSysUnconditionalLock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "s-locked".
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {
 800fed0:	b508      	push	{r3, lr}

  if (port_irq_enabled(port_get_irq_status())) {
 800fed2:	f7ff ff5d 	bl	800fd90 <port_get_irq_status>
 800fed6:	4603      	mov	r3, r0
 800fed8:	4618      	mov	r0, r3
 800feda:	f7ff ff69 	bl	800fdb0 <port_irq_enabled>
 800fede:	4603      	mov	r3, r0
 800fee0:	2b00      	cmp	r3, #0
 800fee2:	d001      	beq.n	800fee8 <chSysUnconditionalLock+0x18>
    chSysLock();
 800fee4:	f7ff ffd4 	bl	800fe90 <chSysLock>
  }
}
 800fee8:	bd08      	pop	{r3, pc}
 800feea:	bf00      	nop
 800feec:	f3af 8000 	nop.w

0800fef0 <chSysUnconditionalUnlock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "normal".
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {
 800fef0:	b508      	push	{r3, lr}

  if (!port_irq_enabled(port_get_irq_status())) {
 800fef2:	f7ff ff4d 	bl	800fd90 <port_get_irq_status>
 800fef6:	4603      	mov	r3, r0
 800fef8:	4618      	mov	r0, r3
 800fefa:	f7ff ff59 	bl	800fdb0 <port_irq_enabled>
 800fefe:	4603      	mov	r3, r0
 800ff00:	f083 0301 	eor.w	r3, r3, #1
 800ff04:	b2db      	uxtb	r3, r3
 800ff06:	2b00      	cmp	r3, #0
 800ff08:	d001      	beq.n	800ff0e <chSysUnconditionalUnlock+0x1e>
    chSysUnlock();
 800ff0a:	f7ff ffc9 	bl	800fea0 <chSysUnlock>
  }
}
 800ff0e:	bd08      	pop	{r3, pc}

0800ff10 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 800ff10:	b082      	sub	sp, #8
 800ff12:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 800ff14:	9b01      	ldr	r3, [sp, #4]
 800ff16:	2200      	movs	r2, #0
 800ff18:	60da      	str	r2, [r3, #12]
}
 800ff1a:	b002      	add	sp, #8
 800ff1c:	4770      	bx	lr
 800ff1e:	bf00      	nop

0800ff20 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800ff20:	b082      	sub	sp, #8
 800ff22:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 800ff24:	9b01      	ldr	r3, [sp, #4]
 800ff26:	68db      	ldr	r3, [r3, #12]
 800ff28:	2b00      	cmp	r3, #0
 800ff2a:	bf0c      	ite	eq
 800ff2c:	2300      	moveq	r3, #0
 800ff2e:	2301      	movne	r3, #1
 800ff30:	b2db      	uxtb	r3, r3
}
 800ff32:	4618      	mov	r0, r3
 800ff34:	b002      	add	sp, #8
 800ff36:	4770      	bx	lr
 800ff38:	f3af 8000 	nop.w
 800ff3c:	f3af 8000 	nop.w

0800ff40 <chVTIsArmed>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 800ff40:	b500      	push	{lr}
 800ff42:	b085      	sub	sp, #20
 800ff44:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 800ff46:	f7ff ffa3 	bl	800fe90 <chSysLock>
  b = chVTIsArmedI(vtp);
 800ff4a:	9801      	ldr	r0, [sp, #4]
 800ff4c:	f7ff ffe8 	bl	800ff20 <chVTIsArmedI>
 800ff50:	4603      	mov	r3, r0
 800ff52:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 800ff56:	f7ff ffa3 	bl	800fea0 <chSysUnlock>

  return b;
 800ff5a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800ff5e:	4618      	mov	r0, r3
 800ff60:	b005      	add	sp, #20
 800ff62:	f85d fb04 	ldr.w	pc, [sp], #4
 800ff66:	bf00      	nop
 800ff68:	f3af 8000 	nop.w
 800ff6c:	f3af 8000 	nop.w

0800ff70 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 800ff70:	b500      	push	{lr}
 800ff72:	b083      	sub	sp, #12
 800ff74:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 800ff76:	9801      	ldr	r0, [sp, #4]
 800ff78:	f7ff ffd2 	bl	800ff20 <chVTIsArmedI>
 800ff7c:	4603      	mov	r3, r0
 800ff7e:	2b00      	cmp	r3, #0
 800ff80:	d002      	beq.n	800ff88 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 800ff82:	9801      	ldr	r0, [sp, #4]
 800ff84:	f7f0 fd44 	bl	8000a10 <chVTDoResetI>
  }
}
 800ff88:	b003      	add	sp, #12
 800ff8a:	f85d fb04 	ldr.w	pc, [sp], #4
 800ff8e:	bf00      	nop

0800ff90 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 800ff90:	b500      	push	{lr}
 800ff92:	b085      	sub	sp, #20
 800ff94:	9003      	str	r0, [sp, #12]
 800ff96:	9102      	str	r1, [sp, #8]
 800ff98:	9201      	str	r2, [sp, #4]
 800ff9a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800ff9c:	9803      	ldr	r0, [sp, #12]
 800ff9e:	f7ff ffe7 	bl	800ff70 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 800ffa2:	9803      	ldr	r0, [sp, #12]
 800ffa4:	9902      	ldr	r1, [sp, #8]
 800ffa6:	9a01      	ldr	r2, [sp, #4]
 800ffa8:	9b00      	ldr	r3, [sp, #0]
 800ffaa:	f7f0 fcf1 	bl	8000990 <chVTDoSetI>
}
 800ffae:	b005      	add	sp, #20
 800ffb0:	f85d fb04 	ldr.w	pc, [sp], #4
 800ffb4:	f3af 8000 	nop.w
 800ffb8:	f3af 8000 	nop.w
 800ffbc:	f3af 8000 	nop.w

0800ffc0 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 800ffc0:	b500      	push	{lr}
 800ffc2:	b085      	sub	sp, #20
 800ffc4:	9003      	str	r0, [sp, #12]
 800ffc6:	9102      	str	r1, [sp, #8]
 800ffc8:	9201      	str	r2, [sp, #4]
 800ffca:	9300      	str	r3, [sp, #0]

  chSysLock();
 800ffcc:	f7ff ff60 	bl	800fe90 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 800ffd0:	9803      	ldr	r0, [sp, #12]
 800ffd2:	9902      	ldr	r1, [sp, #8]
 800ffd4:	9a01      	ldr	r2, [sp, #4]
 800ffd6:	9b00      	ldr	r3, [sp, #0]
 800ffd8:	f7ff ffda 	bl	800ff90 <chVTSetI>
  chSysUnlock();
 800ffdc:	f7ff ff60 	bl	800fea0 <chSysUnlock>
}
 800ffe0:	b005      	add	sp, #20
 800ffe2:	f85d fb04 	ldr.w	pc, [sp], #4
 800ffe6:	bf00      	nop
 800ffe8:	f3af 8000 	nop.w
 800ffec:	f3af 8000 	nop.w

0800fff0 <vtcb>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 800fff0:	b500      	push	{lr}
 800fff2:	b085      	sub	sp, #20
 800fff4:	9001      	str	r0, [sp, #4]
  syssts_t sts;

  (void)p;

  /* Testing normal case.*/
  chSysLockFromISR();
 800fff6:	f7ff ff5b 	bl	800feb0 <chSysLockFromISR>
  chSysUnlockFromISR();
 800fffa:	f7ff ff61 	bl	800fec0 <chSysUnlockFromISR>

  /* Reentrant case.*/
  chSysLockFromISR();
 800fffe:	f7ff ff57 	bl	800feb0 <chSysLockFromISR>
  sts = chSysGetStatusAndLockX();
 8010002:	f7f0 fc3d 	bl	8000880 <chSysGetStatusAndLockX>
 8010006:	9003      	str	r0, [sp, #12]
  chSysRestoreStatusX(sts);
 8010008:	9803      	ldr	r0, [sp, #12]
 801000a:	f7f0 fc59 	bl	80008c0 <chSysRestoreStatusX>
  chSysUnlockFromISR();
 801000e:	f7ff ff57 	bl	800fec0 <chSysUnlockFromISR>
}
 8010012:	b005      	add	sp, #20
 8010014:	f85d fb04 	ldr.w	pc, [sp], #4
 8010018:	f3af 8000 	nop.w
 801001c:	f3af 8000 	nop.w

08010020 <sys1_execute>:

static void sys1_execute(void) {
 8010020:	b500      	push	{lr}
 8010022:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 8010024:	f7f0 fc2c 	bl	8000880 <chSysGetStatusAndLockX>
 8010028:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 801002a:	9805      	ldr	r0, [sp, #20]
 801002c:	f7f0 fc48 	bl	80008c0 <chSysRestoreStatusX>

  /* Reentrant case.*/
  chSysLock();
 8010030:	f7ff ff2e 	bl	800fe90 <chSysLock>
  sts = chSysGetStatusAndLockX();
 8010034:	f7f0 fc24 	bl	8000880 <chSysGetStatusAndLockX>
 8010038:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 801003a:	9805      	ldr	r0, [sp, #20]
 801003c:	f7f0 fc40 	bl	80008c0 <chSysRestoreStatusX>
  chSysUnlock();
 8010040:	f7ff ff2e 	bl	800fea0 <chSysUnlock>

  /* Unconditional lock.*/
  chSysUnconditionalLock();
 8010044:	f7ff ff44 	bl	800fed0 <chSysUnconditionalLock>
  chSysUnconditionalLock();
 8010048:	f7ff ff42 	bl	800fed0 <chSysUnconditionalLock>
  chSysUnlock();
 801004c:	f7ff ff28 	bl	800fea0 <chSysUnlock>

  /* Unconditional unlock.*/
  chSysLock();
 8010050:	f7ff ff1e 	bl	800fe90 <chSysLock>
  chSysUnconditionalUnlock();
 8010054:	f7ff ff4c 	bl	800fef0 <chSysUnconditionalUnlock>
  chSysUnconditionalUnlock();
 8010058:	f7ff ff4a 	bl	800fef0 <chSysUnconditionalUnlock>

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
 801005c:	466b      	mov	r3, sp
 801005e:	4618      	mov	r0, r3
 8010060:	f7ff ff56 	bl	800ff10 <chVTObjectInit>
  chVTSet(&vt, 1, vtcb, NULL);
 8010064:	466b      	mov	r3, sp
 8010066:	4618      	mov	r0, r3
 8010068:	2101      	movs	r1, #1
 801006a:	4a10      	ldr	r2, [pc, #64]	; (80100ac <sys1_execute+0x8c>)
 801006c:	2300      	movs	r3, #0
 801006e:	f7ff ffa7 	bl	800ffc0 <chVTSet>
  chThdSleep(10);
 8010072:	200a      	movs	r0, #10
 8010074:	f7f1 f92c 	bl	80012d0 <chThdSleep>

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 8010078:	466b      	mov	r3, sp
 801007a:	4618      	mov	r0, r3
 801007c:	f7ff ff60 	bl	800ff40 <chVTIsArmed>
 8010080:	4603      	mov	r3, r0
 8010082:	2b00      	cmp	r3, #0
 8010084:	bf0c      	ite	eq
 8010086:	2300      	moveq	r3, #0
 8010088:	2301      	movne	r3, #1
 801008a:	b2db      	uxtb	r3, r3
 801008c:	f083 0301 	eor.w	r3, r3, #1
 8010090:	b2db      	uxtb	r3, r3
 8010092:	f003 0301 	and.w	r3, r3, #1
 8010096:	b2db      	uxtb	r3, r3
 8010098:	2001      	movs	r0, #1
 801009a:	4619      	mov	r1, r3
 801009c:	f7fb fed8 	bl	800be50 <_test_assert>
 80100a0:	4603      	mov	r3, r0
 80100a2:	2b00      	cmp	r3, #0
}
 80100a4:	b007      	add	sp, #28
 80100a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80100aa:	bf00      	nop
 80100ac:	0800fff1 	.word	0x0800fff1

080100b0 <sys2_execute>:
 *
 * <h2>Description</h2>
 * The interrupts handling API is invoked for coverage.
 */

static void sys2_execute(void) {
 80100b0:	b508      	push	{r3, lr}

  chSysSuspend();
 80100b2:	f7ff fedd 	bl	800fe70 <chSysSuspend>
  chSysDisable();
 80100b6:	f7ff fed3 	bl	800fe60 <chSysDisable>
  chSysSuspend();
 80100ba:	f7ff fed9 	bl	800fe70 <chSysSuspend>
  chSysEnable();
 80100be:	f7ff fedf 	bl	800fe80 <chSysEnable>
}
 80100c2:	bd08      	pop	{r3, pc}
 80100c4:	f3af 8000 	nop.w
 80100c8:	f3af 8000 	nop.w
 80100cc:	f3af 8000 	nop.w

080100d0 <sys3_execute>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 80100d0:	b500      	push	{lr}
 80100d2:	b083      	sub	sp, #12
  bool result;

  chSysLock();
 80100d4:	f7ff fedc 	bl	800fe90 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 80100d8:	2001      	movs	r0, #1
 80100da:	f7f0 fb31 	bl	8000740 <chSysIntegrityCheckI>
 80100de:	4603      	mov	r3, r0
 80100e0:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 80100e4:	f7ff fedc 	bl	800fea0 <chSysUnlock>
  test_assert(1, result == false, "ready list check failed");
 80100e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80100ec:	2b00      	cmp	r3, #0
 80100ee:	bf0c      	ite	eq
 80100f0:	2300      	moveq	r3, #0
 80100f2:	2301      	movne	r3, #1
 80100f4:	b2db      	uxtb	r3, r3
 80100f6:	f083 0301 	eor.w	r3, r3, #1
 80100fa:	b2db      	uxtb	r3, r3
 80100fc:	f003 0301 	and.w	r3, r3, #1
 8010100:	b2db      	uxtb	r3, r3
 8010102:	2001      	movs	r0, #1
 8010104:	4619      	mov	r1, r3
 8010106:	f7fb fea3 	bl	800be50 <_test_assert>
 801010a:	4603      	mov	r3, r0
 801010c:	2b00      	cmp	r3, #0
 801010e:	d000      	beq.n	8010112 <sys3_execute+0x42>
 8010110:	e05c      	b.n	80101cc <sys3_execute+0xfc>

  chSysLock();
 8010112:	f7ff febd 	bl	800fe90 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8010116:	2002      	movs	r0, #2
 8010118:	f7f0 fb12 	bl	8000740 <chSysIntegrityCheckI>
 801011c:	4603      	mov	r3, r0
 801011e:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 8010122:	f7ff febd 	bl	800fea0 <chSysUnlock>
  test_assert(2, result == false, "virtual timers list check failed");
 8010126:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801012a:	2b00      	cmp	r3, #0
 801012c:	bf0c      	ite	eq
 801012e:	2300      	moveq	r3, #0
 8010130:	2301      	movne	r3, #1
 8010132:	b2db      	uxtb	r3, r3
 8010134:	f083 0301 	eor.w	r3, r3, #1
 8010138:	b2db      	uxtb	r3, r3
 801013a:	f003 0301 	and.w	r3, r3, #1
 801013e:	b2db      	uxtb	r3, r3
 8010140:	2002      	movs	r0, #2
 8010142:	4619      	mov	r1, r3
 8010144:	f7fb fe84 	bl	800be50 <_test_assert>
 8010148:	4603      	mov	r3, r0
 801014a:	2b00      	cmp	r3, #0
 801014c:	d000      	beq.n	8010150 <sys3_execute+0x80>
 801014e:	e03d      	b.n	80101cc <sys3_execute+0xfc>

  chSysLock();
 8010150:	f7ff fe9e 	bl	800fe90 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8010154:	2004      	movs	r0, #4
 8010156:	f7f0 faf3 	bl	8000740 <chSysIntegrityCheckI>
 801015a:	4603      	mov	r3, r0
 801015c:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 8010160:	f7ff fe9e 	bl	800fea0 <chSysUnlock>
  test_assert(3, result == false, "registry list check failed");
 8010164:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8010168:	2b00      	cmp	r3, #0
 801016a:	bf0c      	ite	eq
 801016c:	2300      	moveq	r3, #0
 801016e:	2301      	movne	r3, #1
 8010170:	b2db      	uxtb	r3, r3
 8010172:	f083 0301 	eor.w	r3, r3, #1
 8010176:	b2db      	uxtb	r3, r3
 8010178:	f003 0301 	and.w	r3, r3, #1
 801017c:	b2db      	uxtb	r3, r3
 801017e:	2003      	movs	r0, #3
 8010180:	4619      	mov	r1, r3
 8010182:	f7fb fe65 	bl	800be50 <_test_assert>
 8010186:	4603      	mov	r3, r0
 8010188:	2b00      	cmp	r3, #0
 801018a:	d000      	beq.n	801018e <sys3_execute+0xbe>
 801018c:	e01e      	b.n	80101cc <sys3_execute+0xfc>

  chSysLock();
 801018e:	f7ff fe7f 	bl	800fe90 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8010192:	2008      	movs	r0, #8
 8010194:	f7f0 fad4 	bl	8000740 <chSysIntegrityCheckI>
 8010198:	4603      	mov	r3, r0
 801019a:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 801019e:	f7ff fe7f 	bl	800fea0 <chSysUnlock>
  test_assert(4, result == false, "port layer check failed");
 80101a2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80101a6:	2b00      	cmp	r3, #0
 80101a8:	bf0c      	ite	eq
 80101aa:	2300      	moveq	r3, #0
 80101ac:	2301      	movne	r3, #1
 80101ae:	b2db      	uxtb	r3, r3
 80101b0:	f083 0301 	eor.w	r3, r3, #1
 80101b4:	b2db      	uxtb	r3, r3
 80101b6:	f003 0301 	and.w	r3, r3, #1
 80101ba:	b2db      	uxtb	r3, r3
 80101bc:	2004      	movs	r0, #4
 80101be:	4619      	mov	r1, r3
 80101c0:	f7fb fe46 	bl	800be50 <_test_assert>
 80101c4:	4603      	mov	r3, r0
 80101c6:	2b00      	cmp	r3, #0
 80101c8:	d000      	beq.n	80101cc <sys3_execute+0xfc>
 80101ca:	bf00      	nop
}
 80101cc:	b003      	add	sp, #12
 80101ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80101d2:	bf00      	nop
 80101d4:	f3af 8000 	nop.w
 80101d8:	f3af 8000 	nop.w
 80101dc:	f3af 8000 	nop.w

080101e0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80101e0:	b082      	sub	sp, #8
 80101e2:	2320      	movs	r3, #32
 80101e4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80101e6:	9b01      	ldr	r3, [sp, #4]
 80101e8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80101ec:	b002      	add	sp, #8
 80101ee:	4770      	bx	lr

080101f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80101f0:	b082      	sub	sp, #8
 80101f2:	2300      	movs	r3, #0
 80101f4:	9301      	str	r3, [sp, #4]
 80101f6:	9b01      	ldr	r3, [sp, #4]
 80101f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80101fc:	b002      	add	sp, #8
 80101fe:	4770      	bx	lr

08010200 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8010200:	b508      	push	{r3, lr}

  port_lock();
 8010202:	f7ff ffed 	bl	80101e0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8010206:	bd08      	pop	{r3, pc}
 8010208:	f3af 8000 	nop.w
 801020c:	f3af 8000 	nop.w

08010210 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8010210:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8010212:	f7ff ffed 	bl	80101f0 <port_unlock>
}
 8010216:	bd08      	pop	{r3, pc}
 8010218:	f3af 8000 	nop.w
 801021c:	f3af 8000 	nop.w

08010220 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8010220:	4b01      	ldr	r3, [pc, #4]	; (8010228 <chThdGetSelfX+0x8>)
 8010222:	699b      	ldr	r3, [r3, #24]
}
 8010224:	4618      	mov	r0, r3
 8010226:	4770      	bx	lr
 8010228:	200039a8 	.word	0x200039a8
 801022c:	f3af 8000 	nop.w

08010230 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8010230:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8010232:	f7ff fff5 	bl	8010220 <chThdGetSelfX>
 8010236:	4603      	mov	r3, r0
 8010238:	689b      	ldr	r3, [r3, #8]
}
 801023a:	4618      	mov	r0, r3
 801023c:	bd08      	pop	{r3, pc}
 801023e:	bf00      	nop

08010240 <chThdShouldTerminateX>:
 * @retval true         termination request pending.
 * @retval false        termination request not pending.
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {
 8010240:	b508      	push	{r3, lr}

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8010242:	f7ff ffed 	bl	8010220 <chThdGetSelfX>
 8010246:	4603      	mov	r3, r0
 8010248:	7f5b      	ldrb	r3, [r3, #29]
 801024a:	f003 0304 	and.w	r3, r3, #4
 801024e:	2b00      	cmp	r3, #0
 8010250:	bf0c      	ite	eq
 8010252:	2300      	moveq	r3, #0
 8010254:	2301      	movne	r3, #1
 8010256:	b2db      	uxtb	r3, r3
}
 8010258:	4618      	mov	r0, r3
 801025a:	bd08      	pop	{r3, pc}
 801025c:	f3af 8000 	nop.w

08010260 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 8010260:	b082      	sub	sp, #8
 8010262:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 8010264:	9b01      	ldr	r3, [sp, #4]
 8010266:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 8010268:	4618      	mov	r0, r3
 801026a:	b002      	add	sp, #8
 801026c:	4770      	bx	lr
 801026e:	bf00      	nop

08010270 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 8010270:	b500      	push	{lr}
 8010272:	b083      	sub	sp, #12
 8010274:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8010276:	9801      	ldr	r0, [sp, #4]
 8010278:	f04f 31ff 	mov.w	r1, #4294967295
 801027c:	f7f3 f800 	bl	8003280 <chIQGetTimeout>
 8010280:	4603      	mov	r3, r0
}
 8010282:	4618      	mov	r0, r3
 8010284:	b003      	add	sp, #12
 8010286:	f85d fb04 	ldr.w	pc, [sp], #4
 801028a:	bf00      	nop
 801028c:	f3af 8000 	nop.w

08010290 <thread1>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {
 8010290:	b500      	push	{lr}
 8010292:	b083      	sub	sp, #12
 8010294:	9001      	str	r0, [sp, #4]

  chThdExit((msg_t)p);
 8010296:	9b01      	ldr	r3, [sp, #4]
 8010298:	4618      	mov	r0, r3
 801029a:	f7f1 f869 	bl	8001370 <chThdExit>
}
 801029e:	b003      	add	sp, #12
 80102a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80102a4:	f3af 8000 	nop.w
 80102a8:	f3af 8000 	nop.w
 80102ac:	f3af 8000 	nop.w

080102b0 <thread2>:

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 80102b0:	b500      	push	{lr}
 80102b2:	b085      	sub	sp, #20
 80102b4:	9001      	str	r0, [sp, #4]
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 80102b6:	f7f2 fca3 	bl	8002c00 <chMsgWait>
 80102ba:	9003      	str	r0, [sp, #12]
    msg = chMsgGet(tp);
 80102bc:	9803      	ldr	r0, [sp, #12]
 80102be:	f7ff ffcf 	bl	8010260 <chMsgGet>
 80102c2:	9002      	str	r0, [sp, #8]
    chMsgRelease(tp, msg);
 80102c4:	9803      	ldr	r0, [sp, #12]
 80102c6:	9902      	ldr	r1, [sp, #8]
 80102c8:	f7f2 fcc2 	bl	8002c50 <chMsgRelease>
  } while (msg);
 80102cc:	9b02      	ldr	r3, [sp, #8]
 80102ce:	2b00      	cmp	r3, #0
 80102d0:	d1f1      	bne.n	80102b6 <thread2+0x6>
}
 80102d2:	b005      	add	sp, #20
 80102d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80102d8:	f3af 8000 	nop.w
 80102dc:	f3af 8000 	nop.w

080102e0 <msg_loop_test>:

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 80102e0:	b500      	push	{lr}
 80102e2:	b085      	sub	sp, #20
 80102e4:	9001      	str	r0, [sp, #4]

  uint32_t n = 0;
 80102e6:	2300      	movs	r3, #0
 80102e8:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 80102ea:	f7fb fe59 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 80102ee:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80102f2:	f7fb fe75 	bl	800bfe0 <test_start_timer>
  do {
    (void)chMsgSend(tp, 1);
 80102f6:	9801      	ldr	r0, [sp, #4]
 80102f8:	2101      	movs	r1, #1
 80102fa:	f7f2 fc51 	bl	8002ba0 <chMsgSend>
    n++;
 80102fe:	9b03      	ldr	r3, [sp, #12]
 8010300:	3301      	adds	r3, #1
 8010302:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010304:	4b07      	ldr	r3, [pc, #28]	; (8010324 <msg_loop_test+0x44>)
 8010306:	781b      	ldrb	r3, [r3, #0]
 8010308:	f083 0301 	eor.w	r3, r3, #1
 801030c:	b2db      	uxtb	r3, r3
 801030e:	2b00      	cmp	r3, #0
 8010310:	d1f1      	bne.n	80102f6 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
 8010312:	9801      	ldr	r0, [sp, #4]
 8010314:	2100      	movs	r1, #0
 8010316:	f7f2 fc43 	bl	8002ba0 <chMsgSend>
  return n;
 801031a:	9b03      	ldr	r3, [sp, #12]
}
 801031c:	4618      	mov	r0, r3
 801031e:	b005      	add	sp, #20
 8010320:	f85d fb04 	ldr.w	pc, [sp], #4
 8010324:	20003e39 	.word	0x20003e39
 8010328:	f3af 8000 	nop.w
 801032c:	f3af 8000 	nop.w

08010330 <bmk1_execute>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8010330:	b510      	push	{r4, lr}
 8010332:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8010334:	4b16      	ldr	r3, [pc, #88]	; (8010390 <bmk1_execute+0x60>)
 8010336:	681c      	ldr	r4, [r3, #0]
 8010338:	f7ff ff7a 	bl	8010230 <chThdGetPriorityX>
 801033c:	4603      	mov	r3, r0
 801033e:	3b01      	subs	r3, #1
 8010340:	2200      	movs	r2, #0
 8010342:	9200      	str	r2, [sp, #0]
 8010344:	4620      	mov	r0, r4
 8010346:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801034a:	461a      	mov	r2, r3
 801034c:	4b11      	ldr	r3, [pc, #68]	; (8010394 <bmk1_execute+0x64>)
 801034e:	f7f0 ff47 	bl	80011e0 <chThdCreateStatic>
 8010352:	4602      	mov	r2, r0
 8010354:	4b10      	ldr	r3, [pc, #64]	; (8010398 <bmk1_execute+0x68>)
 8010356:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 8010358:	4b0f      	ldr	r3, [pc, #60]	; (8010398 <bmk1_execute+0x68>)
 801035a:	681b      	ldr	r3, [r3, #0]
 801035c:	4618      	mov	r0, r3
 801035e:	f7ff ffbf 	bl	80102e0 <msg_loop_test>
 8010362:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 8010364:	f7fb fdf4 	bl	800bf50 <test_wait_threads>
  test_print("--- Score : ");
 8010368:	480c      	ldr	r0, [pc, #48]	; (801039c <bmk1_execute+0x6c>)
 801036a:	f7fb fce1 	bl	800bd30 <test_print>
  test_printn(n);
 801036e:	9803      	ldr	r0, [sp, #12]
 8010370:	f7fb fc96 	bl	800bca0 <test_printn>
  test_print(" msgs/S, ");
 8010374:	480a      	ldr	r0, [pc, #40]	; (80103a0 <bmk1_execute+0x70>)
 8010376:	f7fb fcdb 	bl	800bd30 <test_print>
  test_printn(n << 1);
 801037a:	9b03      	ldr	r3, [sp, #12]
 801037c:	005b      	lsls	r3, r3, #1
 801037e:	4618      	mov	r0, r3
 8010380:	f7fb fc8e 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 8010384:	4807      	ldr	r0, [pc, #28]	; (80103a4 <bmk1_execute+0x74>)
 8010386:	f7fb fcf3 	bl	800bd70 <test_println>
}
 801038a:	b004      	add	sp, #16
 801038c:	bd10      	pop	{r4, pc}
 801038e:	bf00      	nop
 8010390:	0801ad70 	.word	0x0801ad70
 8010394:	080102b1 	.word	0x080102b1
 8010398:	20003e3c 	.word	0x20003e3c
 801039c:	0801b600 	.word	0x0801b600
 80103a0:	0801b610 	.word	0x0801b610
 80103a4:	0801b61c 	.word	0x0801b61c
 80103a8:	f3af 8000 	nop.w
 80103ac:	f3af 8000 	nop.w

080103b0 <bmk2_execute>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 80103b0:	b510      	push	{r4, lr}
 80103b2:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80103b4:	4b16      	ldr	r3, [pc, #88]	; (8010410 <bmk2_execute+0x60>)
 80103b6:	681c      	ldr	r4, [r3, #0]
 80103b8:	f7ff ff3a 	bl	8010230 <chThdGetPriorityX>
 80103bc:	4603      	mov	r3, r0
 80103be:	3301      	adds	r3, #1
 80103c0:	2200      	movs	r2, #0
 80103c2:	9200      	str	r2, [sp, #0]
 80103c4:	4620      	mov	r0, r4
 80103c6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80103ca:	461a      	mov	r2, r3
 80103cc:	4b11      	ldr	r3, [pc, #68]	; (8010414 <bmk2_execute+0x64>)
 80103ce:	f7f0 ff07 	bl	80011e0 <chThdCreateStatic>
 80103d2:	4602      	mov	r2, r0
 80103d4:	4b10      	ldr	r3, [pc, #64]	; (8010418 <bmk2_execute+0x68>)
 80103d6:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 80103d8:	4b0f      	ldr	r3, [pc, #60]	; (8010418 <bmk2_execute+0x68>)
 80103da:	681b      	ldr	r3, [r3, #0]
 80103dc:	4618      	mov	r0, r3
 80103de:	f7ff ff7f 	bl	80102e0 <msg_loop_test>
 80103e2:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 80103e4:	f7fb fdb4 	bl	800bf50 <test_wait_threads>
  test_print("--- Score : ");
 80103e8:	480c      	ldr	r0, [pc, #48]	; (801041c <bmk2_execute+0x6c>)
 80103ea:	f7fb fca1 	bl	800bd30 <test_print>
  test_printn(n);
 80103ee:	9803      	ldr	r0, [sp, #12]
 80103f0:	f7fb fc56 	bl	800bca0 <test_printn>
  test_print(" msgs/S, ");
 80103f4:	480a      	ldr	r0, [pc, #40]	; (8010420 <bmk2_execute+0x70>)
 80103f6:	f7fb fc9b 	bl	800bd30 <test_print>
  test_printn(n << 1);
 80103fa:	9b03      	ldr	r3, [sp, #12]
 80103fc:	005b      	lsls	r3, r3, #1
 80103fe:	4618      	mov	r0, r3
 8010400:	f7fb fc4e 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 8010404:	4807      	ldr	r0, [pc, #28]	; (8010424 <bmk2_execute+0x74>)
 8010406:	f7fb fcb3 	bl	800bd70 <test_println>
}
 801040a:	b004      	add	sp, #16
 801040c:	bd10      	pop	{r4, pc}
 801040e:	bf00      	nop
 8010410:	0801ad70 	.word	0x0801ad70
 8010414:	080102b1 	.word	0x080102b1
 8010418:	20003e3c 	.word	0x20003e3c
 801041c:	0801b600 	.word	0x0801b600
 8010420:	0801b610 	.word	0x0801b610
 8010424:	0801b61c 	.word	0x0801b61c
 8010428:	f3af 8000 	nop.w
 801042c:	f3af 8000 	nop.w

08010430 <bmk3_execute>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8010430:	b510      	push	{r4, lr}
 8010432:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8010434:	4b3a      	ldr	r3, [pc, #232]	; (8010520 <bmk3_execute+0xf0>)
 8010436:	681c      	ldr	r4, [r3, #0]
 8010438:	f7ff fefa 	bl	8010230 <chThdGetPriorityX>
 801043c:	4603      	mov	r3, r0
 801043e:	3301      	adds	r3, #1
 8010440:	2200      	movs	r2, #0
 8010442:	9200      	str	r2, [sp, #0]
 8010444:	4620      	mov	r0, r4
 8010446:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801044a:	461a      	mov	r2, r3
 801044c:	4b35      	ldr	r3, [pc, #212]	; (8010524 <bmk3_execute+0xf4>)
 801044e:	f7f0 fec7 	bl	80011e0 <chThdCreateStatic>
 8010452:	4602      	mov	r2, r0
 8010454:	4b34      	ldr	r3, [pc, #208]	; (8010528 <bmk3_execute+0xf8>)
 8010456:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8010458:	4b31      	ldr	r3, [pc, #196]	; (8010520 <bmk3_execute+0xf0>)
 801045a:	685c      	ldr	r4, [r3, #4]
 801045c:	f7ff fee8 	bl	8010230 <chThdGetPriorityX>
 8010460:	4603      	mov	r3, r0
 8010462:	3b02      	subs	r3, #2
 8010464:	2200      	movs	r2, #0
 8010466:	9200      	str	r2, [sp, #0]
 8010468:	4620      	mov	r0, r4
 801046a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801046e:	461a      	mov	r2, r3
 8010470:	4b2e      	ldr	r3, [pc, #184]	; (801052c <bmk3_execute+0xfc>)
 8010472:	f7f0 feb5 	bl	80011e0 <chThdCreateStatic>
 8010476:	4602      	mov	r2, r0
 8010478:	4b2b      	ldr	r3, [pc, #172]	; (8010528 <bmk3_execute+0xf8>)
 801047a:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 801047c:	4b28      	ldr	r3, [pc, #160]	; (8010520 <bmk3_execute+0xf0>)
 801047e:	689c      	ldr	r4, [r3, #8]
 8010480:	f7ff fed6 	bl	8010230 <chThdGetPriorityX>
 8010484:	4603      	mov	r3, r0
 8010486:	3b03      	subs	r3, #3
 8010488:	2200      	movs	r2, #0
 801048a:	9200      	str	r2, [sp, #0]
 801048c:	4620      	mov	r0, r4
 801048e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010492:	461a      	mov	r2, r3
 8010494:	4b25      	ldr	r3, [pc, #148]	; (801052c <bmk3_execute+0xfc>)
 8010496:	f7f0 fea3 	bl	80011e0 <chThdCreateStatic>
 801049a:	4602      	mov	r2, r0
 801049c:	4b22      	ldr	r3, [pc, #136]	; (8010528 <bmk3_execute+0xf8>)
 801049e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 80104a0:	4b1f      	ldr	r3, [pc, #124]	; (8010520 <bmk3_execute+0xf0>)
 80104a2:	68dc      	ldr	r4, [r3, #12]
 80104a4:	f7ff fec4 	bl	8010230 <chThdGetPriorityX>
 80104a8:	4603      	mov	r3, r0
 80104aa:	3b04      	subs	r3, #4
 80104ac:	2200      	movs	r2, #0
 80104ae:	9200      	str	r2, [sp, #0]
 80104b0:	4620      	mov	r0, r4
 80104b2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80104b6:	461a      	mov	r2, r3
 80104b8:	4b1c      	ldr	r3, [pc, #112]	; (801052c <bmk3_execute+0xfc>)
 80104ba:	f7f0 fe91 	bl	80011e0 <chThdCreateStatic>
 80104be:	4602      	mov	r2, r0
 80104c0:	4b19      	ldr	r3, [pc, #100]	; (8010528 <bmk3_execute+0xf8>)
 80104c2:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 80104c4:	4b16      	ldr	r3, [pc, #88]	; (8010520 <bmk3_execute+0xf0>)
 80104c6:	691c      	ldr	r4, [r3, #16]
 80104c8:	f7ff feb2 	bl	8010230 <chThdGetPriorityX>
 80104cc:	4603      	mov	r3, r0
 80104ce:	3b05      	subs	r3, #5
 80104d0:	2200      	movs	r2, #0
 80104d2:	9200      	str	r2, [sp, #0]
 80104d4:	4620      	mov	r0, r4
 80104d6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80104da:	461a      	mov	r2, r3
 80104dc:	4b13      	ldr	r3, [pc, #76]	; (801052c <bmk3_execute+0xfc>)
 80104de:	f7f0 fe7f 	bl	80011e0 <chThdCreateStatic>
 80104e2:	4602      	mov	r2, r0
 80104e4:	4b10      	ldr	r3, [pc, #64]	; (8010528 <bmk3_execute+0xf8>)
 80104e6:	611a      	str	r2, [r3, #16]
  n = msg_loop_test(threads[0]);
 80104e8:	4b0f      	ldr	r3, [pc, #60]	; (8010528 <bmk3_execute+0xf8>)
 80104ea:	681b      	ldr	r3, [r3, #0]
 80104ec:	4618      	mov	r0, r3
 80104ee:	f7ff fef7 	bl	80102e0 <msg_loop_test>
 80104f2:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 80104f4:	f7fb fd2c 	bl	800bf50 <test_wait_threads>
  test_print("--- Score : ");
 80104f8:	480d      	ldr	r0, [pc, #52]	; (8010530 <bmk3_execute+0x100>)
 80104fa:	f7fb fc19 	bl	800bd30 <test_print>
  test_printn(n);
 80104fe:	9803      	ldr	r0, [sp, #12]
 8010500:	f7fb fbce 	bl	800bca0 <test_printn>
  test_print(" msgs/S, ");
 8010504:	480b      	ldr	r0, [pc, #44]	; (8010534 <bmk3_execute+0x104>)
 8010506:	f7fb fc13 	bl	800bd30 <test_print>
  test_printn(n << 1);
 801050a:	9b03      	ldr	r3, [sp, #12]
 801050c:	005b      	lsls	r3, r3, #1
 801050e:	4618      	mov	r0, r3
 8010510:	f7fb fbc6 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 8010514:	4808      	ldr	r0, [pc, #32]	; (8010538 <bmk3_execute+0x108>)
 8010516:	f7fb fc2b 	bl	800bd70 <test_println>
}
 801051a:	b004      	add	sp, #16
 801051c:	bd10      	pop	{r4, pc}
 801051e:	bf00      	nop
 8010520:	0801ad70 	.word	0x0801ad70
 8010524:	080102b1 	.word	0x080102b1
 8010528:	20003e3c 	.word	0x20003e3c
 801052c:	08010291 	.word	0x08010291
 8010530:	0801b600 	.word	0x0801b600
 8010534:	0801b610 	.word	0x0801b610
 8010538:	0801b61c 	.word	0x0801b61c
 801053c:	f3af 8000 	nop.w

08010540 <thread4>:
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 8010540:	b500      	push	{lr}
 8010542:	b085      	sub	sp, #20
 8010544:	9001      	str	r0, [sp, #4]
  msg_t msg;
  thread_t *self = chThdGetSelfX();
 8010546:	f7ff fe6b 	bl	8010220 <chThdGetSelfX>
 801054a:	9003      	str	r0, [sp, #12]

  (void)p;
  chSysLock();
 801054c:	f7ff fe58 	bl	8010200 <chSysLock>
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8010550:	2003      	movs	r0, #3
 8010552:	f7f0 fb4d 	bl	8000bf0 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
 8010556:	9b03      	ldr	r3, [sp, #12]
 8010558:	6a1b      	ldr	r3, [r3, #32]
 801055a:	9302      	str	r3, [sp, #8]
  } while (msg == MSG_OK);
 801055c:	9b02      	ldr	r3, [sp, #8]
 801055e:	2b00      	cmp	r3, #0
 8010560:	d0f6      	beq.n	8010550 <thread4+0x10>
  chSysUnlock();
 8010562:	f7ff fe55 	bl	8010210 <chSysUnlock>
}
 8010566:	b005      	add	sp, #20
 8010568:	f85d fb04 	ldr.w	pc, [sp], #4
 801056c:	f3af 8000 	nop.w

08010570 <bmk4_execute>:

static void bmk4_execute(void) {
 8010570:	b510      	push	{r4, lr}
 8010572:	b084      	sub	sp, #16
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8010574:	4b29      	ldr	r3, [pc, #164]	; (801061c <bmk4_execute+0xac>)
 8010576:	681c      	ldr	r4, [r3, #0]
 8010578:	f7ff fe5a 	bl	8010230 <chThdGetPriorityX>
 801057c:	4603      	mov	r3, r0
 801057e:	3301      	adds	r3, #1
 8010580:	2200      	movs	r2, #0
 8010582:	9200      	str	r2, [sp, #0]
 8010584:	4620      	mov	r0, r4
 8010586:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801058a:	461a      	mov	r2, r3
 801058c:	4b24      	ldr	r3, [pc, #144]	; (8010620 <bmk4_execute+0xb0>)
 801058e:	f7f0 fe27 	bl	80011e0 <chThdCreateStatic>
 8010592:	4602      	mov	r2, r0
 8010594:	4b23      	ldr	r3, [pc, #140]	; (8010624 <bmk4_execute+0xb4>)
 8010596:	601a      	str	r2, [r3, #0]
 8010598:	4b22      	ldr	r3, [pc, #136]	; (8010624 <bmk4_execute+0xb4>)
 801059a:	681b      	ldr	r3, [r3, #0]
 801059c:	9302      	str	r3, [sp, #8]
                                      thread4, NULL);
  n = 0;
 801059e:	2300      	movs	r3, #0
 80105a0:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 80105a2:	f7fb fcfd 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 80105a6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80105aa:	f7fb fd19 	bl	800bfe0 <test_start_timer>
  do {
    chSysLock();
 80105ae:	f7ff fe27 	bl	8010200 <chSysLock>
    chSchWakeupS(tp, MSG_OK);
 80105b2:	9802      	ldr	r0, [sp, #8]
 80105b4:	2100      	movs	r1, #0
 80105b6:	f7f0 fbbb 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 80105ba:	9802      	ldr	r0, [sp, #8]
 80105bc:	2100      	movs	r1, #0
 80105be:	f7f0 fbb7 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 80105c2:	9802      	ldr	r0, [sp, #8]
 80105c4:	2100      	movs	r1, #0
 80105c6:	f7f0 fbb3 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 80105ca:	9802      	ldr	r0, [sp, #8]
 80105cc:	2100      	movs	r1, #0
 80105ce:	f7f0 fbaf 	bl	8000d30 <chSchWakeupS>
    chSysUnlock();
 80105d2:	f7ff fe1d 	bl	8010210 <chSysUnlock>
    n += 4;
 80105d6:	9b03      	ldr	r3, [sp, #12]
 80105d8:	3304      	adds	r3, #4
 80105da:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80105dc:	4b12      	ldr	r3, [pc, #72]	; (8010628 <bmk4_execute+0xb8>)
 80105de:	781b      	ldrb	r3, [r3, #0]
 80105e0:	f083 0301 	eor.w	r3, r3, #1
 80105e4:	b2db      	uxtb	r3, r3
 80105e6:	2b00      	cmp	r3, #0
 80105e8:	d1e1      	bne.n	80105ae <bmk4_execute+0x3e>
  chSysLock();
 80105ea:	f7ff fe09 	bl	8010200 <chSysLock>
  chSchWakeupS(tp, MSG_TIMEOUT);
 80105ee:	9802      	ldr	r0, [sp, #8]
 80105f0:	f04f 31ff 	mov.w	r1, #4294967295
 80105f4:	f7f0 fb9c 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 80105f8:	f7ff fe0a 	bl	8010210 <chSysUnlock>

  test_wait_threads();
 80105fc:	f7fb fca8 	bl	800bf50 <test_wait_threads>
  test_print("--- Score : ");
 8010600:	480a      	ldr	r0, [pc, #40]	; (801062c <bmk4_execute+0xbc>)
 8010602:	f7fb fb95 	bl	800bd30 <test_print>
  test_printn(n * 2);
 8010606:	9b03      	ldr	r3, [sp, #12]
 8010608:	005b      	lsls	r3, r3, #1
 801060a:	4618      	mov	r0, r3
 801060c:	f7fb fb48 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 8010610:	4807      	ldr	r0, [pc, #28]	; (8010630 <bmk4_execute+0xc0>)
 8010612:	f7fb fbad 	bl	800bd70 <test_println>
}
 8010616:	b004      	add	sp, #16
 8010618:	bd10      	pop	{r4, pc}
 801061a:	bf00      	nop
 801061c:	0801ad70 	.word	0x0801ad70
 8010620:	08010541 	.word	0x08010541
 8010624:	20003e3c 	.word	0x20003e3c
 8010628:	20003e39 	.word	0x20003e39
 801062c:	0801b600 	.word	0x0801b600
 8010630:	0801b61c 	.word	0x0801b61c
 8010634:	f3af 8000 	nop.w
 8010638:	f3af 8000 	nop.w
 801063c:	f3af 8000 	nop.w

08010640 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8010640:	b500      	push	{lr}
 8010642:	b087      	sub	sp, #28

  uint32_t n = 0;
 8010644:	2300      	movs	r3, #0
 8010646:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 8010648:	4b18      	ldr	r3, [pc, #96]	; (80106ac <bmk5_execute+0x6c>)
 801064a:	681b      	ldr	r3, [r3, #0]
 801064c:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() - 1;
 801064e:	f7ff fdef 	bl	8010230 <chThdGetPriorityX>
 8010652:	4603      	mov	r3, r0
 8010654:	3b01      	subs	r3, #1
 8010656:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8010658:	f7fb fca2 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 801065c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010660:	f7fb fcbe 	bl	800bfe0 <test_start_timer>
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8010664:	2300      	movs	r3, #0
 8010666:	9300      	str	r3, [sp, #0]
 8010668:	9804      	ldr	r0, [sp, #16]
 801066a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801066e:	9a03      	ldr	r2, [sp, #12]
 8010670:	4b0f      	ldr	r3, [pc, #60]	; (80106b0 <bmk5_execute+0x70>)
 8010672:	f7f0 fdb5 	bl	80011e0 <chThdCreateStatic>
 8010676:	4603      	mov	r3, r0
 8010678:	4618      	mov	r0, r3
 801067a:	f7f0 fec1 	bl	8001400 <chThdWait>
    n++;
 801067e:	9b05      	ldr	r3, [sp, #20]
 8010680:	3301      	adds	r3, #1
 8010682:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010684:	4b0b      	ldr	r3, [pc, #44]	; (80106b4 <bmk5_execute+0x74>)
 8010686:	781b      	ldrb	r3, [r3, #0]
 8010688:	f083 0301 	eor.w	r3, r3, #1
 801068c:	b2db      	uxtb	r3, r3
 801068e:	2b00      	cmp	r3, #0
 8010690:	d1e8      	bne.n	8010664 <bmk5_execute+0x24>
  test_print("--- Score : ");
 8010692:	4809      	ldr	r0, [pc, #36]	; (80106b8 <bmk5_execute+0x78>)
 8010694:	f7fb fb4c 	bl	800bd30 <test_print>
  test_printn(n);
 8010698:	9805      	ldr	r0, [sp, #20]
 801069a:	f7fb fb01 	bl	800bca0 <test_printn>
  test_println(" threads/S");
 801069e:	4807      	ldr	r0, [pc, #28]	; (80106bc <bmk5_execute+0x7c>)
 80106a0:	f7fb fb66 	bl	800bd70 <test_println>
}
 80106a4:	b007      	add	sp, #28
 80106a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80106aa:	bf00      	nop
 80106ac:	0801ad70 	.word	0x0801ad70
 80106b0:	08010291 	.word	0x08010291
 80106b4:	20003e39 	.word	0x20003e39
 80106b8:	0801b600 	.word	0x0801b600
 80106bc:	0801b6cc 	.word	0x0801b6cc

080106c0 <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 80106c0:	b500      	push	{lr}
 80106c2:	b087      	sub	sp, #28

  uint32_t n = 0;
 80106c4:	2300      	movs	r3, #0
 80106c6:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 80106c8:	4b16      	ldr	r3, [pc, #88]	; (8010724 <bmk6_execute+0x64>)
 80106ca:	681b      	ldr	r3, [r3, #0]
 80106cc:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() + 1;
 80106ce:	f7ff fdaf 	bl	8010230 <chThdGetPriorityX>
 80106d2:	4603      	mov	r3, r0
 80106d4:	3301      	adds	r3, #1
 80106d6:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 80106d8:	f7fb fc62 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 80106dc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80106e0:	f7fb fc7e 	bl	800bfe0 <test_start_timer>
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 80106e4:	2300      	movs	r3, #0
 80106e6:	9300      	str	r3, [sp, #0]
 80106e8:	9804      	ldr	r0, [sp, #16]
 80106ea:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80106ee:	9a03      	ldr	r2, [sp, #12]
 80106f0:	4b0d      	ldr	r3, [pc, #52]	; (8010728 <bmk6_execute+0x68>)
 80106f2:	f7f0 fd75 	bl	80011e0 <chThdCreateStatic>
    n++;
 80106f6:	9b05      	ldr	r3, [sp, #20]
 80106f8:	3301      	adds	r3, #1
 80106fa:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80106fc:	4b0b      	ldr	r3, [pc, #44]	; (801072c <bmk6_execute+0x6c>)
 80106fe:	781b      	ldrb	r3, [r3, #0]
 8010700:	f083 0301 	eor.w	r3, r3, #1
 8010704:	b2db      	uxtb	r3, r3
 8010706:	2b00      	cmp	r3, #0
 8010708:	d1ec      	bne.n	80106e4 <bmk6_execute+0x24>
  test_print("--- Score : ");
 801070a:	4809      	ldr	r0, [pc, #36]	; (8010730 <bmk6_execute+0x70>)
 801070c:	f7fb fb10 	bl	800bd30 <test_print>
  test_printn(n);
 8010710:	9805      	ldr	r0, [sp, #20]
 8010712:	f7fb fac5 	bl	800bca0 <test_printn>
  test_println(" threads/S");
 8010716:	4807      	ldr	r0, [pc, #28]	; (8010734 <bmk6_execute+0x74>)
 8010718:	f7fb fb2a 	bl	800bd70 <test_println>
}
 801071c:	b007      	add	sp, #28
 801071e:	f85d fb04 	ldr.w	pc, [sp], #4
 8010722:	bf00      	nop
 8010724:	0801ad70 	.word	0x0801ad70
 8010728:	08010291 	.word	0x08010291
 801072c:	20003e39 	.word	0x20003e39
 8010730:	0801b600 	.word	0x0801b600
 8010734:	0801b6cc 	.word	0x0801b6cc
 8010738:	f3af 8000 	nop.w
 801073c:	f3af 8000 	nop.w

08010740 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 8010740:	b500      	push	{lr}
 8010742:	b083      	sub	sp, #12
 8010744:	9001      	str	r0, [sp, #4]

  (void)p;
  while (!chThdShouldTerminateX())
 8010746:	e002      	b.n	801074e <thread3+0xe>
    chSemWait(&sem1);
 8010748:	4806      	ldr	r0, [pc, #24]	; (8010764 <thread3+0x24>)
 801074a:	f7f1 fa01 	bl	8001b50 <chSemWait>
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 801074e:	f7ff fd77 	bl	8010240 <chThdShouldTerminateX>
 8010752:	4603      	mov	r3, r0
 8010754:	f083 0301 	eor.w	r3, r3, #1
 8010758:	b2db      	uxtb	r3, r3
 801075a:	2b00      	cmp	r3, #0
 801075c:	d1f4      	bne.n	8010748 <thread3+0x8>
    chSemWait(&sem1);
}
 801075e:	b003      	add	sp, #12
 8010760:	f85d fb04 	ldr.w	pc, [sp], #4
 8010764:	200014f0 	.word	0x200014f0
 8010768:	f3af 8000 	nop.w
 801076c:	f3af 8000 	nop.w

08010770 <bmk7_setup>:

static void bmk7_setup(void) {
 8010770:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 8010772:	4802      	ldr	r0, [pc, #8]	; (801077c <bmk7_setup+0xc>)
 8010774:	2100      	movs	r1, #0
 8010776:	f7f1 f9a3 	bl	8001ac0 <chSemObjectInit>
}
 801077a:	bd08      	pop	{r3, pc}
 801077c:	200014f0 	.word	0x200014f0

08010780 <bmk7_execute>:

static void bmk7_execute(void) {
 8010780:	b510      	push	{r4, lr}
 8010782:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8010784:	4b46      	ldr	r3, [pc, #280]	; (80108a0 <bmk7_execute+0x120>)
 8010786:	681c      	ldr	r4, [r3, #0]
 8010788:	f7ff fd52 	bl	8010230 <chThdGetPriorityX>
 801078c:	4603      	mov	r3, r0
 801078e:	3305      	adds	r3, #5
 8010790:	2200      	movs	r2, #0
 8010792:	9200      	str	r2, [sp, #0]
 8010794:	4620      	mov	r0, r4
 8010796:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801079a:	461a      	mov	r2, r3
 801079c:	4b41      	ldr	r3, [pc, #260]	; (80108a4 <bmk7_execute+0x124>)
 801079e:	f7f0 fd1f 	bl	80011e0 <chThdCreateStatic>
 80107a2:	4602      	mov	r2, r0
 80107a4:	4b40      	ldr	r3, [pc, #256]	; (80108a8 <bmk7_execute+0x128>)
 80107a6:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 80107a8:	4b3d      	ldr	r3, [pc, #244]	; (80108a0 <bmk7_execute+0x120>)
 80107aa:	685c      	ldr	r4, [r3, #4]
 80107ac:	f7ff fd40 	bl	8010230 <chThdGetPriorityX>
 80107b0:	4603      	mov	r3, r0
 80107b2:	3304      	adds	r3, #4
 80107b4:	2200      	movs	r2, #0
 80107b6:	9200      	str	r2, [sp, #0]
 80107b8:	4620      	mov	r0, r4
 80107ba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80107be:	461a      	mov	r2, r3
 80107c0:	4b38      	ldr	r3, [pc, #224]	; (80108a4 <bmk7_execute+0x124>)
 80107c2:	f7f0 fd0d 	bl	80011e0 <chThdCreateStatic>
 80107c6:	4602      	mov	r2, r0
 80107c8:	4b37      	ldr	r3, [pc, #220]	; (80108a8 <bmk7_execute+0x128>)
 80107ca:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 80107cc:	4b34      	ldr	r3, [pc, #208]	; (80108a0 <bmk7_execute+0x120>)
 80107ce:	689c      	ldr	r4, [r3, #8]
 80107d0:	f7ff fd2e 	bl	8010230 <chThdGetPriorityX>
 80107d4:	4603      	mov	r3, r0
 80107d6:	3303      	adds	r3, #3
 80107d8:	2200      	movs	r2, #0
 80107da:	9200      	str	r2, [sp, #0]
 80107dc:	4620      	mov	r0, r4
 80107de:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80107e2:	461a      	mov	r2, r3
 80107e4:	4b2f      	ldr	r3, [pc, #188]	; (80108a4 <bmk7_execute+0x124>)
 80107e6:	f7f0 fcfb 	bl	80011e0 <chThdCreateStatic>
 80107ea:	4602      	mov	r2, r0
 80107ec:	4b2e      	ldr	r3, [pc, #184]	; (80108a8 <bmk7_execute+0x128>)
 80107ee:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 80107f0:	4b2b      	ldr	r3, [pc, #172]	; (80108a0 <bmk7_execute+0x120>)
 80107f2:	68dc      	ldr	r4, [r3, #12]
 80107f4:	f7ff fd1c 	bl	8010230 <chThdGetPriorityX>
 80107f8:	4603      	mov	r3, r0
 80107fa:	3302      	adds	r3, #2
 80107fc:	2200      	movs	r2, #0
 80107fe:	9200      	str	r2, [sp, #0]
 8010800:	4620      	mov	r0, r4
 8010802:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010806:	461a      	mov	r2, r3
 8010808:	4b26      	ldr	r3, [pc, #152]	; (80108a4 <bmk7_execute+0x124>)
 801080a:	f7f0 fce9 	bl	80011e0 <chThdCreateStatic>
 801080e:	4602      	mov	r2, r0
 8010810:	4b25      	ldr	r3, [pc, #148]	; (80108a8 <bmk7_execute+0x128>)
 8010812:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8010814:	4b22      	ldr	r3, [pc, #136]	; (80108a0 <bmk7_execute+0x120>)
 8010816:	691c      	ldr	r4, [r3, #16]
 8010818:	f7ff fd0a 	bl	8010230 <chThdGetPriorityX>
 801081c:	4603      	mov	r3, r0
 801081e:	3301      	adds	r3, #1
 8010820:	2200      	movs	r2, #0
 8010822:	9200      	str	r2, [sp, #0]
 8010824:	4620      	mov	r0, r4
 8010826:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801082a:	461a      	mov	r2, r3
 801082c:	4b1d      	ldr	r3, [pc, #116]	; (80108a4 <bmk7_execute+0x124>)
 801082e:	f7f0 fcd7 	bl	80011e0 <chThdCreateStatic>
 8010832:	4602      	mov	r2, r0
 8010834:	4b1c      	ldr	r3, [pc, #112]	; (80108a8 <bmk7_execute+0x128>)
 8010836:	611a      	str	r2, [r3, #16]

  n = 0;
 8010838:	2300      	movs	r3, #0
 801083a:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 801083c:	f7fb fbb0 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010840:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010844:	f7fb fbcc 	bl	800bfe0 <test_start_timer>
  do {
    chSemReset(&sem1, 0);
 8010848:	4818      	ldr	r0, [pc, #96]	; (80108ac <bmk7_execute+0x12c>)
 801084a:	2100      	movs	r1, #0
 801084c:	f7f1 f948 	bl	8001ae0 <chSemReset>
    n++;
 8010850:	9b03      	ldr	r3, [sp, #12]
 8010852:	3301      	adds	r3, #1
 8010854:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010856:	4b16      	ldr	r3, [pc, #88]	; (80108b0 <bmk7_execute+0x130>)
 8010858:	781b      	ldrb	r3, [r3, #0]
 801085a:	f083 0301 	eor.w	r3, r3, #1
 801085e:	b2db      	uxtb	r3, r3
 8010860:	2b00      	cmp	r3, #0
 8010862:	d1f1      	bne.n	8010848 <bmk7_execute+0xc8>
  test_terminate_threads();
 8010864:	f7fb fb54 	bl	800bf10 <test_terminate_threads>
  chSemReset(&sem1, 0);
 8010868:	4810      	ldr	r0, [pc, #64]	; (80108ac <bmk7_execute+0x12c>)
 801086a:	2100      	movs	r1, #0
 801086c:	f7f1 f938 	bl	8001ae0 <chSemReset>
  test_wait_threads();
 8010870:	f7fb fb6e 	bl	800bf50 <test_wait_threads>

  test_print("--- Score : ");
 8010874:	480f      	ldr	r0, [pc, #60]	; (80108b4 <bmk7_execute+0x134>)
 8010876:	f7fb fa5b 	bl	800bd30 <test_print>
  test_printn(n);
 801087a:	9803      	ldr	r0, [sp, #12]
 801087c:	f7fb fa10 	bl	800bca0 <test_printn>
  test_print(" reschedules/S, ");
 8010880:	480d      	ldr	r0, [pc, #52]	; (80108b8 <bmk7_execute+0x138>)
 8010882:	f7fb fa55 	bl	800bd30 <test_print>
  test_printn(n * 6);
 8010886:	9a03      	ldr	r2, [sp, #12]
 8010888:	4613      	mov	r3, r2
 801088a:	005b      	lsls	r3, r3, #1
 801088c:	4413      	add	r3, r2
 801088e:	005b      	lsls	r3, r3, #1
 8010890:	4618      	mov	r0, r3
 8010892:	f7fb fa05 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 8010896:	4809      	ldr	r0, [pc, #36]	; (80108bc <bmk7_execute+0x13c>)
 8010898:	f7fb fa6a 	bl	800bd70 <test_println>
}
 801089c:	b004      	add	sp, #16
 801089e:	bd10      	pop	{r4, pc}
 80108a0:	0801ad70 	.word	0x0801ad70
 80108a4:	08010741 	.word	0x08010741
 80108a8:	20003e3c 	.word	0x20003e3c
 80108ac:	200014f0 	.word	0x200014f0
 80108b0:	20003e39 	.word	0x20003e39
 80108b4:	0801b600 	.word	0x0801b600
 80108b8:	0801b738 	.word	0x0801b738
 80108bc:	0801b61c 	.word	0x0801b61c

080108c0 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 80108c0:	b500      	push	{lr}
 80108c2:	b083      	sub	sp, #12
 80108c4:	9001      	str	r0, [sp, #4]

  do {
    chThdYield();
 80108c6:	f7f0 fd4b 	bl	8001360 <chThdYield>
    chThdYield();
 80108ca:	f7f0 fd49 	bl	8001360 <chThdYield>
    chThdYield();
 80108ce:	f7f0 fd47 	bl	8001360 <chThdYield>
    chThdYield();
 80108d2:	f7f0 fd45 	bl	8001360 <chThdYield>
    (*(uint32_t *)p) += 4;
 80108d6:	9b01      	ldr	r3, [sp, #4]
 80108d8:	681b      	ldr	r3, [r3, #0]
 80108da:	1d1a      	adds	r2, r3, #4
 80108dc:	9b01      	ldr	r3, [sp, #4]
 80108de:	601a      	str	r2, [r3, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 80108e0:	f7ff fcae 	bl	8010240 <chThdShouldTerminateX>
 80108e4:	4603      	mov	r3, r0
 80108e6:	f083 0301 	eor.w	r3, r3, #1
 80108ea:	b2db      	uxtb	r3, r3
 80108ec:	2b00      	cmp	r3, #0
 80108ee:	d1ea      	bne.n	80108c6 <thread8+0x6>
}
 80108f0:	b003      	add	sp, #12
 80108f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80108f6:	bf00      	nop
 80108f8:	f3af 8000 	nop.w
 80108fc:	f3af 8000 	nop.w

08010900 <bmk8_execute>:

static void bmk8_execute(void) {
 8010900:	b510      	push	{r4, lr}
 8010902:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 8010904:	2300      	movs	r3, #0
 8010906:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8010908:	f7fb fb4a 	bl	800bfa0 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 801090c:	4b36      	ldr	r3, [pc, #216]	; (80109e8 <bmk8_execute+0xe8>)
 801090e:	681c      	ldr	r4, [r3, #0]
 8010910:	f7ff fc8e 	bl	8010230 <chThdGetPriorityX>
 8010914:	4603      	mov	r3, r0
 8010916:	3b01      	subs	r3, #1
 8010918:	aa03      	add	r2, sp, #12
 801091a:	9200      	str	r2, [sp, #0]
 801091c:	4620      	mov	r0, r4
 801091e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010922:	461a      	mov	r2, r3
 8010924:	4b31      	ldr	r3, [pc, #196]	; (80109ec <bmk8_execute+0xec>)
 8010926:	f7f0 fc5b 	bl	80011e0 <chThdCreateStatic>
 801092a:	4602      	mov	r2, r0
 801092c:	4b30      	ldr	r3, [pc, #192]	; (80109f0 <bmk8_execute+0xf0>)
 801092e:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8010930:	4b2d      	ldr	r3, [pc, #180]	; (80109e8 <bmk8_execute+0xe8>)
 8010932:	685c      	ldr	r4, [r3, #4]
 8010934:	f7ff fc7c 	bl	8010230 <chThdGetPriorityX>
 8010938:	4603      	mov	r3, r0
 801093a:	3b01      	subs	r3, #1
 801093c:	aa03      	add	r2, sp, #12
 801093e:	9200      	str	r2, [sp, #0]
 8010940:	4620      	mov	r0, r4
 8010942:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010946:	461a      	mov	r2, r3
 8010948:	4b28      	ldr	r3, [pc, #160]	; (80109ec <bmk8_execute+0xec>)
 801094a:	f7f0 fc49 	bl	80011e0 <chThdCreateStatic>
 801094e:	4602      	mov	r2, r0
 8010950:	4b27      	ldr	r3, [pc, #156]	; (80109f0 <bmk8_execute+0xf0>)
 8010952:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8010954:	4b24      	ldr	r3, [pc, #144]	; (80109e8 <bmk8_execute+0xe8>)
 8010956:	689c      	ldr	r4, [r3, #8]
 8010958:	f7ff fc6a 	bl	8010230 <chThdGetPriorityX>
 801095c:	4603      	mov	r3, r0
 801095e:	3b01      	subs	r3, #1
 8010960:	aa03      	add	r2, sp, #12
 8010962:	9200      	str	r2, [sp, #0]
 8010964:	4620      	mov	r0, r4
 8010966:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801096a:	461a      	mov	r2, r3
 801096c:	4b1f      	ldr	r3, [pc, #124]	; (80109ec <bmk8_execute+0xec>)
 801096e:	f7f0 fc37 	bl	80011e0 <chThdCreateStatic>
 8010972:	4602      	mov	r2, r0
 8010974:	4b1e      	ldr	r3, [pc, #120]	; (80109f0 <bmk8_execute+0xf0>)
 8010976:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8010978:	4b1b      	ldr	r3, [pc, #108]	; (80109e8 <bmk8_execute+0xe8>)
 801097a:	68dc      	ldr	r4, [r3, #12]
 801097c:	f7ff fc58 	bl	8010230 <chThdGetPriorityX>
 8010980:	4603      	mov	r3, r0
 8010982:	3b01      	subs	r3, #1
 8010984:	aa03      	add	r2, sp, #12
 8010986:	9200      	str	r2, [sp, #0]
 8010988:	4620      	mov	r0, r4
 801098a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801098e:	461a      	mov	r2, r3
 8010990:	4b16      	ldr	r3, [pc, #88]	; (80109ec <bmk8_execute+0xec>)
 8010992:	f7f0 fc25 	bl	80011e0 <chThdCreateStatic>
 8010996:	4602      	mov	r2, r0
 8010998:	4b15      	ldr	r3, [pc, #84]	; (80109f0 <bmk8_execute+0xf0>)
 801099a:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 801099c:	4b12      	ldr	r3, [pc, #72]	; (80109e8 <bmk8_execute+0xe8>)
 801099e:	691c      	ldr	r4, [r3, #16]
 80109a0:	f7ff fc46 	bl	8010230 <chThdGetPriorityX>
 80109a4:	4603      	mov	r3, r0
 80109a6:	3b01      	subs	r3, #1
 80109a8:	aa03      	add	r2, sp, #12
 80109aa:	9200      	str	r2, [sp, #0]
 80109ac:	4620      	mov	r0, r4
 80109ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80109b2:	461a      	mov	r2, r3
 80109b4:	4b0d      	ldr	r3, [pc, #52]	; (80109ec <bmk8_execute+0xec>)
 80109b6:	f7f0 fc13 	bl	80011e0 <chThdCreateStatic>
 80109ba:	4602      	mov	r2, r0
 80109bc:	4b0c      	ldr	r3, [pc, #48]	; (80109f0 <bmk8_execute+0xf0>)
 80109be:	611a      	str	r2, [r3, #16]

  chThdSleepSeconds(1);
 80109c0:	480c      	ldr	r0, [pc, #48]	; (80109f4 <bmk8_execute+0xf4>)
 80109c2:	f7f0 fc85 	bl	80012d0 <chThdSleep>
  test_terminate_threads();
 80109c6:	f7fb faa3 	bl	800bf10 <test_terminate_threads>
  test_wait_threads();
 80109ca:	f7fb fac1 	bl	800bf50 <test_wait_threads>

  test_print("--- Score : ");
 80109ce:	480a      	ldr	r0, [pc, #40]	; (80109f8 <bmk8_execute+0xf8>)
 80109d0:	f7fb f9ae 	bl	800bd30 <test_print>
  test_printn(n);
 80109d4:	9b03      	ldr	r3, [sp, #12]
 80109d6:	4618      	mov	r0, r3
 80109d8:	f7fb f962 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 80109dc:	4807      	ldr	r0, [pc, #28]	; (80109fc <bmk8_execute+0xfc>)
 80109de:	f7fb f9c7 	bl	800bd70 <test_println>
}
 80109e2:	b004      	add	sp, #16
 80109e4:	bd10      	pop	{r4, pc}
 80109e6:	bf00      	nop
 80109e8:	0801ad70 	.word	0x0801ad70
 80109ec:	080108c1 	.word	0x080108c1
 80109f0:	20003e3c 	.word	0x20003e3c
 80109f4:	000186a0 	.word	0x000186a0
 80109f8:	0801b600 	.word	0x0801b600
 80109fc:	0801b61c 	.word	0x0801b61c

08010a00 <bmk9_execute>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8010a00:	b500      	push	{lr}
 8010a02:	b085      	sub	sp, #20
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 8010a04:	2300      	movs	r3, #0
 8010a06:	9300      	str	r3, [sp, #0]
 8010a08:	4822      	ldr	r0, [pc, #136]	; (8010a94 <bmk9_execute+0x94>)
 8010a0a:	4923      	ldr	r1, [pc, #140]	; (8010a98 <bmk9_execute+0x98>)
 8010a0c:	2210      	movs	r2, #16
 8010a0e:	2300      	movs	r3, #0
 8010a10:	f7f2 fbc6 	bl	80031a0 <chIQObjectInit>
  n = 0;
 8010a14:	2300      	movs	r3, #0
 8010a16:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8010a18:	f7fb fac2 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010a1c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010a20:	f7fb fade 	bl	800bfe0 <test_start_timer>
  do {
    chSysLock();
 8010a24:	f7ff fbec 	bl	8010200 <chSysLock>
    chIQPutI(&iq, 0);
 8010a28:	481a      	ldr	r0, [pc, #104]	; (8010a94 <bmk9_execute+0x94>)
 8010a2a:	2100      	movs	r1, #0
 8010a2c:	f7f2 fbf8 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 1);
 8010a30:	4818      	ldr	r0, [pc, #96]	; (8010a94 <bmk9_execute+0x94>)
 8010a32:	2101      	movs	r1, #1
 8010a34:	f7f2 fbf4 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 2);
 8010a38:	4816      	ldr	r0, [pc, #88]	; (8010a94 <bmk9_execute+0x94>)
 8010a3a:	2102      	movs	r1, #2
 8010a3c:	f7f2 fbf0 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 3);
 8010a40:	4814      	ldr	r0, [pc, #80]	; (8010a94 <bmk9_execute+0x94>)
 8010a42:	2103      	movs	r1, #3
 8010a44:	f7f2 fbec 	bl	8003220 <chIQPutI>
    chSysUnlock();
 8010a48:	f7ff fbe2 	bl	8010210 <chSysUnlock>
    (void)chIQGet(&iq);
 8010a4c:	4811      	ldr	r0, [pc, #68]	; (8010a94 <bmk9_execute+0x94>)
 8010a4e:	f7ff fc0f 	bl	8010270 <chIQGet>
    (void)chIQGet(&iq);
 8010a52:	4810      	ldr	r0, [pc, #64]	; (8010a94 <bmk9_execute+0x94>)
 8010a54:	f7ff fc0c 	bl	8010270 <chIQGet>
    (void)chIQGet(&iq);
 8010a58:	480e      	ldr	r0, [pc, #56]	; (8010a94 <bmk9_execute+0x94>)
 8010a5a:	f7ff fc09 	bl	8010270 <chIQGet>
    (void)chIQGet(&iq);
 8010a5e:	480d      	ldr	r0, [pc, #52]	; (8010a94 <bmk9_execute+0x94>)
 8010a60:	f7ff fc06 	bl	8010270 <chIQGet>
    n++;
 8010a64:	9b03      	ldr	r3, [sp, #12]
 8010a66:	3301      	adds	r3, #1
 8010a68:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010a6a:	4b0c      	ldr	r3, [pc, #48]	; (8010a9c <bmk9_execute+0x9c>)
 8010a6c:	781b      	ldrb	r3, [r3, #0]
 8010a6e:	f083 0301 	eor.w	r3, r3, #1
 8010a72:	b2db      	uxtb	r3, r3
 8010a74:	2b00      	cmp	r3, #0
 8010a76:	d1d5      	bne.n	8010a24 <bmk9_execute+0x24>
  test_print("--- Score : ");
 8010a78:	4809      	ldr	r0, [pc, #36]	; (8010aa0 <bmk9_execute+0xa0>)
 8010a7a:	f7fb f959 	bl	800bd30 <test_print>
  test_printn(n * 4);
 8010a7e:	9b03      	ldr	r3, [sp, #12]
 8010a80:	009b      	lsls	r3, r3, #2
 8010a82:	4618      	mov	r0, r3
 8010a84:	f7fb f90c 	bl	800bca0 <test_printn>
  test_println(" bytes/S");
 8010a88:	4806      	ldr	r0, [pc, #24]	; (8010aa4 <bmk9_execute+0xa4>)
 8010a8a:	f7fb f971 	bl	800bd70 <test_println>
}
 8010a8e:	b005      	add	sp, #20
 8010a90:	f85d fb04 	ldr.w	pc, [sp], #4
 8010a94:	2000150c 	.word	0x2000150c
 8010a98:	20001530 	.word	0x20001530
 8010a9c:	20003e39 	.word	0x20003e39
 8010aa0:	0801b600 	.word	0x0801b600
 8010aa4:	0801b7c0 	.word	0x0801b7c0
 8010aa8:	f3af 8000 	nop.w
 8010aac:	f3af 8000 	nop.w

08010ab0 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 8010ab0:	b082      	sub	sp, #8
 8010ab2:	9001      	str	r0, [sp, #4]
 8010ab4:	b002      	add	sp, #8
 8010ab6:	4770      	bx	lr
 8010ab8:	f3af 8000 	nop.w
 8010abc:	f3af 8000 	nop.w

08010ac0 <bmk10_execute>:

static void bmk10_execute(void) {
 8010ac0:	b500      	push	{lr}
 8010ac2:	b083      	sub	sp, #12
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 8010ac4:	2300      	movs	r3, #0
 8010ac6:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010ac8:	f7fb fa6a 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010acc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010ad0:	f7fb fa86 	bl	800bfe0 <test_start_timer>
  do {
    chSysLock();
 8010ad4:	f7ff fb94 	bl	8010200 <chSysLock>
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8010ad8:	4816      	ldr	r0, [pc, #88]	; (8010b34 <bmk10_execute+0x74>)
 8010ada:	2101      	movs	r1, #1
 8010adc:	4a16      	ldr	r2, [pc, #88]	; (8010b38 <bmk10_execute+0x78>)
 8010ade:	2300      	movs	r3, #0
 8010ae0:	f7ef ff56 	bl	8000990 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8010ae4:	4815      	ldr	r0, [pc, #84]	; (8010b3c <bmk10_execute+0x7c>)
 8010ae6:	f242 7110 	movw	r1, #10000	; 0x2710
 8010aea:	4a13      	ldr	r2, [pc, #76]	; (8010b38 <bmk10_execute+0x78>)
 8010aec:	2300      	movs	r3, #0
 8010aee:	f7ef ff4f 	bl	8000990 <chVTDoSetI>
    chVTDoResetI(&vt1);
 8010af2:	4810      	ldr	r0, [pc, #64]	; (8010b34 <bmk10_execute+0x74>)
 8010af4:	f7ef ff8c 	bl	8000a10 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8010af8:	4810      	ldr	r0, [pc, #64]	; (8010b3c <bmk10_execute+0x7c>)
 8010afa:	f7ef ff89 	bl	8000a10 <chVTDoResetI>
    chSysUnlock();
 8010afe:	f7ff fb87 	bl	8010210 <chSysUnlock>
    n++;
 8010b02:	9b01      	ldr	r3, [sp, #4]
 8010b04:	3301      	adds	r3, #1
 8010b06:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010b08:	4b0d      	ldr	r3, [pc, #52]	; (8010b40 <bmk10_execute+0x80>)
 8010b0a:	781b      	ldrb	r3, [r3, #0]
 8010b0c:	f083 0301 	eor.w	r3, r3, #1
 8010b10:	b2db      	uxtb	r3, r3
 8010b12:	2b00      	cmp	r3, #0
 8010b14:	d1de      	bne.n	8010ad4 <bmk10_execute+0x14>
  test_print("--- Score : ");
 8010b16:	480b      	ldr	r0, [pc, #44]	; (8010b44 <bmk10_execute+0x84>)
 8010b18:	f7fb f90a 	bl	800bd30 <test_print>
  test_printn(n * 2);
 8010b1c:	9b01      	ldr	r3, [sp, #4]
 8010b1e:	005b      	lsls	r3, r3, #1
 8010b20:	4618      	mov	r0, r3
 8010b22:	f7fb f8bd 	bl	800bca0 <test_printn>
  test_println(" timers/S");
 8010b26:	4808      	ldr	r0, [pc, #32]	; (8010b48 <bmk10_execute+0x88>)
 8010b28:	f7fb f922 	bl	800bd70 <test_println>
}
 8010b2c:	b003      	add	sp, #12
 8010b2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8010b32:	bf00      	nop
 8010b34:	20001540 	.word	0x20001540
 8010b38:	08010ab1 	.word	0x08010ab1
 8010b3c:	20001554 	.word	0x20001554
 8010b40:	20003e39 	.word	0x20003e39
 8010b44:	0801b600 	.word	0x0801b600
 8010b48:	0801b800 	.word	0x0801b800
 8010b4c:	f3af 8000 	nop.w

08010b50 <bmk11_setup>:
 * Switch happens because the counter is always non negative.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk11_setup(void) {
 8010b50:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 1);
 8010b52:	4802      	ldr	r0, [pc, #8]	; (8010b5c <bmk11_setup+0xc>)
 8010b54:	2101      	movs	r1, #1
 8010b56:	f7f0 ffb3 	bl	8001ac0 <chSemObjectInit>
}
 8010b5a:	bd08      	pop	{r3, pc}
 8010b5c:	200014f0 	.word	0x200014f0

08010b60 <bmk11_execute>:

static void bmk11_execute(void) {
 8010b60:	b500      	push	{lr}
 8010b62:	b083      	sub	sp, #12
  uint32_t n = 0;
 8010b64:	2300      	movs	r3, #0
 8010b66:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010b68:	f7fb fa1a 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010b6c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010b70:	f7fb fa36 	bl	800bfe0 <test_start_timer>
  do {
    chSemWait(&sem1);
 8010b74:	4817      	ldr	r0, [pc, #92]	; (8010bd4 <bmk11_execute+0x74>)
 8010b76:	f7f0 ffeb 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010b7a:	4816      	ldr	r0, [pc, #88]	; (8010bd4 <bmk11_execute+0x74>)
 8010b7c:	f7f1 f868 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 8010b80:	4814      	ldr	r0, [pc, #80]	; (8010bd4 <bmk11_execute+0x74>)
 8010b82:	f7f0 ffe5 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010b86:	4813      	ldr	r0, [pc, #76]	; (8010bd4 <bmk11_execute+0x74>)
 8010b88:	f7f1 f862 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 8010b8c:	4811      	ldr	r0, [pc, #68]	; (8010bd4 <bmk11_execute+0x74>)
 8010b8e:	f7f0 ffdf 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010b92:	4810      	ldr	r0, [pc, #64]	; (8010bd4 <bmk11_execute+0x74>)
 8010b94:	f7f1 f85c 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 8010b98:	480e      	ldr	r0, [pc, #56]	; (8010bd4 <bmk11_execute+0x74>)
 8010b9a:	f7f0 ffd9 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010b9e:	480d      	ldr	r0, [pc, #52]	; (8010bd4 <bmk11_execute+0x74>)
 8010ba0:	f7f1 f856 	bl	8001c50 <chSemSignal>
    n++;
 8010ba4:	9b01      	ldr	r3, [sp, #4]
 8010ba6:	3301      	adds	r3, #1
 8010ba8:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010baa:	4b0b      	ldr	r3, [pc, #44]	; (8010bd8 <bmk11_execute+0x78>)
 8010bac:	781b      	ldrb	r3, [r3, #0]
 8010bae:	f083 0301 	eor.w	r3, r3, #1
 8010bb2:	b2db      	uxtb	r3, r3
 8010bb4:	2b00      	cmp	r3, #0
 8010bb6:	d1dd      	bne.n	8010b74 <bmk11_execute+0x14>
  test_print("--- Score : ");
 8010bb8:	4808      	ldr	r0, [pc, #32]	; (8010bdc <bmk11_execute+0x7c>)
 8010bba:	f7fb f8b9 	bl	800bd30 <test_print>
  test_printn(n * 4);
 8010bbe:	9b01      	ldr	r3, [sp, #4]
 8010bc0:	009b      	lsls	r3, r3, #2
 8010bc2:	4618      	mov	r0, r3
 8010bc4:	f7fb f86c 	bl	800bca0 <test_printn>
  test_println(" wait+signal/S");
 8010bc8:	4805      	ldr	r0, [pc, #20]	; (8010be0 <bmk11_execute+0x80>)
 8010bca:	f7fb f8d1 	bl	800bd70 <test_println>
}
 8010bce:	b003      	add	sp, #12
 8010bd0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010bd4:	200014f0 	.word	0x200014f0
 8010bd8:	20003e39 	.word	0x20003e39
 8010bdc:	0801b600 	.word	0x0801b600
 8010be0:	0801b840 	.word	0x0801b840
 8010be4:	f3af 8000 	nop.w
 8010be8:	f3af 8000 	nop.w
 8010bec:	f3af 8000 	nop.w

08010bf0 <bmk12_setup>:
 * because there are no other threads asking for the mutex.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk12_setup(void) {
 8010bf0:	b508      	push	{r3, lr}

  chMtxObjectInit(&mtx1);
 8010bf2:	4802      	ldr	r0, [pc, #8]	; (8010bfc <bmk12_setup+0xc>)
 8010bf4:	f7f1 f97c 	bl	8001ef0 <chMtxObjectInit>
}
 8010bf8:	bd08      	pop	{r3, pc}
 8010bfa:	bf00      	nop
 8010bfc:	200014fc 	.word	0x200014fc

08010c00 <bmk12_execute>:

static void bmk12_execute(void) {
 8010c00:	b500      	push	{lr}
 8010c02:	b083      	sub	sp, #12
  uint32_t n = 0;
 8010c04:	2300      	movs	r3, #0
 8010c06:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010c08:	f7fb f9ca 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010c0c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010c10:	f7fb f9e6 	bl	800bfe0 <test_start_timer>
  do {
    chMtxLock(&mtx1);
 8010c14:	4817      	ldr	r0, [pc, #92]	; (8010c74 <bmk12_execute+0x74>)
 8010c16:	f7f1 f97b 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c1a:	4816      	ldr	r0, [pc, #88]	; (8010c74 <bmk12_execute+0x74>)
 8010c1c:	f7f1 fa20 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010c20:	4814      	ldr	r0, [pc, #80]	; (8010c74 <bmk12_execute+0x74>)
 8010c22:	f7f1 f975 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c26:	4813      	ldr	r0, [pc, #76]	; (8010c74 <bmk12_execute+0x74>)
 8010c28:	f7f1 fa1a 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010c2c:	4811      	ldr	r0, [pc, #68]	; (8010c74 <bmk12_execute+0x74>)
 8010c2e:	f7f1 f96f 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c32:	4810      	ldr	r0, [pc, #64]	; (8010c74 <bmk12_execute+0x74>)
 8010c34:	f7f1 fa14 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010c38:	480e      	ldr	r0, [pc, #56]	; (8010c74 <bmk12_execute+0x74>)
 8010c3a:	f7f1 f969 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c3e:	480d      	ldr	r0, [pc, #52]	; (8010c74 <bmk12_execute+0x74>)
 8010c40:	f7f1 fa0e 	bl	8002060 <chMtxUnlock>
    n++;
 8010c44:	9b01      	ldr	r3, [sp, #4]
 8010c46:	3301      	adds	r3, #1
 8010c48:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010c4a:	4b0b      	ldr	r3, [pc, #44]	; (8010c78 <bmk12_execute+0x78>)
 8010c4c:	781b      	ldrb	r3, [r3, #0]
 8010c4e:	f083 0301 	eor.w	r3, r3, #1
 8010c52:	b2db      	uxtb	r3, r3
 8010c54:	2b00      	cmp	r3, #0
 8010c56:	d1dd      	bne.n	8010c14 <bmk12_execute+0x14>
  test_print("--- Score : ");
 8010c58:	4808      	ldr	r0, [pc, #32]	; (8010c7c <bmk12_execute+0x7c>)
 8010c5a:	f7fb f869 	bl	800bd30 <test_print>
  test_printn(n * 4);
 8010c5e:	9b01      	ldr	r3, [sp, #4]
 8010c60:	009b      	lsls	r3, r3, #2
 8010c62:	4618      	mov	r0, r3
 8010c64:	f7fb f81c 	bl	800bca0 <test_printn>
  test_println(" lock+unlock/S");
 8010c68:	4805      	ldr	r0, [pc, #20]	; (8010c80 <bmk12_execute+0x80>)
 8010c6a:	f7fb f881 	bl	800bd70 <test_println>
}
 8010c6e:	b003      	add	sp, #12
 8010c70:	f85d fb04 	ldr.w	pc, [sp], #4
 8010c74:	200014fc 	.word	0x200014fc
 8010c78:	20003e39 	.word	0x20003e39
 8010c7c:	0801b600 	.word	0x0801b600
 8010c80:	0801b884 	.word	0x0801b884
 8010c84:	f3af 8000 	nop.w
 8010c88:	f3af 8000 	nop.w
 8010c8c:	f3af 8000 	nop.w

08010c90 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 8010c90:	b508      	push	{r3, lr}

  test_print("--- System: ");
 8010c92:	482e      	ldr	r0, [pc, #184]	; (8010d4c <bmk13_execute+0xbc>)
 8010c94:	f7fb f84c 	bl	800bd30 <test_print>
  test_printn(sizeof(ch_system_t));
 8010c98:	f44f 70a8 	mov.w	r0, #336	; 0x150
 8010c9c:	f7fb f800 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010ca0:	482b      	ldr	r0, [pc, #172]	; (8010d50 <bmk13_execute+0xc0>)
 8010ca2:	f7fb f865 	bl	800bd70 <test_println>
  test_print("--- Thread: ");
 8010ca6:	482b      	ldr	r0, [pc, #172]	; (8010d54 <bmk13_execute+0xc4>)
 8010ca8:	f7fb f842 	bl	800bd30 <test_print>
  test_printn(sizeof(thread_t));
 8010cac:	2044      	movs	r0, #68	; 0x44
 8010cae:	f7fa fff7 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010cb2:	4827      	ldr	r0, [pc, #156]	; (8010d50 <bmk13_execute+0xc0>)
 8010cb4:	f7fb f85c 	bl	800bd70 <test_println>
  test_print("--- Timer : ");
 8010cb8:	4827      	ldr	r0, [pc, #156]	; (8010d58 <bmk13_execute+0xc8>)
 8010cba:	f7fb f839 	bl	800bd30 <test_print>
  test_printn(sizeof(virtual_timer_t));
 8010cbe:	2014      	movs	r0, #20
 8010cc0:	f7fa ffee 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010cc4:	4822      	ldr	r0, [pc, #136]	; (8010d50 <bmk13_execute+0xc0>)
 8010cc6:	f7fb f853 	bl	800bd70 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 8010cca:	4824      	ldr	r0, [pc, #144]	; (8010d5c <bmk13_execute+0xcc>)
 8010ccc:	f7fb f830 	bl	800bd30 <test_print>
  test_printn(sizeof(semaphore_t));
 8010cd0:	200c      	movs	r0, #12
 8010cd2:	f7fa ffe5 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010cd6:	481e      	ldr	r0, [pc, #120]	; (8010d50 <bmk13_execute+0xc0>)
 8010cd8:	f7fb f84a 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 8010cdc:	4820      	ldr	r0, [pc, #128]	; (8010d60 <bmk13_execute+0xd0>)
 8010cde:	f7fb f827 	bl	800bd30 <test_print>
  test_printn(sizeof(event_source_t));
 8010ce2:	2004      	movs	r0, #4
 8010ce4:	f7fa ffdc 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010ce8:	4819      	ldr	r0, [pc, #100]	; (8010d50 <bmk13_execute+0xc0>)
 8010cea:	f7fb f841 	bl	800bd70 <test_println>
  test_print("--- EventL: ");
 8010cee:	481d      	ldr	r0, [pc, #116]	; (8010d64 <bmk13_execute+0xd4>)
 8010cf0:	f7fb f81e 	bl	800bd30 <test_print>
  test_printn(sizeof(event_listener_t));
 8010cf4:	2014      	movs	r0, #20
 8010cf6:	f7fa ffd3 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010cfa:	4815      	ldr	r0, [pc, #84]	; (8010d50 <bmk13_execute+0xc0>)
 8010cfc:	f7fb f838 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8010d00:	4819      	ldr	r0, [pc, #100]	; (8010d68 <bmk13_execute+0xd8>)
 8010d02:	f7fb f815 	bl	800bd30 <test_print>
  test_printn(sizeof(mutex_t));
 8010d06:	2010      	movs	r0, #16
 8010d08:	f7fa ffca 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010d0c:	4810      	ldr	r0, [pc, #64]	; (8010d50 <bmk13_execute+0xc0>)
 8010d0e:	f7fb f82f 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8010d12:	4816      	ldr	r0, [pc, #88]	; (8010d6c <bmk13_execute+0xdc>)
 8010d14:	f7fb f80c 	bl	800bd30 <test_print>
  test_printn(sizeof(condition_variable_t));
 8010d18:	2008      	movs	r0, #8
 8010d1a:	f7fa ffc1 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010d1e:	480c      	ldr	r0, [pc, #48]	; (8010d50 <bmk13_execute+0xc0>)
 8010d20:	f7fb f826 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8010d24:	4812      	ldr	r0, [pc, #72]	; (8010d70 <bmk13_execute+0xe0>)
 8010d26:	f7fb f803 	bl	800bd30 <test_print>
  test_printn(sizeof(io_queue_t));
 8010d2a:	2024      	movs	r0, #36	; 0x24
 8010d2c:	f7fa ffb8 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010d30:	4807      	ldr	r0, [pc, #28]	; (8010d50 <bmk13_execute+0xc0>)
 8010d32:	f7fb f81d 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8010d36:	480f      	ldr	r0, [pc, #60]	; (8010d74 <bmk13_execute+0xe4>)
 8010d38:	f7fa fffa 	bl	800bd30 <test_print>
  test_printn(sizeof(mailbox_t));
 8010d3c:	2028      	movs	r0, #40	; 0x28
 8010d3e:	f7fa ffaf 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010d42:	4803      	ldr	r0, [pc, #12]	; (8010d50 <bmk13_execute+0xc0>)
 8010d44:	f7fb f814 	bl	800bd70 <test_println>
#endif
}
 8010d48:	bd08      	pop	{r3, pc}
 8010d4a:	bf00      	nop
 8010d4c:	0801b8c4 	.word	0x0801b8c4
 8010d50:	0801b8d4 	.word	0x0801b8d4
 8010d54:	0801b8dc 	.word	0x0801b8dc
 8010d58:	0801b8ec 	.word	0x0801b8ec
 8010d5c:	0801b8fc 	.word	0x0801b8fc
 8010d60:	0801b90c 	.word	0x0801b90c
 8010d64:	0801b91c 	.word	0x0801b91c
 8010d68:	0801b92c 	.word	0x0801b92c
 8010d6c:	0801b93c 	.word	0x0801b93c
 8010d70:	0801b94c 	.word	0x0801b94c
 8010d74:	0801b95c 	.word	0x0801b95c
 8010d78:	f3af 8000 	nop.w
 8010d7c:	f3af 8000 	nop.w

08010d80 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8010d80:	b082      	sub	sp, #8
 8010d82:	2320      	movs	r3, #32
 8010d84:	9301      	str	r3, [sp, #4]
 8010d86:	9b01      	ldr	r3, [sp, #4]
 8010d88:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8010d8c:	b002      	add	sp, #8
 8010d8e:	4770      	bx	lr

08010d90 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8010d90:	b082      	sub	sp, #8
 8010d92:	2300      	movs	r3, #0
 8010d94:	9301      	str	r3, [sp, #4]
 8010d96:	9b01      	ldr	r3, [sp, #4]
 8010d98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8010d9c:	b002      	add	sp, #8
 8010d9e:	4770      	bx	lr

08010da0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8010da0:	b508      	push	{r3, lr}

  port_lock();
 8010da2:	f7ff ffed 	bl	8010d80 <port_lock>
}
 8010da6:	bd08      	pop	{r3, pc}
 8010da8:	f3af 8000 	nop.w
 8010dac:	f3af 8000 	nop.w

08010db0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8010db0:	b508      	push	{r3, lr}

  port_unlock();
 8010db2:	f7ff ffed 	bl	8010d90 <port_unlock>
}
 8010db6:	bd08      	pop	{r3, pc}
 8010db8:	f3af 8000 	nop.w
 8010dbc:	f3af 8000 	nop.w

08010dc0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8010dc0:	b508      	push	{r3, lr}

  port_lock();
 8010dc2:	f7ff ffdd 	bl	8010d80 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8010dc6:	bd08      	pop	{r3, pc}
 8010dc8:	f3af 8000 	nop.w
 8010dcc:	f3af 8000 	nop.w

08010dd0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8010dd0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8010dd2:	f7ff ffdd 	bl	8010d90 <port_unlock>
}
 8010dd6:	bd08      	pop	{r3, pc}
 8010dd8:	f3af 8000 	nop.w
 8010ddc:	f3af 8000 	nop.w

08010de0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8010de0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8010de2:	f7ff ffdd 	bl	8010da0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8010de6:	bd08      	pop	{r3, pc}
 8010de8:	f3af 8000 	nop.w
 8010dec:	f3af 8000 	nop.w

08010df0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8010df0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8010df2:	f7ff ffdd 	bl	8010db0 <port_unlock_from_isr>
}
 8010df6:	bd08      	pop	{r3, pc}
 8010df8:	f3af 8000 	nop.w
 8010dfc:	f3af 8000 	nop.w

08010e00 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 8010e00:	b082      	sub	sp, #8
 8010e02:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 8010e04:	9b01      	ldr	r3, [sp, #4]
 8010e06:	2200      	movs	r2, #0
 8010e08:	60da      	str	r2, [r3, #12]
}
 8010e0a:	b002      	add	sp, #8
 8010e0c:	4770      	bx	lr
 8010e0e:	bf00      	nop

08010e10 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8010e10:	b082      	sub	sp, #8
 8010e12:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8010e14:	9b01      	ldr	r3, [sp, #4]
 8010e16:	68db      	ldr	r3, [r3, #12]
 8010e18:	2b00      	cmp	r3, #0
 8010e1a:	bf0c      	ite	eq
 8010e1c:	2300      	moveq	r3, #0
 8010e1e:	2301      	movne	r3, #1
 8010e20:	b2db      	uxtb	r3, r3
}
 8010e22:	4618      	mov	r0, r3
 8010e24:	b002      	add	sp, #8
 8010e26:	4770      	bx	lr
 8010e28:	f3af 8000 	nop.w
 8010e2c:	f3af 8000 	nop.w

08010e30 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 8010e30:	b500      	push	{lr}
 8010e32:	b083      	sub	sp, #12
 8010e34:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 8010e36:	9801      	ldr	r0, [sp, #4]
 8010e38:	f7ff ffea 	bl	8010e10 <chVTIsArmedI>
 8010e3c:	4603      	mov	r3, r0
 8010e3e:	2b00      	cmp	r3, #0
 8010e40:	d002      	beq.n	8010e48 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 8010e42:	9801      	ldr	r0, [sp, #4]
 8010e44:	f7ef fde4 	bl	8000a10 <chVTDoResetI>
  }
}
 8010e48:	b003      	add	sp, #12
 8010e4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8010e4e:	bf00      	nop

08010e50 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 8010e50:	b500      	push	{lr}
 8010e52:	b085      	sub	sp, #20
 8010e54:	9003      	str	r0, [sp, #12]
 8010e56:	9102      	str	r1, [sp, #8]
 8010e58:	9201      	str	r2, [sp, #4]
 8010e5a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 8010e5c:	9803      	ldr	r0, [sp, #12]
 8010e5e:	f7ff ffe7 	bl	8010e30 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8010e62:	9803      	ldr	r0, [sp, #12]
 8010e64:	9902      	ldr	r1, [sp, #8]
 8010e66:	9a01      	ldr	r2, [sp, #4]
 8010e68:	9b00      	ldr	r3, [sp, #0]
 8010e6a:	f7ef fd91 	bl	8000990 <chVTDoSetI>
}
 8010e6e:	b005      	add	sp, #20
 8010e70:	f85d fb04 	ldr.w	pc, [sp], #4
 8010e74:	f3af 8000 	nop.w
 8010e78:	f3af 8000 	nop.w
 8010e7c:	f3af 8000 	nop.w

08010e80 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 8010e80:	b500      	push	{lr}
 8010e82:	b085      	sub	sp, #20
 8010e84:	9003      	str	r0, [sp, #12]
 8010e86:	9102      	str	r1, [sp, #8]
 8010e88:	9201      	str	r2, [sp, #4]
 8010e8a:	9300      	str	r3, [sp, #0]

  chSysLock();
 8010e8c:	f7ff ff98 	bl	8010dc0 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 8010e90:	9803      	ldr	r0, [sp, #12]
 8010e92:	9902      	ldr	r1, [sp, #8]
 8010e94:	9a01      	ldr	r2, [sp, #4]
 8010e96:	9b00      	ldr	r3, [sp, #0]
 8010e98:	f7ff ffda 	bl	8010e50 <chVTSetI>
  chSysUnlock();
 8010e9c:	f7ff ff98 	bl	8010dd0 <chSysUnlock>
}
 8010ea0:	b005      	add	sp, #20
 8010ea2:	f85d fb04 	ldr.w	pc, [sp], #4
 8010ea6:	bf00      	nop
 8010ea8:	f3af 8000 	nop.w
 8010eac:	f3af 8000 	nop.w

08010eb0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8010eb0:	b082      	sub	sp, #8
 8010eb2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8010eb4:	9b01      	ldr	r3, [sp, #4]
 8010eb6:	9a01      	ldr	r2, [sp, #4]
 8010eb8:	601a      	str	r2, [r3, #0]
}
 8010eba:	b002      	add	sp, #8
 8010ebc:	4770      	bx	lr
 8010ebe:	bf00      	nop

08010ec0 <chEvtBroadcastI>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 8010ec0:	b500      	push	{lr}
 8010ec2:	b083      	sub	sp, #12
 8010ec4:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8010ec6:	9801      	ldr	r0, [sp, #4]
 8010ec8:	2100      	movs	r1, #0
 8010eca:	f7f1 fbd9 	bl	8002680 <chEvtBroadcastFlagsI>
}
 8010ece:	b003      	add	sp, #12
 8010ed0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010ed4:	f3af 8000 	nop.w
 8010ed8:	f3af 8000 	nop.w
 8010edc:	f3af 8000 	nop.w

08010ee0 <tmrcb>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static void tmrcb(void *p) {
 8010ee0:	b500      	push	{lr}
 8010ee2:	b085      	sub	sp, #20
 8010ee4:	9001      	str	r0, [sp, #4]
  event_timer_t *etp = p;
 8010ee6:	9b01      	ldr	r3, [sp, #4]
 8010ee8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8010eea:	f7ff ff79 	bl	8010de0 <chSysLockFromISR>
  chEvtBroadcastI(&etp->et_es);
 8010eee:	9b03      	ldr	r3, [sp, #12]
 8010ef0:	3314      	adds	r3, #20
 8010ef2:	4618      	mov	r0, r3
 8010ef4:	f7ff ffe4 	bl	8010ec0 <chEvtBroadcastI>
  chVTDoSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010ef8:	9a03      	ldr	r2, [sp, #12]
 8010efa:	9b03      	ldr	r3, [sp, #12]
 8010efc:	699b      	ldr	r3, [r3, #24]
 8010efe:	4610      	mov	r0, r2
 8010f00:	4619      	mov	r1, r3
 8010f02:	4a04      	ldr	r2, [pc, #16]	; (8010f14 <tmrcb+0x34>)
 8010f04:	9b03      	ldr	r3, [sp, #12]
 8010f06:	f7ef fd43 	bl	8000990 <chVTDoSetI>
  chSysUnlockFromISR();
 8010f0a:	f7ff ff71 	bl	8010df0 <chSysUnlockFromISR>
}
 8010f0e:	b005      	add	sp, #20
 8010f10:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f14:	08010ee1 	.word	0x08010ee1
 8010f18:	f3af 8000 	nop.w
 8010f1c:	f3af 8000 	nop.w

08010f20 <evtObjectInit>:
 * @brief Initializes an @p event_timer_t structure.
 *
 * @param[out] etp      the @p event_timer_t structure to be initialized
 * @param[in] time      the interval in system ticks
 */
void evtObjectInit(event_timer_t *etp, systime_t time) {
 8010f20:	b500      	push	{lr}
 8010f22:	b083      	sub	sp, #12
 8010f24:	9001      	str	r0, [sp, #4]
 8010f26:	9100      	str	r1, [sp, #0]

  chEvtObjectInit(&etp->et_es);
 8010f28:	9b01      	ldr	r3, [sp, #4]
 8010f2a:	3314      	adds	r3, #20
 8010f2c:	4618      	mov	r0, r3
 8010f2e:	f7ff ffbf 	bl	8010eb0 <chEvtObjectInit>
  chVTObjectInit(&etp->et_vt);
 8010f32:	9b01      	ldr	r3, [sp, #4]
 8010f34:	4618      	mov	r0, r3
 8010f36:	f7ff ff63 	bl	8010e00 <chVTObjectInit>
  etp->et_interval = time;
 8010f3a:	9b01      	ldr	r3, [sp, #4]
 8010f3c:	9a00      	ldr	r2, [sp, #0]
 8010f3e:	619a      	str	r2, [r3, #24]
}
 8010f40:	b003      	add	sp, #12
 8010f42:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f46:	bf00      	nop
 8010f48:	f3af 8000 	nop.w
 8010f4c:	f3af 8000 	nop.w

08010f50 <evtStart>:
 * @brief   Starts the timer
 * @details If the timer was already running then the function has no effect.
 *
 * @param[in] etp       pointer to an initialized @p event_timer_t structure.
 */
void evtStart(event_timer_t *etp) {
 8010f50:	b500      	push	{lr}
 8010f52:	b083      	sub	sp, #12
 8010f54:	9001      	str	r0, [sp, #4]

  chVTSet(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010f56:	9a01      	ldr	r2, [sp, #4]
 8010f58:	9b01      	ldr	r3, [sp, #4]
 8010f5a:	699b      	ldr	r3, [r3, #24]
 8010f5c:	4610      	mov	r0, r2
 8010f5e:	4619      	mov	r1, r3
 8010f60:	4a03      	ldr	r2, [pc, #12]	; (8010f70 <evtStart+0x20>)
 8010f62:	9b01      	ldr	r3, [sp, #4]
 8010f64:	f7ff ff8c 	bl	8010e80 <chVTSet>
}
 8010f68:	b003      	add	sp, #12
 8010f6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f6e:	bf00      	nop
 8010f70:	08010ee1 	.word	0x08010ee1
 8010f74:	f3af 8000 	nop.w
 8010f78:	f3af 8000 	nop.w
 8010f7c:	f3af 8000 	nop.w

08010f80 <writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 8010f80:	b500      	push	{lr}
 8010f82:	b087      	sub	sp, #28
 8010f84:	9003      	str	r0, [sp, #12]
 8010f86:	9102      	str	r1, [sp, #8]
 8010f88:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 8010f8a:	9b03      	ldr	r3, [sp, #12]
 8010f8c:	9305      	str	r3, [sp, #20]

  if (msp->size - msp->eos < n)
 8010f8e:	9b05      	ldr	r3, [sp, #20]
 8010f90:	689a      	ldr	r2, [r3, #8]
 8010f92:	9b05      	ldr	r3, [sp, #20]
 8010f94:	68db      	ldr	r3, [r3, #12]
 8010f96:	1ad2      	subs	r2, r2, r3
 8010f98:	9b01      	ldr	r3, [sp, #4]
 8010f9a:	429a      	cmp	r2, r3
 8010f9c:	d205      	bcs.n	8010faa <writes+0x2a>
    n = msp->size - msp->eos;
 8010f9e:	9b05      	ldr	r3, [sp, #20]
 8010fa0:	689a      	ldr	r2, [r3, #8]
 8010fa2:	9b05      	ldr	r3, [sp, #20]
 8010fa4:	68db      	ldr	r3, [r3, #12]
 8010fa6:	1ad3      	subs	r3, r2, r3
 8010fa8:	9301      	str	r3, [sp, #4]
  memcpy(msp->buffer + msp->eos, bp, n);
 8010faa:	9b05      	ldr	r3, [sp, #20]
 8010fac:	685a      	ldr	r2, [r3, #4]
 8010fae:	9b05      	ldr	r3, [sp, #20]
 8010fb0:	68db      	ldr	r3, [r3, #12]
 8010fb2:	4413      	add	r3, r2
 8010fb4:	4618      	mov	r0, r3
 8010fb6:	9902      	ldr	r1, [sp, #8]
 8010fb8:	9a01      	ldr	r2, [sp, #4]
 8010fba:	f006 fb11 	bl	80175e0 <memcpy>
  msp->eos += n;
 8010fbe:	9b05      	ldr	r3, [sp, #20]
 8010fc0:	68da      	ldr	r2, [r3, #12]
 8010fc2:	9b01      	ldr	r3, [sp, #4]
 8010fc4:	441a      	add	r2, r3
 8010fc6:	9b05      	ldr	r3, [sp, #20]
 8010fc8:	60da      	str	r2, [r3, #12]
  return n;
 8010fca:	9b01      	ldr	r3, [sp, #4]
}
 8010fcc:	4618      	mov	r0, r3
 8010fce:	b007      	add	sp, #28
 8010fd0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010fd4:	f3af 8000 	nop.w
 8010fd8:	f3af 8000 	nop.w
 8010fdc:	f3af 8000 	nop.w

08010fe0 <reads>:

static size_t reads(void *ip, uint8_t *bp, size_t n) {
 8010fe0:	b500      	push	{lr}
 8010fe2:	b087      	sub	sp, #28
 8010fe4:	9003      	str	r0, [sp, #12]
 8010fe6:	9102      	str	r1, [sp, #8]
 8010fe8:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 8010fea:	9b03      	ldr	r3, [sp, #12]
 8010fec:	9305      	str	r3, [sp, #20]

  if (msp->eos - msp->offset < n)
 8010fee:	9b05      	ldr	r3, [sp, #20]
 8010ff0:	68da      	ldr	r2, [r3, #12]
 8010ff2:	9b05      	ldr	r3, [sp, #20]
 8010ff4:	691b      	ldr	r3, [r3, #16]
 8010ff6:	1ad2      	subs	r2, r2, r3
 8010ff8:	9b01      	ldr	r3, [sp, #4]
 8010ffa:	429a      	cmp	r2, r3
 8010ffc:	d205      	bcs.n	801100a <reads+0x2a>
    n = msp->eos - msp->offset;
 8010ffe:	9b05      	ldr	r3, [sp, #20]
 8011000:	68da      	ldr	r2, [r3, #12]
 8011002:	9b05      	ldr	r3, [sp, #20]
 8011004:	691b      	ldr	r3, [r3, #16]
 8011006:	1ad3      	subs	r3, r2, r3
 8011008:	9301      	str	r3, [sp, #4]
  memcpy(bp, msp->buffer + msp->offset, n);
 801100a:	9b05      	ldr	r3, [sp, #20]
 801100c:	685a      	ldr	r2, [r3, #4]
 801100e:	9b05      	ldr	r3, [sp, #20]
 8011010:	691b      	ldr	r3, [r3, #16]
 8011012:	4413      	add	r3, r2
 8011014:	9802      	ldr	r0, [sp, #8]
 8011016:	4619      	mov	r1, r3
 8011018:	9a01      	ldr	r2, [sp, #4]
 801101a:	f006 fae1 	bl	80175e0 <memcpy>
  msp->offset += n;
 801101e:	9b05      	ldr	r3, [sp, #20]
 8011020:	691a      	ldr	r2, [r3, #16]
 8011022:	9b01      	ldr	r3, [sp, #4]
 8011024:	441a      	add	r2, r3
 8011026:	9b05      	ldr	r3, [sp, #20]
 8011028:	611a      	str	r2, [r3, #16]
  return n;
 801102a:	9b01      	ldr	r3, [sp, #4]
}
 801102c:	4618      	mov	r0, r3
 801102e:	b007      	add	sp, #28
 8011030:	f85d fb04 	ldr.w	pc, [sp], #4
 8011034:	f3af 8000 	nop.w
 8011038:	f3af 8000 	nop.w
 801103c:	f3af 8000 	nop.w

08011040 <put>:

static msg_t put(void *ip, uint8_t b) {
 8011040:	b084      	sub	sp, #16
 8011042:	9001      	str	r0, [sp, #4]
 8011044:	460b      	mov	r3, r1
 8011046:	f88d 3003 	strb.w	r3, [sp, #3]
  MemoryStream *msp = ip;
 801104a:	9b01      	ldr	r3, [sp, #4]
 801104c:	9303      	str	r3, [sp, #12]

  if (msp->size - msp->eos <= 0)
 801104e:	9b03      	ldr	r3, [sp, #12]
 8011050:	689a      	ldr	r2, [r3, #8]
 8011052:	9b03      	ldr	r3, [sp, #12]
 8011054:	68db      	ldr	r3, [r3, #12]
 8011056:	429a      	cmp	r2, r3
 8011058:	d102      	bne.n	8011060 <put+0x20>
    return MSG_RESET;
 801105a:	f06f 0301 	mvn.w	r3, #1
 801105e:	e00d      	b.n	801107c <put+0x3c>
  *(msp->buffer + msp->eos) = b;
 8011060:	9b03      	ldr	r3, [sp, #12]
 8011062:	685a      	ldr	r2, [r3, #4]
 8011064:	9b03      	ldr	r3, [sp, #12]
 8011066:	68db      	ldr	r3, [r3, #12]
 8011068:	4413      	add	r3, r2
 801106a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 801106e:	701a      	strb	r2, [r3, #0]
  msp->eos += 1;
 8011070:	9b03      	ldr	r3, [sp, #12]
 8011072:	68db      	ldr	r3, [r3, #12]
 8011074:	1c5a      	adds	r2, r3, #1
 8011076:	9b03      	ldr	r3, [sp, #12]
 8011078:	60da      	str	r2, [r3, #12]
  return MSG_OK;
 801107a:	2300      	movs	r3, #0
}
 801107c:	4618      	mov	r0, r3
 801107e:	b004      	add	sp, #16
 8011080:	4770      	bx	lr
 8011082:	bf00      	nop
 8011084:	f3af 8000 	nop.w
 8011088:	f3af 8000 	nop.w
 801108c:	f3af 8000 	nop.w

08011090 <get>:

static msg_t get(void *ip) {
 8011090:	b084      	sub	sp, #16
 8011092:	9001      	str	r0, [sp, #4]
  uint8_t b;
  MemoryStream *msp = ip;
 8011094:	9b01      	ldr	r3, [sp, #4]
 8011096:	9303      	str	r3, [sp, #12]

  if (msp->eos - msp->offset <= 0)
 8011098:	9b03      	ldr	r3, [sp, #12]
 801109a:	68da      	ldr	r2, [r3, #12]
 801109c:	9b03      	ldr	r3, [sp, #12]
 801109e:	691b      	ldr	r3, [r3, #16]
 80110a0:	429a      	cmp	r2, r3
 80110a2:	d102      	bne.n	80110aa <get+0x1a>
    return MSG_RESET;
 80110a4:	f06f 0301 	mvn.w	r3, #1
 80110a8:	e00e      	b.n	80110c8 <get+0x38>
  b = *(msp->buffer + msp->offset);
 80110aa:	9b03      	ldr	r3, [sp, #12]
 80110ac:	685a      	ldr	r2, [r3, #4]
 80110ae:	9b03      	ldr	r3, [sp, #12]
 80110b0:	691b      	ldr	r3, [r3, #16]
 80110b2:	4413      	add	r3, r2
 80110b4:	781b      	ldrb	r3, [r3, #0]
 80110b6:	f88d 300b 	strb.w	r3, [sp, #11]
  msp->offset += 1;
 80110ba:	9b03      	ldr	r3, [sp, #12]
 80110bc:	691b      	ldr	r3, [r3, #16]
 80110be:	1c5a      	adds	r2, r3, #1
 80110c0:	9b03      	ldr	r3, [sp, #12]
 80110c2:	611a      	str	r2, [r3, #16]
  return b;
 80110c4:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 80110c8:	4618      	mov	r0, r3
 80110ca:	b004      	add	sp, #16
 80110cc:	4770      	bx	lr
 80110ce:	bf00      	nop

080110d0 <msObjectInit>:
 * @param[in] eos       initial End Of Stream offset. Normally you need to
 *                      put this to zero for RAM buffers or equal to @p size
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {
 80110d0:	b084      	sub	sp, #16
 80110d2:	9003      	str	r0, [sp, #12]
 80110d4:	9102      	str	r1, [sp, #8]
 80110d6:	9201      	str	r2, [sp, #4]
 80110d8:	9300      	str	r3, [sp, #0]

  msp->vmt    = &vmt;
 80110da:	9b03      	ldr	r3, [sp, #12]
 80110dc:	4a07      	ldr	r2, [pc, #28]	; (80110fc <msObjectInit+0x2c>)
 80110de:	601a      	str	r2, [r3, #0]
  msp->buffer = buffer;
 80110e0:	9b03      	ldr	r3, [sp, #12]
 80110e2:	9a02      	ldr	r2, [sp, #8]
 80110e4:	605a      	str	r2, [r3, #4]
  msp->size   = size;
 80110e6:	9b03      	ldr	r3, [sp, #12]
 80110e8:	9a01      	ldr	r2, [sp, #4]
 80110ea:	609a      	str	r2, [r3, #8]
  msp->eos    = eos;
 80110ec:	9b03      	ldr	r3, [sp, #12]
 80110ee:	9a00      	ldr	r2, [sp, #0]
 80110f0:	60da      	str	r2, [r3, #12]
  msp->offset = 0;
 80110f2:	9b03      	ldr	r3, [sp, #12]
 80110f4:	2200      	movs	r2, #0
 80110f6:	611a      	str	r2, [r3, #16]
}
 80110f8:	b004      	add	sp, #16
 80110fa:	4770      	bx	lr
 80110fc:	0801b9d0 	.word	0x0801b9d0

08011100 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8011100:	b088      	sub	sp, #32
 8011102:	9003      	str	r0, [sp, #12]
 8011104:	9102      	str	r1, [sp, #8]
 8011106:	9201      	str	r2, [sp, #4]
 8011108:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 801110a:	9b02      	ldr	r3, [sp, #8]
 801110c:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 801110e:	9b00      	ldr	r3, [sp, #0]
 8011110:	2b00      	cmp	r3, #0
 8011112:	d102      	bne.n	801111a <long_to_string_with_divisor+0x1a>
    ll = num;
 8011114:	9b02      	ldr	r3, [sp, #8]
 8011116:	9304      	str	r3, [sp, #16]
 8011118:	e001      	b.n	801111e <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 801111a:	9b00      	ldr	r3, [sp, #0]
 801111c:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 801111e:	9b03      	ldr	r3, [sp, #12]
 8011120:	330b      	adds	r3, #11
 8011122:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8011124:	9b05      	ldr	r3, [sp, #20]
 8011126:	9a01      	ldr	r2, [sp, #4]
 8011128:	fbb3 f2f2 	udiv	r2, r3, r2
 801112c:	9901      	ldr	r1, [sp, #4]
 801112e:	fb01 f202 	mul.w	r2, r1, r2
 8011132:	1a9b      	subs	r3, r3, r2
 8011134:	9307      	str	r3, [sp, #28]
    i += '0';
 8011136:	9b07      	ldr	r3, [sp, #28]
 8011138:	3330      	adds	r3, #48	; 0x30
 801113a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 801113c:	9b07      	ldr	r3, [sp, #28]
 801113e:	2b39      	cmp	r3, #57	; 0x39
 8011140:	dd02      	ble.n	8011148 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 8011142:	9b07      	ldr	r3, [sp, #28]
 8011144:	3307      	adds	r3, #7
 8011146:	9307      	str	r3, [sp, #28]
    *--q = i;
 8011148:	9b06      	ldr	r3, [sp, #24]
 801114a:	3b01      	subs	r3, #1
 801114c:	9306      	str	r3, [sp, #24]
 801114e:	9b07      	ldr	r3, [sp, #28]
 8011150:	b2da      	uxtb	r2, r3
 8011152:	9b06      	ldr	r3, [sp, #24]
 8011154:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8011156:	9a05      	ldr	r2, [sp, #20]
 8011158:	9b01      	ldr	r3, [sp, #4]
 801115a:	fbb2 f3f3 	udiv	r3, r2, r3
 801115e:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8011160:	9a04      	ldr	r2, [sp, #16]
 8011162:	9b01      	ldr	r3, [sp, #4]
 8011164:	fbb2 f3f3 	udiv	r3, r2, r3
 8011168:	9304      	str	r3, [sp, #16]
 801116a:	9b04      	ldr	r3, [sp, #16]
 801116c:	2b00      	cmp	r3, #0
 801116e:	d1d9      	bne.n	8011124 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 8011170:	9b03      	ldr	r3, [sp, #12]
 8011172:	330b      	adds	r3, #11
 8011174:	461a      	mov	r2, r3
 8011176:	9b06      	ldr	r3, [sp, #24]
 8011178:	1ad3      	subs	r3, r2, r3
 801117a:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 801117c:	9b03      	ldr	r3, [sp, #12]
 801117e:	1c5a      	adds	r2, r3, #1
 8011180:	9203      	str	r2, [sp, #12]
 8011182:	9a06      	ldr	r2, [sp, #24]
 8011184:	1c51      	adds	r1, r2, #1
 8011186:	9106      	str	r1, [sp, #24]
 8011188:	7812      	ldrb	r2, [r2, #0]
 801118a:	701a      	strb	r2, [r3, #0]
  while (--i);
 801118c:	9b07      	ldr	r3, [sp, #28]
 801118e:	3b01      	subs	r3, #1
 8011190:	9307      	str	r3, [sp, #28]
 8011192:	9b07      	ldr	r3, [sp, #28]
 8011194:	2b00      	cmp	r3, #0
 8011196:	d1f1      	bne.n	801117c <long_to_string_with_divisor+0x7c>

  return p;
 8011198:	9b03      	ldr	r3, [sp, #12]
}
 801119a:	4618      	mov	r0, r3
 801119c:	b008      	add	sp, #32
 801119e:	4770      	bx	lr

080111a0 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 80111a0:	b500      	push	{lr}
 80111a2:	b085      	sub	sp, #20
 80111a4:	9003      	str	r0, [sp, #12]
 80111a6:	9102      	str	r1, [sp, #8]
 80111a8:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 80111aa:	9803      	ldr	r0, [sp, #12]
 80111ac:	9902      	ldr	r1, [sp, #8]
 80111ae:	9a01      	ldr	r2, [sp, #4]
 80111b0:	2300      	movs	r3, #0
 80111b2:	f7ff ffa5 	bl	8011100 <long_to_string_with_divisor>
 80111b6:	4603      	mov	r3, r0
}
 80111b8:	4618      	mov	r0, r3
 80111ba:	b005      	add	sp, #20
 80111bc:	f85d fb04 	ldr.w	pc, [sp], #4

080111c0 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80111c0:	b500      	push	{lr}
 80111c2:	b091      	sub	sp, #68	; 0x44
 80111c4:	9003      	str	r0, [sp, #12]
 80111c6:	9102      	str	r1, [sp, #8]
 80111c8:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 80111ca:	2300      	movs	r3, #0
 80111cc:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 80111ce:	9b02      	ldr	r3, [sp, #8]
 80111d0:	1c5a      	adds	r2, r3, #1
 80111d2:	9202      	str	r2, [sp, #8]
 80111d4:	781b      	ldrb	r3, [r3, #0]
 80111d6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 80111da:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80111de:	2b00      	cmp	r3, #0
 80111e0:	d101      	bne.n	80111e6 <chvprintf+0x26>
      return n;
 80111e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80111e4:	e210      	b.n	8011608 <chvprintf+0x448>
    if (c != '%') {
 80111e6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80111ea:	2b25      	cmp	r3, #37	; 0x25
 80111ec:	d00b      	beq.n	8011206 <chvprintf+0x46>
      streamPut(chp, (uint8_t)c);
 80111ee:	9b03      	ldr	r3, [sp, #12]
 80111f0:	681b      	ldr	r3, [r3, #0]
 80111f2:	689b      	ldr	r3, [r3, #8]
 80111f4:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 80111f8:	9803      	ldr	r0, [sp, #12]
 80111fa:	4611      	mov	r1, r2
 80111fc:	4798      	blx	r3
      n++;
 80111fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011200:	3301      	adds	r3, #1
 8011202:	9309      	str	r3, [sp, #36]	; 0x24
      continue;
 8011204:	e1ff      	b.n	8011606 <chvprintf+0x446>
    }
    p = tmpbuf;
 8011206:	ab04      	add	r3, sp, #16
 8011208:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 801120a:	ab04      	add	r3, sp, #16
 801120c:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 801120e:	2300      	movs	r3, #0
 8011210:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 8011214:	9b02      	ldr	r3, [sp, #8]
 8011216:	781b      	ldrb	r3, [r3, #0]
 8011218:	2b2d      	cmp	r3, #45	; 0x2d
 801121a:	d105      	bne.n	8011228 <chvprintf+0x68>
      fmt++;
 801121c:	9b02      	ldr	r3, [sp, #8]
 801121e:	3301      	adds	r3, #1
 8011220:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 8011222:	2301      	movs	r3, #1
 8011224:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 8011228:	2320      	movs	r3, #32
 801122a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 801122e:	9b02      	ldr	r3, [sp, #8]
 8011230:	781b      	ldrb	r3, [r3, #0]
 8011232:	2b30      	cmp	r3, #48	; 0x30
 8011234:	d105      	bne.n	8011242 <chvprintf+0x82>
      fmt++;
 8011236:	9b02      	ldr	r3, [sp, #8]
 8011238:	3301      	adds	r3, #1
 801123a:	9302      	str	r3, [sp, #8]
      filler = '0';
 801123c:	2330      	movs	r3, #48	; 0x30
 801123e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 8011242:	2300      	movs	r3, #0
 8011244:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 8011246:	9b02      	ldr	r3, [sp, #8]
 8011248:	1c5a      	adds	r2, r3, #1
 801124a:	9202      	str	r2, [sp, #8]
 801124c:	781b      	ldrb	r3, [r3, #0]
 801124e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 8011252:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011256:	2b2f      	cmp	r3, #47	; 0x2f
 8011258:	d909      	bls.n	801126e <chvprintf+0xae>
 801125a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801125e:	2b39      	cmp	r3, #57	; 0x39
 8011260:	d805      	bhi.n	801126e <chvprintf+0xae>
        c -= '0';
 8011262:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011266:	3b30      	subs	r3, #48	; 0x30
 8011268:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 801126c:	e012      	b.n	8011294 <chvprintf+0xd4>
      else if (c == '*')
 801126e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011272:	2b2a      	cmp	r3, #42	; 0x2a
 8011274:	d106      	bne.n	8011284 <chvprintf+0xc4>
        c = va_arg(ap, int);
 8011276:	9b01      	ldr	r3, [sp, #4]
 8011278:	1d1a      	adds	r2, r3, #4
 801127a:	9201      	str	r2, [sp, #4]
 801127c:	681b      	ldr	r3, [r3, #0]
 801127e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8011282:	e007      	b.n	8011294 <chvprintf+0xd4>
      else
        break;
 8011284:	bf00      	nop
      width = width * 10 + c;
    }
    precision = 0;
 8011286:	2300      	movs	r3, #0
 8011288:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 801128a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801128e:	2b2e      	cmp	r3, #46	; 0x2e
 8011290:	d137      	bne.n	8011302 <chvprintf+0x142>
 8011292:	e00a      	b.n	80112aa <chvprintf+0xea>
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 8011294:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8011296:	4613      	mov	r3, r2
 8011298:	009b      	lsls	r3, r3, #2
 801129a:	4413      	add	r3, r2
 801129c:	005b      	lsls	r3, r3, #1
 801129e:	461a      	mov	r2, r3
 80112a0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112a4:	4413      	add	r3, r2
 80112a6:	930a      	str	r3, [sp, #40]	; 0x28
    }
 80112a8:	e7cd      	b.n	8011246 <chvprintf+0x86>
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 80112aa:	9b02      	ldr	r3, [sp, #8]
 80112ac:	1c5a      	adds	r2, r3, #1
 80112ae:	9202      	str	r2, [sp, #8]
 80112b0:	781b      	ldrb	r3, [r3, #0]
 80112b2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 80112b6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112ba:	2b2f      	cmp	r3, #47	; 0x2f
 80112bc:	d909      	bls.n	80112d2 <chvprintf+0x112>
 80112be:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112c2:	2b39      	cmp	r3, #57	; 0x39
 80112c4:	d805      	bhi.n	80112d2 <chvprintf+0x112>
          c -= '0';
 80112c6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112ca:	3b30      	subs	r3, #48	; 0x30
 80112cc:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80112d0:	e00b      	b.n	80112ea <chvprintf+0x12a>
        else if (c == '*')
 80112d2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112d6:	2b2a      	cmp	r3, #42	; 0x2a
 80112d8:	d106      	bne.n	80112e8 <chvprintf+0x128>
          c = va_arg(ap, int);
 80112da:	9b01      	ldr	r3, [sp, #4]
 80112dc:	1d1a      	adds	r2, r3, #4
 80112de:	9201      	str	r2, [sp, #4]
 80112e0:	681b      	ldr	r3, [r3, #0]
 80112e2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80112e6:	e000      	b.n	80112ea <chvprintf+0x12a>
        else
          break;
 80112e8:	e00b      	b.n	8011302 <chvprintf+0x142>
        precision *= 10;
 80112ea:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80112ec:	4613      	mov	r3, r2
 80112ee:	009b      	lsls	r3, r3, #2
 80112f0:	4413      	add	r3, r2
 80112f2:	005b      	lsls	r3, r3, #1
 80112f4:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 80112f6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112fa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80112fc:	4413      	add	r3, r2
 80112fe:	930b      	str	r3, [sp, #44]	; 0x2c
      }
 8011300:	e7d3      	b.n	80112aa <chvprintf+0xea>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8011302:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011306:	2b6c      	cmp	r3, #108	; 0x6c
 8011308:	d003      	beq.n	8011312 <chvprintf+0x152>
 801130a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801130e:	2b4c      	cmp	r3, #76	; 0x4c
 8011310:	d10e      	bne.n	8011330 <chvprintf+0x170>
      is_long = TRUE;
 8011312:	2301      	movs	r3, #1
 8011314:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 8011318:	9b02      	ldr	r3, [sp, #8]
 801131a:	781b      	ldrb	r3, [r3, #0]
 801131c:	2b00      	cmp	r3, #0
 801131e:	d006      	beq.n	801132e <chvprintf+0x16e>
        c = *fmt++;
 8011320:	9b02      	ldr	r3, [sp, #8]
 8011322:	1c5a      	adds	r2, r3, #1
 8011324:	9202      	str	r2, [sp, #8]
 8011326:	781b      	ldrb	r3, [r3, #0]
 8011328:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
 801132c:	e013      	b.n	8011356 <chvprintf+0x196>
 801132e:	e012      	b.n	8011356 <chvprintf+0x196>
        c = *fmt++;
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8011330:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011334:	2b40      	cmp	r3, #64	; 0x40
 8011336:	d905      	bls.n	8011344 <chvprintf+0x184>
 8011338:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801133c:	2b5a      	cmp	r3, #90	; 0x5a
 801133e:	d801      	bhi.n	8011344 <chvprintf+0x184>
 8011340:	2301      	movs	r3, #1
 8011342:	e000      	b.n	8011346 <chvprintf+0x186>
 8011344:	2300      	movs	r3, #0
 8011346:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 801134a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 801134e:	f003 0301 	and.w	r3, r3, #1
 8011352:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23

    /* Command decoding.*/
    switch (c) {
 8011356:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801135a:	3b44      	subs	r3, #68	; 0x44
 801135c:	2b34      	cmp	r3, #52	; 0x34
 801135e:	f200 80e2 	bhi.w	8011526 <chvprintf+0x366>
 8011362:	a201      	add	r2, pc, #4	; (adr r2, 8011368 <chvprintf+0x1a8>)
 8011364:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011368:	0801149f 	.word	0x0801149f
 801136c:	08011527 	.word	0x08011527
 8011370:	08011527 	.word	0x08011527
 8011374:	08011527 	.word	0x08011527
 8011378:	08011527 	.word	0x08011527
 801137c:	0801149f 	.word	0x0801149f
 8011380:	08011527 	.word	0x08011527
 8011384:	08011527 	.word	0x08011527
 8011388:	08011527 	.word	0x08011527
 801138c:	08011527 	.word	0x08011527
 8011390:	08011527 	.word	0x08011527
 8011394:	080114f1 	.word	0x080114f1
 8011398:	08011527 	.word	0x08011527
 801139c:	08011527 	.word	0x08011527
 80113a0:	08011527 	.word	0x08011527
 80113a4:	08011527 	.word	0x08011527
 80113a8:	08011527 	.word	0x08011527
 80113ac:	080114e9 	.word	0x080114e9
 80113b0:	08011527 	.word	0x08011527
 80113b4:	08011527 	.word	0x08011527
 80113b8:	080114e1 	.word	0x080114e1
 80113bc:	08011527 	.word	0x08011527
 80113c0:	08011527 	.word	0x08011527
 80113c4:	08011527 	.word	0x08011527
 80113c8:	08011527 	.word	0x08011527
 80113cc:	08011527 	.word	0x08011527
 80113d0:	08011527 	.word	0x08011527
 80113d4:	08011527 	.word	0x08011527
 80113d8:	08011527 	.word	0x08011527
 80113dc:	08011527 	.word	0x08011527
 80113e0:	08011527 	.word	0x08011527
 80113e4:	0801143d 	.word	0x0801143d
 80113e8:	0801149f 	.word	0x0801149f
 80113ec:	08011527 	.word	0x08011527
 80113f0:	08011527 	.word	0x08011527
 80113f4:	08011527 	.word	0x08011527
 80113f8:	08011527 	.word	0x08011527
 80113fc:	0801149f 	.word	0x0801149f
 8011400:	08011527 	.word	0x08011527
 8011404:	08011527 	.word	0x08011527
 8011408:	08011527 	.word	0x08011527
 801140c:	08011527 	.word	0x08011527
 8011410:	08011527 	.word	0x08011527
 8011414:	080114f1 	.word	0x080114f1
 8011418:	08011527 	.word	0x08011527
 801141c:	08011527 	.word	0x08011527
 8011420:	08011527 	.word	0x08011527
 8011424:	08011457 	.word	0x08011457
 8011428:	08011527 	.word	0x08011527
 801142c:	080114e9 	.word	0x080114e9
 8011430:	08011527 	.word	0x08011527
 8011434:	08011527 	.word	0x08011527
 8011438:	080114e1 	.word	0x080114e1
    case 'c':
      filler = ' ';
 801143c:	2320      	movs	r3, #32
 801143e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 8011442:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011444:	1c5a      	adds	r2, r3, #1
 8011446:	920f      	str	r2, [sp, #60]	; 0x3c
 8011448:	9a01      	ldr	r2, [sp, #4]
 801144a:	1d11      	adds	r1, r2, #4
 801144c:	9101      	str	r1, [sp, #4]
 801144e:	6812      	ldr	r2, [r2, #0]
 8011450:	b2d2      	uxtb	r2, r2
 8011452:	701a      	strb	r2, [r3, #0]
      break;
 8011454:	e06e      	b.n	8011534 <chvprintf+0x374>
    case 's':
      filler = ' ';
 8011456:	2320      	movs	r3, #32
 8011458:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 801145c:	9b01      	ldr	r3, [sp, #4]
 801145e:	1d1a      	adds	r2, r3, #4
 8011460:	9201      	str	r2, [sp, #4]
 8011462:	681b      	ldr	r3, [r3, #0]
 8011464:	930e      	str	r3, [sp, #56]	; 0x38
 8011466:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011468:	2b00      	cmp	r3, #0
 801146a:	d101      	bne.n	8011470 <chvprintf+0x2b0>
        s = "(null)";
 801146c:	4b68      	ldr	r3, [pc, #416]	; (8011610 <chvprintf+0x450>)
 801146e:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 8011470:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011472:	2b00      	cmp	r3, #0
 8011474:	d102      	bne.n	801147c <chvprintf+0x2bc>
        precision = 32767;
 8011476:	f647 73ff 	movw	r3, #32767	; 0x7fff
 801147a:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 801147c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801147e:	930f      	str	r3, [sp, #60]	; 0x3c
 8011480:	e002      	b.n	8011488 <chvprintf+0x2c8>
 8011482:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011484:	3301      	adds	r3, #1
 8011486:	930f      	str	r3, [sp, #60]	; 0x3c
 8011488:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801148a:	781b      	ldrb	r3, [r3, #0]
 801148c:	2b00      	cmp	r3, #0
 801148e:	d005      	beq.n	801149c <chvprintf+0x2dc>
 8011490:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011492:	3b01      	subs	r3, #1
 8011494:	930b      	str	r3, [sp, #44]	; 0x2c
 8011496:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011498:	2b00      	cmp	r3, #0
 801149a:	daf2      	bge.n	8011482 <chvprintf+0x2c2>
        ;
      break;
 801149c:	e04a      	b.n	8011534 <chvprintf+0x374>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 801149e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80114a2:	2b00      	cmp	r3, #0
 80114a4:	d005      	beq.n	80114b2 <chvprintf+0x2f2>
        l = va_arg(ap, long);
 80114a6:	9b01      	ldr	r3, [sp, #4]
 80114a8:	1d1a      	adds	r2, r3, #4
 80114aa:	9201      	str	r2, [sp, #4]
 80114ac:	681b      	ldr	r3, [r3, #0]
 80114ae:	9307      	str	r3, [sp, #28]
 80114b0:	e004      	b.n	80114bc <chvprintf+0x2fc>
      else
        l = va_arg(ap, int);
 80114b2:	9b01      	ldr	r3, [sp, #4]
 80114b4:	1d1a      	adds	r2, r3, #4
 80114b6:	9201      	str	r2, [sp, #4]
 80114b8:	681b      	ldr	r3, [r3, #0]
 80114ba:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 80114bc:	9b07      	ldr	r3, [sp, #28]
 80114be:	2b00      	cmp	r3, #0
 80114c0:	da07      	bge.n	80114d2 <chvprintf+0x312>
        *p++ = '-';
 80114c2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80114c4:	1c5a      	adds	r2, r3, #1
 80114c6:	920f      	str	r2, [sp, #60]	; 0x3c
 80114c8:	222d      	movs	r2, #45	; 0x2d
 80114ca:	701a      	strb	r2, [r3, #0]
        l = -l;
 80114cc:	9b07      	ldr	r3, [sp, #28]
 80114ce:	425b      	negs	r3, r3
 80114d0:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 80114d2:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80114d4:	9907      	ldr	r1, [sp, #28]
 80114d6:	220a      	movs	r2, #10
 80114d8:	f7ff fe62 	bl	80111a0 <ch_ltoa>
 80114dc:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 80114de:	e029      	b.n	8011534 <chvprintf+0x374>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 80114e0:	2310      	movs	r3, #16
 80114e2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 80114e6:	e006      	b.n	80114f6 <chvprintf+0x336>
    case 'U':
    case 'u':
      c = 10;
 80114e8:	230a      	movs	r3, #10
 80114ea:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 80114ee:	e002      	b.n	80114f6 <chvprintf+0x336>
    case 'O':
    case 'o':
      c = 8;
 80114f0:	2308      	movs	r3, #8
 80114f2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 80114f6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80114fa:	2b00      	cmp	r3, #0
 80114fc:	d005      	beq.n	801150a <chvprintf+0x34a>
        l = va_arg(ap, unsigned long);
 80114fe:	9b01      	ldr	r3, [sp, #4]
 8011500:	1d1a      	adds	r2, r3, #4
 8011502:	9201      	str	r2, [sp, #4]
 8011504:	681b      	ldr	r3, [r3, #0]
 8011506:	9307      	str	r3, [sp, #28]
 8011508:	e004      	b.n	8011514 <chvprintf+0x354>
      else
        l = va_arg(ap, unsigned int);
 801150a:	9b01      	ldr	r3, [sp, #4]
 801150c:	1d1a      	adds	r2, r3, #4
 801150e:	9201      	str	r2, [sp, #4]
 8011510:	681b      	ldr	r3, [r3, #0]
 8011512:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 8011514:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011518:	980f      	ldr	r0, [sp, #60]	; 0x3c
 801151a:	9907      	ldr	r1, [sp, #28]
 801151c:	461a      	mov	r2, r3
 801151e:	f7ff fe3f 	bl	80111a0 <ch_ltoa>
 8011522:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 8011524:	e006      	b.n	8011534 <chvprintf+0x374>
    default:
      *p++ = c;
 8011526:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011528:	1c5a      	adds	r2, r3, #1
 801152a:	920f      	str	r2, [sp, #60]	; 0x3c
 801152c:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8011530:	701a      	strb	r2, [r3, #0]
      break;
 8011532:	bf00      	nop
    }
    i = (int)(p - s);
 8011534:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8011536:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011538:	1ad3      	subs	r3, r2, r3
 801153a:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 801153c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801153e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011540:	1ad3      	subs	r3, r2, r3
 8011542:	930a      	str	r3, [sp, #40]	; 0x28
 8011544:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011546:	2b00      	cmp	r3, #0
 8011548:	da01      	bge.n	801154e <chvprintf+0x38e>
      width = 0;
 801154a:	2300      	movs	r3, #0
 801154c:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 801154e:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 8011552:	f083 0301 	eor.w	r3, r3, #1
 8011556:	b2db      	uxtb	r3, r3
 8011558:	2b00      	cmp	r3, #0
 801155a:	d002      	beq.n	8011562 <chvprintf+0x3a2>
      width = -width;
 801155c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801155e:	425b      	negs	r3, r3
 8011560:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 8011562:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011564:	2b00      	cmp	r3, #0
 8011566:	da28      	bge.n	80115ba <chvprintf+0x3fa>
      if (*s == '-' && filler == '0') {
 8011568:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801156a:	781b      	ldrb	r3, [r3, #0]
 801156c:	2b2d      	cmp	r3, #45	; 0x2d
 801156e:	d113      	bne.n	8011598 <chvprintf+0x3d8>
 8011570:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 8011574:	2b30      	cmp	r3, #48	; 0x30
 8011576:	d10f      	bne.n	8011598 <chvprintf+0x3d8>
        streamPut(chp, (uint8_t)*s++);
 8011578:	9b03      	ldr	r3, [sp, #12]
 801157a:	681b      	ldr	r3, [r3, #0]
 801157c:	689a      	ldr	r2, [r3, #8]
 801157e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011580:	1c59      	adds	r1, r3, #1
 8011582:	910e      	str	r1, [sp, #56]	; 0x38
 8011584:	781b      	ldrb	r3, [r3, #0]
 8011586:	9803      	ldr	r0, [sp, #12]
 8011588:	4619      	mov	r1, r3
 801158a:	4790      	blx	r2
        n++;
 801158c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801158e:	3301      	adds	r3, #1
 8011590:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 8011592:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011594:	3b01      	subs	r3, #1
 8011596:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8011598:	9b03      	ldr	r3, [sp, #12]
 801159a:	681b      	ldr	r3, [r3, #0]
 801159c:	689b      	ldr	r3, [r3, #8]
 801159e:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80115a2:	9803      	ldr	r0, [sp, #12]
 80115a4:	4611      	mov	r1, r2
 80115a6:	4798      	blx	r3
        n++;
 80115a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80115aa:	3301      	adds	r3, #1
 80115ac:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 80115ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80115b0:	3301      	adds	r3, #1
 80115b2:	930a      	str	r3, [sp, #40]	; 0x28
 80115b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80115b6:	2b00      	cmp	r3, #0
 80115b8:	d1ee      	bne.n	8011598 <chvprintf+0x3d8>
    }
    while (--i >= 0) {
 80115ba:	e00c      	b.n	80115d6 <chvprintf+0x416>
      streamPut(chp, (uint8_t)*s++);
 80115bc:	9b03      	ldr	r3, [sp, #12]
 80115be:	681b      	ldr	r3, [r3, #0]
 80115c0:	689a      	ldr	r2, [r3, #8]
 80115c2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80115c4:	1c59      	adds	r1, r3, #1
 80115c6:	910e      	str	r1, [sp, #56]	; 0x38
 80115c8:	781b      	ldrb	r3, [r3, #0]
 80115ca:	9803      	ldr	r0, [sp, #12]
 80115cc:	4619      	mov	r1, r3
 80115ce:	4790      	blx	r2
      n++;
 80115d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80115d2:	3301      	adds	r3, #1
 80115d4:	9309      	str	r3, [sp, #36]	; 0x24
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80115d6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80115d8:	3b01      	subs	r3, #1
 80115da:	930c      	str	r3, [sp, #48]	; 0x30
 80115dc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80115de:	2b00      	cmp	r3, #0
 80115e0:	daec      	bge.n	80115bc <chvprintf+0x3fc>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80115e2:	e00d      	b.n	8011600 <chvprintf+0x440>
      streamPut(chp, (uint8_t)filler);
 80115e4:	9b03      	ldr	r3, [sp, #12]
 80115e6:	681b      	ldr	r3, [r3, #0]
 80115e8:	689b      	ldr	r3, [r3, #8]
 80115ea:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80115ee:	9803      	ldr	r0, [sp, #12]
 80115f0:	4611      	mov	r1, r2
 80115f2:	4798      	blx	r3
      n++;
 80115f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80115f6:	3301      	adds	r3, #1
 80115f8:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 80115fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80115fc:	3b01      	subs	r3, #1
 80115fe:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8011600:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011602:	2b00      	cmp	r3, #0
 8011604:	d1ee      	bne.n	80115e4 <chvprintf+0x424>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
 8011606:	e5e2      	b.n	80111ce <chvprintf+0xe>
}
 8011608:	4618      	mov	r0, r3
 801160a:	b011      	add	sp, #68	; 0x44
 801160c:	f85d fb04 	ldr.w	pc, [sp], #4
 8011610:	0801b9e0 	.word	0x0801b9e0
 8011614:	f3af 8000 	nop.w
 8011618:	f3af 8000 	nop.w
 801161c:	f3af 8000 	nop.w

08011620 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8011620:	b40e      	push	{r1, r2, r3}
 8011622:	b500      	push	{lr}
 8011624:	b084      	sub	sp, #16
 8011626:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8011628:	ab06      	add	r3, sp, #24
 801162a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 801162c:	9801      	ldr	r0, [sp, #4]
 801162e:	9905      	ldr	r1, [sp, #20]
 8011630:	9a02      	ldr	r2, [sp, #8]
 8011632:	f7ff fdc5 	bl	80111c0 <chvprintf>
 8011636:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8011638:	9b03      	ldr	r3, [sp, #12]
}
 801163a:	4618      	mov	r0, r3
 801163c:	b004      	add	sp, #16
 801163e:	f85d eb04 	ldr.w	lr, [sp], #4
 8011642:	b003      	add	sp, #12
 8011644:	4770      	bx	lr
 8011646:	bf00      	nop
 8011648:	f3af 8000 	nop.w
 801164c:	f3af 8000 	nop.w

08011650 <chsnprintf>:
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 8011650:	b40c      	push	{r2, r3}
 8011652:	b500      	push	{lr}
 8011654:	b08d      	sub	sp, #52	; 0x34
 8011656:	9001      	str	r0, [sp, #4]
 8011658:	9100      	str	r1, [sp, #0]
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 801165a:	9b00      	ldr	r3, [sp, #0]
 801165c:	2b00      	cmp	r3, #0
 801165e:	d003      	beq.n	8011668 <chsnprintf+0x18>
    size_wo_nul = size - 1;
 8011660:	9b00      	ldr	r3, [sp, #0]
 8011662:	3b01      	subs	r3, #1
 8011664:	930b      	str	r3, [sp, #44]	; 0x2c
 8011666:	e001      	b.n	801166c <chsnprintf+0x1c>
  else
    size_wo_nul = 0;
 8011668:	2300      	movs	r3, #0
 801166a:	930b      	str	r3, [sp, #44]	; 0x2c

  /* Memory stream object to be used as a string writer, reserving one
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);
 801166c:	ab03      	add	r3, sp, #12
 801166e:	4618      	mov	r0, r3
 8011670:	9901      	ldr	r1, [sp, #4]
 8011672:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8011674:	2300      	movs	r3, #0
 8011676:	f7ff fd2b 	bl	80110d0 <msObjectInit>

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
 801167a:	ab03      	add	r3, sp, #12
 801167c:	930a      	str	r3, [sp, #40]	; 0x28
  va_start(ap, fmt);
 801167e:	ab0f      	add	r3, sp, #60	; 0x3c
 8011680:	9308      	str	r3, [sp, #32]
  retval = chvprintf(chp, fmt, ap);
 8011682:	980a      	ldr	r0, [sp, #40]	; 0x28
 8011684:	990e      	ldr	r1, [sp, #56]	; 0x38
 8011686:	9a08      	ldr	r2, [sp, #32]
 8011688:	f7ff fd9a 	bl	80111c0 <chvprintf>
 801168c:	9009      	str	r0, [sp, #36]	; 0x24
  va_end(ap);

  /* Terminate with a zero, unless size==0.*/
  if (ms.eos < size)
 801168e:	9a06      	ldr	r2, [sp, #24]
 8011690:	9b00      	ldr	r3, [sp, #0]
 8011692:	429a      	cmp	r2, r3
 8011694:	d204      	bcs.n	80116a0 <chsnprintf+0x50>
      str[ms.eos] = 0;
 8011696:	9b06      	ldr	r3, [sp, #24]
 8011698:	9a01      	ldr	r2, [sp, #4]
 801169a:	4413      	add	r3, r2
 801169c:	2200      	movs	r2, #0
 801169e:	701a      	strb	r2, [r3, #0]

  /* Return number of bytes that would have been written.*/
  return retval;
 80116a0:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 80116a2:	4618      	mov	r0, r3
 80116a4:	b00d      	add	sp, #52	; 0x34
 80116a6:	f85d eb04 	ldr.w	lr, [sp], #4
 80116aa:	b002      	add	sp, #8
 80116ac:	4770      	bx	lr
 80116ae:	bf00      	nop

080116b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80116b0:	b082      	sub	sp, #8
 80116b2:	2320      	movs	r3, #32
 80116b4:	9301      	str	r3, [sp, #4]
 80116b6:	9b01      	ldr	r3, [sp, #4]
 80116b8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80116bc:	b002      	add	sp, #8
 80116be:	4770      	bx	lr

080116c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80116c0:	b082      	sub	sp, #8
 80116c2:	2300      	movs	r3, #0
 80116c4:	9301      	str	r3, [sp, #4]
 80116c6:	9b01      	ldr	r3, [sp, #4]
 80116c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80116cc:	b002      	add	sp, #8
 80116ce:	4770      	bx	lr

080116d0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80116d0:	b508      	push	{r3, lr}

  port_lock();
 80116d2:	f7ff ffed 	bl	80116b0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80116d6:	bd08      	pop	{r3, pc}
 80116d8:	f3af 8000 	nop.w
 80116dc:	f3af 8000 	nop.w

080116e0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80116e0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80116e2:	f7ff ffed 	bl	80116c0 <port_unlock>
}
 80116e6:	bd08      	pop	{r3, pc}
 80116e8:	f3af 8000 	nop.w
 80116ec:	f3af 8000 	nop.w

080116f0 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 80116f0:	4b01      	ldr	r3, [pc, #4]	; (80116f8 <chVTGetSystemTimeX+0x8>)
 80116f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80116f4:	4618      	mov	r0, r3
 80116f6:	4770      	bx	lr
 80116f8:	200039a8 	.word	0x200039a8
 80116fc:	f3af 8000 	nop.w

08011700 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8011700:	b500      	push	{lr}
 8011702:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8011704:	f7ff ffe4 	bl	80116d0 <chSysLock>
  systime = chVTGetSystemTimeX();
 8011708:	f7ff fff2 	bl	80116f0 <chVTGetSystemTimeX>
 801170c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 801170e:	f7ff ffe7 	bl	80116e0 <chSysUnlock>

  return systime;
 8011712:	9b01      	ldr	r3, [sp, #4]
}
 8011714:	4618      	mov	r0, r3
 8011716:	b003      	add	sp, #12
 8011718:	f85d fb04 	ldr.w	pc, [sp], #4
 801171c:	f3af 8000 	nop.w

08011720 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8011720:	b082      	sub	sp, #8
 8011722:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8011724:	4b02      	ldr	r3, [pc, #8]	; (8011730 <chRegSetThreadName+0x10>)
 8011726:	699b      	ldr	r3, [r3, #24]
 8011728:	9a01      	ldr	r2, [sp, #4]
 801172a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 801172c:	b002      	add	sp, #8
 801172e:	4770      	bx	lr
 8011730:	200039a8 	.word	0x200039a8
 8011734:	f3af 8000 	nop.w
 8011738:	f3af 8000 	nop.w
 801173c:	f3af 8000 	nop.w

08011740 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8011740:	b082      	sub	sp, #8
 8011742:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8011744:	9b01      	ldr	r3, [sp, #4]
 8011746:	9a01      	ldr	r2, [sp, #4]
 8011748:	601a      	str	r2, [r3, #0]
}
 801174a:	b002      	add	sp, #8
 801174c:	4770      	bx	lr
 801174e:	bf00      	nop

08011750 <chEvtBroadcastI>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 8011750:	b500      	push	{lr}
 8011752:	b083      	sub	sp, #12
 8011754:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8011756:	9801      	ldr	r0, [sp, #4]
 8011758:	2100      	movs	r1, #0
 801175a:	f7f0 ff91 	bl	8002680 <chEvtBroadcastFlagsI>
}
 801175e:	b003      	add	sp, #12
 8011760:	f85d fb04 	ldr.w	pc, [sp], #4
 8011764:	f3af 8000 	nop.w
 8011768:	f3af 8000 	nop.w
 801176c:	f3af 8000 	nop.w

08011770 <_strtok>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8011770:	b500      	push	{lr}
 8011772:	b087      	sub	sp, #28
 8011774:	9003      	str	r0, [sp, #12]
 8011776:	9102      	str	r1, [sp, #8]
 8011778:	9201      	str	r2, [sp, #4]
  char *token;
  if (str)
 801177a:	9b03      	ldr	r3, [sp, #12]
 801177c:	2b00      	cmp	r3, #0
 801177e:	d002      	beq.n	8011786 <_strtok+0x16>
    *saveptr = str;
 8011780:	9b01      	ldr	r3, [sp, #4]
 8011782:	9a03      	ldr	r2, [sp, #12]
 8011784:	601a      	str	r2, [r3, #0]
  token = *saveptr;
 8011786:	9b01      	ldr	r3, [sp, #4]
 8011788:	681b      	ldr	r3, [r3, #0]
 801178a:	9305      	str	r3, [sp, #20]

  if (!token)
 801178c:	9b05      	ldr	r3, [sp, #20]
 801178e:	2b00      	cmp	r3, #0
 8011790:	d101      	bne.n	8011796 <_strtok+0x26>
    return NULL;
 8011792:	2300      	movs	r3, #0
 8011794:	e020      	b.n	80117d8 <_strtok+0x68>

  token += strspn(token, delim);
 8011796:	9805      	ldr	r0, [sp, #20]
 8011798:	9902      	ldr	r1, [sp, #8]
 801179a:	f007 f811 	bl	80187c0 <strspn>
 801179e:	4603      	mov	r3, r0
 80117a0:	9a05      	ldr	r2, [sp, #20]
 80117a2:	4413      	add	r3, r2
 80117a4:	9305      	str	r3, [sp, #20]
  *saveptr = strpbrk(token, delim);
 80117a6:	9805      	ldr	r0, [sp, #20]
 80117a8:	9902      	ldr	r1, [sp, #8]
 80117aa:	f006 ffe1 	bl	8018770 <strpbrk>
 80117ae:	4602      	mov	r2, r0
 80117b0:	9b01      	ldr	r3, [sp, #4]
 80117b2:	601a      	str	r2, [r3, #0]
  if (*saveptr)
 80117b4:	9b01      	ldr	r3, [sp, #4]
 80117b6:	681b      	ldr	r3, [r3, #0]
 80117b8:	2b00      	cmp	r3, #0
 80117ba:	d006      	beq.n	80117ca <_strtok+0x5a>
    *(*saveptr)++ = '\0';
 80117bc:	9b01      	ldr	r3, [sp, #4]
 80117be:	681b      	ldr	r3, [r3, #0]
 80117c0:	1c59      	adds	r1, r3, #1
 80117c2:	9a01      	ldr	r2, [sp, #4]
 80117c4:	6011      	str	r1, [r2, #0]
 80117c6:	2200      	movs	r2, #0
 80117c8:	701a      	strb	r2, [r3, #0]

  return *token ? token : NULL;
 80117ca:	9b05      	ldr	r3, [sp, #20]
 80117cc:	781b      	ldrb	r3, [r3, #0]
 80117ce:	2b00      	cmp	r3, #0
 80117d0:	d001      	beq.n	80117d6 <_strtok+0x66>
 80117d2:	9b05      	ldr	r3, [sp, #20]
 80117d4:	e000      	b.n	80117d8 <_strtok+0x68>
 80117d6:	2300      	movs	r3, #0
}
 80117d8:	4618      	mov	r0, r3
 80117da:	b007      	add	sp, #28
 80117dc:	f85d fb04 	ldr.w	pc, [sp], #4

080117e0 <usage>:

static void usage(BaseSequentialStream *chp, char *p) {
 80117e0:	b500      	push	{lr}
 80117e2:	b083      	sub	sp, #12
 80117e4:	9001      	str	r0, [sp, #4]
 80117e6:	9100      	str	r1, [sp, #0]

  chprintf(chp, "Usage: %s\r\n", p);
 80117e8:	9801      	ldr	r0, [sp, #4]
 80117ea:	4903      	ldr	r1, [pc, #12]	; (80117f8 <usage+0x18>)
 80117ec:	9a00      	ldr	r2, [sp, #0]
 80117ee:	f7ff ff17 	bl	8011620 <chprintf>
}
 80117f2:	b003      	add	sp, #12
 80117f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80117f8:	0801b9f0 	.word	0x0801b9f0
 80117fc:	f3af 8000 	nop.w

08011800 <list_commands>:

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {
 8011800:	b500      	push	{lr}
 8011802:	b083      	sub	sp, #12
 8011804:	9001      	str	r0, [sp, #4]
 8011806:	9100      	str	r1, [sp, #0]

  while (scp->sc_name != NULL) {
 8011808:	e009      	b.n	801181e <list_commands+0x1e>
    chprintf(chp, "%s ", scp->sc_name);
 801180a:	9b00      	ldr	r3, [sp, #0]
 801180c:	681b      	ldr	r3, [r3, #0]
 801180e:	9801      	ldr	r0, [sp, #4]
 8011810:	4906      	ldr	r1, [pc, #24]	; (801182c <list_commands+0x2c>)
 8011812:	461a      	mov	r2, r3
 8011814:	f7ff ff04 	bl	8011620 <chprintf>
    scp++;
 8011818:	9b00      	ldr	r3, [sp, #0]
 801181a:	3308      	adds	r3, #8
 801181c:	9300      	str	r3, [sp, #0]
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 801181e:	9b00      	ldr	r3, [sp, #0]
 8011820:	681b      	ldr	r3, [r3, #0]
 8011822:	2b00      	cmp	r3, #0
 8011824:	d1f1      	bne.n	801180a <list_commands+0xa>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}
 8011826:	b003      	add	sp, #12
 8011828:	f85d fb04 	ldr.w	pc, [sp], #4
 801182c:	0801b9fc 	.word	0x0801b9fc

08011830 <cmd_info>:

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8011830:	b500      	push	{lr}
 8011832:	b087      	sub	sp, #28
 8011834:	9005      	str	r0, [sp, #20]
 8011836:	9104      	str	r1, [sp, #16]
 8011838:	9203      	str	r2, [sp, #12]

  (void)argv;
  if (argc > 0) {
 801183a:	9b04      	ldr	r3, [sp, #16]
 801183c:	2b00      	cmp	r3, #0
 801183e:	dd04      	ble.n	801184a <cmd_info+0x1a>
    usage(chp, "info");
 8011840:	9805      	ldr	r0, [sp, #20]
 8011842:	4919      	ldr	r1, [pc, #100]	; (80118a8 <cmd_info+0x78>)
 8011844:	f7ff ffcc 	bl	80117e0 <usage>
    return;
 8011848:	e02a      	b.n	80118a0 <cmd_info+0x70>
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 801184a:	9805      	ldr	r0, [sp, #20]
 801184c:	4917      	ldr	r1, [pc, #92]	; (80118ac <cmd_info+0x7c>)
 801184e:	4a18      	ldr	r2, [pc, #96]	; (80118b0 <cmd_info+0x80>)
 8011850:	f7ff fee6 	bl	8011620 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 8011854:	9805      	ldr	r0, [sp, #20]
 8011856:	4917      	ldr	r1, [pc, #92]	; (80118b4 <cmd_info+0x84>)
 8011858:	4a17      	ldr	r2, [pc, #92]	; (80118b8 <cmd_info+0x88>)
 801185a:	f7ff fee1 	bl	8011620 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 801185e:	9805      	ldr	r0, [sp, #20]
 8011860:	4916      	ldr	r1, [pc, #88]	; (80118bc <cmd_info+0x8c>)
 8011862:	4a17      	ldr	r2, [pc, #92]	; (80118c0 <cmd_info+0x90>)
 8011864:	f7ff fedc 	bl	8011620 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 8011868:	9805      	ldr	r0, [sp, #20]
 801186a:	4916      	ldr	r1, [pc, #88]	; (80118c4 <cmd_info+0x94>)
 801186c:	4a16      	ldr	r2, [pc, #88]	; (80118c8 <cmd_info+0x98>)
 801186e:	f7ff fed7 	bl	8011620 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 8011872:	9805      	ldr	r0, [sp, #20]
 8011874:	4915      	ldr	r1, [pc, #84]	; (80118cc <cmd_info+0x9c>)
 8011876:	4a16      	ldr	r2, [pc, #88]	; (80118d0 <cmd_info+0xa0>)
 8011878:	f7ff fed2 	bl	8011620 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 801187c:	9805      	ldr	r0, [sp, #20]
 801187e:	4915      	ldr	r1, [pc, #84]	; (80118d4 <cmd_info+0xa4>)
 8011880:	4a15      	ldr	r2, [pc, #84]	; (80118d8 <cmd_info+0xa8>)
 8011882:	f7ff fecd 	bl	8011620 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 8011886:	9805      	ldr	r0, [sp, #20]
 8011888:	4914      	ldr	r1, [pc, #80]	; (80118dc <cmd_info+0xac>)
 801188a:	4a15      	ldr	r2, [pc, #84]	; (80118e0 <cmd_info+0xb0>)
 801188c:	f7ff fec8 	bl	8011620 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 8011890:	4b14      	ldr	r3, [pc, #80]	; (80118e4 <cmd_info+0xb4>)
 8011892:	9300      	str	r3, [sp, #0]
 8011894:	9805      	ldr	r0, [sp, #20]
 8011896:	4914      	ldr	r1, [pc, #80]	; (80118e8 <cmd_info+0xb8>)
 8011898:	4a14      	ldr	r2, [pc, #80]	; (80118ec <cmd_info+0xbc>)
 801189a:	4b15      	ldr	r3, [pc, #84]	; (80118f0 <cmd_info+0xc0>)
 801189c:	f7ff fec0 	bl	8011620 <chprintf>
#endif
#endif
}
 80118a0:	b007      	add	sp, #28
 80118a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80118a6:	bf00      	nop
 80118a8:	0801ba00 	.word	0x0801ba00
 80118ac:	0801ba08 	.word	0x0801ba08
 80118b0:	0801ba1c 	.word	0x0801ba1c
 80118b4:	0801ba24 	.word	0x0801ba24
 80118b8:	0801ba38 	.word	0x0801ba38
 80118bc:	0801ba80 	.word	0x0801ba80
 80118c0:	0801ba94 	.word	0x0801ba94
 80118c4:	0801baa0 	.word	0x0801baa0
 80118c8:	0801bab4 	.word	0x0801bab4
 80118cc:	0801bac0 	.word	0x0801bac0
 80118d0:	0801bad4 	.word	0x0801bad4
 80118d4:	0801baec 	.word	0x0801baec
 80118d8:	0801bb00 	.word	0x0801bb00
 80118dc:	0801bb1c 	.word	0x0801bb1c
 80118e0:	0801bb30 	.word	0x0801bb30
 80118e4:	0801bb68 	.word	0x0801bb68
 80118e8:	0801bb40 	.word	0x0801bb40
 80118ec:	0801bb58 	.word	0x0801bb58
 80118f0:	0801bb64 	.word	0x0801bb64
 80118f4:	f3af 8000 	nop.w
 80118f8:	f3af 8000 	nop.w
 80118fc:	f3af 8000 	nop.w

08011900 <cmd_systime>:

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 8011900:	b500      	push	{lr}
 8011902:	b085      	sub	sp, #20
 8011904:	9003      	str	r0, [sp, #12]
 8011906:	9102      	str	r1, [sp, #8]
 8011908:	9201      	str	r2, [sp, #4]

  (void)argv;
  if (argc > 0) {
 801190a:	9b02      	ldr	r3, [sp, #8]
 801190c:	2b00      	cmp	r3, #0
 801190e:	dd04      	ble.n	801191a <cmd_systime+0x1a>
    usage(chp, "systime");
 8011910:	9803      	ldr	r0, [sp, #12]
 8011912:	4907      	ldr	r1, [pc, #28]	; (8011930 <cmd_systime+0x30>)
 8011914:	f7ff ff64 	bl	80117e0 <usage>
    return;
 8011918:	e007      	b.n	801192a <cmd_systime+0x2a>
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 801191a:	f7ff fef1 	bl	8011700 <chVTGetSystemTime>
 801191e:	4603      	mov	r3, r0
 8011920:	9803      	ldr	r0, [sp, #12]
 8011922:	4904      	ldr	r1, [pc, #16]	; (8011934 <cmd_systime+0x34>)
 8011924:	461a      	mov	r2, r3
 8011926:	f7ff fe7b 	bl	8011620 <chprintf>
}
 801192a:	b005      	add	sp, #20
 801192c:	f85d fb04 	ldr.w	pc, [sp], #4
 8011930:	0801bb74 	.word	0x0801bb74
 8011934:	0801bb7c 	.word	0x0801bb7c
 8011938:	f3af 8000 	nop.w
 801193c:	f3af 8000 	nop.w

08011940 <cmdexec>:
  {"systime", cmd_systime},
  {NULL, NULL}
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {
 8011940:	b500      	push	{lr}
 8011942:	b085      	sub	sp, #20
 8011944:	9003      	str	r0, [sp, #12]
 8011946:	9102      	str	r1, [sp, #8]
 8011948:	9201      	str	r2, [sp, #4]
 801194a:	9300      	str	r3, [sp, #0]

  while (scp->sc_name != NULL) {
 801194c:	e013      	b.n	8011976 <cmdexec+0x36>
    if (strcmp(scp->sc_name, name) == 0) {
 801194e:	9b03      	ldr	r3, [sp, #12]
 8011950:	681b      	ldr	r3, [r3, #0]
 8011952:	4618      	mov	r0, r3
 8011954:	9901      	ldr	r1, [sp, #4]
 8011956:	f005 fee3 	bl	8017720 <strcmp>
 801195a:	4603      	mov	r3, r0
 801195c:	2b00      	cmp	r3, #0
 801195e:	d107      	bne.n	8011970 <cmdexec+0x30>
      scp->sc_function(chp, argc, argv);
 8011960:	9b03      	ldr	r3, [sp, #12]
 8011962:	685b      	ldr	r3, [r3, #4]
 8011964:	9802      	ldr	r0, [sp, #8]
 8011966:	9900      	ldr	r1, [sp, #0]
 8011968:	9a06      	ldr	r2, [sp, #24]
 801196a:	4798      	blx	r3
      return false;
 801196c:	2300      	movs	r3, #0
 801196e:	e007      	b.n	8011980 <cmdexec+0x40>
    }
    scp++;
 8011970:	9b03      	ldr	r3, [sp, #12]
 8011972:	3308      	adds	r3, #8
 8011974:	9303      	str	r3, [sp, #12]
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8011976:	9b03      	ldr	r3, [sp, #12]
 8011978:	681b      	ldr	r3, [r3, #0]
 801197a:	2b00      	cmp	r3, #0
 801197c:	d1e7      	bne.n	801194e <cmdexec+0xe>
      scp->sc_function(chp, argc, argv);
      return false;
    }
    scp++;
  }
  return true;
 801197e:	2301      	movs	r3, #1
}
 8011980:	4618      	mov	r0, r3
 8011982:	b005      	add	sp, #20
 8011984:	f85d fb04 	ldr.w	pc, [sp], #4
 8011988:	f3af 8000 	nop.w
 801198c:	f3af 8000 	nop.w

08011990 <shell_thread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8011990:	b500      	push	{lr}
 8011992:	b0a1      	sub	sp, #132	; 0x84
 8011994:	9003      	str	r0, [sp, #12]
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 8011996:	9b03      	ldr	r3, [sp, #12]
 8011998:	681b      	ldr	r3, [r3, #0]
 801199a:	931d      	str	r3, [sp, #116]	; 0x74
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 801199c:	9b03      	ldr	r3, [sp, #12]
 801199e:	685b      	ldr	r3, [r3, #4]
 80119a0:	931c      	str	r3, [sp, #112]	; 0x70
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 80119a2:	4855      	ldr	r0, [pc, #340]	; (8011af8 <shell_thread+0x168>)
 80119a4:	f7ff febc 	bl	8011720 <chRegSetThreadName>
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 80119a8:	981d      	ldr	r0, [sp, #116]	; 0x74
 80119aa:	4954      	ldr	r1, [pc, #336]	; (8011afc <shell_thread+0x16c>)
 80119ac:	f7ff fe38 	bl	8011620 <chprintf>
  while (true) {
    chprintf(chp, "ch> ");
 80119b0:	981d      	ldr	r0, [sp, #116]	; 0x74
 80119b2:	4953      	ldr	r1, [pc, #332]	; (8011b00 <shell_thread+0x170>)
 80119b4:	f7ff fe34 	bl	8011620 <chprintf>
    if (shellGetLine(chp, line, sizeof(line))) {
 80119b8:	ab0a      	add	r3, sp, #40	; 0x28
 80119ba:	981d      	ldr	r0, [sp, #116]	; 0x74
 80119bc:	4619      	mov	r1, r3
 80119be:	2240      	movs	r2, #64	; 0x40
 80119c0:	f000 f8fe 	bl	8011bc0 <shellGetLine>
 80119c4:	4603      	mov	r3, r0
 80119c6:	2b00      	cmp	r3, #0
 80119c8:	d004      	beq.n	80119d4 <shell_thread+0x44>
      chprintf(chp, "\r\nlogout");
 80119ca:	981d      	ldr	r0, [sp, #116]	; 0x74
 80119cc:	494d      	ldr	r1, [pc, #308]	; (8011b04 <shell_thread+0x174>)
 80119ce:	f7ff fe27 	bl	8011620 <chprintf>
      break;
 80119d2:	e08a      	b.n	8011aea <shell_thread+0x15a>
    }
    lp = _strtok(line, " \t", &tokp);
 80119d4:	aa0a      	add	r2, sp, #40	; 0x28
 80119d6:	ab1a      	add	r3, sp, #104	; 0x68
 80119d8:	4610      	mov	r0, r2
 80119da:	494b      	ldr	r1, [pc, #300]	; (8011b08 <shell_thread+0x178>)
 80119dc:	461a      	mov	r2, r3
 80119de:	f7ff fec7 	bl	8011770 <_strtok>
 80119e2:	901b      	str	r0, [sp, #108]	; 0x6c
    cmd = lp;
 80119e4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80119e6:	931e      	str	r3, [sp, #120]	; 0x78
    n = 0;
 80119e8:	2300      	movs	r3, #0
 80119ea:	931f      	str	r3, [sp, #124]	; 0x7c
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 80119ec:	e012      	b.n	8011a14 <shell_thread+0x84>
      if (n >= SHELL_MAX_ARGUMENTS) {
 80119ee:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80119f0:	2b03      	cmp	r3, #3
 80119f2:	dd06      	ble.n	8011a02 <shell_thread+0x72>
        chprintf(chp, "too many arguments\r\n");
 80119f4:	981d      	ldr	r0, [sp, #116]	; 0x74
 80119f6:	4945      	ldr	r1, [pc, #276]	; (8011b0c <shell_thread+0x17c>)
 80119f8:	f7ff fe12 	bl	8011620 <chprintf>
        cmd = NULL;
 80119fc:	2300      	movs	r3, #0
 80119fe:	931e      	str	r3, [sp, #120]	; 0x78
        break;
 8011a00:	e012      	b.n	8011a28 <shell_thread+0x98>
      }
      args[n++] = lp;
 8011a02:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a04:	1c5a      	adds	r2, r3, #1
 8011a06:	921f      	str	r2, [sp, #124]	; 0x7c
 8011a08:	009b      	lsls	r3, r3, #2
 8011a0a:	aa20      	add	r2, sp, #128	; 0x80
 8011a0c:	4413      	add	r3, r2
 8011a0e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8011a10:	f843 2c6c 	str.w	r2, [r3, #-108]
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8011a14:	ab1a      	add	r3, sp, #104	; 0x68
 8011a16:	2000      	movs	r0, #0
 8011a18:	493b      	ldr	r1, [pc, #236]	; (8011b08 <shell_thread+0x178>)
 8011a1a:	461a      	mov	r2, r3
 8011a1c:	f7ff fea8 	bl	8011770 <_strtok>
 8011a20:	901b      	str	r0, [sp, #108]	; 0x6c
 8011a22:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8011a24:	2b00      	cmp	r3, #0
 8011a26:	d1e2      	bne.n	80119ee <shell_thread+0x5e>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8011a28:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a2a:	009b      	lsls	r3, r3, #2
 8011a2c:	aa20      	add	r2, sp, #128	; 0x80
 8011a2e:	4413      	add	r3, r2
 8011a30:	2200      	movs	r2, #0
 8011a32:	f843 2c6c 	str.w	r2, [r3, #-108]
    if (cmd != NULL) {
 8011a36:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8011a38:	2b00      	cmp	r3, #0
 8011a3a:	d055      	beq.n	8011ae8 <shell_thread+0x158>
      if (strcmp(cmd, "exit") == 0) {
 8011a3c:	981e      	ldr	r0, [sp, #120]	; 0x78
 8011a3e:	4934      	ldr	r1, [pc, #208]	; (8011b10 <shell_thread+0x180>)
 8011a40:	f005 fe6e 	bl	8017720 <strcmp>
 8011a44:	4603      	mov	r3, r0
 8011a46:	2b00      	cmp	r3, #0
 8011a48:	d108      	bne.n	8011a5c <shell_thread+0xcc>
        if (n > 0) {
 8011a4a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a4c:	2b00      	cmp	r3, #0
 8011a4e:	dd04      	ble.n	8011a5a <shell_thread+0xca>
          usage(chp, "exit");
 8011a50:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a52:	492f      	ldr	r1, [pc, #188]	; (8011b10 <shell_thread+0x180>)
 8011a54:	f7ff fec4 	bl	80117e0 <usage>
          continue;
 8011a58:	e046      	b.n	8011ae8 <shell_thread+0x158>
        }
        break;
 8011a5a:	e046      	b.n	8011aea <shell_thread+0x15a>
      }
      else if (strcmp(cmd, "help") == 0) {
 8011a5c:	981e      	ldr	r0, [sp, #120]	; 0x78
 8011a5e:	492d      	ldr	r1, [pc, #180]	; (8011b14 <shell_thread+0x184>)
 8011a60:	f005 fe5e 	bl	8017720 <strcmp>
 8011a64:	4603      	mov	r3, r0
 8011a66:	2b00      	cmp	r3, #0
 8011a68:	d11b      	bne.n	8011aa2 <shell_thread+0x112>
        if (n > 0) {
 8011a6a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a6c:	2b00      	cmp	r3, #0
 8011a6e:	dd04      	ble.n	8011a7a <shell_thread+0xea>
          usage(chp, "help");
 8011a70:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a72:	4928      	ldr	r1, [pc, #160]	; (8011b14 <shell_thread+0x184>)
 8011a74:	f7ff feb4 	bl	80117e0 <usage>
          continue;
 8011a78:	e036      	b.n	8011ae8 <shell_thread+0x158>
        }
        chprintf(chp, "Commands: help exit ");
 8011a7a:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a7c:	4926      	ldr	r1, [pc, #152]	; (8011b18 <shell_thread+0x188>)
 8011a7e:	f7ff fdcf 	bl	8011620 <chprintf>
        list_commands(chp, local_commands);
 8011a82:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a84:	4925      	ldr	r1, [pc, #148]	; (8011b1c <shell_thread+0x18c>)
 8011a86:	f7ff febb 	bl	8011800 <list_commands>
        if (scp != NULL)
 8011a8a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8011a8c:	2b00      	cmp	r3, #0
 8011a8e:	d003      	beq.n	8011a98 <shell_thread+0x108>
          list_commands(chp, scp);
 8011a90:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a92:	991c      	ldr	r1, [sp, #112]	; 0x70
 8011a94:	f7ff feb4 	bl	8011800 <list_commands>
        chprintf(chp, "\r\n");
 8011a98:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a9a:	4921      	ldr	r1, [pc, #132]	; (8011b20 <shell_thread+0x190>)
 8011a9c:	f7ff fdc0 	bl	8011620 <chprintf>
 8011aa0:	e022      	b.n	8011ae8 <shell_thread+0x158>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8011aa2:	ab05      	add	r3, sp, #20
 8011aa4:	9300      	str	r3, [sp, #0]
 8011aa6:	481d      	ldr	r0, [pc, #116]	; (8011b1c <shell_thread+0x18c>)
 8011aa8:	991d      	ldr	r1, [sp, #116]	; 0x74
 8011aaa:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8011aac:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011aae:	f7ff ff47 	bl	8011940 <cmdexec>
 8011ab2:	4603      	mov	r3, r0
 8011ab4:	2b00      	cmp	r3, #0
 8011ab6:	d017      	beq.n	8011ae8 <shell_thread+0x158>
 8011ab8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8011aba:	2b00      	cmp	r3, #0
 8011abc:	d00a      	beq.n	8011ad4 <shell_thread+0x144>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8011abe:	ab05      	add	r3, sp, #20
 8011ac0:	9300      	str	r3, [sp, #0]
 8011ac2:	981c      	ldr	r0, [sp, #112]	; 0x70
 8011ac4:	991d      	ldr	r1, [sp, #116]	; 0x74
 8011ac6:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8011ac8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011aca:	f7ff ff39 	bl	8011940 <cmdexec>
 8011ace:	4603      	mov	r3, r0
 8011ad0:	2b00      	cmp	r3, #0
 8011ad2:	d009      	beq.n	8011ae8 <shell_thread+0x158>
        chprintf(chp, "%s", cmd);
 8011ad4:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011ad6:	4913      	ldr	r1, [pc, #76]	; (8011b24 <shell_thread+0x194>)
 8011ad8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8011ada:	f7ff fda1 	bl	8011620 <chprintf>
        chprintf(chp, " ?\r\n");
 8011ade:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011ae0:	4911      	ldr	r1, [pc, #68]	; (8011b28 <shell_thread+0x198>)
 8011ae2:	f7ff fd9d 	bl	8011620 <chprintf>
      }
    }
  }
 8011ae6:	e763      	b.n	80119b0 <shell_thread+0x20>
 8011ae8:	e762      	b.n	80119b0 <shell_thread+0x20>
  shellExit(MSG_OK);
 8011aea:	2000      	movs	r0, #0
 8011aec:	f000 f828 	bl	8011b40 <shellExit>
}
 8011af0:	b021      	add	sp, #132	; 0x84
 8011af2:	f85d fb04 	ldr.w	pc, [sp], #4
 8011af6:	bf00      	nop
 8011af8:	0801bb9c 	.word	0x0801bb9c
 8011afc:	0801bba4 	.word	0x0801bba4
 8011b00:	0801bbbc 	.word	0x0801bbbc
 8011b04:	0801bbc4 	.word	0x0801bbc4
 8011b08:	0801bbd0 	.word	0x0801bbd0
 8011b0c:	0801bbd4 	.word	0x0801bbd4
 8011b10:	0801bbec 	.word	0x0801bbec
 8011b14:	0801bbf4 	.word	0x0801bbf4
 8011b18:	0801bbfc 	.word	0x0801bbfc
 8011b1c:	0801bb84 	.word	0x0801bb84
 8011b20:	0801bc14 	.word	0x0801bc14
 8011b24:	0801bc18 	.word	0x0801bc18
 8011b28:	0801bc1c 	.word	0x0801bc1c
 8011b2c:	f3af 8000 	nop.w

08011b30 <shellInit>:
/**
 * @brief   Shell manager initialization.
 *
 * @api
 */
void shellInit(void) {
 8011b30:	b508      	push	{r3, lr}

  chEvtObjectInit(&shell_terminated);
 8011b32:	4802      	ldr	r0, [pc, #8]	; (8011b3c <shellInit+0xc>)
 8011b34:	f7ff fe04 	bl	8011740 <chEvtObjectInit>
}
 8011b38:	bd08      	pop	{r3, pc}
 8011b3a:	bf00      	nop
 8011b3c:	200044b8 	.word	0x200044b8

08011b40 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 8011b40:	b500      	push	{lr}
 8011b42:	b083      	sub	sp, #12
 8011b44:	9001      	str	r0, [sp, #4]

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
 8011b46:	f7ff fdc3 	bl	80116d0 <chSysLock>
  chEvtBroadcastI(&shell_terminated);
 8011b4a:	4804      	ldr	r0, [pc, #16]	; (8011b5c <shellExit+0x1c>)
 8011b4c:	f7ff fe00 	bl	8011750 <chEvtBroadcastI>
  chThdExitS(msg);
 8011b50:	9801      	ldr	r0, [sp, #4]
 8011b52:	f7ef fc1d 	bl	8001390 <chThdExitS>
}
 8011b56:	b003      	add	sp, #12
 8011b58:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b5c:	200044b8 	.word	0x200044b8

08011b60 <shellCreate>:
 * @retval NULL         thread creation failed because memory allocation.
 *
 * @api
 */
#if CH_CFG_USE_HEAP && CH_CFG_USE_DYNAMIC
thread_t *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
 8011b60:	b500      	push	{lr}
 8011b62:	b087      	sub	sp, #28
 8011b64:	9005      	str	r0, [sp, #20]
 8011b66:	9104      	str	r1, [sp, #16]
 8011b68:	9203      	str	r2, [sp, #12]

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
 8011b6a:	9b05      	ldr	r3, [sp, #20]
 8011b6c:	9300      	str	r3, [sp, #0]
 8011b6e:	2000      	movs	r0, #0
 8011b70:	9904      	ldr	r1, [sp, #16]
 8011b72:	9a03      	ldr	r2, [sp, #12]
 8011b74:	4b03      	ldr	r3, [pc, #12]	; (8011b84 <shellCreate+0x24>)
 8011b76:	f7ef fe6b 	bl	8001850 <chThdCreateFromHeap>
 8011b7a:	4603      	mov	r3, r0
}
 8011b7c:	4618      	mov	r0, r3
 8011b7e:	b007      	add	sp, #28
 8011b80:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b84:	08011991 	.word	0x08011991
 8011b88:	f3af 8000 	nop.w
 8011b8c:	f3af 8000 	nop.w

08011b90 <shellCreateStatic>:
 * @return              A pointer to the shell thread.
 *
 * @api
 */
thread_t *shellCreateStatic(const ShellConfig *scp, void *wsp,
                            size_t size, tprio_t prio) {
 8011b90:	b500      	push	{lr}
 8011b92:	b087      	sub	sp, #28
 8011b94:	9005      	str	r0, [sp, #20]
 8011b96:	9104      	str	r1, [sp, #16]
 8011b98:	9203      	str	r2, [sp, #12]
 8011b9a:	9302      	str	r3, [sp, #8]

  return chThdCreateStatic(wsp, size, prio, shell_thread, (void *)scp);
 8011b9c:	9b05      	ldr	r3, [sp, #20]
 8011b9e:	9300      	str	r3, [sp, #0]
 8011ba0:	9804      	ldr	r0, [sp, #16]
 8011ba2:	9903      	ldr	r1, [sp, #12]
 8011ba4:	9a02      	ldr	r2, [sp, #8]
 8011ba6:	4b04      	ldr	r3, [pc, #16]	; (8011bb8 <shellCreateStatic+0x28>)
 8011ba8:	f7ef fb1a 	bl	80011e0 <chThdCreateStatic>
 8011bac:	4603      	mov	r3, r0
}
 8011bae:	4618      	mov	r0, r3
 8011bb0:	b007      	add	sp, #28
 8011bb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8011bb6:	bf00      	nop
 8011bb8:	08011991 	.word	0x08011991
 8011bbc:	f3af 8000 	nop.w

08011bc0 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8011bc0:	b500      	push	{lr}
 8011bc2:	b087      	sub	sp, #28
 8011bc4:	9003      	str	r0, [sp, #12]
 8011bc6:	9102      	str	r1, [sp, #8]
 8011bc8:	9201      	str	r2, [sp, #4]
  char *p = line;
 8011bca:	9b02      	ldr	r3, [sp, #8]
 8011bcc:	9305      	str	r3, [sp, #20]

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 8011bce:	9b03      	ldr	r3, [sp, #12]
 8011bd0:	681b      	ldr	r3, [r3, #0]
 8011bd2:	685b      	ldr	r3, [r3, #4]
 8011bd4:	f10d 0213 	add.w	r2, sp, #19
 8011bd8:	9803      	ldr	r0, [sp, #12]
 8011bda:	4611      	mov	r1, r2
 8011bdc:	2201      	movs	r2, #1
 8011bde:	4798      	blx	r3
 8011be0:	4603      	mov	r3, r0
 8011be2:	2b00      	cmp	r3, #0
 8011be4:	d101      	bne.n	8011bea <shellGetLine+0x2a>
      return true;
 8011be6:	2301      	movs	r3, #1
 8011be8:	e055      	b.n	8011c96 <shellGetLine+0xd6>
    if (c == 4) {
 8011bea:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011bee:	2b04      	cmp	r3, #4
 8011bf0:	d105      	bne.n	8011bfe <shellGetLine+0x3e>
      chprintf(chp, "^D");
 8011bf2:	9803      	ldr	r0, [sp, #12]
 8011bf4:	492a      	ldr	r1, [pc, #168]	; (8011ca0 <shellGetLine+0xe0>)
 8011bf6:	f7ff fd13 	bl	8011620 <chprintf>
      return true;
 8011bfa:	2301      	movs	r3, #1
 8011bfc:	e04b      	b.n	8011c96 <shellGetLine+0xd6>
    }
    if ((c == 8) || (c == 127)) {
 8011bfe:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011c02:	2b08      	cmp	r3, #8
 8011c04:	d003      	beq.n	8011c0e <shellGetLine+0x4e>
 8011c06:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011c0a:	2b7f      	cmp	r3, #127	; 0x7f
 8011c0c:	d11a      	bne.n	8011c44 <shellGetLine+0x84>
      if (p != line) {
 8011c0e:	9a05      	ldr	r2, [sp, #20]
 8011c10:	9b02      	ldr	r3, [sp, #8]
 8011c12:	429a      	cmp	r2, r3
 8011c14:	d015      	beq.n	8011c42 <shellGetLine+0x82>
        chSequentialStreamPut(chp, 0x08);
 8011c16:	9b03      	ldr	r3, [sp, #12]
 8011c18:	681b      	ldr	r3, [r3, #0]
 8011c1a:	689b      	ldr	r3, [r3, #8]
 8011c1c:	9803      	ldr	r0, [sp, #12]
 8011c1e:	2108      	movs	r1, #8
 8011c20:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 8011c22:	9b03      	ldr	r3, [sp, #12]
 8011c24:	681b      	ldr	r3, [r3, #0]
 8011c26:	689b      	ldr	r3, [r3, #8]
 8011c28:	9803      	ldr	r0, [sp, #12]
 8011c2a:	2120      	movs	r1, #32
 8011c2c:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x08);
 8011c2e:	9b03      	ldr	r3, [sp, #12]
 8011c30:	681b      	ldr	r3, [r3, #0]
 8011c32:	689b      	ldr	r3, [r3, #8]
 8011c34:	9803      	ldr	r0, [sp, #12]
 8011c36:	2108      	movs	r1, #8
 8011c38:	4798      	blx	r3
        p--;
 8011c3a:	9b05      	ldr	r3, [sp, #20]
 8011c3c:	3b01      	subs	r3, #1
 8011c3e:	9305      	str	r3, [sp, #20]
      }
      continue;
 8011c40:	e028      	b.n	8011c94 <shellGetLine+0xd4>
 8011c42:	e027      	b.n	8011c94 <shellGetLine+0xd4>
    }
    if (c == '\r') {
 8011c44:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011c48:	2b0d      	cmp	r3, #13
 8011c4a:	d108      	bne.n	8011c5e <shellGetLine+0x9e>
      chprintf(chp, "\r\n");
 8011c4c:	9803      	ldr	r0, [sp, #12]
 8011c4e:	4915      	ldr	r1, [pc, #84]	; (8011ca4 <shellGetLine+0xe4>)
 8011c50:	f7ff fce6 	bl	8011620 <chprintf>
      *p = 0;
 8011c54:	9b05      	ldr	r3, [sp, #20]
 8011c56:	2200      	movs	r2, #0
 8011c58:	701a      	strb	r2, [r3, #0]
      return false;
 8011c5a:	2300      	movs	r3, #0
 8011c5c:	e01b      	b.n	8011c96 <shellGetLine+0xd6>
    }
    if (c < 0x20)
 8011c5e:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011c62:	2b1f      	cmp	r3, #31
 8011c64:	d800      	bhi.n	8011c68 <shellGetLine+0xa8>
      continue;
 8011c66:	e015      	b.n	8011c94 <shellGetLine+0xd4>
    if (p < line + size - 1) {
 8011c68:	9b01      	ldr	r3, [sp, #4]
 8011c6a:	3b01      	subs	r3, #1
 8011c6c:	9a02      	ldr	r2, [sp, #8]
 8011c6e:	441a      	add	r2, r3
 8011c70:	9b05      	ldr	r3, [sp, #20]
 8011c72:	429a      	cmp	r2, r3
 8011c74:	d90e      	bls.n	8011c94 <shellGetLine+0xd4>
      chSequentialStreamPut(chp, c);
 8011c76:	9b03      	ldr	r3, [sp, #12]
 8011c78:	681b      	ldr	r3, [r3, #0]
 8011c7a:	689b      	ldr	r3, [r3, #8]
 8011c7c:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8011c80:	9803      	ldr	r0, [sp, #12]
 8011c82:	4611      	mov	r1, r2
 8011c84:	4798      	blx	r3
      *p++ = (char)c;
 8011c86:	9b05      	ldr	r3, [sp, #20]
 8011c88:	1c5a      	adds	r2, r3, #1
 8011c8a:	9205      	str	r2, [sp, #20]
 8011c8c:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8011c90:	701a      	strb	r2, [r3, #0]
    }
  }
 8011c92:	e79c      	b.n	8011bce <shellGetLine+0xe>
 8011c94:	e79b      	b.n	8011bce <shellGetLine+0xe>
}
 8011c96:	4618      	mov	r0, r3
 8011c98:	b007      	add	sp, #28
 8011c9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8011c9e:	bf00      	nop
 8011ca0:	0801bc24 	.word	0x0801bc24
 8011ca4:	0801bc14 	.word	0x0801bc14
 8011ca8:	f3af 8000 	nop.w
 8011cac:	f3af 8000 	nop.w

08011cb0 <_read_r>:

/***************************************************************************/

__attribute__((used))
int _read_r(struct _reent *r, int file, char * ptr, int len)
{
 8011cb0:	b084      	sub	sp, #16
 8011cb2:	9003      	str	r0, [sp, #12]
 8011cb4:	9102      	str	r1, [sp, #8]
 8011cb6:	9201      	str	r2, [sp, #4]
 8011cb8:	9300      	str	r3, [sp, #0]
  return len;
#else
  (void)file;
  (void)ptr;
  (void)len;
  __errno_r(r) = EINVAL;
 8011cba:	9b03      	ldr	r3, [sp, #12]
 8011cbc:	2216      	movs	r2, #22
 8011cbe:	601a      	str	r2, [r3, #0]
  return -1;
 8011cc0:	f04f 33ff 	mov.w	r3, #4294967295
#endif
}
 8011cc4:	4618      	mov	r0, r3
 8011cc6:	b004      	add	sp, #16
 8011cc8:	4770      	bx	lr
 8011cca:	bf00      	nop
 8011ccc:	f3af 8000 	nop.w

08011cd0 <_lseek_r>:

/***************************************************************************/

__attribute__((used))
int _lseek_r(struct _reent *r, int file, int ptr, int dir)
{
 8011cd0:	b084      	sub	sp, #16
 8011cd2:	9003      	str	r0, [sp, #12]
 8011cd4:	9102      	str	r1, [sp, #8]
 8011cd6:	9201      	str	r2, [sp, #4]
 8011cd8:	9300      	str	r3, [sp, #0]
  (void)r;
  (void)file;
  (void)ptr;
  (void)dir;

  return 0;
 8011cda:	2300      	movs	r3, #0
}
 8011cdc:	4618      	mov	r0, r3
 8011cde:	b004      	add	sp, #16
 8011ce0:	4770      	bx	lr
 8011ce2:	bf00      	nop
 8011ce4:	f3af 8000 	nop.w
 8011ce8:	f3af 8000 	nop.w
 8011cec:	f3af 8000 	nop.w

08011cf0 <_write_r>:

/***************************************************************************/

__attribute__((used))
int _write_r(struct _reent *r, int file, char * ptr, int len)
{
 8011cf0:	b084      	sub	sp, #16
 8011cf2:	9003      	str	r0, [sp, #12]
 8011cf4:	9102      	str	r1, [sp, #8]
 8011cf6:	9201      	str	r2, [sp, #4]
 8011cf8:	9300      	str	r3, [sp, #0]
    __errno_r(r) = EINVAL;
    return -1;
  }
  sdWrite(&STDOUT_SD, (uint8_t *)ptr, (size_t)len);
#endif
  return len;
 8011cfa:	9b00      	ldr	r3, [sp, #0]
}
 8011cfc:	4618      	mov	r0, r3
 8011cfe:	b004      	add	sp, #16
 8011d00:	4770      	bx	lr
 8011d02:	bf00      	nop
 8011d04:	f3af 8000 	nop.w
 8011d08:	f3af 8000 	nop.w
 8011d0c:	f3af 8000 	nop.w

08011d10 <_open_r>:


__attribute__((used))
int _open_r(struct _reent *r, int file)
{
 8011d10:	b082      	sub	sp, #8
 8011d12:	9001      	str	r0, [sp, #4]
 8011d14:	9100      	str	r1, [sp, #0]
  (void)r;
  (void)file;

  return 0;
 8011d16:	2300      	movs	r3, #0
}
 8011d18:	4618      	mov	r0, r3
 8011d1a:	b002      	add	sp, #8
 8011d1c:	4770      	bx	lr
 8011d1e:	bf00      	nop

08011d20 <_close_r>:
/***************************************************************************/

__attribute__((used))
int _close_r(struct _reent *r, int file)
{
 8011d20:	b082      	sub	sp, #8
 8011d22:	9001      	str	r0, [sp, #4]
 8011d24:	9100      	str	r1, [sp, #0]
  (void)r;
  (void)file;

  return 0;
 8011d26:	2300      	movs	r3, #0
}
 8011d28:	4618      	mov	r0, r3
 8011d2a:	b002      	add	sp, #8
 8011d2c:	4770      	bx	lr
 8011d2e:	bf00      	nop

08011d30 <_sbrk_r>:

/***************************************************************************/

__attribute__((used))
caddr_t _sbrk_r(struct _reent *r, int incr)
{
 8011d30:	b500      	push	{lr}
 8011d32:	b085      	sub	sp, #20
 8011d34:	9001      	str	r0, [sp, #4]
 8011d36:	9100      	str	r1, [sp, #0]
#if CH_CFG_USE_MEMCORE
  void *p;

  chDbgCheck(incr >= 0);

  p = chCoreAlloc((size_t)incr);
 8011d38:	9b00      	ldr	r3, [sp, #0]
 8011d3a:	4618      	mov	r0, r3
 8011d3c:	f7f1 fc90 	bl	8003660 <chCoreAlloc>
 8011d40:	9003      	str	r0, [sp, #12]
  if (p == NULL) {
 8011d42:	9b03      	ldr	r3, [sp, #12]
 8011d44:	2b00      	cmp	r3, #0
 8011d46:	d105      	bne.n	8011d54 <_sbrk_r+0x24>
    __errno_r(r) = ENOMEM;
 8011d48:	9b01      	ldr	r3, [sp, #4]
 8011d4a:	220c      	movs	r2, #12
 8011d4c:	601a      	str	r2, [r3, #0]
    return (caddr_t)-1;
 8011d4e:	f04f 33ff 	mov.w	r3, #4294967295
 8011d52:	e000      	b.n	8011d56 <_sbrk_r+0x26>
  }
  return (caddr_t)p;
 8011d54:	9b03      	ldr	r3, [sp, #12]
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 8011d56:	4618      	mov	r0, r3
 8011d58:	b005      	add	sp, #20
 8011d5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d5e:	bf00      	nop

08011d60 <_fstat_r>:

/***************************************************************************/

__attribute__((used))
int _fstat_r(struct _reent *r, int file, struct stat * st)
{
 8011d60:	b500      	push	{lr}
 8011d62:	b085      	sub	sp, #20
 8011d64:	9003      	str	r0, [sp, #12]
 8011d66:	9102      	str	r1, [sp, #8]
 8011d68:	9201      	str	r2, [sp, #4]
  (void)r;
  (void)file;

  memset(st, 0, sizeof(*st));
 8011d6a:	9801      	ldr	r0, [sp, #4]
 8011d6c:	2100      	movs	r1, #0
 8011d6e:	223c      	movs	r2, #60	; 0x3c
 8011d70:	f005 fe0e 	bl	8017990 <memset>
  st->st_mode = S_IFCHR;
 8011d74:	9b01      	ldr	r3, [sp, #4]
 8011d76:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8011d7a:	605a      	str	r2, [r3, #4]
  return 0;
 8011d7c:	2300      	movs	r3, #0
}
 8011d7e:	4618      	mov	r0, r3
 8011d80:	b005      	add	sp, #20
 8011d82:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d86:	bf00      	nop
 8011d88:	f3af 8000 	nop.w
 8011d8c:	f3af 8000 	nop.w

08011d90 <_isatty_r>:

/***************************************************************************/

__attribute__((used))
int _isatty_r(struct _reent *r, int fd)
{
 8011d90:	b082      	sub	sp, #8
 8011d92:	9001      	str	r0, [sp, #4]
 8011d94:	9100      	str	r1, [sp, #0]
  (void)r;
  (void)fd;

  return 1;
 8011d96:	2301      	movs	r3, #1
}
 8011d98:	4618      	mov	r0, r3
 8011d9a:	b002      	add	sp, #8
 8011d9c:	4770      	bx	lr
 8011d9e:	bf00      	nop

08011da0 <chThdTerminatedX>:
 * @retval true         thread terminated.
 * @retval false        thread not terminated.
 *
 * @xclass
 */
static inline bool chThdTerminatedX(thread_t *tp) {
 8011da0:	b082      	sub	sp, #8
 8011da2:	9001      	str	r0, [sp, #4]

  return (bool)(tp->p_state == CH_STATE_FINAL);
 8011da4:	9b01      	ldr	r3, [sp, #4]
 8011da6:	7f1b      	ldrb	r3, [r3, #28]
 8011da8:	2b0f      	cmp	r3, #15
 8011daa:	bf14      	ite	ne
 8011dac:	2300      	movne	r3, #0
 8011dae:	2301      	moveq	r3, #1
 8011db0:	b2db      	uxtb	r3, r3
}
 8011db2:	4618      	mov	r0, r3
 8011db4:	b002      	add	sp, #8
 8011db6:	4770      	bx	lr
 8011db8:	f3af 8000 	nop.w
 8011dbc:	f3af 8000 	nop.w

08011dc0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8011dc0:	b082      	sub	sp, #8
 8011dc2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8011dc4:	4b02      	ldr	r3, [pc, #8]	; (8011dd0 <chRegSetThreadName+0x10>)
 8011dc6:	699b      	ldr	r3, [r3, #24]
 8011dc8:	9a01      	ldr	r2, [sp, #4]
 8011dca:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8011dcc:	b002      	add	sp, #8
 8011dce:	4770      	bx	lr
 8011dd0:	200039a8 	.word	0x200039a8
 8011dd4:	f3af 8000 	nop.w
 8011dd8:	f3af 8000 	nop.w
 8011ddc:	f3af 8000 	nop.w

08011de0 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8011de0:	b088      	sub	sp, #32
 8011de2:	9003      	str	r0, [sp, #12]
 8011de4:	9102      	str	r1, [sp, #8]
 8011de6:	9201      	str	r2, [sp, #4]
 8011de8:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 8011dea:	9b02      	ldr	r3, [sp, #8]
 8011dec:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 8011dee:	9b00      	ldr	r3, [sp, #0]
 8011df0:	2b00      	cmp	r3, #0
 8011df2:	d102      	bne.n	8011dfa <long_to_string_with_divisor+0x1a>
    ll = num;
 8011df4:	9b02      	ldr	r3, [sp, #8]
 8011df6:	9304      	str	r3, [sp, #16]
 8011df8:	e001      	b.n	8011dfe <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 8011dfa:	9b00      	ldr	r3, [sp, #0]
 8011dfc:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 8011dfe:	9b03      	ldr	r3, [sp, #12]
 8011e00:	330b      	adds	r3, #11
 8011e02:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8011e04:	9b05      	ldr	r3, [sp, #20]
 8011e06:	9a01      	ldr	r2, [sp, #4]
 8011e08:	fbb3 f2f2 	udiv	r2, r3, r2
 8011e0c:	9901      	ldr	r1, [sp, #4]
 8011e0e:	fb01 f202 	mul.w	r2, r1, r2
 8011e12:	1a9b      	subs	r3, r3, r2
 8011e14:	9307      	str	r3, [sp, #28]
    i += '0';
 8011e16:	9b07      	ldr	r3, [sp, #28]
 8011e18:	3330      	adds	r3, #48	; 0x30
 8011e1a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 8011e1c:	9b07      	ldr	r3, [sp, #28]
 8011e1e:	2b39      	cmp	r3, #57	; 0x39
 8011e20:	dd02      	ble.n	8011e28 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 8011e22:	9b07      	ldr	r3, [sp, #28]
 8011e24:	3307      	adds	r3, #7
 8011e26:	9307      	str	r3, [sp, #28]
    *--q = i;
 8011e28:	9b06      	ldr	r3, [sp, #24]
 8011e2a:	3b01      	subs	r3, #1
 8011e2c:	9306      	str	r3, [sp, #24]
 8011e2e:	9b07      	ldr	r3, [sp, #28]
 8011e30:	b2da      	uxtb	r2, r3
 8011e32:	9b06      	ldr	r3, [sp, #24]
 8011e34:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8011e36:	9a05      	ldr	r2, [sp, #20]
 8011e38:	9b01      	ldr	r3, [sp, #4]
 8011e3a:	fbb2 f3f3 	udiv	r3, r2, r3
 8011e3e:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8011e40:	9a04      	ldr	r2, [sp, #16]
 8011e42:	9b01      	ldr	r3, [sp, #4]
 8011e44:	fbb2 f3f3 	udiv	r3, r2, r3
 8011e48:	9304      	str	r3, [sp, #16]
 8011e4a:	9b04      	ldr	r3, [sp, #16]
 8011e4c:	2b00      	cmp	r3, #0
 8011e4e:	d1d9      	bne.n	8011e04 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 8011e50:	9b03      	ldr	r3, [sp, #12]
 8011e52:	330b      	adds	r3, #11
 8011e54:	461a      	mov	r2, r3
 8011e56:	9b06      	ldr	r3, [sp, #24]
 8011e58:	1ad3      	subs	r3, r2, r3
 8011e5a:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 8011e5c:	9b03      	ldr	r3, [sp, #12]
 8011e5e:	1c5a      	adds	r2, r3, #1
 8011e60:	9203      	str	r2, [sp, #12]
 8011e62:	9a06      	ldr	r2, [sp, #24]
 8011e64:	1c51      	adds	r1, r2, #1
 8011e66:	9106      	str	r1, [sp, #24]
 8011e68:	7812      	ldrb	r2, [r2, #0]
 8011e6a:	701a      	strb	r2, [r3, #0]
  while (--i);
 8011e6c:	9b07      	ldr	r3, [sp, #28]
 8011e6e:	3b01      	subs	r3, #1
 8011e70:	9307      	str	r3, [sp, #28]
 8011e72:	9b07      	ldr	r3, [sp, #28]
 8011e74:	2b00      	cmp	r3, #0
 8011e76:	d1f1      	bne.n	8011e5c <long_to_string_with_divisor+0x7c>

  return p;
 8011e78:	9b03      	ldr	r3, [sp, #12]
}
 8011e7a:	4618      	mov	r0, r3
 8011e7c:	b008      	add	sp, #32
 8011e7e:	4770      	bx	lr

08011e80 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8011e80:	b500      	push	{lr}
 8011e82:	b085      	sub	sp, #20
 8011e84:	9003      	str	r0, [sp, #12]
 8011e86:	9102      	str	r1, [sp, #8]
 8011e88:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 8011e8a:	9803      	ldr	r0, [sp, #12]
 8011e8c:	9902      	ldr	r1, [sp, #8]
 8011e8e:	9a01      	ldr	r2, [sp, #4]
 8011e90:	2300      	movs	r3, #0
 8011e92:	f7ff ffa5 	bl	8011de0 <long_to_string_with_divisor>
 8011e96:	4603      	mov	r3, r0
}
 8011e98:	4618      	mov	r0, r3
 8011e9a:	b005      	add	sp, #20
 8011e9c:	f85d fb04 	ldr.w	pc, [sp], #4

08011ea0 <counterThread>:
 * THREADS
 *******************************/

/* Thread that blinks North LED as an "alive" indicator */
static THD_WORKING_AREA(waCounterThread,128);
static THD_FUNCTION(counterThread,arg) {
 8011ea0:	b500      	push	{lr}
 8011ea2:	b083      	sub	sp, #12
 8011ea4:	9001      	str	r0, [sp, #4]
  UNUSED(arg);
  chRegSetThreadName("blinker");
 8011ea6:	480a      	ldr	r0, [pc, #40]	; (8011ed0 <counterThread+0x30>)
 8011ea8:	f7ff ff8a 	bl	8011dc0 <chRegSetThreadName>
  while (TRUE) {
    palSetLine(BOARD_LED);   
 8011eac:	4b09      	ldr	r3, [pc, #36]	; (8011ed4 <counterThread+0x34>)
 8011eae:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8011eb2:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 8011eb4:	f24c 3050 	movw	r0, #50000	; 0xc350
 8011eb8:	f7ef fa0a 	bl	80012d0 <chThdSleep>
		palClearLine(BOARD_LED);
 8011ebc:	4b05      	ldr	r3, [pc, #20]	; (8011ed4 <counterThread+0x34>)
 8011ebe:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8011ec2:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8011ec4:	f24c 3050 	movw	r0, #50000	; 0xc350
 8011ec8:	f7ef fa02 	bl	80012d0 <chThdSleep>
  }
 8011ecc:	e7ee      	b.n	8011eac <counterThread+0xc>
 8011ece:	bf00      	nop
 8011ed0:	0801bc30 	.word	0x0801bc30
 8011ed4:	48001800 	.word	0x48001800
 8011ed8:	f3af 8000 	nop.w
 8011edc:	f3af 8000 	nop.w

08011ee0 <tcpThread>:
}

/* Send Data via TCP Socket */
static THD_WORKING_AREA(waTCPThread, 4096);
static THD_FUNCTION(tcpThread,arg) {
 8011ee0:	b510      	push	{r4, lr}
 8011ee2:	b0ac      	sub	sp, #176	; 0xb0
 8011ee4:	9001      	str	r0, [sp, #4]
  UNUSED(arg);
  chRegSetThreadName("socket");
 8011ee6:	487b      	ldr	r0, [pc, #492]	; (80120d4 <tcpThread+0x1f4>)
 8011ee8:	f7ff ff6a 	bl	8011dc0 <chRegSetThreadName>
  chThdSleepSeconds(5);
 8011eec:	487a      	ldr	r0, [pc, #488]	; (80120d8 <tcpThread+0x1f8>)
 8011eee:	f7ef f9ef 	bl	80012d0 <chThdSleep>
  while (TRUE) {
  	if(start_tcp){
 8011ef2:	4b7a      	ldr	r3, [pc, #488]	; (80120dc <tcpThread+0x1fc>)
 8011ef4:	681b      	ldr	r3, [r3, #0]
 8011ef6:	2b00      	cmp	r3, #0
 8011ef8:	f000 80e7 	beq.w	80120ca <tcpThread+0x1ea>

  	// 1. system power on/Check that system is on
  	chprintf((BaseSequentialStream*)&SD5, "\n\rSTARTING TCP\n\r");
 8011efc:	4878      	ldr	r0, [pc, #480]	; (80120e0 <tcpThread+0x200>)
 8011efe:	4979      	ldr	r1, [pc, #484]	; (80120e4 <tcpThread+0x204>)
 8011f00:	f7ff fb8e 	bl	8011620 <chprintf>

  	EUARTSendCommand(&EUARTH, "AT", 2);
 8011f04:	4878      	ldr	r0, [pc, #480]	; (80120e8 <tcpThread+0x208>)
 8011f06:	4979      	ldr	r1, [pc, #484]	; (80120ec <tcpThread+0x20c>)
 8011f08:	2202      	movs	r2, #2
 8011f0a:	f000 fe99 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(1);
 8011f0e:	4878      	ldr	r0, [pc, #480]	; (80120f0 <tcpThread+0x210>)
 8011f10:	f7ef f9de 	bl	80012d0 <chThdSleep>
	//EUARTRecvResponse("OK");
  	// 2. query and wait for GPRS to attach to network
  	EUARTSendCommand(&EUARTH, "AT+CGATT?", 9);
 8011f14:	4874      	ldr	r0, [pc, #464]	; (80120e8 <tcpThread+0x208>)
 8011f16:	4977      	ldr	r1, [pc, #476]	; (80120f4 <tcpThread+0x214>)
 8011f18:	2209      	movs	r2, #9
 8011f1a:	f000 fe91 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(2);
 8011f1e:	4876      	ldr	r0, [pc, #472]	; (80120f8 <tcpThread+0x218>)
 8011f20:	f7ef f9d6 	bl	80012d0 <chThdSleep>
  	//EUARTRecvResponse("+CGATT: 1");
  	// 3. Reset any running IP session
  	EUARTSendCommand(&EUARTH, "AT+CIPSHUT", 10);
 8011f24:	4870      	ldr	r0, [pc, #448]	; (80120e8 <tcpThread+0x208>)
 8011f26:	4975      	ldr	r1, [pc, #468]	; (80120fc <tcpThread+0x21c>)
 8011f28:	220a      	movs	r2, #10
 8011f2a:	f000 fe89 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(2);
 8011f2e:	4872      	ldr	r0, [pc, #456]	; (80120f8 <tcpThread+0x218>)
 8011f30:	f7ef f9ce 	bl	80012d0 <chThdSleep>
	//EUARTRecvResponse("SHUT OK");
  	// 4. Check if IP stack is initialized
  	EUARTSendCommand(&EUARTH, "AT+CIPSTATUS", 12);
 8011f34:	486c      	ldr	r0, [pc, #432]	; (80120e8 <tcpThread+0x208>)
 8011f36:	4972      	ldr	r1, [pc, #456]	; (8012100 <tcpThread+0x220>)
 8011f38:	220c      	movs	r2, #12
 8011f3a:	f000 fe81 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(2);
 8011f3e:	486e      	ldr	r0, [pc, #440]	; (80120f8 <tcpThread+0x218>)
 8011f40:	f7ef f9c6 	bl	80012d0 <chThdSleep>
	//EUARTRecvResponse("STATE: IP INITIAL");
  	// 5. Set Connection mode to single
  	EUARTSendCommand(&EUARTH, "AT+CIPMUX=0", 11);
 8011f44:	4868      	ldr	r0, [pc, #416]	; (80120e8 <tcpThread+0x208>)
 8011f46:	496f      	ldr	r1, [pc, #444]	; (8012104 <tcpThread+0x224>)
 8011f48:	220b      	movs	r2, #11
 8011f4a:	f000 fe79 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(1);
 8011f4e:	4868      	ldr	r0, [pc, #416]	; (80120f0 <tcpThread+0x210>)
 8011f50:	f7ef f9be 	bl	80012d0 <chThdSleep>
	//EUARTRecvResponse("OK");
	// 6. Set APN
	// char* at_command = "AT+CSTT=";
	// char* apn = TPN_APN;
	// strcat(at_command, apn);
  	EUARTSendCommand(&EUARTH, "AT+CSTT=\"wholesale\"", 19); //tpo.pmvne
 8011f54:	4864      	ldr	r0, [pc, #400]	; (80120e8 <tcpThread+0x208>)
 8011f56:	496c      	ldr	r1, [pc, #432]	; (8012108 <tcpThread+0x228>)
 8011f58:	2213      	movs	r2, #19
 8011f5a:	f000 fe71 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(2);
 8011f5e:	4866      	ldr	r0, [pc, #408]	; (80120f8 <tcpThread+0x218>)
 8011f60:	f7ef f9b6 	bl	80012d0 <chThdSleep>
	//EUARTRecvResponse("OK");
  	// 7. Bring wireless up
  	EUARTSendCommand(&EUARTH, "AT+CIICR", 8);
 8011f64:	4860      	ldr	r0, [pc, #384]	; (80120e8 <tcpThread+0x208>)
 8011f66:	4969      	ldr	r1, [pc, #420]	; (801210c <tcpThread+0x22c>)
 8011f68:	2208      	movs	r2, #8
 8011f6a:	f000 fe69 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(15);
 8011f6e:	4868      	ldr	r0, [pc, #416]	; (8012110 <tcpThread+0x230>)
 8011f70:	f7ef f9ae 	bl	80012d0 <chThdSleep>
  	//EUARTRecvResponse("OK");
  	// 8. Get Local IP Address 
  	EUARTSendCommand(&EUARTH, "AT+CIFSR", 8);
 8011f74:	485c      	ldr	r0, [pc, #368]	; (80120e8 <tcpThread+0x208>)
 8011f76:	4967      	ldr	r1, [pc, #412]	; (8012114 <tcpThread+0x234>)
 8011f78:	2208      	movs	r2, #8
 8011f7a:	f000 fe61 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(1);
 8011f7e:	485c      	ldr	r0, [pc, #368]	; (80120f0 <tcpThread+0x210>)
 8011f80:	f7ef f9a6 	bl	80012d0 <chThdSleep>
	// 9. Connect socket via TCP
  	EUARTSendCommand(&EUARTH, "AT+CIPSTART=\"TCP\",\"silo.cs.indiana.edu\",\"50106\"", 47);
 8011f84:	4858      	ldr	r0, [pc, #352]	; (80120e8 <tcpThread+0x208>)
 8011f86:	4964      	ldr	r1, [pc, #400]	; (8012118 <tcpThread+0x238>)
 8011f88:	222f      	movs	r2, #47	; 0x2f
 8011f8a:	f000 fe59 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(5);
 8011f8e:	4852      	ldr	r0, [pc, #328]	; (80120d8 <tcpThread+0x1f8>)
 8011f90:	f7ef f99e 	bl	80012d0 <chThdSleep>
	// EUARTRecvResponse("CONNECT OK")
  	//10. Transfer data
    char sendCo[32];
    strcpy(sendCo,"AT+CIPSEND=");
 8011f94:	ab03      	add	r3, sp, #12
 8011f96:	4a61      	ldr	r2, [pc, #388]	; (801211c <tcpThread+0x23c>)
 8011f98:	ca07      	ldmia	r2, {r0, r1, r2}
 8011f9a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    int numStored = num_timestamps * 34;
 8011f9e:	4b60      	ldr	r3, [pc, #384]	; (8012120 <tcpThread+0x240>)
 8011fa0:	681a      	ldr	r2, [r3, #0]
 8011fa2:	4613      	mov	r3, r2
 8011fa4:	011b      	lsls	r3, r3, #4
 8011fa6:	4413      	add	r3, r2
 8011fa8:	005b      	lsls	r3, r3, #1
 8011faa:	9329      	str	r3, [sp, #164]	; 0xa4
    char charStored[32];
    ch_ltoa(charStored, numStored, 10);
 8011fac:	ab0b      	add	r3, sp, #44	; 0x2c
 8011fae:	4618      	mov	r0, r3
 8011fb0:	9929      	ldr	r1, [sp, #164]	; 0xa4
 8011fb2:	220a      	movs	r2, #10
 8011fb4:	f7ff ff64 	bl	8011e80 <ch_ltoa>
    strcat(sendCo, charStored);
 8011fb8:	aa03      	add	r2, sp, #12
 8011fba:	ab0b      	add	r3, sp, #44	; 0x2c
 8011fbc:	4610      	mov	r0, r2
 8011fbe:	4619      	mov	r1, r3
 8011fc0:	f005 fd36 	bl	8017a30 <strcat>
    EUARTSendCommand(&EUARTH, sendCo, strlen(sendCo));
 8011fc4:	ab03      	add	r3, sp, #12
 8011fc6:	4618      	mov	r0, r3
 8011fc8:	f006 fba2 	bl	8018710 <strlen>
 8011fcc:	4603      	mov	r3, r0
 8011fce:	aa03      	add	r2, sp, #12
 8011fd0:	4845      	ldr	r0, [pc, #276]	; (80120e8 <tcpThread+0x208>)
 8011fd2:	4611      	mov	r1, r2
 8011fd4:	461a      	mov	r2, r3
 8011fd6:	f000 fe33 	bl	8012c40 <EUARTSendCommand>
    chThdSleepSeconds(1);
 8011fda:	4845      	ldr	r0, [pc, #276]	; (80120f0 <tcpThread+0x210>)
 8011fdc:	f7ef f978 	bl	80012d0 <chThdSleep>
  	int i;
    struct tm timeptr;
    uint32_t ms;
    char tm_str[32];
    char count_str[16];
    int bytes_sent = 0;
 8011fe0:	2300      	movs	r3, #0
 8011fe2:	932a      	str	r3, [sp, #168]	; 0xa8
  	for (i = 0; i < num_timestamps; i++) {
 8011fe4:	2300      	movs	r3, #0
 8011fe6:	932b      	str	r3, [sp, #172]	; 0xac
 8011fe8:	e055      	b.n	8012096 <tcpThread+0x1b6>
	    rtcConvertDateTimeToStructTm(&timestamp_data[i].time, &timeptr, &ms);
 8011fea:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 8011fec:	4613      	mov	r3, r2
 8011fee:	005b      	lsls	r3, r3, #1
 8011ff0:	4413      	add	r3, r2
 8011ff2:	009b      	lsls	r3, r3, #2
 8011ff4:	4a4b      	ldr	r2, [pc, #300]	; (8012124 <tcpThread+0x244>)
 8011ff6:	1899      	adds	r1, r3, r2
 8011ff8:	aa1b      	add	r2, sp, #108	; 0x6c
 8011ffa:	ab28      	add	r3, sp, #160	; 0xa0
 8011ffc:	4608      	mov	r0, r1
 8011ffe:	4611      	mov	r1, r2
 8012000:	461a      	mov	r2, r3
 8012002:	f7f3 f87d 	bl	8005100 <rtcConvertDateTimeToStructTm>
  		strftime(tm_str, 31, "%c", &timeptr);
 8012006:	aa13      	add	r2, sp, #76	; 0x4c
 8012008:	ab1b      	add	r3, sp, #108	; 0x6c
 801200a:	4610      	mov	r0, r2
 801200c:	211f      	movs	r1, #31
 801200e:	4a46      	ldr	r2, [pc, #280]	; (8012128 <tcpThread+0x248>)
 8012010:	f005 fe0e 	bl	8017c30 <strftime>
	    EUARTSendCommand(&EUARTH, tm_str, strlen(tm_str)); //strlen(tm_str)
 8012014:	ab13      	add	r3, sp, #76	; 0x4c
 8012016:	4618      	mov	r0, r3
 8012018:	f006 fb7a 	bl	8018710 <strlen>
 801201c:	4603      	mov	r3, r0
 801201e:	aa13      	add	r2, sp, #76	; 0x4c
 8012020:	4831      	ldr	r0, [pc, #196]	; (80120e8 <tcpThread+0x208>)
 8012022:	4611      	mov	r1, r2
 8012024:	461a      	mov	r2, r3
 8012026:	f000 fe0b 	bl	8012c40 <EUARTSendCommand>
  		EUARTSendCommand(&EUARTH, ",", 1);
 801202a:	482f      	ldr	r0, [pc, #188]	; (80120e8 <tcpThread+0x208>)
 801202c:	493f      	ldr	r1, [pc, #252]	; (801212c <tcpThread+0x24c>)
 801202e:	2201      	movs	r2, #1
 8012030:	f000 fe06 	bl	8012c40 <EUARTSendCommand>
  		ch_ltoa(count_str, (long)timestamp_data[i].people_count, 10);
 8012034:	493b      	ldr	r1, [pc, #236]	; (8012124 <tcpThread+0x244>)
 8012036:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 8012038:	4613      	mov	r3, r2
 801203a:	005b      	lsls	r3, r3, #1
 801203c:	4413      	add	r3, r2
 801203e:	009b      	lsls	r3, r3, #2
 8012040:	440b      	add	r3, r1
 8012042:	3308      	adds	r3, #8
 8012044:	681b      	ldr	r3, [r3, #0]
 8012046:	aa24      	add	r2, sp, #144	; 0x90
 8012048:	4610      	mov	r0, r2
 801204a:	4619      	mov	r1, r3
 801204c:	220a      	movs	r2, #10
 801204e:	f7ff ff17 	bl	8011e80 <ch_ltoa>
  		EUARTSendCommand(&EUARTH, count_str, strlen(count_str));
 8012052:	ab24      	add	r3, sp, #144	; 0x90
 8012054:	4618      	mov	r0, r3
 8012056:	f006 fb5b 	bl	8018710 <strlen>
 801205a:	4603      	mov	r3, r0
 801205c:	aa24      	add	r2, sp, #144	; 0x90
 801205e:	4822      	ldr	r0, [pc, #136]	; (80120e8 <tcpThread+0x208>)
 8012060:	4611      	mov	r1, r2
 8012062:	461a      	mov	r2, r3
 8012064:	f000 fdec 	bl	8012c40 <EUARTSendCommand>
	    EUARTSendCommand(&EUARTH, "\n", 1);
 8012068:	481f      	ldr	r0, [pc, #124]	; (80120e8 <tcpThread+0x208>)
 801206a:	4931      	ldr	r1, [pc, #196]	; (8012130 <tcpThread+0x250>)
 801206c:	2201      	movs	r2, #1
 801206e:	f000 fde7 	bl	8012c40 <EUARTSendCommand>
      bytes_sent += (strlen(tm_str) + strlen(count_str) + 6);
 8012072:	ab13      	add	r3, sp, #76	; 0x4c
 8012074:	4618      	mov	r0, r3
 8012076:	f006 fb4b 	bl	8018710 <strlen>
 801207a:	4604      	mov	r4, r0
 801207c:	ab24      	add	r3, sp, #144	; 0x90
 801207e:	4618      	mov	r0, r3
 8012080:	f006 fb46 	bl	8018710 <strlen>
 8012084:	4603      	mov	r3, r0
 8012086:	18e2      	adds	r2, r4, r3
 8012088:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801208a:	4413      	add	r3, r2
 801208c:	3306      	adds	r3, #6
 801208e:	932a      	str	r3, [sp, #168]	; 0xa8
    struct tm timeptr;
    uint32_t ms;
    char tm_str[32];
    char count_str[16];
    int bytes_sent = 0;
  	for (i = 0; i < num_timestamps; i++) {
 8012090:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8012092:	3301      	adds	r3, #1
 8012094:	932b      	str	r3, [sp, #172]	; 0xac
 8012096:	4b22      	ldr	r3, [pc, #136]	; (8012120 <tcpThread+0x240>)
 8012098:	681b      	ldr	r3, [r3, #0]
 801209a:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 801209c:	429a      	cmp	r2, r3
 801209e:	dba4      	blt.n	8011fea <tcpThread+0x10a>
  		ch_ltoa(count_str, (long)timestamp_data[i].people_count, 10);
  		EUARTSendCommand(&EUARTH, count_str, strlen(count_str));
	    EUARTSendCommand(&EUARTH, "\n", 1);
      bytes_sent += (strlen(tm_str) + strlen(count_str) + 6);
	  }
    for (i = 0; i < (numStored - bytes_sent); i+=2) {
 80120a0:	2300      	movs	r3, #0
 80120a2:	932b      	str	r3, [sp, #172]	; 0xac
 80120a4:	e006      	b.n	80120b4 <tcpThread+0x1d4>
      EUARTSendCommand(&EUARTH, " ");
 80120a6:	4810      	ldr	r0, [pc, #64]	; (80120e8 <tcpThread+0x208>)
 80120a8:	4922      	ldr	r1, [pc, #136]	; (8012134 <tcpThread+0x254>)
 80120aa:	f000 fdc9 	bl	8012c40 <EUARTSendCommand>
  		ch_ltoa(count_str, (long)timestamp_data[i].people_count, 10);
  		EUARTSendCommand(&EUARTH, count_str, strlen(count_str));
	    EUARTSendCommand(&EUARTH, "\n", 1);
      bytes_sent += (strlen(tm_str) + strlen(count_str) + 6);
	  }
    for (i = 0; i < (numStored - bytes_sent); i+=2) {
 80120ae:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 80120b0:	3302      	adds	r3, #2
 80120b2:	932b      	str	r3, [sp, #172]	; 0xac
 80120b4:	9a29      	ldr	r2, [sp, #164]	; 0xa4
 80120b6:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 80120b8:	1ad2      	subs	r2, r2, r3
 80120ba:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 80120bc:	429a      	cmp	r2, r3
 80120be:	dcf2      	bgt.n	80120a6 <tcpThread+0x1c6>
      EUARTSendCommand(&EUARTH, " ");
    }
	// 12. Close TCP connection
	  EUARTSendCommand(&EUARTH, "AT+CIPSHUT", 10);
 80120c0:	4809      	ldr	r0, [pc, #36]	; (80120e8 <tcpThread+0x208>)
 80120c2:	490e      	ldr	r1, [pc, #56]	; (80120fc <tcpThread+0x21c>)
 80120c4:	220a      	movs	r2, #10
 80120c6:	f000 fdbb 	bl	8012c40 <EUARTSendCommand>
	//EUARTRecvResponse("SHUT OK");
	// 13. Sleep until the next transfer
	  }
	  //start_tcp = 0;
	  chThdSleepSeconds(TCP_FREQ);
 80120ca:	481b      	ldr	r0, [pc, #108]	; (8012138 <tcpThread+0x258>)
 80120cc:	f7ef f900 	bl	80012d0 <chThdSleep>
	}
 80120d0:	e70f      	b.n	8011ef2 <tcpThread+0x12>
 80120d2:	bf00      	nop
 80120d4:	0801bc38 	.word	0x0801bc38
 80120d8:	0007a120 	.word	0x0007a120
 80120dc:	200008fc 	.word	0x200008fc
 80120e0:	20003db8 	.word	0x20003db8
 80120e4:	0801bc40 	.word	0x0801bc40
 80120e8:	200044c0 	.word	0x200044c0
 80120ec:	0801bc54 	.word	0x0801bc54
 80120f0:	000186a0 	.word	0x000186a0
 80120f4:	0801bc58 	.word	0x0801bc58
 80120f8:	00030d40 	.word	0x00030d40
 80120fc:	0801bc64 	.word	0x0801bc64
 8012100:	0801bc70 	.word	0x0801bc70
 8012104:	0801bc80 	.word	0x0801bc80
 8012108:	0801bc8c 	.word	0x0801bc8c
 801210c:	0801bca0 	.word	0x0801bca0
 8012110:	0016e360 	.word	0x0016e360
 8012114:	0801bcac 	.word	0x0801bcac
 8012118:	0801bcb8 	.word	0x0801bcb8
 801211c:	0801bce8 	.word	0x0801bce8
 8012120:	20001574 	.word	0x20001574
 8012124:	200044e4 	.word	0x200044e4
 8012128:	0801bcf4 	.word	0x0801bcf4
 801212c:	0801bcf8 	.word	0x0801bcf8
 8012130:	0801bcfc 	.word	0x0801bcfc
 8012134:	0801bd00 	.word	0x0801bd00
 8012138:	005b8d80 	.word	0x005b8d80
 801213c:	f3af 8000 	nop.w

08012140 <timeStamp>:
} 

/* Time Stamp */
static THD_WORKING_AREA(waTimeStamp,4096);
static THD_FUNCTION(timeStamp,arg) {
 8012140:	b500      	push	{lr}
 8012142:	b083      	sub	sp, #12
 8012144:	9001      	str	r0, [sp, #4]
        UNUSED(arg);
        chRegSetThreadName("timestamp");
 8012146:	484c      	ldr	r0, [pc, #304]	; (8012278 <timeStamp+0x138>)
 8012148:	f7ff fe3a 	bl	8011dc0 <chRegSetThreadName>
        while (TRUE) {
                rtcGetTime(&RTCD1, &(timestamp_data[num_timestamps].time)); 
 801214c:	4b4b      	ldr	r3, [pc, #300]	; (801227c <timeStamp+0x13c>)
 801214e:	681a      	ldr	r2, [r3, #0]
 8012150:	4613      	mov	r3, r2
 8012152:	005b      	lsls	r3, r3, #1
 8012154:	4413      	add	r3, r2
 8012156:	009b      	lsls	r3, r3, #2
 8012158:	4a49      	ldr	r2, [pc, #292]	; (8012280 <timeStamp+0x140>)
 801215a:	4413      	add	r3, r2
 801215c:	4849      	ldr	r0, [pc, #292]	; (8012284 <timeStamp+0x144>)
 801215e:	4619      	mov	r1, r3
 8012160:	f7f2 ff9e 	bl	80050a0 <rtcGetTime>
                rtcSetTime(&RTCD1, &(timestamp_data[num_timestamps].time)); //Write the time as a backup if the board fails/resets 
 8012164:	4b45      	ldr	r3, [pc, #276]	; (801227c <timeStamp+0x13c>)
 8012166:	681a      	ldr	r2, [r3, #0]
 8012168:	4613      	mov	r3, r2
 801216a:	005b      	lsls	r3, r3, #1
 801216c:	4413      	add	r3, r2
 801216e:	009b      	lsls	r3, r3, #2
 8012170:	4a43      	ldr	r2, [pc, #268]	; (8012280 <timeStamp+0x140>)
 8012172:	4413      	add	r3, r2
 8012174:	4843      	ldr	r0, [pc, #268]	; (8012284 <timeStamp+0x144>)
 8012176:	4619      	mov	r1, r3
 8012178:	f7f2 ff82 	bl	8005080 <rtcSetTime>
				if((num_timestamps < MAX_TIMESTAMPS - 1)){ //Stops writing when memory full
 801217c:	4b3f      	ldr	r3, [pc, #252]	; (801227c <timeStamp+0x13c>)
 801217e:	681b      	ldr	r3, [r3, #0]
 8012180:	f5b3 7ff9 	cmp.w	r3, #498	; 0x1f2
 8012184:	dc74      	bgt.n	8012270 <timeStamp+0x130>
					if(people_count == 0){ //Checks for low calibration
 8012186:	4b40      	ldr	r3, [pc, #256]	; (8012288 <timeStamp+0x148>)
 8012188:	681b      	ldr	r3, [r3, #0]
 801218a:	2b00      	cmp	r3, #0
 801218c:	d108      	bne.n	80121a0 <timeStamp+0x60>
						zero_counts_in_a_row++;
 801218e:	4b3f      	ldr	r3, [pc, #252]	; (801228c <timeStamp+0x14c>)
 8012190:	681b      	ldr	r3, [r3, #0]
 8012192:	1c5a      	adds	r2, r3, #1
 8012194:	4b3d      	ldr	r3, [pc, #244]	; (801228c <timeStamp+0x14c>)
 8012196:	601a      	str	r2, [r3, #0]
						people_counts_in_a_row = 0;
 8012198:	4b3d      	ldr	r3, [pc, #244]	; (8012290 <timeStamp+0x150>)
 801219a:	2200      	movs	r2, #0
 801219c:	601a      	str	r2, [r3, #0]
 801219e:	e007      	b.n	80121b0 <timeStamp+0x70>
					}
					else{
						zero_counts_in_a_row = 0;
 80121a0:	4b3a      	ldr	r3, [pc, #232]	; (801228c <timeStamp+0x14c>)
 80121a2:	2200      	movs	r2, #0
 80121a4:	601a      	str	r2, [r3, #0]
						people_counts_in_a_row++;
 80121a6:	4b3a      	ldr	r3, [pc, #232]	; (8012290 <timeStamp+0x150>)
 80121a8:	681b      	ldr	r3, [r3, #0]
 80121aa:	1c5a      	adds	r2, r3, #1
 80121ac:	4b38      	ldr	r3, [pc, #224]	; (8012290 <timeStamp+0x150>)
 80121ae:	601a      	str	r2, [r3, #0]
					}
					if(!(SS_FLAG) || (SS_FLAG && people_count > 0)){						
				        timestamp_data[num_timestamps].people_count = people_count;
 80121b0:	4b32      	ldr	r3, [pc, #200]	; (801227c <timeStamp+0x13c>)
 80121b2:	681a      	ldr	r2, [r3, #0]
 80121b4:	4b34      	ldr	r3, [pc, #208]	; (8012288 <timeStamp+0x148>)
 80121b6:	6819      	ldr	r1, [r3, #0]
 80121b8:	4831      	ldr	r0, [pc, #196]	; (8012280 <timeStamp+0x140>)
 80121ba:	4613      	mov	r3, r2
 80121bc:	005b      	lsls	r3, r3, #1
 80121be:	4413      	add	r3, r2
 80121c0:	009b      	lsls	r3, r3, #2
 80121c2:	4403      	add	r3, r0
 80121c4:	3308      	adds	r3, #8
 80121c6:	6019      	str	r1, [r3, #0]
				        people_count = 0;
 80121c8:	4b2f      	ldr	r3, [pc, #188]	; (8012288 <timeStamp+0x148>)
 80121ca:	2200      	movs	r2, #0
 80121cc:	601a      	str	r2, [r3, #0]
						num_timestamps++;
 80121ce:	4b2b      	ldr	r3, [pc, #172]	; (801227c <timeStamp+0x13c>)
 80121d0:	681b      	ldr	r3, [r3, #0]
 80121d2:	1c5a      	adds	r2, r3, #1
 80121d4:	4b29      	ldr	r3, [pc, #164]	; (801227c <timeStamp+0x13c>)
 80121d6:	601a      	str	r2, [r3, #0]
					}

					if (zero_counts_in_a_row * TIMESTAMP_FREQ > RECALIBRATION_FREQ ||
 80121d8:	4b2c      	ldr	r3, [pc, #176]	; (801228c <timeStamp+0x14c>)
 80121da:	681a      	ldr	r2, [r3, #0]
 80121dc:	4613      	mov	r3, r2
 80121de:	011b      	lsls	r3, r3, #4
 80121e0:	1a9b      	subs	r3, r3, r2
 80121e2:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 80121e6:	dc07      	bgt.n	80121f8 <timeStamp+0xb8>
						people_counts_in_a_row * TIMESTAMP_FREQ > RECALIBRATION_FREQ){
 80121e8:	4b29      	ldr	r3, [pc, #164]	; (8012290 <timeStamp+0x150>)
 80121ea:	681a      	ldr	r2, [r3, #0]
 80121ec:	4613      	mov	r3, r2
 80121ee:	011b      	lsls	r3, r3, #4
 80121f0:	1a9b      	subs	r3, r3, r2
				        timestamp_data[num_timestamps].people_count = people_count;
				        people_count = 0;
						num_timestamps++;
					}

					if (zero_counts_in_a_row * TIMESTAMP_FREQ > RECALIBRATION_FREQ ||
 80121f2:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 80121f6:	dd3b      	ble.n	8012270 <timeStamp+0x130>
						people_counts_in_a_row * TIMESTAMP_FREQ > RECALIBRATION_FREQ){
						//Time to try re-calibrating
						LSM303AGR_ACC_Get_Acceleration(NULL, calibrated_axes);
 80121f8:	2000      	movs	r0, #0
 80121fa:	4926      	ldr	r1, [pc, #152]	; (8012294 <timeStamp+0x154>)
 80121fc:	f000 ff70 	bl	80130e0 <LSM303AGR_ACC_Get_Acceleration>
	  					chprintf((BaseSequentialStream*)&SD5, "\rWarning: Accelerometer Re-calibrated\r\nPrevious data may not be accurate.\r\n");
 8012200:	4825      	ldr	r0, [pc, #148]	; (8012298 <timeStamp+0x158>)
 8012202:	4926      	ldr	r1, [pc, #152]	; (801229c <timeStamp+0x15c>)
 8012204:	f7ff fa0c 	bl	8011620 <chprintf>
	  					rtcGetTime(&RTCD1, &(timestamp_data[num_timestamps].time));
 8012208:	4b1c      	ldr	r3, [pc, #112]	; (801227c <timeStamp+0x13c>)
 801220a:	681a      	ldr	r2, [r3, #0]
 801220c:	4613      	mov	r3, r2
 801220e:	005b      	lsls	r3, r3, #1
 8012210:	4413      	add	r3, r2
 8012212:	009b      	lsls	r3, r3, #2
 8012214:	4a1a      	ldr	r2, [pc, #104]	; (8012280 <timeStamp+0x140>)
 8012216:	4413      	add	r3, r2
 8012218:	481a      	ldr	r0, [pc, #104]	; (8012284 <timeStamp+0x144>)
 801221a:	4619      	mov	r1, r3
 801221c:	f7f2 ff40 	bl	80050a0 <rtcGetTime>
	  					if (zero_counts_in_a_row > 0) //@TODO make these macros
 8012220:	4b1a      	ldr	r3, [pc, #104]	; (801228c <timeStamp+0x14c>)
 8012222:	681b      	ldr	r3, [r3, #0]
 8012224:	2b00      	cmp	r3, #0
 8012226:	dd0c      	ble.n	8012242 <timeStamp+0x102>
	  					{		timestamp_data[num_timestamps].people_count = -1;	}
 8012228:	4b14      	ldr	r3, [pc, #80]	; (801227c <timeStamp+0x13c>)
 801222a:	681a      	ldr	r2, [r3, #0]
 801222c:	4914      	ldr	r1, [pc, #80]	; (8012280 <timeStamp+0x140>)
 801222e:	4613      	mov	r3, r2
 8012230:	005b      	lsls	r3, r3, #1
 8012232:	4413      	add	r3, r2
 8012234:	009b      	lsls	r3, r3, #2
 8012236:	440b      	add	r3, r1
 8012238:	3308      	adds	r3, #8
 801223a:	f04f 32ff 	mov.w	r2, #4294967295
 801223e:	601a      	str	r2, [r3, #0]
 8012240:	e00b      	b.n	801225a <timeStamp+0x11a>
	  					else{ 	timestamp_data[num_timestamps].people_count = -2; } //Signals re-calibration points
 8012242:	4b0e      	ldr	r3, [pc, #56]	; (801227c <timeStamp+0x13c>)
 8012244:	681a      	ldr	r2, [r3, #0]
 8012246:	490e      	ldr	r1, [pc, #56]	; (8012280 <timeStamp+0x140>)
 8012248:	4613      	mov	r3, r2
 801224a:	005b      	lsls	r3, r3, #1
 801224c:	4413      	add	r3, r2
 801224e:	009b      	lsls	r3, r3, #2
 8012250:	440b      	add	r3, r1
 8012252:	3308      	adds	r3, #8
 8012254:	f06f 0201 	mvn.w	r2, #1
 8012258:	601a      	str	r2, [r3, #0]
	  					num_timestamps++;
 801225a:	4b08      	ldr	r3, [pc, #32]	; (801227c <timeStamp+0x13c>)
 801225c:	681b      	ldr	r3, [r3, #0]
 801225e:	1c5a      	adds	r2, r3, #1
 8012260:	4b06      	ldr	r3, [pc, #24]	; (801227c <timeStamp+0x13c>)
 8012262:	601a      	str	r2, [r3, #0]
	  					zero_counts_in_a_row = 0;
 8012264:	4b09      	ldr	r3, [pc, #36]	; (801228c <timeStamp+0x14c>)
 8012266:	2200      	movs	r2, #0
 8012268:	601a      	str	r2, [r3, #0]
	  					people_counts_in_a_row =0 ;
 801226a:	4b09      	ldr	r3, [pc, #36]	; (8012290 <timeStamp+0x150>)
 801226c:	2200      	movs	r2, #0
 801226e:	601a      	str	r2, [r3, #0]
					}
				}


				
                chThdSleepSeconds(TIMESTAMP_FREQ);
 8012270:	480b      	ldr	r0, [pc, #44]	; (80122a0 <timeStamp+0x160>)
 8012272:	f7ef f82d 	bl	80012d0 <chThdSleep>
        }
 8012276:	e769      	b.n	801214c <timeStamp+0xc>
 8012278:	0801bd04 	.word	0x0801bd04
 801227c:	20001574 	.word	0x20001574
 8012280:	200044e4 	.word	0x200044e4
 8012284:	20003d38 	.word	0x20003d38
 8012288:	20001568 	.word	0x20001568
 801228c:	20001570 	.word	0x20001570
 8012290:	2000156c 	.word	0x2000156c
 8012294:	200008f0 	.word	0x200008f0
 8012298:	20003db8 	.word	0x20003db8
 801229c:	0801bd10 	.word	0x0801bd10
 80122a0:	0016e360 	.word	0x0016e360
 80122a4:	f3af 8000 	nop.w
 80122a8:	f3af 8000 	nop.w
 80122ac:	f3af 8000 	nop.w

080122b0 <checkThreshold>:
/*
 *   Check Threshold
 *  */

THD_WORKING_AREA(waCheckThreshold, 4096);
THD_FUNCTION(checkThreshold, arg) {
 80122b0:	b500      	push	{lr}
 80122b2:	b087      	sub	sp, #28
 80122b4:	9001      	str	r0, [sp, #4]

        (void)arg;
        chRegSetThreadName("checkthreshold");
 80122b6:	4817      	ldr	r0, [pc, #92]	; (8012314 <checkThreshold+0x64>)
 80122b8:	f7ff fd82 	bl	8011dc0 <chRegSetThreadName>
        int data[3];
	int curr_accel;
        while(true) {
                LSM303AGR_ACC_Get_Acceleration(NULL, data);
 80122bc:	ab02      	add	r3, sp, #8
 80122be:	2000      	movs	r0, #0
 80122c0:	4619      	mov	r1, r3
 80122c2:	f000 ff0d 	bl	80130e0 <LSM303AGR_ACC_Get_Acceleration>
                curr_accel = abs(data[0] - calibrated_axes[0]) 
 80122c6:	9a02      	ldr	r2, [sp, #8]
 80122c8:	4b13      	ldr	r3, [pc, #76]	; (8012318 <checkThreshold+0x68>)
 80122ca:	681b      	ldr	r3, [r3, #0]
 80122cc:	1ad3      	subs	r3, r2, r3
 80122ce:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80122d2:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
														+ abs(data[1]-calibrated_axes[1]) 
 80122d6:	9903      	ldr	r1, [sp, #12]
 80122d8:	4b0f      	ldr	r3, [pc, #60]	; (8012318 <checkThreshold+0x68>)
 80122da:	685b      	ldr	r3, [r3, #4]
 80122dc:	1acb      	subs	r3, r1, r3
 80122de:	2b00      	cmp	r3, #0
 80122e0:	bfb8      	it	lt
 80122e2:	425b      	neglt	r3, r3
 80122e4:	441a      	add	r2, r3
														+ abs(data[2]-calibrated_axes[2]); //sum total accel, offset by calibration
 80122e6:	9904      	ldr	r1, [sp, #16]
 80122e8:	4b0b      	ldr	r3, [pc, #44]	; (8012318 <checkThreshold+0x68>)
 80122ea:	689b      	ldr	r3, [r3, #8]
 80122ec:	1acb      	subs	r3, r1, r3
 80122ee:	2b00      	cmp	r3, #0
 80122f0:	bfb8      	it	lt
 80122f2:	425b      	neglt	r3, r3
        chRegSetThreadName("checkthreshold");
        int data[3];
	int curr_accel;
        while(true) {
                LSM303AGR_ACC_Get_Acceleration(NULL, data);
                curr_accel = abs(data[0] - calibrated_axes[0]) 
 80122f4:	4413      	add	r3, r2
 80122f6:	9305      	str	r3, [sp, #20]
														+ abs(data[1]-calibrated_axes[1]) 
														+ abs(data[2]-calibrated_axes[2]); //sum total accel, offset by calibration
				
                if (curr_accel > MOVEMENT_THRESHOLD) {
 80122f8:	9b05      	ldr	r3, [sp, #20]
 80122fa:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 80122fe:	dd04      	ble.n	801230a <checkThreshold+0x5a>
                        people_count++;
 8012300:	4b06      	ldr	r3, [pc, #24]	; (801231c <checkThreshold+0x6c>)
 8012302:	681b      	ldr	r3, [r3, #0]
 8012304:	1c5a      	adds	r2, r3, #1
 8012306:	4b05      	ldr	r3, [pc, #20]	; (801231c <checkThreshold+0x6c>)
 8012308:	601a      	str	r2, [r3, #0]
  					rtcGetTime(&RTCD1, &(timestamp_data[num_timestamps].time));
  					timestamp_data[num_timestamps].people_count = -1; //Signal re-calibration points in data
  					num_timestamps++;
  					bullshit_checker = 0;
                }*/
                chThdSleepMilliseconds(ACCEL_MOVEMENT_FREQ);
 801230a:	4805      	ldr	r0, [pc, #20]	; (8012320 <checkThreshold+0x70>)
 801230c:	f7ee ffe0 	bl	80012d0 <chThdSleep>
        }
 8012310:	e7d4      	b.n	80122bc <checkThreshold+0xc>
 8012312:	bf00      	nop
 8012314:	0801bd5c 	.word	0x0801bd5c
 8012318:	200008f0 	.word	0x200008f0
 801231c:	20001568 	.word	0x20001568
 8012320:	000186a0 	.word	0x000186a0
 8012324:	f3af 8000 	nop.w
 8012328:	f3af 8000 	nop.w
 801232c:	f3af 8000 	nop.w

08012330 <cmd_myecho>:


/*******************************
 * SHELL FUNCTIONS
 *******************************/
static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
 8012330:	b500      	push	{lr}
 8012332:	b087      	sub	sp, #28
 8012334:	9003      	str	r0, [sp, #12]
 8012336:	9102      	str	r1, [sp, #8]
 8012338:	9201      	str	r2, [sp, #4]
  int32_t i;
  (void)argv;
  for (i=0;i<argc;i++) {
 801233a:	2300      	movs	r3, #0
 801233c:	9305      	str	r3, [sp, #20]
 801233e:	e00c      	b.n	801235a <cmd_myecho+0x2a>
    chprintf(chp, "%s\n\r", argv[i]);
 8012340:	9b05      	ldr	r3, [sp, #20]
 8012342:	009b      	lsls	r3, r3, #2
 8012344:	9a01      	ldr	r2, [sp, #4]
 8012346:	4413      	add	r3, r2
 8012348:	681b      	ldr	r3, [r3, #0]
 801234a:	9803      	ldr	r0, [sp, #12]
 801234c:	4906      	ldr	r1, [pc, #24]	; (8012368 <cmd_myecho+0x38>)
 801234e:	461a      	mov	r2, r3
 8012350:	f7ff f966 	bl	8011620 <chprintf>
 * SHELL FUNCTIONS
 *******************************/
static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
  int32_t i;
  (void)argv;
  for (i=0;i<argc;i++) {
 8012354:	9b05      	ldr	r3, [sp, #20]
 8012356:	3301      	adds	r3, #1
 8012358:	9305      	str	r3, [sp, #20]
 801235a:	9a05      	ldr	r2, [sp, #20]
 801235c:	9b02      	ldr	r3, [sp, #8]
 801235e:	429a      	cmp	r2, r3
 8012360:	dbee      	blt.n	8012340 <cmd_myecho+0x10>
    chprintf(chp, "%s\n\r", argv[i]);
  }
}
 8012362:	b007      	add	sp, #28
 8012364:	f85d fb04 	ldr.w	pc, [sp], #4
 8012368:	0801bd6c 	.word	0x0801bd6c
 801236c:	f3af 8000 	nop.w

08012370 <cmd_call_maggie>:

//Makes a call
static void cmd_call_maggie(BaseSequentialStream *chp, int argc, char *argv[]) {
 8012370:	b500      	push	{lr}
 8012372:	b087      	sub	sp, #28
 8012374:	9003      	str	r0, [sp, #12]
 8012376:	9102      	str	r1, [sp, #8]
 8012378:	9201      	str	r2, [sp, #4]
  (void)argv;
  (void)argc;

	char * cmd =  "ATD17654041973;";
 801237a:	4b07      	ldr	r3, [pc, #28]	; (8012398 <cmd_call_maggie+0x28>)
 801237c:	9305      	str	r3, [sp, #20]
	EUARTSendCommand(&EUARTH, cmd, 15);
 801237e:	4807      	ldr	r0, [pc, #28]	; (801239c <cmd_call_maggie+0x2c>)
 8012380:	9905      	ldr	r1, [sp, #20]
 8012382:	220f      	movs	r2, #15
 8012384:	f000 fc5c 	bl	8012c40 <EUARTSendCommand>

		chprintf(chp, "Sent call.\n\r");
 8012388:	9803      	ldr	r0, [sp, #12]
 801238a:	4905      	ldr	r1, [pc, #20]	; (80123a0 <cmd_call_maggie+0x30>)
 801238c:	f7ff f948 	bl	8011620 <chprintf>
}
 8012390:	b007      	add	sp, #28
 8012392:	f85d fb04 	ldr.w	pc, [sp], #4
 8012396:	bf00      	nop
 8012398:	0801bd74 	.word	0x0801bd74
 801239c:	200044c0 	.word	0x200044c0
 80123a0:	0801bd84 	.word	0x0801bd84
 80123a4:	f3af 8000 	nop.w
 80123a8:	f3af 8000 	nop.w
 80123ac:	f3af 8000 	nop.w

080123b0 <cmd_modem_cmd>:

static void cmd_modem_cmd(BaseSequentialStream *chp, int argc, char *argv[]) {
 80123b0:	b500      	push	{lr}
 80123b2:	b087      	sub	sp, #28
 80123b4:	9003      	str	r0, [sp, #12]
 80123b6:	9102      	str	r1, [sp, #8]
 80123b8:	9201      	str	r2, [sp, #4]
  (void)argv;
  (void)argc;
	
	if(argc != 1){		chprintf(chp, "Bad args.\n\r"); }
 80123ba:	9b02      	ldr	r3, [sp, #8]
 80123bc:	2b01      	cmp	r3, #1
 80123be:	d004      	beq.n	80123ca <cmd_modem_cmd+0x1a>
 80123c0:	9803      	ldr	r0, [sp, #12]
 80123c2:	490b      	ldr	r1, [pc, #44]	; (80123f0 <cmd_modem_cmd+0x40>)
 80123c4:	f7ff f92c 	bl	8011620 <chprintf>
 80123c8:	e00f      	b.n	80123ea <cmd_modem_cmd+0x3a>
	else{
	char * cmd =  argv[0];
 80123ca:	9b01      	ldr	r3, [sp, #4]
 80123cc:	681b      	ldr	r3, [r3, #0]
 80123ce:	9305      	str	r3, [sp, #20]
	
	EUARTSendCommand(&EUARTH, cmd, strlen(cmd));
 80123d0:	9805      	ldr	r0, [sp, #20]
 80123d2:	f006 f99d 	bl	8018710 <strlen>
 80123d6:	4603      	mov	r3, r0
 80123d8:	4806      	ldr	r0, [pc, #24]	; (80123f4 <cmd_modem_cmd+0x44>)
 80123da:	9905      	ldr	r1, [sp, #20]
 80123dc:	461a      	mov	r2, r3
 80123de:	f000 fc2f 	bl	8012c40 <EUARTSendCommand>

		chprintf(chp, "Sent call.\n\r");
 80123e2:	9803      	ldr	r0, [sp, #12]
 80123e4:	4904      	ldr	r1, [pc, #16]	; (80123f8 <cmd_modem_cmd+0x48>)
 80123e6:	f7ff f91b 	bl	8011620 <chprintf>
	}
}
 80123ea:	b007      	add	sp, #28
 80123ec:	f85d fb04 	ldr.w	pc, [sp], #4
 80123f0:	0801bd94 	.word	0x0801bd94
 80123f4:	200044c0 	.word	0x200044c0
 80123f8:	0801bd84 	.word	0x0801bd84
 80123fc:	f3af 8000 	nop.w

08012400 <cmd_put_char>:
//Transmits one char over emulated UART
static void cmd_put_char(BaseSequentialStream *chp, int argc, char *argv[]) {
 8012400:	b500      	push	{lr}
 8012402:	b087      	sub	sp, #28
 8012404:	9003      	str	r0, [sp, #12]
 8012406:	9102      	str	r1, [sp, #8]
 8012408:	9201      	str	r2, [sp, #4]
  (void)argv;
  (void)argc;

	//@TODO allow for multi-letter chars, e.g. '/n'
	if(argc == 1){
 801240a:	9b02      	ldr	r3, [sp, #8]
 801240c:	2b01      	cmp	r3, #1
 801240e:	d111      	bne.n	8012434 <cmd_put_char+0x34>
		char letter = argv[0][0];
 8012410:	9b01      	ldr	r3, [sp, #4]
 8012412:	681b      	ldr	r3, [r3, #0]
 8012414:	781b      	ldrb	r3, [r3, #0]
 8012416:	f88d 3017 	strb.w	r3, [sp, #23]
		int put_return = EUARTPutChar(&EUARTH, letter);
 801241a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 801241e:	4809      	ldr	r0, [pc, #36]	; (8012444 <cmd_put_char+0x44>)
 8012420:	4619      	mov	r1, r3
 8012422:	f000 fbad 	bl	8012b80 <EUARTPutChar>
 8012426:	9004      	str	r0, [sp, #16]
//    EUARTGetChar(&EUARTH, &ch);
    chprintf(chp, "\n%d\n\r", put_return);
 8012428:	9803      	ldr	r0, [sp, #12]
 801242a:	4907      	ldr	r1, [pc, #28]	; (8012448 <cmd_put_char+0x48>)
 801242c:	9a04      	ldr	r2, [sp, #16]
 801242e:	f7ff f8f7 	bl	8011620 <chprintf>
 8012432:	e003      	b.n	801243c <cmd_put_char+0x3c>
	}
	else{
		chprintf(chp, "Incorrect args.\n\r");
 8012434:	9803      	ldr	r0, [sp, #12]
 8012436:	4905      	ldr	r1, [pc, #20]	; (801244c <cmd_put_char+0x4c>)
 8012438:	f7ff f8f2 	bl	8011620 <chprintf>
	}
}
 801243c:	b007      	add	sp, #28
 801243e:	f85d fb04 	ldr.w	pc, [sp], #4
 8012442:	bf00      	nop
 8012444:	200044c0 	.word	0x200044c0
 8012448:	0801bda0 	.word	0x0801bda0
 801244c:	0801bda8 	.word	0x0801bda8

08012450 <cmd_get_char>:

//Receives one char over emulated UART, or times out
static void cmd_get_char(BaseSequentialStream *chp, int argc, char *argv[]) {
 8012450:	b500      	push	{lr}
 8012452:	b087      	sub	sp, #28
 8012454:	9003      	str	r0, [sp, #12]
 8012456:	9102      	str	r1, [sp, #8]
 8012458:	9201      	str	r2, [sp, #4]

	uint8_t code;
	char ch;
	int i;
//	for(i = 0; i < 5; i++){
					code = EUARTGetChar(&EUARTH, &ch);
 801245a:	f10d 0316 	add.w	r3, sp, #22
 801245e:	4811      	ldr	r0, [pc, #68]	; (80124a4 <cmd_get_char+0x54>)
 8012460:	4619      	mov	r1, r3
 8012462:	f000 fc0d 	bl	8012c80 <EUARTGetChar>
 8012466:	4603      	mov	r3, r0
 8012468:	f88d 3017 	strb.w	r3, [sp, #23]
					if(code == EUART_TIMEOUT){
 801246c:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8012470:	2b06      	cmp	r3, #6
 8012472:	d104      	bne.n	801247e <cmd_get_char+0x2e>
						chprintf(chp, "EUART Timed out\n\r");
 8012474:	9803      	ldr	r0, [sp, #12]
 8012476:	490c      	ldr	r1, [pc, #48]	; (80124a8 <cmd_get_char+0x58>)
 8012478:	f7ff f8d2 	bl	8011620 <chprintf>
 801247c:	e007      	b.n	801248e <cmd_get_char+0x3e>
					}
					else if(code == EUART_ERROR){
 801247e:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8012482:	2b07      	cmp	r3, #7
 8012484:	d103      	bne.n	801248e <cmd_get_char+0x3e>
						chprintf(chp, "EUART Error\n\r");
 8012486:	9803      	ldr	r0, [sp, #12]
 8012488:	4908      	ldr	r1, [pc, #32]	; (80124ac <cmd_get_char+0x5c>)
 801248a:	f7ff f8c9 	bl	8011620 <chprintf>
					}
					chprintf(chp, "\ngot char: %c aka 0x%x\n\r", ch);
 801248e:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8012492:	9803      	ldr	r0, [sp, #12]
 8012494:	4906      	ldr	r1, [pc, #24]	; (80124b0 <cmd_get_char+0x60>)
 8012496:	461a      	mov	r2, r3
 8012498:	f7ff f8c2 	bl	8011620 <chprintf>
//	}
}
 801249c:	b007      	add	sp, #28
 801249e:	f85d fb04 	ldr.w	pc, [sp], #4
 80124a2:	bf00      	nop
 80124a4:	200044c0 	.word	0x200044c0
 80124a8:	0801bdbc 	.word	0x0801bdbc
 80124ac:	0801bdd0 	.word	0x0801bdd0
 80124b0:	0801bde0 	.word	0x0801bde0
 80124b4:	f3af 8000 	nop.w
 80124b8:	f3af 8000 	nop.w
 80124bc:	f3af 8000 	nop.w

080124c0 <cmd_test_char>:

static void cmd_test_char(BaseSequentialStream *chp, int argc, char *argv[]) {
 80124c0:	b500      	push	{lr}
 80124c2:	b08b      	sub	sp, #44	; 0x2c
 80124c4:	9005      	str	r0, [sp, #20]
 80124c6:	9104      	str	r1, [sp, #16]
 80124c8:	9203      	str	r2, [sp, #12]
  (void)argv;
  (void)argc;
	char letter = '\0';
 80124ca:	2300      	movs	r3, #0
 80124cc:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27

	if(argc == 1){
 80124d0:	9b04      	ldr	r3, [sp, #16]
 80124d2:	2b01      	cmp	r3, #1
 80124d4:	d105      	bne.n	80124e2 <cmd_test_char+0x22>
		letter = argv[0][0];}
 80124d6:	9b03      	ldr	r3, [sp, #12]
 80124d8:	681b      	ldr	r3, [r3, #0]
 80124da:	781b      	ldrb	r3, [r3, #0]
 80124dc:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
 80124e0:	e003      	b.n	80124ea <cmd_test_char+0x2a>
	else	{
		chprintf(chp, "Incorrect args.\n\r");}
 80124e2:	9805      	ldr	r0, [sp, #20]
 80124e4:	491d      	ldr	r1, [pc, #116]	; (801255c <cmd_test_char+0x9c>)
 80124e6:	f7ff f89b 	bl	8011620 <chprintf>

	uint8_t code;
	char ch;
	int i;
	for(i = 0; i < 5; i++){
 80124ea:	2300      	movs	r3, #0
 80124ec:	9308      	str	r3, [sp, #32]
 80124ee:	e02f      	b.n	8012550 <cmd_test_char+0x90>
					
					int put_return = EUARTPutChar(&EUARTH, letter);
 80124f0:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 80124f4:	481a      	ldr	r0, [pc, #104]	; (8012560 <cmd_test_char+0xa0>)
 80124f6:	4619      	mov	r1, r3
 80124f8:	f000 fb42 	bl	8012b80 <EUARTPutChar>
 80124fc:	9007      	str	r0, [sp, #28]
					code = EUARTGetChar(&EUARTH, &ch);
 80124fe:	f10d 031a 	add.w	r3, sp, #26
 8012502:	4817      	ldr	r0, [pc, #92]	; (8012560 <cmd_test_char+0xa0>)
 8012504:	4619      	mov	r1, r3
 8012506:	f000 fbbb 	bl	8012c80 <EUARTGetChar>
 801250a:	4603      	mov	r3, r0
 801250c:	f88d 301b 	strb.w	r3, [sp, #27]
					if(code == EUART_TIMEOUT){
 8012510:	f89d 301b 	ldrb.w	r3, [sp, #27]
 8012514:	2b06      	cmp	r3, #6
 8012516:	d104      	bne.n	8012522 <cmd_test_char+0x62>
						chprintf(chp, "EUART Timed out\n\r");
 8012518:	9805      	ldr	r0, [sp, #20]
 801251a:	4912      	ldr	r1, [pc, #72]	; (8012564 <cmd_test_char+0xa4>)
 801251c:	f7ff f880 	bl	8011620 <chprintf>
 8012520:	e007      	b.n	8012532 <cmd_test_char+0x72>
					}
					else if(code == EUART_ERROR){
 8012522:	f89d 301b 	ldrb.w	r3, [sp, #27]
 8012526:	2b07      	cmp	r3, #7
 8012528:	d103      	bne.n	8012532 <cmd_test_char+0x72>
						chprintf(chp, "EUART Error\n\r");
 801252a:	9805      	ldr	r0, [sp, #20]
 801252c:	490e      	ldr	r1, [pc, #56]	; (8012568 <cmd_test_char+0xa8>)
 801252e:	f7ff f877 	bl	8011620 <chprintf>
					}
					chprintf(chp, "\ngot char: %c aka 0x%x, compare to %c\n\r", ch, (int) ch, letter);
 8012532:	f89d 301a 	ldrb.w	r3, [sp, #26]
 8012536:	461a      	mov	r2, r3
 8012538:	f89d 301a 	ldrb.w	r3, [sp, #26]
 801253c:	f89d 1027 	ldrb.w	r1, [sp, #39]	; 0x27
 8012540:	9100      	str	r1, [sp, #0]
 8012542:	9805      	ldr	r0, [sp, #20]
 8012544:	4909      	ldr	r1, [pc, #36]	; (801256c <cmd_test_char+0xac>)
 8012546:	f7ff f86b 	bl	8011620 <chprintf>
		chprintf(chp, "Incorrect args.\n\r");}

	uint8_t code;
	char ch;
	int i;
	for(i = 0; i < 5; i++){
 801254a:	9b08      	ldr	r3, [sp, #32]
 801254c:	3301      	adds	r3, #1
 801254e:	9308      	str	r3, [sp, #32]
 8012550:	9b08      	ldr	r3, [sp, #32]
 8012552:	2b04      	cmp	r3, #4
 8012554:	ddcc      	ble.n	80124f0 <cmd_test_char+0x30>
					else if(code == EUART_ERROR){
						chprintf(chp, "EUART Error\n\r");
					}
					chprintf(chp, "\ngot char: %c aka 0x%x, compare to %c\n\r", ch, (int) ch, letter);
	}
}
 8012556:	b00b      	add	sp, #44	; 0x2c
 8012558:	f85d fb04 	ldr.w	pc, [sp], #4
 801255c:	0801bda8 	.word	0x0801bda8
 8012560:	200044c0 	.word	0x200044c0
 8012564:	0801bdbc 	.word	0x0801bdbc
 8012568:	0801bdd0 	.word	0x0801bdd0
 801256c:	0801bdfc 	.word	0x0801bdfc

08012570 <cmd_accel_wai>:

//Prints whoami value for accel
static void cmd_accel_wai(BaseSequentialStream *chp, int argc, char *argv[]) {
 8012570:	b500      	push	{lr}
 8012572:	b087      	sub	sp, #28
 8012574:	9003      	str	r0, [sp, #12]
 8012576:	9102      	str	r1, [sp, #8]
 8012578:	9201      	str	r2, [sp, #4]
  uint8_t wai;
  (void)argv;
  (void)argc;

  LSM303AGR_ACC_R_WHO_AM_I(NULL, &wai);
 801257a:	f10d 0317 	add.w	r3, sp, #23
 801257e:	2000      	movs	r0, #0
 8012580:	4619      	mov	r1, r3
 8012582:	f000 fccd 	bl	8012f20 <LSM303AGR_ACC_R_WHO_AM_I>
  chprintf(chp,"lsm303 Who Am I data = 0x%02x\n\r",wai);
 8012586:	f89d 3017 	ldrb.w	r3, [sp, #23]
 801258a:	9803      	ldr	r0, [sp, #12]
 801258c:	4903      	ldr	r1, [pc, #12]	; (801259c <cmd_accel_wai+0x2c>)
 801258e:	461a      	mov	r2, r3
 8012590:	f7ff f846 	bl	8011620 <chprintf>
}
 8012594:	b007      	add	sp, #28
 8012596:	f85d fb04 	ldr.w	pc, [sp], #4
 801259a:	bf00      	nop
 801259c:	0801be24 	.word	0x0801be24

080125a0 <cmd_accel_print>:

//Prints current reading on accel
static void cmd_accel_print(BaseSequentialStream *chp, int argc, char *argv[]) {
 80125a0:	b500      	push	{lr}
 80125a2:	b08b      	sub	sp, #44	; 0x2c
 80125a4:	9005      	str	r0, [sp, #20]
 80125a6:	9104      	str	r1, [sp, #16]
 80125a8:	9203      	str	r2, [sp, #12]
  (void)argv;
  (void)argc;

	int accel_axes[3];
	LSM303AGR_ACC_Get_Acceleration(NULL, accel_axes); //Read accelerometer
 80125aa:	ab07      	add	r3, sp, #28
 80125ac:	2000      	movs	r0, #0
 80125ae:	4619      	mov	r1, r3
 80125b0:	f000 fd96 	bl	80130e0 <LSM303AGR_ACC_Get_Acceleration>
	chprintf(chp,"\rRaw: %d, %d, %d\r\n", accel_axes[0], accel_axes[1], accel_axes[2]);
 80125b4:	9a07      	ldr	r2, [sp, #28]
 80125b6:	9b08      	ldr	r3, [sp, #32]
 80125b8:	9909      	ldr	r1, [sp, #36]	; 0x24
 80125ba:	9100      	str	r1, [sp, #0]
 80125bc:	9805      	ldr	r0, [sp, #20]
 80125be:	4917      	ldr	r1, [pc, #92]	; (801261c <cmd_accel_print+0x7c>)
 80125c0:	f7ff f82e 	bl	8011620 <chprintf>
	for(i = 0; i < 3; i++){
 80125c4:	4b16      	ldr	r3, [pc, #88]	; (8012620 <cmd_accel_print+0x80>)
 80125c6:	2200      	movs	r2, #0
 80125c8:	601a      	str	r2, [r3, #0]
 80125ca:	e018      	b.n	80125fe <cmd_accel_print+0x5e>
		accel_axes[i] = accel_axes[i] + calibrated_axes[i];
 80125cc:	4b14      	ldr	r3, [pc, #80]	; (8012620 <cmd_accel_print+0x80>)
 80125ce:	6819      	ldr	r1, [r3, #0]
 80125d0:	4b13      	ldr	r3, [pc, #76]	; (8012620 <cmd_accel_print+0x80>)
 80125d2:	681b      	ldr	r3, [r3, #0]
 80125d4:	009b      	lsls	r3, r3, #2
 80125d6:	aa0a      	add	r2, sp, #40	; 0x28
 80125d8:	4413      	add	r3, r2
 80125da:	f853 2c0c 	ldr.w	r2, [r3, #-12]
 80125de:	4b10      	ldr	r3, [pc, #64]	; (8012620 <cmd_accel_print+0x80>)
 80125e0:	6818      	ldr	r0, [r3, #0]
 80125e2:	4b10      	ldr	r3, [pc, #64]	; (8012624 <cmd_accel_print+0x84>)
 80125e4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80125e8:	441a      	add	r2, r3
 80125ea:	008b      	lsls	r3, r1, #2
 80125ec:	a90a      	add	r1, sp, #40	; 0x28
 80125ee:	440b      	add	r3, r1
 80125f0:	f843 2c0c 	str.w	r2, [r3, #-12]
  (void)argc;

	int accel_axes[3];
	LSM303AGR_ACC_Get_Acceleration(NULL, accel_axes); //Read accelerometer
	chprintf(chp,"\rRaw: %d, %d, %d\r\n", accel_axes[0], accel_axes[1], accel_axes[2]);
	for(i = 0; i < 3; i++){
 80125f4:	4b0a      	ldr	r3, [pc, #40]	; (8012620 <cmd_accel_print+0x80>)
 80125f6:	681b      	ldr	r3, [r3, #0]
 80125f8:	1c5a      	adds	r2, r3, #1
 80125fa:	4b09      	ldr	r3, [pc, #36]	; (8012620 <cmd_accel_print+0x80>)
 80125fc:	601a      	str	r2, [r3, #0]
 80125fe:	4b08      	ldr	r3, [pc, #32]	; (8012620 <cmd_accel_print+0x80>)
 8012600:	681b      	ldr	r3, [r3, #0]
 8012602:	2b02      	cmp	r3, #2
 8012604:	dde2      	ble.n	80125cc <cmd_accel_print+0x2c>
		accel_axes[i] = accel_axes[i] + calibrated_axes[i];
	}	
	chprintf(chp,"\rCalibrated: %d, %d, %d\r\n", accel_axes[0], accel_axes[1], accel_axes[2]);
 8012606:	9a07      	ldr	r2, [sp, #28]
 8012608:	9b08      	ldr	r3, [sp, #32]
 801260a:	9909      	ldr	r1, [sp, #36]	; 0x24
 801260c:	9100      	str	r1, [sp, #0]
 801260e:	9805      	ldr	r0, [sp, #20]
 8012610:	4905      	ldr	r1, [pc, #20]	; (8012628 <cmd_accel_print+0x88>)
 8012612:	f7ff f805 	bl	8011620 <chprintf>
}
 8012616:	b00b      	add	sp, #44	; 0x2c
 8012618:	f85d fb04 	ldr.w	pc, [sp], #4
 801261c:	0801be44 	.word	0x0801be44
 8012620:	200044d8 	.word	0x200044d8
 8012624:	200008f0 	.word	0x200008f0
 8012628:	0801be58 	.word	0x0801be58
 801262c:	f3af 8000 	nop.w

08012630 <cmd_display_counts>:

static void cmd_display_counts(BaseSequentialStream *chp, int argc, char *argv[]){
 8012630:	b530      	push	{r4, r5, lr}
 8012632:	b08f      	sub	sp, #60	; 0x3c
 8012634:	9007      	str	r0, [sp, #28]
 8012636:	9106      	str	r1, [sp, #24]
 8012638:	9205      	str	r2, [sp, #20]
	(void)argv;
	(void)argc; 

	int i;
	RTCDateTime ts;
	for(i = 0; i < num_timestamps; i++){
 801263a:	2300      	movs	r3, #0
 801263c:	930d      	str	r3, [sp, #52]	; 0x34
 801263e:	e052      	b.n	80126e6 <cmd_display_counts+0xb6>
			ts = timestamp_data[i].time;
 8012640:	4932      	ldr	r1, [pc, #200]	; (801270c <cmd_display_counts+0xdc>)
 8012642:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8012644:	4613      	mov	r3, r2
 8012646:	005b      	lsls	r3, r3, #1
 8012648:	4413      	add	r3, r2
 801264a:	009b      	lsls	r3, r3, #2
 801264c:	18ca      	adds	r2, r1, r3
 801264e:	ab09      	add	r3, sp, #36	; 0x24
 8012650:	e892 0003 	ldmia.w	r2, {r0, r1}
 8012654:	e883 0003 	stmia.w	r3, {r0, r1}
			int hours = ts.millisecond / 3600000; //converting ms to hours
 8012658:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801265a:	f3c3 031a 	ubfx	r3, r3, #0, #27
 801265e:	4a2c      	ldr	r2, [pc, #176]	; (8012710 <cmd_display_counts+0xe0>)
 8012660:	fb82 1203 	smull	r1, r2, r2, r3
 8012664:	1512      	asrs	r2, r2, #20
 8012666:	17db      	asrs	r3, r3, #31
 8012668:	1ad3      	subs	r3, r2, r3
 801266a:	930c      	str	r3, [sp, #48]	; 0x30
			int mins = ts.millisecond % 3600000 / 60000; //converting ms to minutes
 801266c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801266e:	f3c3 031a 	ubfx	r3, r3, #0, #27
 8012672:	461a      	mov	r2, r3
 8012674:	4b26      	ldr	r3, [pc, #152]	; (8012710 <cmd_display_counts+0xe0>)
 8012676:	fb83 1302 	smull	r1, r3, r3, r2
 801267a:	1519      	asrs	r1, r3, #20
 801267c:	17d3      	asrs	r3, r2, #31
 801267e:	1acb      	subs	r3, r1, r3
 8012680:	4924      	ldr	r1, [pc, #144]	; (8012714 <cmd_display_counts+0xe4>)
 8012682:	fb01 f303 	mul.w	r3, r1, r3
 8012686:	1ad3      	subs	r3, r2, r3
 8012688:	4a23      	ldr	r2, [pc, #140]	; (8012718 <cmd_display_counts+0xe8>)
 801268a:	fb82 1203 	smull	r1, r2, r2, r3
 801268e:	1392      	asrs	r2, r2, #14
 8012690:	17db      	asrs	r3, r3, #31
 8012692:	1ad3      	subs	r3, r2, r3
 8012694:	930b      	str	r3, [sp, #44]	; 0x2c
  		chprintf(chp,"\r%02d/%02d/%04d %02d:%02d -  %d\r\n", ts.month, ts.day,ts.year + 1980, hours, mins, timestamp_data[i].people_count);
 8012696:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 801269a:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801269e:	b2db      	uxtb	r3, r3
 80126a0:	461d      	mov	r5, r3
 80126a2:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
 80126a6:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80126aa:	b2db      	uxtb	r3, r3
 80126ac:	461c      	mov	r4, r3
 80126ae:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
 80126b2:	f203 71bc 	addw	r1, r3, #1980	; 0x7bc
 80126b6:	4815      	ldr	r0, [pc, #84]	; (801270c <cmd_display_counts+0xdc>)
 80126b8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80126ba:	4613      	mov	r3, r2
 80126bc:	005b      	lsls	r3, r3, #1
 80126be:	4413      	add	r3, r2
 80126c0:	009b      	lsls	r3, r3, #2
 80126c2:	4403      	add	r3, r0
 80126c4:	3308      	adds	r3, #8
 80126c6:	681b      	ldr	r3, [r3, #0]
 80126c8:	9100      	str	r1, [sp, #0]
 80126ca:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80126cc:	9201      	str	r2, [sp, #4]
 80126ce:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80126d0:	9202      	str	r2, [sp, #8]
 80126d2:	9303      	str	r3, [sp, #12]
 80126d4:	9807      	ldr	r0, [sp, #28]
 80126d6:	4911      	ldr	r1, [pc, #68]	; (801271c <cmd_display_counts+0xec>)
 80126d8:	462a      	mov	r2, r5
 80126da:	4623      	mov	r3, r4
 80126dc:	f7fe ffa0 	bl	8011620 <chprintf>
	(void)argv;
	(void)argc; 

	int i;
	RTCDateTime ts;
	for(i = 0; i < num_timestamps; i++){
 80126e0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80126e2:	3301      	adds	r3, #1
 80126e4:	930d      	str	r3, [sp, #52]	; 0x34
 80126e6:	4b0e      	ldr	r3, [pc, #56]	; (8012720 <cmd_display_counts+0xf0>)
 80126e8:	681b      	ldr	r3, [r3, #0]
 80126ea:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80126ec:	429a      	cmp	r2, r3
 80126ee:	dba7      	blt.n	8012640 <cmd_display_counts+0x10>
			ts = timestamp_data[i].time;
			int hours = ts.millisecond / 3600000; //converting ms to hours
			int mins = ts.millisecond % 3600000 / 60000; //converting ms to minutes
  		chprintf(chp,"\r%02d/%02d/%04d %02d:%02d -  %d\r\n", ts.month, ts.day,ts.year + 1980, hours, mins, timestamp_data[i].people_count);
	} 
  		chprintf(chp,"\r%d records, approx. %d seconds of recording\r\n", num_timestamps, num_timestamps * TIMESTAMP_FREQ);
 80126f0:	4b0b      	ldr	r3, [pc, #44]	; (8012720 <cmd_display_counts+0xf0>)
 80126f2:	681c      	ldr	r4, [r3, #0]
 80126f4:	4b0a      	ldr	r3, [pc, #40]	; (8012720 <cmd_display_counts+0xf0>)
 80126f6:	681a      	ldr	r2, [r3, #0]
 80126f8:	4613      	mov	r3, r2
 80126fa:	011b      	lsls	r3, r3, #4
 80126fc:	1a9b      	subs	r3, r3, r2
 80126fe:	9807      	ldr	r0, [sp, #28]
 8012700:	4908      	ldr	r1, [pc, #32]	; (8012724 <cmd_display_counts+0xf4>)
 8012702:	4622      	mov	r2, r4
 8012704:	f7fe ff8c 	bl	8011620 <chprintf>
}
 8012708:	b00f      	add	sp, #60	; 0x3c
 801270a:	bd30      	pop	{r4, r5, pc}
 801270c:	200044e4 	.word	0x200044e4
 8012710:	4a90be59 	.word	0x4a90be59
 8012714:	0036ee80 	.word	0x0036ee80
 8012718:	45e7b273 	.word	0x45e7b273
 801271c:	0801be74 	.word	0x0801be74
 8012720:	20001574 	.word	0x20001574
 8012724:	0801be98 	.word	0x0801be98
 8012728:	f3af 8000 	nop.w
 801272c:	f3af 8000 	nop.w

08012730 <cmd_accel_calibrate>:
//Recalibrates accelerometer
static void cmd_accel_calibrate(BaseSequentialStream *chp, int argc, char *argv[]){
 8012730:	b500      	push	{lr}
 8012732:	b087      	sub	sp, #28
 8012734:	9005      	str	r0, [sp, #20]
 8012736:	9104      	str	r1, [sp, #16]
 8012738:	9203      	str	r2, [sp, #12]
	(void)argv;
	(void)argc; 
  		
	chprintf(chp,"\rDevice should be held in a fixed position in its intended orientation with no vibration\r\n");
 801273a:	9805      	ldr	r0, [sp, #20]
 801273c:	490c      	ldr	r1, [pc, #48]	; (8012770 <cmd_accel_calibrate+0x40>)
 801273e:	f7fe ff6f 	bl	8011620 <chprintf>
	chprintf(chp,"\rCalibrating...\r\n");
 8012742:	9805      	ldr	r0, [sp, #20]
 8012744:	490b      	ldr	r1, [pc, #44]	; (8012774 <cmd_accel_calibrate+0x44>)
 8012746:	f7fe ff6b 	bl	8011620 <chprintf>
	
	LSM303AGR_ACC_Get_Acceleration(NULL, calibrated_axes);
 801274a:	2000      	movs	r0, #0
 801274c:	490a      	ldr	r1, [pc, #40]	; (8012778 <cmd_accel_calibrate+0x48>)
 801274e:	f000 fcc7 	bl	80130e0 <LSM303AGR_ACC_Get_Acceleration>
	chprintf(chp,"\rCalibrated with X: %d, Y: %d, Z:%d\r\n", calibrated_axes[0], calibrated_axes[1], calibrated_axes[2]);	
 8012752:	4b09      	ldr	r3, [pc, #36]	; (8012778 <cmd_accel_calibrate+0x48>)
 8012754:	681a      	ldr	r2, [r3, #0]
 8012756:	4b08      	ldr	r3, [pc, #32]	; (8012778 <cmd_accel_calibrate+0x48>)
 8012758:	685b      	ldr	r3, [r3, #4]
 801275a:	4907      	ldr	r1, [pc, #28]	; (8012778 <cmd_accel_calibrate+0x48>)
 801275c:	6889      	ldr	r1, [r1, #8]
 801275e:	9100      	str	r1, [sp, #0]
 8012760:	9805      	ldr	r0, [sp, #20]
 8012762:	4906      	ldr	r1, [pc, #24]	; (801277c <cmd_accel_calibrate+0x4c>)
 8012764:	f7fe ff5c 	bl	8011620 <chprintf>
}
 8012768:	b007      	add	sp, #28
 801276a:	f85d fb04 	ldr.w	pc, [sp], #4
 801276e:	bf00      	nop
 8012770:	0801bec8 	.word	0x0801bec8
 8012774:	0801bf24 	.word	0x0801bf24
 8012778:	200008f0 	.word	0x200008f0
 801277c:	0801bf38 	.word	0x0801bf38

08012780 <cmd_start_tcp>:

//Recalibrates accelerometer
static void cmd_start_tcp(BaseSequentialStream *chp, int argc, char *argv[]){
 8012780:	b500      	push	{lr}
 8012782:	b085      	sub	sp, #20
 8012784:	9003      	str	r0, [sp, #12]
 8012786:	9102      	str	r1, [sp, #8]
 8012788:	9201      	str	r2, [sp, #4]
	(void)argv;
	(void)argc; 
  	
  	start_tcp = 1;	
 801278a:	4b05      	ldr	r3, [pc, #20]	; (80127a0 <cmd_start_tcp+0x20>)
 801278c:	2201      	movs	r2, #1
 801278e:	601a      	str	r2, [r3, #0]
	chprintf(chp, "\rSet TCP flag\r\n");
 8012790:	9803      	ldr	r0, [sp, #12]
 8012792:	4904      	ldr	r1, [pc, #16]	; (80127a4 <cmd_start_tcp+0x24>)
 8012794:	f7fe ff44 	bl	8011620 <chprintf>
	
	
	}
 8012798:	b005      	add	sp, #20
 801279a:	f85d fb04 	ldr.w	pc, [sp], #4
 801279e:	bf00      	nop
 80127a0:	200008fc 	.word	0x200008fc
 80127a4:	0801bf60 	.word	0x0801bf60
 80127a8:	f3af 8000 	nop.w
 80127ac:	f3af 8000 	nop.w

080127b0 <cmd_set_time>:


//Sets current time in order to collect data with timestamps.
static void cmd_set_time(BaseSequentialStream *chp, int argc, char *argv[]){
 80127b0:	b500      	push	{lr}
 80127b2:	b08b      	sub	sp, #44	; 0x2c
 80127b4:	9003      	str	r0, [sp, #12]
 80127b6:	9102      	str	r1, [sp, #8]
 80127b8:	9201      	str	r2, [sp, #4]
	if(argc != 2){
 80127ba:	9b02      	ldr	r3, [sp, #8]
 80127bc:	2b02      	cmp	r3, #2
 80127be:	d008      	beq.n	80127d2 <cmd_set_time+0x22>
		chprintf(chp,"\rIncorrect arguments. Example input:\r\n");		
 80127c0:	9803      	ldr	r0, [sp, #12]
 80127c2:	4949      	ldr	r1, [pc, #292]	; (80128e8 <cmd_set_time+0x138>)
 80127c4:	f7fe ff2c 	bl	8011620 <chprintf>
		chprintf(chp,"\rset_time DD/MM/YYYY HH:MM (military time)\r\n");	
 80127c8:	9803      	ldr	r0, [sp, #12]
 80127ca:	4948      	ldr	r1, [pc, #288]	; (80128ec <cmd_set_time+0x13c>)
 80127cc:	f7fe ff28 	bl	8011620 <chprintf>
 80127d0:	e087      	b.n	80128e2 <cmd_set_time+0x132>
		return;	
	}

	char * token;
	RTCDateTime time_spec;
	const char slash[2] = "/";
 80127d2:	232f      	movs	r3, #47	; 0x2f
 80127d4:	f8ad 3014 	strh.w	r3, [sp, #20]
	const char colon[2] = ":";
 80127d8:	233a      	movs	r3, #58	; 0x3a
 80127da:	f8ad 3010 	strh.w	r3, [sp, #16]

	//@TODO error handling for bad inputs
	token = strtok(argv[0], slash); //Day	
 80127de:	9b01      	ldr	r3, [sp, #4]
 80127e0:	681a      	ldr	r2, [r3, #0]
 80127e2:	ab05      	add	r3, sp, #20
 80127e4:	4610      	mov	r0, r2
 80127e6:	4619      	mov	r1, r3
 80127e8:	f006 f80a 	bl	8018800 <strtok>
 80127ec:	9009      	str	r0, [sp, #36]	; 0x24
	time_spec.day = atoi(token); //Day
 80127ee:	9809      	ldr	r0, [sp, #36]	; 0x24
 80127f0:	f005 f8be 	bl	8017970 <atoi>
 80127f4:	4603      	mov	r3, r0
 80127f6:	b2db      	uxtb	r3, r3
 80127f8:	f003 031f 	and.w	r3, r3, #31
 80127fc:	b2da      	uxtb	r2, r3
 80127fe:	f89d 301a 	ldrb.w	r3, [sp, #26]
 8012802:	f362 0304 	bfi	r3, r2, #0, #5
 8012806:	f88d 301a 	strb.w	r3, [sp, #26]
	token = strtok(NULL, slash); //Month	
 801280a:	ab05      	add	r3, sp, #20
 801280c:	2000      	movs	r0, #0
 801280e:	4619      	mov	r1, r3
 8012810:	f005 fff6 	bl	8018800 <strtok>
 8012814:	9009      	str	r0, [sp, #36]	; 0x24
	time_spec.month = atoi(token); //Month
 8012816:	9809      	ldr	r0, [sp, #36]	; 0x24
 8012818:	f005 f8aa 	bl	8017970 <atoi>
 801281c:	4603      	mov	r3, r0
 801281e:	b2db      	uxtb	r3, r3
 8012820:	f003 030f 	and.w	r3, r3, #15
 8012824:	b2da      	uxtb	r2, r3
 8012826:	f89d 3019 	ldrb.w	r3, [sp, #25]
 801282a:	f362 0303 	bfi	r3, r2, #0, #4
 801282e:	f88d 3019 	strb.w	r3, [sp, #25]
	token = strtok(NULL, slash); //Year
 8012832:	ab05      	add	r3, sp, #20
 8012834:	2000      	movs	r0, #0
 8012836:	4619      	mov	r1, r3
 8012838:	f005 ffe2 	bl	8018800 <strtok>
 801283c:	9009      	str	r0, [sp, #36]	; 0x24
	time_spec.year = atoi(token) - 1980; //Year (offset by 1980)
 801283e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8012840:	f005 f896 	bl	8017970 <atoi>
 8012844:	4603      	mov	r3, r0
 8012846:	b2db      	uxtb	r3, r3
 8012848:	3344      	adds	r3, #68	; 0x44
 801284a:	b2da      	uxtb	r2, r3
 801284c:	f89d 3018 	ldrb.w	r3, [sp, #24]
 8012850:	f362 0307 	bfi	r3, r2, #0, #8
 8012854:	f88d 3018 	strb.w	r3, [sp, #24]
	
	int milliseconds;
	token = strtok(argv[1], colon); //Hour
 8012858:	9b01      	ldr	r3, [sp, #4]
 801285a:	3304      	adds	r3, #4
 801285c:	681a      	ldr	r2, [r3, #0]
 801285e:	ab04      	add	r3, sp, #16
 8012860:	4610      	mov	r0, r2
 8012862:	4619      	mov	r1, r3
 8012864:	f005 ffcc 	bl	8018800 <strtok>
 8012868:	9009      	str	r0, [sp, #36]	; 0x24
	milliseconds = atoi(token) * 60 * 60 * 1000; //Hour to milliseconds
 801286a:	9809      	ldr	r0, [sp, #36]	; 0x24
 801286c:	f005 f880 	bl	8017970 <atoi>
 8012870:	4603      	mov	r3, r0
 8012872:	4a1f      	ldr	r2, [pc, #124]	; (80128f0 <cmd_set_time+0x140>)
 8012874:	fb02 f303 	mul.w	r3, r2, r3
 8012878:	9308      	str	r3, [sp, #32]
	token = strtok(NULL, colon); //Min
 801287a:	ab04      	add	r3, sp, #16
 801287c:	2000      	movs	r0, #0
 801287e:	4619      	mov	r1, r3
 8012880:	f005 ffbe 	bl	8018800 <strtok>
 8012884:	9009      	str	r0, [sp, #36]	; 0x24
	time_spec.millisecond = atoi(token) * 60 * 1000 + milliseconds; //Min to millisecond
 8012886:	9809      	ldr	r0, [sp, #36]	; 0x24
 8012888:	f005 f872 	bl	8017970 <atoi>
 801288c:	4603      	mov	r3, r0
 801288e:	f64e 2260 	movw	r2, #60000	; 0xea60
 8012892:	fb02 f203 	mul.w	r2, r2, r3
 8012896:	9b08      	ldr	r3, [sp, #32]
 8012898:	4413      	add	r3, r2
 801289a:	f023 4278 	bic.w	r2, r3, #4160749568	; 0xf8000000
 801289e:	9b07      	ldr	r3, [sp, #28]
 80128a0:	f362 031a 	bfi	r3, r2, #0, #27
 80128a4:	9307      	str	r3, [sp, #28]

	//Fill in rest of struct with defaults
	time_spec.dstflag = 1;	
 80128a6:	f89d 3019 	ldrb.w	r3, [sp, #25]
 80128aa:	f043 0310 	orr.w	r3, r3, #16
 80128ae:	f88d 3019 	strb.w	r3, [sp, #25]
	time_spec.dayofweek = 1; //This is wrong
 80128b2:	f89d 3019 	ldrb.w	r3, [sp, #25]
 80128b6:	2201      	movs	r2, #1
 80128b8:	f362 1347 	bfi	r3, r2, #5, #3
 80128bc:	f88d 3019 	strb.w	r3, [sp, #25]

	rtcSetTime(&RTCD1, &time_spec);
 80128c0:	ab06      	add	r3, sp, #24
 80128c2:	480c      	ldr	r0, [pc, #48]	; (80128f4 <cmd_set_time+0x144>)
 80128c4:	4619      	mov	r1, r3
 80128c6:	f7f2 fbdb 	bl	8005080 <rtcSetTime>
	//"Wipe" old data.
	num_timestamps = 0;
 80128ca:	4b0b      	ldr	r3, [pc, #44]	; (80128f8 <cmd_set_time+0x148>)
 80128cc:	2200      	movs	r2, #0
 80128ce:	601a      	str	r2, [r3, #0]
	people_count = 0;
 80128d0:	4b0a      	ldr	r3, [pc, #40]	; (80128fc <cmd_set_time+0x14c>)
 80128d2:	2200      	movs	r2, #0
 80128d4:	601a      	str	r2, [r3, #0]
	start_time = time_spec;
 80128d6:	4b0a      	ldr	r3, [pc, #40]	; (8012900 <cmd_set_time+0x150>)
 80128d8:	aa06      	add	r2, sp, #24
 80128da:	e892 0003 	ldmia.w	r2, {r0, r1}
 80128de:	e883 0003 	stmia.w	r3, {r0, r1}
	//@TODO make this better! Use system time
}
 80128e2:	b00b      	add	sp, #44	; 0x2c
 80128e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80128e8:	0801bf70 	.word	0x0801bf70
 80128ec:	0801bf98 	.word	0x0801bf98
 80128f0:	0036ee80 	.word	0x0036ee80
 80128f4:	20003d38 	.word	0x20003d38
 80128f8:	20001574 	.word	0x20001574
 80128fc:	20001568 	.word	0x20001568
 8012900:	200044dc 	.word	0x200044dc
 8012904:	f3af 8000 	nop.w
 8012908:	f3af 8000 	nop.w
 801290c:	f3af 8000 	nop.w

08012910 <main>:

/*
 * Application entry point.
 */

int main(void) {
 8012910:	b500      	push	{lr}
 8012912:	b083      	sub	sp, #12
   *   RTOS is active.
   */

	static thread_t *shelltp = NULL;

  halInit();
 8012914:	f7f1 f95c 	bl	8003bd0 <halInit>
  chSysInit();
 8012918:	f7ed fec2 	bl	80006a0 <chSysInit>

  /*
   * Activates the serial driver 5 using the driver default configuration.
   * PC12(TX) and PD2(RX). The default baud rate is 38400.
   */
  sdStart(&SD5, NULL);
 801291c:	4830      	ldr	r0, [pc, #192]	; (80129e0 <main+0xd0>)
 801291e:	2100      	movs	r1, #0
 8012920:	f7f3 fc76 	bl	8006210 <sdStart>
  chprintf((BaseSequentialStream*)&SD5, "\n\rUp and Running\n\r");
 8012924:	482e      	ldr	r0, [pc, #184]	; (80129e0 <main+0xd0>)
 8012926:	492f      	ldr	r1, [pc, #188]	; (80129e4 <main+0xd4>)
 8012928:	f7fe fe7a 	bl	8011620 <chprintf>
  chprintf((BaseSequentialStream*)&SD5, "\rHint: run set_time DD/MM/YYYY HH:MM (military time) to initialize time.\r\n");
 801292c:	482c      	ldr	r0, [pc, #176]	; (80129e0 <main+0xd0>)
 801292e:	492e      	ldr	r1, [pc, #184]	; (80129e8 <main+0xd8>)
 8012930:	f7fe fe76 	bl	8011620 <chprintf>


  /* Initialize the command shell */ 
  shellInit();
 8012934:	f7ff f8fc 	bl	8011b30 <shellInit>

  /* Initialize the emulated UART */
	EUARTInit(&EUARTH); 
 8012938:	482c      	ldr	r0, [pc, #176]	; (80129ec <main+0xdc>)
 801293a:	f000 f8f9 	bl	8012b30 <EUARTInit>

  /* Initialize the Accelerometer */
  LSM303AGR_ACC_Init();
 801293e:	f000 fa7f 	bl	8012e40 <LSM303AGR_ACC_Init>
  /* Calibrate the Accelerometer */
  LSM303AGR_ACC_Get_Acceleration(NULL, calibrated_axes);
 8012942:	2000      	movs	r0, #0
 8012944:	492a      	ldr	r1, [pc, #168]	; (80129f0 <main+0xe0>)
 8012946:	f000 fbcb 	bl	80130e0 <LSM303AGR_ACC_Get_Acceleration>
  chprintf((BaseSequentialStream*)&SD5, "\rAccelerometer Calibrated\r\n");
 801294a:	4825      	ldr	r0, [pc, #148]	; (80129e0 <main+0xd0>)
 801294c:	4929      	ldr	r1, [pc, #164]	; (80129f4 <main+0xe4>)
 801294e:	f7fe fe67 	bl	8011620 <chprintf>

  
  
	chThdCreateStatic(waCounterThread, sizeof(waCounterThread), NORMALPRIO+1, counterThread, NULL);
 8012952:	2300      	movs	r3, #0
 8012954:	9300      	str	r3, [sp, #0]
 8012956:	4828      	ldr	r0, [pc, #160]	; (80129f8 <main+0xe8>)
 8012958:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801295c:	2241      	movs	r2, #65	; 0x41
 801295e:	4b27      	ldr	r3, [pc, #156]	; (80129fc <main+0xec>)
 8012960:	f7ee fc3e 	bl	80011e0 <chThdCreateStatic>
	chThdCreateStatic(waTimeStamp, sizeof(waTimeStamp), NORMALPRIO+1, timeStamp, NULL);
 8012964:	2300      	movs	r3, #0
 8012966:	9300      	str	r3, [sp, #0]
 8012968:	4825      	ldr	r0, [pc, #148]	; (8012a00 <main+0xf0>)
 801296a:	f241 01c8 	movw	r1, #4296	; 0x10c8
 801296e:	2241      	movs	r2, #65	; 0x41
 8012970:	4b24      	ldr	r3, [pc, #144]	; (8012a04 <main+0xf4>)
 8012972:	f7ee fc35 	bl	80011e0 <chThdCreateStatic>
	chThdCreateStatic(waCheckThreshold, sizeof(waCheckThreshold), NORMALPRIO+1, checkThreshold, NULL);
 8012976:	2300      	movs	r3, #0
 8012978:	9300      	str	r3, [sp, #0]
 801297a:	4823      	ldr	r0, [pc, #140]	; (8012a08 <main+0xf8>)
 801297c:	f241 01c8 	movw	r1, #4296	; 0x10c8
 8012980:	2241      	movs	r2, #65	; 0x41
 8012982:	4b22      	ldr	r3, [pc, #136]	; (8012a0c <main+0xfc>)
 8012984:	f7ee fc2c 	bl	80011e0 <chThdCreateStatic>
	chThdCreateStatic(waTCPThread, sizeof(waTCPThread), NORMALPRIO+1, tcpThread, NULL);
 8012988:	2300      	movs	r3, #0
 801298a:	9300      	str	r3, [sp, #0]
 801298c:	4820      	ldr	r0, [pc, #128]	; (8012a10 <main+0x100>)
 801298e:	f241 01c8 	movw	r1, #4296	; 0x10c8
 8012992:	2241      	movs	r2, #65	; 0x41
 8012994:	4b1f      	ldr	r3, [pc, #124]	; (8012a14 <main+0x104>)
 8012996:	f7ee fc23 	bl	80011e0 <chThdCreateStatic>

while (TRUE) {
                if (!shelltp) {
 801299a:	4b1f      	ldr	r3, [pc, #124]	; (8012a18 <main+0x108>)
 801299c:	681b      	ldr	r3, [r3, #0]
 801299e:	2b00      	cmp	r3, #0
 80129a0:	d109      	bne.n	80129b6 <main+0xa6>
                        shelltp = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
 80129a2:	481e      	ldr	r0, [pc, #120]	; (8012a1c <main+0x10c>)
 80129a4:	f640 01c8 	movw	r1, #2248	; 0x8c8
 80129a8:	2240      	movs	r2, #64	; 0x40
 80129aa:	f7ff f8d9 	bl	8011b60 <shellCreate>
 80129ae:	4602      	mov	r2, r0
 80129b0:	4b19      	ldr	r3, [pc, #100]	; (8012a18 <main+0x108>)
 80129b2:	601a      	str	r2, [r3, #0]
 80129b4:	e00f      	b.n	80129d6 <main+0xc6>
                }
                else if (chThdTerminatedX(shelltp)) {
 80129b6:	4b18      	ldr	r3, [pc, #96]	; (8012a18 <main+0x108>)
 80129b8:	681b      	ldr	r3, [r3, #0]
 80129ba:	4618      	mov	r0, r3
 80129bc:	f7ff f9f0 	bl	8011da0 <chThdTerminatedX>
 80129c0:	4603      	mov	r3, r0
 80129c2:	2b00      	cmp	r3, #0
 80129c4:	d007      	beq.n	80129d6 <main+0xc6>
                        chThdRelease(shelltp); /* Recovers memory of the previous shell.   */
 80129c6:	4b14      	ldr	r3, [pc, #80]	; (8012a18 <main+0x108>)
 80129c8:	681b      	ldr	r3, [r3, #0]
 80129ca:	4618      	mov	r0, r3
 80129cc:	f7ee fef8 	bl	80017c0 <chThdRelease>
                        shelltp = NULL; /* Triggers spawning of a new shell.        */
 80129d0:	4b11      	ldr	r3, [pc, #68]	; (8012a18 <main+0x108>)
 80129d2:	2200      	movs	r2, #0
 80129d4:	601a      	str	r2, [r3, #0]
                }
		
	chThdSleepMilliseconds(1000);
 80129d6:	4812      	ldr	r0, [pc, #72]	; (8012a20 <main+0x110>)
 80129d8:	f7ee fc7a 	bl	80012d0 <chThdSleep>
      

}
 80129dc:	e7dd      	b.n	801299a <main+0x8a>
 80129de:	bf00      	nop
 80129e0:	20003db8 	.word	0x20003db8
 80129e4:	0801c0d8 	.word	0x0801c0d8
 80129e8:	0801c0ec 	.word	0x0801c0ec
 80129ec:	200044c0 	.word	0x200044c0
 80129f0:	200008f0 	.word	0x200008f0
 80129f4:	0801c138 	.word	0x0801c138
 80129f8:	20001578 	.word	0x20001578
 80129fc:	08011ea1 	.word	0x08011ea1
 8012a00:	20002788 	.word	0x20002788
 8012a04:	08012141 	.word	0x08012141
 8012a08:	20005c58 	.word	0x20005c58
 8012a0c:	080122b1 	.word	0x080122b1
 8012a10:	200016c0 	.word	0x200016c0
 8012a14:	08011ee1 	.word	0x08011ee1
 8012a18:	20003850 	.word	0x20003850
 8012a1c:	0801c0d0 	.word	0x0801c0d0
 8012a20:	000186a0 	.word	0x000186a0
 8012a24:	f3af 8000 	nop.w
 8012a28:	f3af 8000 	nop.w
 8012a2c:	f3af 8000 	nop.w

08012a30 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8012a30:	b082      	sub	sp, #8
 8012a32:	2320      	movs	r3, #32
 8012a34:	9301      	str	r3, [sp, #4]
 8012a36:	9b01      	ldr	r3, [sp, #4]
 8012a38:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8012a3c:	b002      	add	sp, #8
 8012a3e:	4770      	bx	lr

08012a40 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8012a40:	b082      	sub	sp, #8
 8012a42:	2300      	movs	r3, #0
 8012a44:	9301      	str	r3, [sp, #4]
 8012a46:	9b01      	ldr	r3, [sp, #4]
 8012a48:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8012a4c:	b002      	add	sp, #8
 8012a4e:	4770      	bx	lr

08012a50 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8012a50:	b508      	push	{r3, lr}

  port_lock();
 8012a52:	f7ff ffed 	bl	8012a30 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8012a56:	bd08      	pop	{r3, pc}
 8012a58:	f3af 8000 	nop.w
 8012a5c:	f3af 8000 	nop.w

08012a60 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8012a60:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8012a62:	f7ff ffed 	bl	8012a40 <port_unlock>
}
 8012a66:	bd08      	pop	{r3, pc}
 8012a68:	f3af 8000 	nop.w
 8012a6c:	f3af 8000 	nop.w

08012a70 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8012a70:	4b01      	ldr	r3, [pc, #4]	; (8012a78 <chVTGetSystemTimeX+0x8>)
 8012a72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8012a74:	4618      	mov	r0, r3
 8012a76:	4770      	bx	lr
 8012a78:	200039a8 	.word	0x200039a8
 8012a7c:	f3af 8000 	nop.w

08012a80 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8012a80:	b500      	push	{lr}
 8012a82:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8012a84:	f7ff ffe4 	bl	8012a50 <chSysLock>
  systime = chVTGetSystemTimeX();
 8012a88:	f7ff fff2 	bl	8012a70 <chVTGetSystemTimeX>
 8012a8c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8012a8e:	f7ff ffe7 	bl	8012a60 <chSysUnlock>

  return systime;
 8012a92:	9b01      	ldr	r3, [sp, #4]
}
 8012a94:	4618      	mov	r0, r3
 8012a96:	b003      	add	sp, #12
 8012a98:	f85d fb04 	ldr.w	pc, [sp], #4
 8012a9c:	f3af 8000 	nop.w

08012aa0 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8012aa0:	b084      	sub	sp, #16
 8012aa2:	9003      	str	r0, [sp, #12]
 8012aa4:	9102      	str	r1, [sp, #8]
 8012aa6:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8012aa8:	9a03      	ldr	r2, [sp, #12]
 8012aaa:	9b02      	ldr	r3, [sp, #8]
 8012aac:	1ad2      	subs	r2, r2, r3
 8012aae:	9901      	ldr	r1, [sp, #4]
 8012ab0:	9b02      	ldr	r3, [sp, #8]
 8012ab2:	1acb      	subs	r3, r1, r3
 8012ab4:	429a      	cmp	r2, r3
 8012ab6:	bf2c      	ite	cs
 8012ab8:	2300      	movcs	r3, #0
 8012aba:	2301      	movcc	r3, #1
 8012abc:	b2db      	uxtb	r3, r3
}
 8012abe:	4618      	mov	r0, r3
 8012ac0:	b004      	add	sp, #16
 8012ac2:	4770      	bx	lr
 8012ac4:	f3af 8000 	nop.w
 8012ac8:	f3af 8000 	nop.w
 8012acc:	f3af 8000 	nop.w

08012ad0 <chVTIsSystemTimeWithin>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @api
 */
static inline bool chVTIsSystemTimeWithin(systime_t start, systime_t end) {
 8012ad0:	b500      	push	{lr}
 8012ad2:	b083      	sub	sp, #12
 8012ad4:	9001      	str	r0, [sp, #4]
 8012ad6:	9100      	str	r1, [sp, #0]

  return chVTIsTimeWithinX(chVTGetSystemTime(), start, end);
 8012ad8:	f7ff ffd2 	bl	8012a80 <chVTGetSystemTime>
 8012adc:	4603      	mov	r3, r0
 8012ade:	4618      	mov	r0, r3
 8012ae0:	9901      	ldr	r1, [sp, #4]
 8012ae2:	9a00      	ldr	r2, [sp, #0]
 8012ae4:	f7ff ffdc 	bl	8012aa0 <chVTIsTimeWithinX>
 8012ae8:	4603      	mov	r3, r0
}
 8012aea:	4618      	mov	r0, r3
 8012aec:	b003      	add	sp, #12
 8012aee:	f85d fb04 	ldr.w	pc, [sp], #4
 8012af2:	bf00      	nop
 8012af4:	f3af 8000 	nop.w
 8012af8:	f3af 8000 	nop.w
 8012afc:	f3af 8000 	nop.w

08012b00 <EUARTInitPins>:
#include "hal.h"
#include "chmtx.h"
#include "chvt.h"

//Initializes TX/RX pins
int EUARTInitPins(void){
 8012b00:	b508      	push	{r3, lr}

	palSetPadMode(EUART_RX_PORT, EUART_RX_PIN, PAL_MODE_INPUT); 		//Initialize RX
 8012b02:	4808      	ldr	r0, [pc, #32]	; (8012b24 <EUARTInitPins+0x24>)
 8012b04:	2101      	movs	r1, #1
 8012b06:	2200      	movs	r2, #0
 8012b08:	f7f5 fae2 	bl	80080d0 <_pal_lld_setgroupmode>
	palSetPadMode(EUART_TX_PORT, EUART_TX_PIN, PAL_MODE_OUTPUT_PUSHPULL);	//Initialize TX
 8012b0c:	4805      	ldr	r0, [pc, #20]	; (8012b24 <EUARTInitPins+0x24>)
 8012b0e:	2102      	movs	r1, #2
 8012b10:	2201      	movs	r2, #1
 8012b12:	f7f5 fadd 	bl	80080d0 <_pal_lld_setgroupmode>

	palSetPad(EUART_TX_PORT, EUART_TX_PIN);  //Set high
 8012b16:	4b03      	ldr	r3, [pc, #12]	; (8012b24 <EUARTInitPins+0x24>)
 8012b18:	2202      	movs	r2, #2
 8012b1a:	831a      	strh	r2, [r3, #24]
	
	return 0;
 8012b1c:	2300      	movs	r3, #0
}
 8012b1e:	4618      	mov	r0, r3
 8012b20:	bd08      	pop	{r3, pc}
 8012b22:	bf00      	nop
 8012b24:	48000800 	.word	0x48000800
 8012b28:	f3af 8000 	nop.w
 8012b2c:	f3af 8000 	nop.w

08012b30 <EUARTInit>:

//Inputs: empty EUARTHandle
void EUARTInit(EUARTHandle * handle){
 8012b30:	b500      	push	{lr}
 8012b32:	b083      	sub	sp, #12
 8012b34:	9001      	str	r0, [sp, #4]
	handle->uartStatus = EUART_UNINIT; 
 8012b36:	9b01      	ldr	r3, [sp, #4]
 8012b38:	2200      	movs	r2, #0
 8012b3a:	759a      	strb	r2, [r3, #22]
	handle->WordSize = EUART_WORD_SIZE;
 8012b3c:	9b01      	ldr	r3, [sp, #4]
 8012b3e:	2208      	movs	r2, #8
 8012b40:	701a      	strb	r2, [r3, #0]
	handle->BaudRate = EUART_BAUD;
 8012b42:	9b01      	ldr	r3, [sp, #4]
 8012b44:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8012b48:	605a      	str	r2, [r3, #4]
	handle->TimeOut = EUART_MAX_TIME;	//milliseconds
 8012b4a:	9b01      	ldr	r3, [sp, #4]
 8012b4c:	f241 3288 	movw	r2, #5000	; 0x1388
 8012b50:	815a      	strh	r2, [r3, #10]
	handle->TimerPeriod = 1000000 / EUART_BAUD; //microseconds per bit
 8012b52:	9b01      	ldr	r3, [sp, #4]
 8012b54:	f240 3241 	movw	r2, #833	; 0x341
 8012b58:	811a      	strh	r2, [r3, #8]
	//handle->TimerPeriod = 833;
 	handle->txXferCount = 0;
 8012b5a:	9b01      	ldr	r3, [sp, #4]
 8012b5c:	2200      	movs	r2, #0
 8012b5e:	751a      	strb	r2, [r3, #20]
	handle->rxXferCount = 0;
 8012b60:	9b01      	ldr	r3, [sp, #4]
 8012b62:	2200      	movs	r2, #0
 8012b64:	755a      	strb	r2, [r3, #21]
	EUARTInitPins();
 8012b66:	f7ff ffcb 	bl	8012b00 <EUARTInitPins>
	handle->uartStatus = EUART_READY; //We're initialized!
 8012b6a:	9b01      	ldr	r3, [sp, #4]
 8012b6c:	2201      	movs	r2, #1
 8012b6e:	759a      	strb	r2, [r3, #22]
}
 8012b70:	b003      	add	sp, #12
 8012b72:	f85d fb04 	ldr.w	pc, [sp], #4
 8012b76:	bf00      	nop
 8012b78:	f3af 8000 	nop.w
 8012b7c:	f3af 8000 	nop.w

08012b80 <EUARTPutChar>:
}
*/


//return 0 if no probs
int EUARTPutChar(EUARTHandle * handle, char ch){
 8012b80:	b500      	push	{lr}
 8012b82:	b087      	sub	sp, #28
 8012b84:	9001      	str	r0, [sp, #4]
 8012b86:	460b      	mov	r3, r1
 8012b88:	f88d 3003 	strb.w	r3, [sp, #3]
	
	int bit_num;
	uint8_t byte = (uint8_t) ch;
 8012b8c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012b90:	f88d 3013 	strb.w	r3, [sp, #19]
	systime_t start, period;

	start = chVTGetSystemTime();
 8012b94:	f7ff ff74 	bl	8012a80 <chVTGetSystemTime>
 8012b98:	9003      	str	r0, [sp, #12]
	period = US2ST(handle->TimerPeriod);
 8012b9a:	9b01      	ldr	r3, [sp, #4]
 8012b9c:	891b      	ldrh	r3, [r3, #8]
 8012b9e:	4a22      	ldr	r2, [pc, #136]	; (8012c28 <EUARTPutChar+0xa8>)
 8012ba0:	fb02 f303 	mul.w	r3, r2, r3
 8012ba4:	f503 2374 	add.w	r3, r3, #999424	; 0xf4000
 8012ba8:	f203 233f 	addw	r3, r3, #575	; 0x23f
 8012bac:	4a1f      	ldr	r2, [pc, #124]	; (8012c2c <EUARTPutChar+0xac>)
 8012bae:	fba2 1303 	umull	r1, r3, r2, r3
 8012bb2:	0c9b      	lsrs	r3, r3, #18
 8012bb4:	9302      	str	r3, [sp, #8]

	//start bit
	palClearPad(EUART_TX_PORT, EUART_TX_PIN);
 8012bb6:	4b1e      	ldr	r3, [pc, #120]	; (8012c30 <EUARTPutChar+0xb0>)
 8012bb8:	2202      	movs	r2, #2
 8012bba:	835a      	strh	r2, [r3, #26]
	chThdSleepUntil(start + period);
 8012bbc:	9a03      	ldr	r2, [sp, #12]
 8012bbe:	9b02      	ldr	r3, [sp, #8]
 8012bc0:	4413      	add	r3, r2
 8012bc2:	4618      	mov	r0, r3
 8012bc4:	f7ee fb94 	bl	80012f0 <chThdSleepUntil>
	

	for(bit_num = 0; bit_num < EUART_WORD_SIZE; bit_num++){
 8012bc8:	2300      	movs	r3, #0
 8012bca:	9305      	str	r3, [sp, #20]
 8012bcc:	e01e      	b.n	8012c0c <EUARTPutChar+0x8c>

			//iterate through char bits
			if(byte & 0x01){
 8012bce:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8012bd2:	f003 0301 	and.w	r3, r3, #1
 8012bd6:	2b00      	cmp	r3, #0
 8012bd8:	d003      	beq.n	8012be2 <EUARTPutChar+0x62>
				palSetPad(EUART_TX_PORT, EUART_TX_PIN);		}	//set High
 8012bda:	4b15      	ldr	r3, [pc, #84]	; (8012c30 <EUARTPutChar+0xb0>)
 8012bdc:	2202      	movs	r2, #2
 8012bde:	831a      	strh	r2, [r3, #24]
 8012be0:	e002      	b.n	8012be8 <EUARTPutChar+0x68>
			else{
				palClearPad(EUART_TX_PORT, EUART_TX_PIN);			}	//set Low
 8012be2:	4b13      	ldr	r3, [pc, #76]	; (8012c30 <EUARTPutChar+0xb0>)
 8012be4:	2202      	movs	r2, #2
 8012be6:	835a      	strh	r2, [r3, #26]
				byte = byte >> 1; 	
 8012be8:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8012bec:	085b      	lsrs	r3, r3, #1
 8012bee:	f88d 3013 	strb.w	r3, [sp, #19]

		chThdSleepUntil(start + ((bit_num+2) * period));
 8012bf2:	9b05      	ldr	r3, [sp, #20]
 8012bf4:	3302      	adds	r3, #2
 8012bf6:	9a02      	ldr	r2, [sp, #8]
 8012bf8:	fb02 f203 	mul.w	r2, r2, r3
 8012bfc:	9b03      	ldr	r3, [sp, #12]
 8012bfe:	4413      	add	r3, r2
 8012c00:	4618      	mov	r0, r3
 8012c02:	f7ee fb75 	bl	80012f0 <chThdSleepUntil>
	//start bit
	palClearPad(EUART_TX_PORT, EUART_TX_PIN);
	chThdSleepUntil(start + period);
	

	for(bit_num = 0; bit_num < EUART_WORD_SIZE; bit_num++){
 8012c06:	9b05      	ldr	r3, [sp, #20]
 8012c08:	3301      	adds	r3, #1
 8012c0a:	9305      	str	r3, [sp, #20]
 8012c0c:	9b05      	ldr	r3, [sp, #20]
 8012c0e:	2b07      	cmp	r3, #7
 8012c10:	dddd      	ble.n	8012bce <EUARTPutChar+0x4e>

		}
	

	//stop bit
	palSetPad(EUART_TX_PORT, EUART_TX_PIN);
 8012c12:	4b07      	ldr	r3, [pc, #28]	; (8012c30 <EUARTPutChar+0xb0>)
 8012c14:	2202      	movs	r2, #2
 8012c16:	831a      	strh	r2, [r3, #24]
	chThdSleep(period);
 8012c18:	9802      	ldr	r0, [sp, #8]
 8012c1a:	f7ee fb59 	bl	80012d0 <chThdSleep>
	return 0;
 8012c1e:	2300      	movs	r3, #0
}
 8012c20:	4618      	mov	r0, r3
 8012c22:	b007      	add	sp, #28
 8012c24:	f85d fb04 	ldr.w	pc, [sp], #4
 8012c28:	000186a0 	.word	0x000186a0
 8012c2c:	431bde83 	.word	0x431bde83
 8012c30:	48000800 	.word	0x48000800
 8012c34:	f3af 8000 	nop.w
 8012c38:	f3af 8000 	nop.w
 8012c3c:	f3af 8000 	nop.w

08012c40 <EUARTSendCommand>:

uint8_t EUARTSendCommand(EUARTHandle * handle, char * cmd, int length){
 8012c40:	b500      	push	{lr}
 8012c42:	b087      	sub	sp, #28
 8012c44:	9003      	str	r0, [sp, #12]
 8012c46:	9102      	str	r1, [sp, #8]
 8012c48:	9201      	str	r2, [sp, #4]
	int ch_i;
	for(ch_i = 0; ch_i < length; ch_i++){	
 8012c4a:	2300      	movs	r3, #0
 8012c4c:	9305      	str	r3, [sp, #20]
 8012c4e:	e00a      	b.n	8012c66 <EUARTSendCommand+0x26>
		EUARTPutChar(handle, cmd[ch_i]);
 8012c50:	9b05      	ldr	r3, [sp, #20]
 8012c52:	9a02      	ldr	r2, [sp, #8]
 8012c54:	4413      	add	r3, r2
 8012c56:	781b      	ldrb	r3, [r3, #0]
 8012c58:	9803      	ldr	r0, [sp, #12]
 8012c5a:	4619      	mov	r1, r3
 8012c5c:	f7ff ff90 	bl	8012b80 <EUARTPutChar>
	return 0;
}

uint8_t EUARTSendCommand(EUARTHandle * handle, char * cmd, int length){
	int ch_i;
	for(ch_i = 0; ch_i < length; ch_i++){	
 8012c60:	9b05      	ldr	r3, [sp, #20]
 8012c62:	3301      	adds	r3, #1
 8012c64:	9305      	str	r3, [sp, #20]
 8012c66:	9a05      	ldr	r2, [sp, #20]
 8012c68:	9b01      	ldr	r3, [sp, #4]
 8012c6a:	429a      	cmp	r2, r3
 8012c6c:	dbf0      	blt.n	8012c50 <EUARTSendCommand+0x10>
		EUARTPutChar(handle, cmd[ch_i]);
	}

	EUARTPutChar(handle, '\r');
 8012c6e:	9803      	ldr	r0, [sp, #12]
 8012c70:	210d      	movs	r1, #13
 8012c72:	f7ff ff85 	bl	8012b80 <EUARTPutChar>
	return 0;
 8012c76:	2300      	movs	r3, #0
}
 8012c78:	4618      	mov	r0, r3
 8012c7a:	b007      	add	sp, #28
 8012c7c:	f85d fb04 	ldr.w	pc, [sp], #4

08012c80 <EUARTGetChar>:



//Takes output letter, returns an EUART status code (see euart.h)
uint8_t EUARTGetChar(EUARTHandle * handle, char * letter){
 8012c80:	b500      	push	{lr}
 8012c82:	b08b      	sub	sp, #44	; 0x2c
 8012c84:	9001      	str	r0, [sp, #4]
 8012c86:	9100      	str	r1, [sp, #0]
	int bit_num;
	int sample_num;
	uint8_t byte = 0x00;
 8012c88:	2300      	movs	r3, #0
 8012c8a:	f88d 301f 	strb.w	r3, [sp, #31]
	uint8_t sample_accum = 0;
 8012c8e:	2300      	movs	r3, #0
 8012c90:	f88d 301e 	strb.w	r3, [sp, #30]
	systime_t start, sample_period, period, timeout;
	uint8_t timedOut = 0; //Flag
 8012c94:	2300      	movs	r3, #0
 8012c96:	f88d 301d 	strb.w	r3, [sp, #29]

	start = chVTGetSystemTime();
 8012c9a:	f7ff fef1 	bl	8012a80 <chVTGetSystemTime>
 8012c9e:	9006      	str	r0, [sp, #24]
	timeout = start + MS2ST(handle->TimeOut);
 8012ca0:	9b01      	ldr	r3, [sp, #4]
 8012ca2:	895b      	ldrh	r3, [r3, #10]
 8012ca4:	4a5f      	ldr	r2, [pc, #380]	; (8012e24 <EUARTGetChar+0x1a4>)
 8012ca6:	fb02 f303 	mul.w	r3, r2, r3
 8012caa:	f203 32e7 	addw	r2, r3, #999	; 0x3e7
 8012cae:	4b5e      	ldr	r3, [pc, #376]	; (8012e28 <EUARTGetChar+0x1a8>)
 8012cb0:	fba3 1302 	umull	r1, r3, r3, r2
 8012cb4:	099a      	lsrs	r2, r3, #6
 8012cb6:	9b06      	ldr	r3, [sp, #24]
 8012cb8:	4413      	add	r3, r2
 8012cba:	9305      	str	r3, [sp, #20]
	while(palReadPad(EUART_RX_PORT, EUART_RX_PIN) && !timedOut){ //either detect start pin or give up & timeout
 8012cbc:	e009      	b.n	8012cd2 <EUARTGetChar+0x52>
		timedOut =  !chVTIsSystemTimeWithin(start,timeout);
 8012cbe:	9806      	ldr	r0, [sp, #24]
 8012cc0:	9905      	ldr	r1, [sp, #20]
 8012cc2:	f7ff ff05 	bl	8012ad0 <chVTIsSystemTimeWithin>
 8012cc6:	4603      	mov	r3, r0
 8012cc8:	f083 0301 	eor.w	r3, r3, #1
 8012ccc:	b2db      	uxtb	r3, r3
 8012cce:	f88d 301d 	strb.w	r3, [sp, #29]
	systime_t start, sample_period, period, timeout;
	uint8_t timedOut = 0; //Flag

	start = chVTGetSystemTime();
	timeout = start + MS2ST(handle->TimeOut);
	while(palReadPad(EUART_RX_PORT, EUART_RX_PIN) && !timedOut){ //either detect start pin or give up & timeout
 8012cd2:	4b56      	ldr	r3, [pc, #344]	; (8012e2c <EUARTGetChar+0x1ac>)
 8012cd4:	691b      	ldr	r3, [r3, #16]
 8012cd6:	f003 0301 	and.w	r3, r3, #1
 8012cda:	2b00      	cmp	r3, #0
 8012cdc:	d003      	beq.n	8012ce6 <EUARTGetChar+0x66>
 8012cde:	f89d 301d 	ldrb.w	r3, [sp, #29]
 8012ce2:	2b00      	cmp	r3, #0
 8012ce4:	d0eb      	beq.n	8012cbe <EUARTGetChar+0x3e>
		timedOut =  !chVTIsSystemTimeWithin(start,timeout);
	}
	
	//check for timeout
	if(timedOut) {
 8012ce6:	f89d 301d 	ldrb.w	r3, [sp, #29]
 8012cea:	2b00      	cmp	r3, #0
 8012cec:	d004      	beq.n	8012cf8 <EUARTGetChar+0x78>
		*letter = '\0'; 
 8012cee:	9b00      	ldr	r3, [sp, #0]
 8012cf0:	2200      	movs	r2, #0
 8012cf2:	701a      	strb	r2, [r3, #0]
		return EUART_TIMEOUT; }
 8012cf4:	2306      	movs	r3, #6
 8012cf6:	e091      	b.n	8012e1c <EUARTGetChar+0x19c>

	//wait half-cycle, 
	start = chVTGetSystemTime();
 8012cf8:	f7ff fec2 	bl	8012a80 <chVTGetSystemTime>
 8012cfc:	9006      	str	r0, [sp, #24]
	period = US2ST(handle->TimerPeriod); //Read 3/bit to check for offset errors
 8012cfe:	9b01      	ldr	r3, [sp, #4]
 8012d00:	891b      	ldrh	r3, [r3, #8]
 8012d02:	4a48      	ldr	r2, [pc, #288]	; (8012e24 <EUARTGetChar+0x1a4>)
 8012d04:	fb02 f303 	mul.w	r3, r2, r3
 8012d08:	f503 2374 	add.w	r3, r3, #999424	; 0xf4000
 8012d0c:	f203 233f 	addw	r3, r3, #575	; 0x23f
 8012d10:	4a47      	ldr	r2, [pc, #284]	; (8012e30 <EUARTGetChar+0x1b0>)
 8012d12:	fba2 1303 	umull	r1, r3, r2, r3
 8012d16:	0c9b      	lsrs	r3, r3, #18
 8012d18:	9304      	str	r3, [sp, #16]
	sample_period = period / 4;
 8012d1a:	9b04      	ldr	r3, [sp, #16]
 8012d1c:	089b      	lsrs	r3, r3, #2
 8012d1e:	9303      	str	r3, [sp, #12]
	chThdSleepMicroseconds(period+ sample_period); //offset cycle slightly
 8012d20:	9a04      	ldr	r2, [sp, #16]
 8012d22:	9b03      	ldr	r3, [sp, #12]
 8012d24:	4413      	add	r3, r2
 8012d26:	4a3f      	ldr	r2, [pc, #252]	; (8012e24 <EUARTGetChar+0x1a4>)
 8012d28:	fb02 f303 	mul.w	r3, r2, r3
 8012d2c:	f503 2374 	add.w	r3, r3, #999424	; 0xf4000
 8012d30:	f203 233f 	addw	r3, r3, #575	; 0x23f
 8012d34:	4a3e      	ldr	r2, [pc, #248]	; (8012e30 <EUARTGetChar+0x1b0>)
 8012d36:	fba2 1303 	umull	r1, r3, r2, r3
 8012d3a:	0c9b      	lsrs	r3, r3, #18
 8012d3c:	4618      	mov	r0, r3
 8012d3e:	f7ee fac7 	bl	80012d0 <chThdSleep>
	
	//Read 8 bits
	for(bit_num = 1; bit_num < EUART_WORD_SIZE+1; bit_num++){ //one-indexing for easier math
 8012d42:	2301      	movs	r3, #1
 8012d44:	9309      	str	r3, [sp, #36]	; 0x24
 8012d46:	e046      	b.n	8012dd6 <EUARTGetChar+0x156>
		chSysLock();	
 8012d48:	f7ff fe82 	bl	8012a50 <chSysLock>
		for(sample_num = 1; sample_num < 4; sample_num++){
 8012d4c:	2301      	movs	r3, #1
 8012d4e:	9308      	str	r3, [sp, #32]
 8012d50:	e01c      	b.n	8012d8c <EUARTGetChar+0x10c>
			//Read pin 3x per bit to reduce error
			sample_accum += palReadPad(EUART_RX_PORT, EUART_RX_PIN);
 8012d52:	4b36      	ldr	r3, [pc, #216]	; (8012e2c <EUARTGetChar+0x1ac>)
 8012d54:	691b      	ldr	r3, [r3, #16]
 8012d56:	b2db      	uxtb	r3, r3
 8012d58:	f003 0301 	and.w	r3, r3, #1
 8012d5c:	b2da      	uxtb	r2, r3
 8012d5e:	f89d 301e 	ldrb.w	r3, [sp, #30]
 8012d62:	4413      	add	r3, r2
 8012d64:	f88d 301e 	strb.w	r3, [sp, #30]
			chThdSleepMicroseconds(sample_period);
 8012d68:	9b03      	ldr	r3, [sp, #12]
 8012d6a:	4a2e      	ldr	r2, [pc, #184]	; (8012e24 <EUARTGetChar+0x1a4>)
 8012d6c:	fb02 f303 	mul.w	r3, r2, r3
 8012d70:	f503 2374 	add.w	r3, r3, #999424	; 0xf4000
 8012d74:	f203 233f 	addw	r3, r3, #575	; 0x23f
 8012d78:	4a2d      	ldr	r2, [pc, #180]	; (8012e30 <EUARTGetChar+0x1b0>)
 8012d7a:	fba2 1303 	umull	r1, r3, r2, r3
 8012d7e:	0c9b      	lsrs	r3, r3, #18
 8012d80:	4618      	mov	r0, r3
 8012d82:	f7ee faa5 	bl	80012d0 <chThdSleep>
	chThdSleepMicroseconds(period+ sample_period); //offset cycle slightly
	
	//Read 8 bits
	for(bit_num = 1; bit_num < EUART_WORD_SIZE+1; bit_num++){ //one-indexing for easier math
		chSysLock();	
		for(sample_num = 1; sample_num < 4; sample_num++){
 8012d86:	9b08      	ldr	r3, [sp, #32]
 8012d88:	3301      	adds	r3, #1
 8012d8a:	9308      	str	r3, [sp, #32]
 8012d8c:	9b08      	ldr	r3, [sp, #32]
 8012d8e:	2b03      	cmp	r3, #3
 8012d90:	dddf      	ble.n	8012d52 <EUARTGetChar+0xd2>
			sample_accum += palReadPad(EUART_RX_PORT, EUART_RX_PIN);
			chThdSleepMicroseconds(sample_period);
		}

		//interpreting samples	
		byte = byte | (sample_accum / 2); //Out of 3 samples, use majority yay integer division
 8012d92:	f89d 301e 	ldrb.w	r3, [sp, #30]
 8012d96:	085b      	lsrs	r3, r3, #1
 8012d98:	b2da      	uxtb	r2, r3
 8012d9a:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8012d9e:	4313      	orrs	r3, r2
 8012da0:	f88d 301f 	strb.w	r3, [sp, #31]
		if(bit_num < EUART_WORD_SIZE){byte = byte << 1;} //pack byte, don't shift last val
 8012da4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012da6:	2b07      	cmp	r3, #7
 8012da8:	dc04      	bgt.n	8012db4 <EUARTGetChar+0x134>
 8012daa:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8012dae:	005b      	lsls	r3, r3, #1
 8012db0:	f88d 301f 	strb.w	r3, [sp, #31]
		sample_accum = 0;
 8012db4:	2300      	movs	r3, #0
 8012db6:	f88d 301e 	strb.w	r3, [sp, #30]

		chSysUnlock();	
 8012dba:	f7ff fe51 	bl	8012a60 <chSysUnlock>
		//sleep until next bit
		chThdSleepUntil(start + (bit_num * period));
 8012dbe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012dc0:	9a04      	ldr	r2, [sp, #16]
 8012dc2:	fb02 f203 	mul.w	r2, r2, r3
 8012dc6:	9b06      	ldr	r3, [sp, #24]
 8012dc8:	4413      	add	r3, r2
 8012dca:	4618      	mov	r0, r3
 8012dcc:	f7ee fa90 	bl	80012f0 <chThdSleepUntil>
	period = US2ST(handle->TimerPeriod); //Read 3/bit to check for offset errors
	sample_period = period / 4;
	chThdSleepMicroseconds(period+ sample_period); //offset cycle slightly
	
	//Read 8 bits
	for(bit_num = 1; bit_num < EUART_WORD_SIZE+1; bit_num++){ //one-indexing for easier math
 8012dd0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012dd2:	3301      	adds	r3, #1
 8012dd4:	9309      	str	r3, [sp, #36]	; 0x24
 8012dd6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012dd8:	2b08      	cmp	r3, #8
 8012dda:	ddb5      	ble.n	8012d48 <EUARTGetChar+0xc8>
		chSysUnlock();	
		//sleep until next bit
		chThdSleepUntil(start + (bit_num * period));
	}

	chThdSleepMicroseconds(sample_period); //give ourselves a little cushion.	
 8012ddc:	9b03      	ldr	r3, [sp, #12]
 8012dde:	4a11      	ldr	r2, [pc, #68]	; (8012e24 <EUARTGetChar+0x1a4>)
 8012de0:	fb02 f303 	mul.w	r3, r2, r3
 8012de4:	f503 2374 	add.w	r3, r3, #999424	; 0xf4000
 8012de8:	f203 233f 	addw	r3, r3, #575	; 0x23f
 8012dec:	4a10      	ldr	r2, [pc, #64]	; (8012e30 <EUARTGetChar+0x1b0>)
 8012dee:	fba2 1303 	umull	r1, r3, r2, r3
 8012df2:	0c9b      	lsrs	r3, r3, #18
 8012df4:	4618      	mov	r0, r3
 8012df6:	f7ee fa6b 	bl	80012d0 <chThdSleep>
	if(!palReadPad(EUART_RX_PORT, EUART_RX_PIN)){ 
 8012dfa:	4b0c      	ldr	r3, [pc, #48]	; (8012e2c <EUARTGetChar+0x1ac>)
 8012dfc:	691b      	ldr	r3, [r3, #16]
 8012dfe:	f003 0301 	and.w	r3, r3, #1
 8012e02:	2b00      	cmp	r3, #0
 8012e04:	d105      	bne.n	8012e12 <EUARTGetChar+0x192>
		//We're missing our stop bit :(
		//pack what we have & throw our error
		*letter = (char) byte;
 8012e06:	9b00      	ldr	r3, [sp, #0]
 8012e08:	f89d 201f 	ldrb.w	r2, [sp, #31]
 8012e0c:	701a      	strb	r2, [r3, #0]
		return EUART_ERROR; 
 8012e0e:	2307      	movs	r3, #7
 8012e10:	e004      	b.n	8012e1c <EUARTGetChar+0x19c>
	}
	else{ 
		*letter = (char) byte;	
 8012e12:	9b00      	ldr	r3, [sp, #0]
 8012e14:	f89d 201f 	ldrb.w	r2, [sp, #31]
 8012e18:	701a      	strb	r2, [r3, #0]
		return EUART_READY;
 8012e1a:	2301      	movs	r3, #1
	}
}
 8012e1c:	4618      	mov	r0, r3
 8012e1e:	b00b      	add	sp, #44	; 0x2c
 8012e20:	f85d fb04 	ldr.w	pc, [sp], #4
 8012e24:	000186a0 	.word	0x000186a0
 8012e28:	10624dd3 	.word	0x10624dd3
 8012e2c:	48000800 	.word	0x48000800
 8012e30:	431bde83 	.word	0x431bde83
 8012e34:	f3af 8000 	nop.w
 8012e38:	f3af 8000 	nop.w
 8012e3c:	f3af 8000 	nop.w

08012e40 <LSM303AGR_ACC_Init>:
/************** Generic Function  *******************/


/* Enable 3 wire SPI mode on the LSM303AGR */

status_t LSM303AGR_ACC_Init(void) {
 8012e40:	b500      	push	{lr}
 8012e42:	b083      	sub	sp, #12
  uint8_t value = LSM303AGR_ACC_SIM_3_WIRES;
 8012e44:	2301      	movs	r3, #1
 8012e46:	f88d 3007 	strb.w	r3, [sp, #7]
  LSM303AGR_ACC_WriteReg(NULL,LSM303AGR_ACC_CTRL_REG4,&value,1);
 8012e4a:	f10d 0307 	add.w	r3, sp, #7
 8012e4e:	2000      	movs	r0, #0
 8012e50:	2123      	movs	r1, #35	; 0x23
 8012e52:	461a      	mov	r2, r3
 8012e54:	2301      	movs	r3, #1
 8012e56:	f000 f813 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 uint8_t REG1_VAL = 0x27;
 8012e5a:	2327      	movs	r3, #39	; 0x27
 8012e5c:	f88d 3006 	strb.w	r3, [sp, #6]
  LSM303AGR_ACC_WriteReg(NULL,LSM303AGR_ACC_CTRL_REG1,&REG1_VAL,1);
 8012e60:	f10d 0306 	add.w	r3, sp, #6
 8012e64:	2000      	movs	r0, #0
 8012e66:	2120      	movs	r1, #32
 8012e68:	461a      	mov	r2, r3
 8012e6a:	2301      	movs	r3, #1
 8012e6c:	f000 f808 	bl	8012e80 <LSM303AGR_ACC_WriteReg>



  return MEMS_SUCCESS;
 8012e70:	2301      	movs	r3, #1
}
 8012e72:	4618      	mov	r0, r3
 8012e74:	b003      	add	sp, #12
 8012e76:	f85d fb04 	ldr.w	pc, [sp], #4
 8012e7a:	bf00      	nop
 8012e7c:	f3af 8000 	nop.w

08012e80 <LSM303AGR_ACC_WriteReg>:
* Input       : Register Address, ptr to buffer to be written,
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_WriteReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len) {
 8012e80:	b500      	push	{lr}
 8012e82:	b087      	sub	sp, #28
 8012e84:	9005      	str	r0, [sp, #20]
 8012e86:	9203      	str	r2, [sp, #12]
 8012e88:	460a      	mov	r2, r1
 8012e8a:	f88d 2013 	strb.w	r2, [sp, #19]
 8012e8e:	f8ad 3010 	strh.w	r3, [sp, #16]
  UNUSED(handle);
  if (Sensor_IO_SPI_Write(&SENSOR_PORT, &lsm303ad_accel_cfg, Reg, Bufp, len))
 8012e92:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8012e96:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 8012e9a:	9200      	str	r2, [sp, #0]
 8012e9c:	4807      	ldr	r0, [pc, #28]	; (8012ebc <LSM303AGR_ACC_WriteReg+0x3c>)
 8012e9e:	4908      	ldr	r1, [pc, #32]	; (8012ec0 <LSM303AGR_ACC_WriteReg+0x40>)
 8012ea0:	461a      	mov	r2, r3
 8012ea2:	9b03      	ldr	r3, [sp, #12]
 8012ea4:	f003 ffdc 	bl	8016e60 <Sensor_IO_SPI_Write>
 8012ea8:	4603      	mov	r3, r0
 8012eaa:	2b00      	cmp	r3, #0
 8012eac:	d001      	beq.n	8012eb2 <LSM303AGR_ACC_WriteReg+0x32>
  {
    return MEMS_ERROR;
 8012eae:	2300      	movs	r3, #0
 8012eb0:	e000      	b.n	8012eb4 <LSM303AGR_ACC_WriteReg+0x34>
  }
  else
  {
    return MEMS_SUCCESS;
 8012eb2:	2301      	movs	r3, #1
  }
}
 8012eb4:	4618      	mov	r0, r3
 8012eb6:	b007      	add	sp, #28
 8012eb8:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ebc:	20003d88 	.word	0x20003d88
 8012ec0:	20000900 	.word	0x20000900
 8012ec4:	f3af 8000 	nop.w
 8012ec8:	f3af 8000 	nop.w
 8012ecc:	f3af 8000 	nop.w

08012ed0 <LSM303AGR_ACC_ReadReg>:
* Input       : Register Address, ptr to buffer to be read,
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_ReadReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len) {
 8012ed0:	b500      	push	{lr}
 8012ed2:	b087      	sub	sp, #28
 8012ed4:	9005      	str	r0, [sp, #20]
 8012ed6:	9203      	str	r2, [sp, #12]
 8012ed8:	460a      	mov	r2, r1
 8012eda:	f88d 2013 	strb.w	r2, [sp, #19]
 8012ede:	f8ad 3010 	strh.w	r3, [sp, #16]
  UNUSED(handle);
  if (Sensor_IO_SPI_Read(&SENSOR_PORT, &lsm303ad_accel_cfg, Reg, Bufp, len))
 8012ee2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8012ee6:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 8012eea:	9200      	str	r2, [sp, #0]
 8012eec:	4807      	ldr	r0, [pc, #28]	; (8012f0c <LSM303AGR_ACC_ReadReg+0x3c>)
 8012eee:	4908      	ldr	r1, [pc, #32]	; (8012f10 <LSM303AGR_ACC_ReadReg+0x40>)
 8012ef0:	461a      	mov	r2, r3
 8012ef2:	9b03      	ldr	r3, [sp, #12]
 8012ef4:	f004 f814 	bl	8016f20 <Sensor_IO_SPI_Read>
 8012ef8:	4603      	mov	r3, r0
 8012efa:	2b00      	cmp	r3, #0
 8012efc:	d001      	beq.n	8012f02 <LSM303AGR_ACC_ReadReg+0x32>
  {
    return MEMS_ERROR;
 8012efe:	2300      	movs	r3, #0
 8012f00:	e000      	b.n	8012f04 <LSM303AGR_ACC_ReadReg+0x34>
  }
  else
  {
    return MEMS_SUCCESS;
 8012f02:	2301      	movs	r3, #1
  }
}
 8012f04:	4618      	mov	r0, r3
 8012f06:	b007      	add	sp, #28
 8012f08:	f85d fb04 	ldr.w	pc, [sp], #4
 8012f0c:	20003d88 	.word	0x20003d88
 8012f10:	20000900 	.word	0x20000900
 8012f14:	f3af 8000 	nop.w
 8012f18:	f3af 8000 	nop.w
 8012f1c:	f3af 8000 	nop.w

08012f20 <LSM303AGR_ACC_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WHO_AM_I(void *handle, u8_t *value)
{
 8012f20:	b500      	push	{lr}
 8012f22:	b083      	sub	sp, #12
 8012f24:	9001      	str	r0, [sp, #4]
 8012f26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_WHO_AM_I_REG, value, 1) )
 8012f28:	9801      	ldr	r0, [sp, #4]
 8012f2a:	210f      	movs	r1, #15
 8012f2c:	9a00      	ldr	r2, [sp, #0]
 8012f2e:	2301      	movs	r3, #1
 8012f30:	f7ff ffce 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8012f34:	4603      	mov	r3, r0
 8012f36:	2b00      	cmp	r3, #0
 8012f38:	d101      	bne.n	8012f3e <LSM303AGR_ACC_R_WHO_AM_I+0x1e>
    return MEMS_ERROR;
 8012f3a:	2300      	movs	r3, #0
 8012f3c:	e000      	b.n	8012f40 <LSM303AGR_ACC_R_WHO_AM_I+0x20>

  /* *value &= LSM303AGR_ACC_WHO_AM_I_MASK; //coerce */
  /* *value = *value >> LSM303AGR_ACC_WHO_AM_I_POSITION; //mask */

  return MEMS_SUCCESS;
 8012f3e:	2301      	movs	r3, #1
}
 8012f40:	4618      	mov	r0, r3
 8012f42:	b003      	add	sp, #12
 8012f44:	f85d fb04 	ldr.w	pc, [sp], #4
 8012f48:	f3af 8000 	nop.w
 8012f4c:	f3af 8000 	nop.w

08012f50 <LSM303AGR_ACC_W_BlockDataUpdate>:
* Input          : LSM303AGR_ACC_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t newValue)
{
 8012f50:	b500      	push	{lr}
 8012f52:	b085      	sub	sp, #20
 8012f54:	9001      	str	r0, [sp, #4]
 8012f56:	460b      	mov	r3, r1
 8012f58:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8012f5c:	f10d 030f 	add.w	r3, sp, #15
 8012f60:	9801      	ldr	r0, [sp, #4]
 8012f62:	2123      	movs	r1, #35	; 0x23
 8012f64:	461a      	mov	r2, r3
 8012f66:	2301      	movs	r3, #1
 8012f68:	f7ff ffb2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8012f6c:	4603      	mov	r3, r0
 8012f6e:	2b00      	cmp	r3, #0
 8012f70:	d101      	bne.n	8012f76 <LSM303AGR_ACC_W_BlockDataUpdate+0x26>
    return MEMS_ERROR;
 8012f72:	2300      	movs	r3, #0
 8012f74:	e01c      	b.n	8012fb0 <LSM303AGR_ACC_W_BlockDataUpdate+0x60>

  value &= ~LSM303AGR_ACC_BDU_MASK;
 8012f76:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012f7a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012f7e:	b2db      	uxtb	r3, r3
 8012f80:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012f84:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012f88:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012f8c:	4313      	orrs	r3, r2
 8012f8e:	b2db      	uxtb	r3, r3
 8012f90:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8012f94:	f10d 030f 	add.w	r3, sp, #15
 8012f98:	9801      	ldr	r0, [sp, #4]
 8012f9a:	2123      	movs	r1, #35	; 0x23
 8012f9c:	461a      	mov	r2, r3
 8012f9e:	2301      	movs	r3, #1
 8012fa0:	f7ff ff6e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8012fa4:	4603      	mov	r3, r0
 8012fa6:	2b00      	cmp	r3, #0
 8012fa8:	d101      	bne.n	8012fae <LSM303AGR_ACC_W_BlockDataUpdate+0x5e>
    return MEMS_ERROR;
 8012faa:	2300      	movs	r3, #0
 8012fac:	e000      	b.n	8012fb0 <LSM303AGR_ACC_W_BlockDataUpdate+0x60>

  return MEMS_SUCCESS;
 8012fae:	2301      	movs	r3, #1
}
 8012fb0:	4618      	mov	r0, r3
 8012fb2:	b005      	add	sp, #20
 8012fb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012fb8:	f3af 8000 	nop.w
 8012fbc:	f3af 8000 	nop.w

08012fc0 <LSM303AGR_ACC_R_BlockDataUpdate>:
* Input          : Pointer to LSM303AGR_ACC_BDU_t
* Output         : Status of BDU see LSM303AGR_ACC_BDU_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t *value)
{
 8012fc0:	b500      	push	{lr}
 8012fc2:	b083      	sub	sp, #12
 8012fc4:	9001      	str	r0, [sp, #4]
 8012fc6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8012fc8:	9801      	ldr	r0, [sp, #4]
 8012fca:	2123      	movs	r1, #35	; 0x23
 8012fcc:	9a00      	ldr	r2, [sp, #0]
 8012fce:	2301      	movs	r3, #1
 8012fd0:	f7ff ff7e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8012fd4:	4603      	mov	r3, r0
 8012fd6:	2b00      	cmp	r3, #0
 8012fd8:	d101      	bne.n	8012fde <LSM303AGR_ACC_R_BlockDataUpdate+0x1e>
    return MEMS_ERROR;
 8012fda:	2300      	movs	r3, #0
 8012fdc:	e007      	b.n	8012fee <LSM303AGR_ACC_R_BlockDataUpdate+0x2e>

  *value &= LSM303AGR_ACC_BDU_MASK; //mask
 8012fde:	9b00      	ldr	r3, [sp, #0]
 8012fe0:	781b      	ldrb	r3, [r3, #0]
 8012fe2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8012fe6:	b2da      	uxtb	r2, r3
 8012fe8:	9b00      	ldr	r3, [sp, #0]
 8012fea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012fec:	2301      	movs	r3, #1
}
 8012fee:	4618      	mov	r0, r3
 8012ff0:	b003      	add	sp, #12
 8012ff2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ff6:	bf00      	nop
 8012ff8:	f3af 8000 	nop.w
 8012ffc:	f3af 8000 	nop.w

08013000 <LSM303AGR_ACC_W_FullScale>:
* Input          : LSM303AGR_ACC_FS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FullScale(void *handle, LSM303AGR_ACC_FS_t newValue)
{
 8013000:	b500      	push	{lr}
 8013002:	b085      	sub	sp, #20
 8013004:	9001      	str	r0, [sp, #4]
 8013006:	460b      	mov	r3, r1
 8013008:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801300c:	f10d 030f 	add.w	r3, sp, #15
 8013010:	9801      	ldr	r0, [sp, #4]
 8013012:	2123      	movs	r1, #35	; 0x23
 8013014:	461a      	mov	r2, r3
 8013016:	2301      	movs	r3, #1
 8013018:	f7ff ff5a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801301c:	4603      	mov	r3, r0
 801301e:	2b00      	cmp	r3, #0
 8013020:	d101      	bne.n	8013026 <LSM303AGR_ACC_W_FullScale+0x26>
    return MEMS_ERROR;
 8013022:	2300      	movs	r3, #0
 8013024:	e01c      	b.n	8013060 <LSM303AGR_ACC_W_FullScale+0x60>

  value &= ~LSM303AGR_ACC_FS_MASK;
 8013026:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801302a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 801302e:	b2db      	uxtb	r3, r3
 8013030:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013034:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013038:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801303c:	4313      	orrs	r3, r2
 801303e:	b2db      	uxtb	r3, r3
 8013040:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8013044:	f10d 030f 	add.w	r3, sp, #15
 8013048:	9801      	ldr	r0, [sp, #4]
 801304a:	2123      	movs	r1, #35	; 0x23
 801304c:	461a      	mov	r2, r3
 801304e:	2301      	movs	r3, #1
 8013050:	f7ff ff16 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013054:	4603      	mov	r3, r0
 8013056:	2b00      	cmp	r3, #0
 8013058:	d101      	bne.n	801305e <LSM303AGR_ACC_W_FullScale+0x5e>
    return MEMS_ERROR;
 801305a:	2300      	movs	r3, #0
 801305c:	e000      	b.n	8013060 <LSM303AGR_ACC_W_FullScale+0x60>

  return MEMS_SUCCESS;
 801305e:	2301      	movs	r3, #1
}
 8013060:	4618      	mov	r0, r3
 8013062:	b005      	add	sp, #20
 8013064:	f85d fb04 	ldr.w	pc, [sp], #4
 8013068:	f3af 8000 	nop.w
 801306c:	f3af 8000 	nop.w

08013070 <LSM303AGR_ACC_R_FullScale>:
* Input          : Pointer to LSM303AGR_ACC_FS_t
* Output         : Status of FS see LSM303AGR_ACC_FS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FullScale(void *handle, LSM303AGR_ACC_FS_t *value)
{
 8013070:	b500      	push	{lr}
 8013072:	b083      	sub	sp, #12
 8013074:	9001      	str	r0, [sp, #4]
 8013076:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8013078:	9801      	ldr	r0, [sp, #4]
 801307a:	2123      	movs	r1, #35	; 0x23
 801307c:	9a00      	ldr	r2, [sp, #0]
 801307e:	2301      	movs	r3, #1
 8013080:	f7ff ff26 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013084:	4603      	mov	r3, r0
 8013086:	2b00      	cmp	r3, #0
 8013088:	d101      	bne.n	801308e <LSM303AGR_ACC_R_FullScale+0x1e>
    return MEMS_ERROR;
 801308a:	2300      	movs	r3, #0
 801308c:	e007      	b.n	801309e <LSM303AGR_ACC_R_FullScale+0x2e>

  *value &= LSM303AGR_ACC_FS_MASK; //mask
 801308e:	9b00      	ldr	r3, [sp, #0]
 8013090:	781b      	ldrb	r3, [r3, #0]
 8013092:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8013096:	b2da      	uxtb	r2, r3
 8013098:	9b00      	ldr	r3, [sp, #0]
 801309a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801309c:	2301      	movs	r3, #1
}
 801309e:	4618      	mov	r0, r3
 80130a0:	b003      	add	sp, #12
 80130a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80130a6:	bf00      	nop
 80130a8:	f3af 8000 	nop.w
 80130ac:	f3af 8000 	nop.w

080130b0 <LSM303AGR_ACC_Get_Raw_Acceleration>:
* Input          : pointer to [u8_t]
* Output         : Acceleration buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Raw_Acceleration(void *handle, u8_t *buff)
{
 80130b0:	b500      	push	{lr}
 80130b2:	b083      	sub	sp, #12
 80130b4:	9001      	str	r0, [sp, #4]
 80130b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_X_L, buff, 6 ) )
 80130b8:	9801      	ldr	r0, [sp, #4]
 80130ba:	2128      	movs	r1, #40	; 0x28
 80130bc:	9a00      	ldr	r2, [sp, #0]
 80130be:	2306      	movs	r3, #6
 80130c0:	f7ff ff06 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80130c4:	4603      	mov	r3, r0
 80130c6:	2b00      	cmp	r3, #0
 80130c8:	d101      	bne.n	80130ce <LSM303AGR_ACC_Get_Raw_Acceleration+0x1e>
    return MEMS_ERROR;
 80130ca:	2300      	movs	r3, #0
 80130cc:	e000      	b.n	80130d0 <LSM303AGR_ACC_Get_Raw_Acceleration+0x20>

  return MEMS_SUCCESS;
 80130ce:	2301      	movs	r3, #1
}
 80130d0:	4618      	mov	r0, r3
 80130d2:	b003      	add	sp, #12
 80130d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80130d8:	f3af 8000 	nop.w
 80130dc:	f3af 8000 	nop.w

080130e0 <LSM303AGR_ACC_Get_Acceleration>:
    62520,  /* FS @8g */
    187580, /* FS @16g */
  },
};
status_t LSM303AGR_ACC_Get_Acceleration(void *handle, int *buff)
{
 80130e0:	b570      	push	{r4, r5, r6, lr}
 80130e2:	b086      	sub	sp, #24
 80130e4:	9001      	str	r0, [sp, #4]
 80130e6:	9100      	str	r1, [sp, #0]
  Type3Axis16bit_U raw_data_tmp;
  u8_t op_mode = 0, fs_mode = 0, shift = 0;
 80130e8:	2300      	movs	r3, #0
 80130ea:	f88d 3017 	strb.w	r3, [sp, #23]
 80130ee:	2300      	movs	r3, #0
 80130f0:	f88d 3016 	strb.w	r3, [sp, #22]
 80130f4:	2300      	movs	r3, #0
 80130f6:	f88d 3015 	strb.w	r3, [sp, #21]
  LSM303AGR_ACC_LPEN_t lp;
  LSM303AGR_ACC_HR_t hr;
  LSM303AGR_ACC_FS_t fs;

  /* Determine which operational mode the acc is set */
  LSM303AGR_ACC_R_HiRes(handle, &hr);
 80130fa:	f10d 030a 	add.w	r3, sp, #10
 80130fe:	9801      	ldr	r0, [sp, #4]
 8013100:	4619      	mov	r1, r3
 8013102:	f001 f9dd 	bl	80144c0 <LSM303AGR_ACC_R_HiRes>
  LSM303AGR_ACC_R_LOWPWR_EN(handle, &lp);
 8013106:	f10d 030b 	add.w	r3, sp, #11
 801310a:	9801      	ldr	r0, [sp, #4]
 801310c:	4619      	mov	r1, r3
 801310e:	f000 fc57 	bl	80139c0 <LSM303AGR_ACC_R_LOWPWR_EN>

  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8013112:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8013116:	2b08      	cmp	r3, #8
 8013118:	d10a      	bne.n	8013130 <LSM303AGR_ACC_Get_Acceleration+0x50>
 801311a:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801311e:	2b00      	cmp	r3, #0
 8013120:	d106      	bne.n	8013130 <LSM303AGR_ACC_Get_Acceleration+0x50>
  {
    /* op mode is LP 8-bit */
    op_mode = 2;
 8013122:	2302      	movs	r3, #2
 8013124:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 8;
 8013128:	2308      	movs	r3, #8
 801312a:	f88d 3015 	strb.w	r3, [sp, #21]
 801312e:	e01f      	b.n	8013170 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8013130:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8013134:	2b00      	cmp	r3, #0
 8013136:	d10a      	bne.n	801314e <LSM303AGR_ACC_Get_Acceleration+0x6e>
 8013138:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801313c:	2b00      	cmp	r3, #0
 801313e:	d106      	bne.n	801314e <LSM303AGR_ACC_Get_Acceleration+0x6e>
  {
    /* op mode is Normal 10-bit */
    op_mode = 1;
 8013140:	2301      	movs	r3, #1
 8013142:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 6;
 8013146:	2306      	movs	r3, #6
 8013148:	f88d 3015 	strb.w	r3, [sp, #21]
 801314c:	e010      	b.n	8013170 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_ENABLED)
 801314e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8013152:	2b00      	cmp	r3, #0
 8013154:	d10a      	bne.n	801316c <LSM303AGR_ACC_Get_Acceleration+0x8c>
 8013156:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801315a:	2b08      	cmp	r3, #8
 801315c:	d106      	bne.n	801316c <LSM303AGR_ACC_Get_Acceleration+0x8c>
  {
    /* op mode is HR 12-bit */
    op_mode = 0;
 801315e:	2300      	movs	r3, #0
 8013160:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 4;
 8013164:	2304      	movs	r3, #4
 8013166:	f88d 3015 	strb.w	r3, [sp, #21]
 801316a:	e001      	b.n	8013170 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else
    return MEMS_ERROR;
 801316c:	2300      	movs	r3, #0
 801316e:	e0b8      	b.n	80132e2 <LSM303AGR_ACC_Get_Acceleration+0x202>

  /* Determine the Full Scale the acc is set */
  LSM303AGR_ACC_R_FullScale(handle, &fs);
 8013170:	f10d 0309 	add.w	r3, sp, #9
 8013174:	9801      	ldr	r0, [sp, #4]
 8013176:	4619      	mov	r1, r3
 8013178:	f7ff ff7a 	bl	8013070 <LSM303AGR_ACC_R_FullScale>
  switch (fs)
 801317c:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8013180:	2b10      	cmp	r3, #16
 8013182:	d00d      	beq.n	80131a0 <LSM303AGR_ACC_Get_Acceleration+0xc0>
 8013184:	2b10      	cmp	r3, #16
 8013186:	dc02      	bgt.n	801318e <LSM303AGR_ACC_Get_Acceleration+0xae>
 8013188:	2b00      	cmp	r3, #0
 801318a:	d005      	beq.n	8013198 <LSM303AGR_ACC_Get_Acceleration+0xb8>
 801318c:	e014      	b.n	80131b8 <LSM303AGR_ACC_Get_Acceleration+0xd8>
 801318e:	2b20      	cmp	r3, #32
 8013190:	d00a      	beq.n	80131a8 <LSM303AGR_ACC_Get_Acceleration+0xc8>
 8013192:	2b30      	cmp	r3, #48	; 0x30
 8013194:	d00c      	beq.n	80131b0 <LSM303AGR_ACC_Get_Acceleration+0xd0>
 8013196:	e00f      	b.n	80131b8 <LSM303AGR_ACC_Get_Acceleration+0xd8>
  {
    case LSM303AGR_ACC_FS_2G:
      fs_mode = 0;
 8013198:	2300      	movs	r3, #0
 801319a:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 801319e:	e00b      	b.n	80131b8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_4G:
      fs_mode = 1;
 80131a0:	2301      	movs	r3, #1
 80131a2:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80131a6:	e007      	b.n	80131b8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_8G:
      fs_mode = 2;
 80131a8:	2302      	movs	r3, #2
 80131aa:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80131ae:	e003      	b.n	80131b8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_16G:
      fs_mode = 3;
 80131b0:	2303      	movs	r3, #3
 80131b2:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80131b6:	bf00      	nop
  }

  /* Read out raw accelerometer samples */
  LSM303AGR_ACC_Get_Raw_Acceleration(handle, raw_data_tmp.u8bit);
 80131b8:	ab03      	add	r3, sp, #12
 80131ba:	9801      	ldr	r0, [sp, #4]
 80131bc:	4619      	mov	r1, r3
 80131be:	f7ff ff77 	bl	80130b0 <LSM303AGR_ACC_Get_Raw_Acceleration>

  /* Apply proper shift and sensitivity */
  buff[0] = ((raw_data_tmp.i16bit[0] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 80131c2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80131c6:	b21a      	sxth	r2, r3
 80131c8:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80131cc:	fa42 f303 	asr.w	r3, r2, r3
 80131d0:	4618      	mov	r0, r3
 80131d2:	ea4f 71e0 	mov.w	r1, r0, asr #31
 80131d6:	f89d 4017 	ldrb.w	r4, [sp, #23]
 80131da:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80131de:	4a42      	ldr	r2, [pc, #264]	; (80132e8 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 80131e0:	00a4      	lsls	r4, r4, #2
 80131e2:	4423      	add	r3, r4
 80131e4:	00db      	lsls	r3, r3, #3
 80131e6:	4413      	add	r3, r2
 80131e8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80131ec:	fb02 f501 	mul.w	r5, r2, r1
 80131f0:	fb00 f403 	mul.w	r4, r0, r3
 80131f4:	442c      	add	r4, r5
 80131f6:	fba0 2302 	umull	r2, r3, r0, r2
 80131fa:	18e1      	adds	r1, r4, r3
 80131fc:	460b      	mov	r3, r1
 80131fe:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 8013202:	f143 0300 	adc.w	r3, r3, #0
 8013206:	4610      	mov	r0, r2
 8013208:	4619      	mov	r1, r3
 801320a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801320e:	f04f 0300 	mov.w	r3, #0
 8013212:	f003 fef5 	bl	8017000 <__aeabi_ldivmod>
 8013216:	4602      	mov	r2, r0
 8013218:	460b      	mov	r3, r1
 801321a:	9b00      	ldr	r3, [sp, #0]
 801321c:	601a      	str	r2, [r3, #0]
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 801321e:	9b00      	ldr	r3, [sp, #0]
 8013220:	1d1c      	adds	r4, r3, #4
 8013222:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8013226:	b21a      	sxth	r2, r3
 8013228:	f89d 3015 	ldrb.w	r3, [sp, #21]
 801322c:	fa42 f303 	asr.w	r3, r2, r3
 8013230:	4618      	mov	r0, r3
 8013232:	ea4f 71e0 	mov.w	r1, r0, asr #31
 8013236:	f89d 5017 	ldrb.w	r5, [sp, #23]
 801323a:	f89d 3016 	ldrb.w	r3, [sp, #22]
 801323e:	4a2a      	ldr	r2, [pc, #168]	; (80132e8 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 8013240:	00ad      	lsls	r5, r5, #2
 8013242:	442b      	add	r3, r5
 8013244:	00db      	lsls	r3, r3, #3
 8013246:	4413      	add	r3, r2
 8013248:	e9d3 2300 	ldrd	r2, r3, [r3]
 801324c:	fb02 f601 	mul.w	r6, r2, r1
 8013250:	fb00 f503 	mul.w	r5, r0, r3
 8013254:	4435      	add	r5, r6
 8013256:	fba0 2302 	umull	r2, r3, r0, r2
 801325a:	18e9      	adds	r1, r5, r3
 801325c:	460b      	mov	r3, r1
 801325e:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 8013262:	f143 0300 	adc.w	r3, r3, #0
 8013266:	4610      	mov	r0, r2
 8013268:	4619      	mov	r1, r3
 801326a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801326e:	f04f 0300 	mov.w	r3, #0
 8013272:	f003 fec5 	bl	8017000 <__aeabi_ldivmod>
 8013276:	4602      	mov	r2, r0
 8013278:	460b      	mov	r3, r1
 801327a:	4613      	mov	r3, r2
 801327c:	6023      	str	r3, [r4, #0]
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 801327e:	9b00      	ldr	r3, [sp, #0]
 8013280:	f103 0408 	add.w	r4, r3, #8
 8013284:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 8013288:	b21a      	sxth	r2, r3
 801328a:	f89d 3015 	ldrb.w	r3, [sp, #21]
 801328e:	fa42 f303 	asr.w	r3, r2, r3
 8013292:	4618      	mov	r0, r3
 8013294:	ea4f 71e0 	mov.w	r1, r0, asr #31
 8013298:	f89d 5017 	ldrb.w	r5, [sp, #23]
 801329c:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80132a0:	4a11      	ldr	r2, [pc, #68]	; (80132e8 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 80132a2:	00ad      	lsls	r5, r5, #2
 80132a4:	442b      	add	r3, r5
 80132a6:	00db      	lsls	r3, r3, #3
 80132a8:	4413      	add	r3, r2
 80132aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80132ae:	fb02 f601 	mul.w	r6, r2, r1
 80132b2:	fb00 f503 	mul.w	r5, r0, r3
 80132b6:	4435      	add	r5, r6
 80132b8:	fba0 2302 	umull	r2, r3, r0, r2
 80132bc:	18e9      	adds	r1, r5, r3
 80132be:	460b      	mov	r3, r1
 80132c0:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 80132c4:	f143 0300 	adc.w	r3, r3, #0
 80132c8:	4610      	mov	r0, r2
 80132ca:	4619      	mov	r1, r3
 80132cc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80132d0:	f04f 0300 	mov.w	r3, #0
 80132d4:	f003 fe94 	bl	8017000 <__aeabi_ldivmod>
 80132d8:	4602      	mov	r2, r0
 80132da:	460b      	mov	r3, r1
 80132dc:	4613      	mov	r3, r2
 80132de:	6023      	str	r3, [r4, #0]

  return MEMS_SUCCESS;
 80132e0:	2301      	movs	r3, #1
}
 80132e2:	4618      	mov	r0, r3
 80132e4:	b006      	add	sp, #24
 80132e6:	bd70      	pop	{r4, r5, r6, pc}
 80132e8:	0801c160 	.word	0x0801c160
 80132ec:	f3af 8000 	nop.w

080132f0 <LSM303AGR_ACC_W_ODR>:
* Input          : LSM303AGR_ACC_ODR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ODR(void *handle, LSM303AGR_ACC_ODR_t newValue)
{
 80132f0:	b500      	push	{lr}
 80132f2:	b085      	sub	sp, #20
 80132f4:	9001      	str	r0, [sp, #4]
 80132f6:	460b      	mov	r3, r1
 80132f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 80132fc:	f10d 030f 	add.w	r3, sp, #15
 8013300:	9801      	ldr	r0, [sp, #4]
 8013302:	2120      	movs	r1, #32
 8013304:	461a      	mov	r2, r3
 8013306:	2301      	movs	r3, #1
 8013308:	f7ff fde2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801330c:	4603      	mov	r3, r0
 801330e:	2b00      	cmp	r3, #0
 8013310:	d101      	bne.n	8013316 <LSM303AGR_ACC_W_ODR+0x26>
    return MEMS_ERROR;
 8013312:	2300      	movs	r3, #0
 8013314:	e01c      	b.n	8013350 <LSM303AGR_ACC_W_ODR+0x60>

  value &= ~LSM303AGR_ACC_ODR_MASK;
 8013316:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801331a:	f003 030f 	and.w	r3, r3, #15
 801331e:	b2db      	uxtb	r3, r3
 8013320:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013324:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013328:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801332c:	4313      	orrs	r3, r2
 801332e:	b2db      	uxtb	r3, r3
 8013330:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8013334:	f10d 030f 	add.w	r3, sp, #15
 8013338:	9801      	ldr	r0, [sp, #4]
 801333a:	2120      	movs	r1, #32
 801333c:	461a      	mov	r2, r3
 801333e:	2301      	movs	r3, #1
 8013340:	f7ff fd9e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013344:	4603      	mov	r3, r0
 8013346:	2b00      	cmp	r3, #0
 8013348:	d101      	bne.n	801334e <LSM303AGR_ACC_W_ODR+0x5e>
    return MEMS_ERROR;
 801334a:	2300      	movs	r3, #0
 801334c:	e000      	b.n	8013350 <LSM303AGR_ACC_W_ODR+0x60>

  return MEMS_SUCCESS;
 801334e:	2301      	movs	r3, #1
}
 8013350:	4618      	mov	r0, r3
 8013352:	b005      	add	sp, #20
 8013354:	f85d fb04 	ldr.w	pc, [sp], #4
 8013358:	f3af 8000 	nop.w
 801335c:	f3af 8000 	nop.w

08013360 <LSM303AGR_ACC_R_ODR>:
* Input          : Pointer to LSM303AGR_ACC_ODR_t
* Output         : Status of ODR see LSM303AGR_ACC_ODR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ODR(void *handle, LSM303AGR_ACC_ODR_t *value)
{
 8013360:	b500      	push	{lr}
 8013362:	b083      	sub	sp, #12
 8013364:	9001      	str	r0, [sp, #4]
 8013366:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8013368:	9801      	ldr	r0, [sp, #4]
 801336a:	2120      	movs	r1, #32
 801336c:	9a00      	ldr	r2, [sp, #0]
 801336e:	2301      	movs	r3, #1
 8013370:	f7ff fdae 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013374:	4603      	mov	r3, r0
 8013376:	2b00      	cmp	r3, #0
 8013378:	d101      	bne.n	801337e <LSM303AGR_ACC_R_ODR+0x1e>
    return MEMS_ERROR;
 801337a:	2300      	movs	r3, #0
 801337c:	e007      	b.n	801338e <LSM303AGR_ACC_R_ODR+0x2e>

  *value &= LSM303AGR_ACC_ODR_MASK; //mask
 801337e:	9b00      	ldr	r3, [sp, #0]
 8013380:	781b      	ldrb	r3, [r3, #0]
 8013382:	f023 030f 	bic.w	r3, r3, #15
 8013386:	b2da      	uxtb	r2, r3
 8013388:	9b00      	ldr	r3, [sp, #0]
 801338a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801338c:	2301      	movs	r3, #1
}
 801338e:	4618      	mov	r0, r3
 8013390:	b003      	add	sp, #12
 8013392:	f85d fb04 	ldr.w	pc, [sp], #4
 8013396:	bf00      	nop
 8013398:	f3af 8000 	nop.w
 801339c:	f3af 8000 	nop.w

080133a0 <LSM303AGR_ACC_R_x_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_1DA_t
* Output         : Status of 1DA see LSM303AGR_ACC_1DA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_x_data_avail(void *handle, LSM303AGR_ACC_1DA_t *value)
{
 80133a0:	b500      	push	{lr}
 80133a2:	b083      	sub	sp, #12
 80133a4:	9001      	str	r0, [sp, #4]
 80133a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80133a8:	9801      	ldr	r0, [sp, #4]
 80133aa:	2107      	movs	r1, #7
 80133ac:	9a00      	ldr	r2, [sp, #0]
 80133ae:	2301      	movs	r3, #1
 80133b0:	f7ff fd8e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80133b4:	4603      	mov	r3, r0
 80133b6:	2b00      	cmp	r3, #0
 80133b8:	d101      	bne.n	80133be <LSM303AGR_ACC_R_x_data_avail+0x1e>
    return MEMS_ERROR;
 80133ba:	2300      	movs	r3, #0
 80133bc:	e007      	b.n	80133ce <LSM303AGR_ACC_R_x_data_avail+0x2e>

  *value &= LSM303AGR_ACC_1DA_MASK; //mask
 80133be:	9b00      	ldr	r3, [sp, #0]
 80133c0:	781b      	ldrb	r3, [r3, #0]
 80133c2:	f003 0301 	and.w	r3, r3, #1
 80133c6:	b2da      	uxtb	r2, r3
 80133c8:	9b00      	ldr	r3, [sp, #0]
 80133ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80133cc:	2301      	movs	r3, #1
}
 80133ce:	4618      	mov	r0, r3
 80133d0:	b003      	add	sp, #12
 80133d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80133d6:	bf00      	nop
 80133d8:	f3af 8000 	nop.w
 80133dc:	f3af 8000 	nop.w

080133e0 <LSM303AGR_ACC_R_y_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_2DA__t
* Output         : Status of 2DA_ see LSM303AGR_ACC_2DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_y_data_avail(void *handle, LSM303AGR_ACC_2DA__t *value)
{
 80133e0:	b500      	push	{lr}
 80133e2:	b083      	sub	sp, #12
 80133e4:	9001      	str	r0, [sp, #4]
 80133e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80133e8:	9801      	ldr	r0, [sp, #4]
 80133ea:	2107      	movs	r1, #7
 80133ec:	9a00      	ldr	r2, [sp, #0]
 80133ee:	2301      	movs	r3, #1
 80133f0:	f7ff fd6e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80133f4:	4603      	mov	r3, r0
 80133f6:	2b00      	cmp	r3, #0
 80133f8:	d101      	bne.n	80133fe <LSM303AGR_ACC_R_y_data_avail+0x1e>
    return MEMS_ERROR;
 80133fa:	2300      	movs	r3, #0
 80133fc:	e007      	b.n	801340e <LSM303AGR_ACC_R_y_data_avail+0x2e>

  *value &= LSM303AGR_ACC_2DA__MASK; //mask
 80133fe:	9b00      	ldr	r3, [sp, #0]
 8013400:	781b      	ldrb	r3, [r3, #0]
 8013402:	f003 0302 	and.w	r3, r3, #2
 8013406:	b2da      	uxtb	r2, r3
 8013408:	9b00      	ldr	r3, [sp, #0]
 801340a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801340c:	2301      	movs	r3, #1
}
 801340e:	4618      	mov	r0, r3
 8013410:	b003      	add	sp, #12
 8013412:	f85d fb04 	ldr.w	pc, [sp], #4
 8013416:	bf00      	nop
 8013418:	f3af 8000 	nop.w
 801341c:	f3af 8000 	nop.w

08013420 <LSM303AGR_ACC_R_z_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_3DA__t
* Output         : Status of 3DA_ see LSM303AGR_ACC_3DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_z_data_avail(void *handle, LSM303AGR_ACC_3DA__t *value)
{
 8013420:	b500      	push	{lr}
 8013422:	b083      	sub	sp, #12
 8013424:	9001      	str	r0, [sp, #4]
 8013426:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8013428:	9801      	ldr	r0, [sp, #4]
 801342a:	2107      	movs	r1, #7
 801342c:	9a00      	ldr	r2, [sp, #0]
 801342e:	2301      	movs	r3, #1
 8013430:	f7ff fd4e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013434:	4603      	mov	r3, r0
 8013436:	2b00      	cmp	r3, #0
 8013438:	d101      	bne.n	801343e <LSM303AGR_ACC_R_z_data_avail+0x1e>
    return MEMS_ERROR;
 801343a:	2300      	movs	r3, #0
 801343c:	e007      	b.n	801344e <LSM303AGR_ACC_R_z_data_avail+0x2e>

  *value &= LSM303AGR_ACC_3DA__MASK; //mask
 801343e:	9b00      	ldr	r3, [sp, #0]
 8013440:	781b      	ldrb	r3, [r3, #0]
 8013442:	f003 0304 	and.w	r3, r3, #4
 8013446:	b2da      	uxtb	r2, r3
 8013448:	9b00      	ldr	r3, [sp, #0]
 801344a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801344c:	2301      	movs	r3, #1
}
 801344e:	4618      	mov	r0, r3
 8013450:	b003      	add	sp, #12
 8013452:	f85d fb04 	ldr.w	pc, [sp], #4
 8013456:	bf00      	nop
 8013458:	f3af 8000 	nop.w
 801345c:	f3af 8000 	nop.w

08013460 <LSM303AGR_ACC_R_xyz_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_321DA__t
* Output         : Status of 321DA_ see LSM303AGR_ACC_321DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_xyz_data_avail(void *handle, LSM303AGR_ACC_321DA__t *value)
{
 8013460:	b500      	push	{lr}
 8013462:	b083      	sub	sp, #12
 8013464:	9001      	str	r0, [sp, #4]
 8013466:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8013468:	9801      	ldr	r0, [sp, #4]
 801346a:	2107      	movs	r1, #7
 801346c:	9a00      	ldr	r2, [sp, #0]
 801346e:	2301      	movs	r3, #1
 8013470:	f7ff fd2e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013474:	4603      	mov	r3, r0
 8013476:	2b00      	cmp	r3, #0
 8013478:	d101      	bne.n	801347e <LSM303AGR_ACC_R_xyz_data_avail+0x1e>
    return MEMS_ERROR;
 801347a:	2300      	movs	r3, #0
 801347c:	e007      	b.n	801348e <LSM303AGR_ACC_R_xyz_data_avail+0x2e>

  *value &= LSM303AGR_ACC_321DA__MASK; //mask
 801347e:	9b00      	ldr	r3, [sp, #0]
 8013480:	781b      	ldrb	r3, [r3, #0]
 8013482:	f003 0308 	and.w	r3, r3, #8
 8013486:	b2da      	uxtb	r2, r3
 8013488:	9b00      	ldr	r3, [sp, #0]
 801348a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801348c:	2301      	movs	r3, #1
}
 801348e:	4618      	mov	r0, r3
 8013490:	b003      	add	sp, #12
 8013492:	f85d fb04 	ldr.w	pc, [sp], #4
 8013496:	bf00      	nop
 8013498:	f3af 8000 	nop.w
 801349c:	f3af 8000 	nop.w

080134a0 <LSM303AGR_ACC_R_DataXOverrun>:
* Input          : Pointer to LSM303AGR_ACC_1OR__t
* Output         : Status of 1OR_ see LSM303AGR_ACC_1OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataXOverrun(void *handle, LSM303AGR_ACC_1OR__t *value)
{
 80134a0:	b500      	push	{lr}
 80134a2:	b083      	sub	sp, #12
 80134a4:	9001      	str	r0, [sp, #4]
 80134a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80134a8:	9801      	ldr	r0, [sp, #4]
 80134aa:	2107      	movs	r1, #7
 80134ac:	9a00      	ldr	r2, [sp, #0]
 80134ae:	2301      	movs	r3, #1
 80134b0:	f7ff fd0e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80134b4:	4603      	mov	r3, r0
 80134b6:	2b00      	cmp	r3, #0
 80134b8:	d101      	bne.n	80134be <LSM303AGR_ACC_R_DataXOverrun+0x1e>
    return MEMS_ERROR;
 80134ba:	2300      	movs	r3, #0
 80134bc:	e007      	b.n	80134ce <LSM303AGR_ACC_R_DataXOverrun+0x2e>

  *value &= LSM303AGR_ACC_1OR__MASK; //mask
 80134be:	9b00      	ldr	r3, [sp, #0]
 80134c0:	781b      	ldrb	r3, [r3, #0]
 80134c2:	f003 0310 	and.w	r3, r3, #16
 80134c6:	b2da      	uxtb	r2, r3
 80134c8:	9b00      	ldr	r3, [sp, #0]
 80134ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80134cc:	2301      	movs	r3, #1
}
 80134ce:	4618      	mov	r0, r3
 80134d0:	b003      	add	sp, #12
 80134d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80134d6:	bf00      	nop
 80134d8:	f3af 8000 	nop.w
 80134dc:	f3af 8000 	nop.w

080134e0 <LSM303AGR_ACC_R_DataYOverrun>:
* Input          : Pointer to LSM303AGR_ACC_2OR__t
* Output         : Status of 2OR_ see LSM303AGR_ACC_2OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataYOverrun(void *handle, LSM303AGR_ACC_2OR__t *value)
{
 80134e0:	b500      	push	{lr}
 80134e2:	b083      	sub	sp, #12
 80134e4:	9001      	str	r0, [sp, #4]
 80134e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80134e8:	9801      	ldr	r0, [sp, #4]
 80134ea:	2107      	movs	r1, #7
 80134ec:	9a00      	ldr	r2, [sp, #0]
 80134ee:	2301      	movs	r3, #1
 80134f0:	f7ff fcee 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80134f4:	4603      	mov	r3, r0
 80134f6:	2b00      	cmp	r3, #0
 80134f8:	d101      	bne.n	80134fe <LSM303AGR_ACC_R_DataYOverrun+0x1e>
    return MEMS_ERROR;
 80134fa:	2300      	movs	r3, #0
 80134fc:	e007      	b.n	801350e <LSM303AGR_ACC_R_DataYOverrun+0x2e>

  *value &= LSM303AGR_ACC_2OR__MASK; //mask
 80134fe:	9b00      	ldr	r3, [sp, #0]
 8013500:	781b      	ldrb	r3, [r3, #0]
 8013502:	f003 0320 	and.w	r3, r3, #32
 8013506:	b2da      	uxtb	r2, r3
 8013508:	9b00      	ldr	r3, [sp, #0]
 801350a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801350c:	2301      	movs	r3, #1
}
 801350e:	4618      	mov	r0, r3
 8013510:	b003      	add	sp, #12
 8013512:	f85d fb04 	ldr.w	pc, [sp], #4
 8013516:	bf00      	nop
 8013518:	f3af 8000 	nop.w
 801351c:	f3af 8000 	nop.w

08013520 <LSM303AGR_ACC_R_DataZOverrun>:
* Input          : Pointer to LSM303AGR_ACC_3OR__t
* Output         : Status of 3OR_ see LSM303AGR_ACC_3OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataZOverrun(void *handle, LSM303AGR_ACC_3OR__t *value)
{
 8013520:	b500      	push	{lr}
 8013522:	b083      	sub	sp, #12
 8013524:	9001      	str	r0, [sp, #4]
 8013526:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8013528:	9801      	ldr	r0, [sp, #4]
 801352a:	2107      	movs	r1, #7
 801352c:	9a00      	ldr	r2, [sp, #0]
 801352e:	2301      	movs	r3, #1
 8013530:	f7ff fcce 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013534:	4603      	mov	r3, r0
 8013536:	2b00      	cmp	r3, #0
 8013538:	d101      	bne.n	801353e <LSM303AGR_ACC_R_DataZOverrun+0x1e>
    return MEMS_ERROR;
 801353a:	2300      	movs	r3, #0
 801353c:	e007      	b.n	801354e <LSM303AGR_ACC_R_DataZOverrun+0x2e>

  *value &= LSM303AGR_ACC_3OR__MASK; //mask
 801353e:	9b00      	ldr	r3, [sp, #0]
 8013540:	781b      	ldrb	r3, [r3, #0]
 8013542:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013546:	b2da      	uxtb	r2, r3
 8013548:	9b00      	ldr	r3, [sp, #0]
 801354a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801354c:	2301      	movs	r3, #1
}
 801354e:	4618      	mov	r0, r3
 8013550:	b003      	add	sp, #12
 8013552:	f85d fb04 	ldr.w	pc, [sp], #4
 8013556:	bf00      	nop
 8013558:	f3af 8000 	nop.w
 801355c:	f3af 8000 	nop.w

08013560 <LSM303AGR_ACC_R_DataXYZOverrun>:
* Input          : Pointer to LSM303AGR_ACC_321OR__t
* Output         : Status of 321OR_ see LSM303AGR_ACC_321OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataXYZOverrun(void *handle, LSM303AGR_ACC_321OR__t *value)
{
 8013560:	b500      	push	{lr}
 8013562:	b083      	sub	sp, #12
 8013564:	9001      	str	r0, [sp, #4]
 8013566:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8013568:	9801      	ldr	r0, [sp, #4]
 801356a:	2107      	movs	r1, #7
 801356c:	9a00      	ldr	r2, [sp, #0]
 801356e:	2301      	movs	r3, #1
 8013570:	f7ff fcae 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013574:	4603      	mov	r3, r0
 8013576:	2b00      	cmp	r3, #0
 8013578:	d101      	bne.n	801357e <LSM303AGR_ACC_R_DataXYZOverrun+0x1e>
    return MEMS_ERROR;
 801357a:	2300      	movs	r3, #0
 801357c:	e007      	b.n	801358e <LSM303AGR_ACC_R_DataXYZOverrun+0x2e>

  *value &= LSM303AGR_ACC_321OR__MASK; //mask
 801357e:	9b00      	ldr	r3, [sp, #0]
 8013580:	781b      	ldrb	r3, [r3, #0]
 8013582:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8013586:	b2da      	uxtb	r2, r3
 8013588:	9b00      	ldr	r3, [sp, #0]
 801358a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801358c:	2301      	movs	r3, #1
}
 801358e:	4618      	mov	r0, r3
 8013590:	b003      	add	sp, #12
 8013592:	f85d fb04 	ldr.w	pc, [sp], #4
 8013596:	bf00      	nop
 8013598:	f3af 8000 	nop.w
 801359c:	f3af 8000 	nop.w

080135a0 <LSM303AGR_ACC_R_int_counter>:
* Input          : Pointer to u8_t
* Output         : Status of IC
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_int_counter(void *handle, u8_t *value)
{
 80135a0:	b500      	push	{lr}
 80135a2:	b083      	sub	sp, #12
 80135a4:	9001      	str	r0, [sp, #4]
 80135a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT_COUNTER_REG, (u8_t *)value, 1) )
 80135a8:	9801      	ldr	r0, [sp, #4]
 80135aa:	210e      	movs	r1, #14
 80135ac:	9a00      	ldr	r2, [sp, #0]
 80135ae:	2301      	movs	r3, #1
 80135b0:	f7ff fc8e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80135b4:	4603      	mov	r3, r0
 80135b6:	2b00      	cmp	r3, #0
 80135b8:	d101      	bne.n	80135be <LSM303AGR_ACC_R_int_counter+0x1e>
    return MEMS_ERROR;
 80135ba:	2300      	movs	r3, #0
 80135bc:	e008      	b.n	80135d0 <LSM303AGR_ACC_R_int_counter+0x30>

  *value &= LSM303AGR_ACC_IC_MASK; //coerce
 80135be:	9b00      	ldr	r3, [sp, #0]
 80135c0:	781a      	ldrb	r2, [r3, #0]
 80135c2:	9b00      	ldr	r3, [sp, #0]
 80135c4:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_IC_POSITION; //mask
 80135c6:	9b00      	ldr	r3, [sp, #0]
 80135c8:	781a      	ldrb	r2, [r3, #0]
 80135ca:	9b00      	ldr	r3, [sp, #0]
 80135cc:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80135ce:	2301      	movs	r3, #1
}
 80135d0:	4618      	mov	r0, r3
 80135d2:	b003      	add	sp, #12
 80135d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80135d8:	f3af 8000 	nop.w
 80135dc:	f3af 8000 	nop.w

080135e0 <LSM303AGR_ACC_W_TEMP_EN_bits>:
* Input          : LSM303AGR_ACC_TEMP_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_TEMP_EN_bits(void *handle, LSM303AGR_ACC_TEMP_EN_t newValue)
{
 80135e0:	b500      	push	{lr}
 80135e2:	b085      	sub	sp, #20
 80135e4:	9001      	str	r0, [sp, #4]
 80135e6:	460b      	mov	r3, r1
 80135e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 80135ec:	f10d 030f 	add.w	r3, sp, #15
 80135f0:	9801      	ldr	r0, [sp, #4]
 80135f2:	211f      	movs	r1, #31
 80135f4:	461a      	mov	r2, r3
 80135f6:	2301      	movs	r3, #1
 80135f8:	f7ff fc6a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80135fc:	4603      	mov	r3, r0
 80135fe:	2b00      	cmp	r3, #0
 8013600:	d101      	bne.n	8013606 <LSM303AGR_ACC_W_TEMP_EN_bits+0x26>
    return MEMS_ERROR;
 8013602:	2300      	movs	r3, #0
 8013604:	e01c      	b.n	8013640 <LSM303AGR_ACC_W_TEMP_EN_bits+0x60>

  value &= ~LSM303AGR_ACC_TEMP_EN_MASK;
 8013606:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801360a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801360e:	b2db      	uxtb	r3, r3
 8013610:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013614:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013618:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801361c:	4313      	orrs	r3, r2
 801361e:	b2db      	uxtb	r3, r3
 8013620:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8013624:	f10d 030f 	add.w	r3, sp, #15
 8013628:	9801      	ldr	r0, [sp, #4]
 801362a:	211f      	movs	r1, #31
 801362c:	461a      	mov	r2, r3
 801362e:	2301      	movs	r3, #1
 8013630:	f7ff fc26 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013634:	4603      	mov	r3, r0
 8013636:	2b00      	cmp	r3, #0
 8013638:	d101      	bne.n	801363e <LSM303AGR_ACC_W_TEMP_EN_bits+0x5e>
    return MEMS_ERROR;
 801363a:	2300      	movs	r3, #0
 801363c:	e000      	b.n	8013640 <LSM303AGR_ACC_W_TEMP_EN_bits+0x60>

  return MEMS_SUCCESS;
 801363e:	2301      	movs	r3, #1
}
 8013640:	4618      	mov	r0, r3
 8013642:	b005      	add	sp, #20
 8013644:	f85d fb04 	ldr.w	pc, [sp], #4
 8013648:	f3af 8000 	nop.w
 801364c:	f3af 8000 	nop.w

08013650 <LSM303AGR_ACC_R_TEMP_EN_bits>:
* Input          : Pointer to LSM303AGR_ACC_TEMP_EN_t
* Output         : Status of TEMP_EN see LSM303AGR_ACC_TEMP_EN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_TEMP_EN_bits(void *handle, LSM303AGR_ACC_TEMP_EN_t *value)
{
 8013650:	b500      	push	{lr}
 8013652:	b083      	sub	sp, #12
 8013654:	9001      	str	r0, [sp, #4]
 8013656:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, (u8_t *)value, 1) )
 8013658:	9801      	ldr	r0, [sp, #4]
 801365a:	211f      	movs	r1, #31
 801365c:	9a00      	ldr	r2, [sp, #0]
 801365e:	2301      	movs	r3, #1
 8013660:	f7ff fc36 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013664:	4603      	mov	r3, r0
 8013666:	2b00      	cmp	r3, #0
 8013668:	d101      	bne.n	801366e <LSM303AGR_ACC_R_TEMP_EN_bits+0x1e>
    return MEMS_ERROR;
 801366a:	2300      	movs	r3, #0
 801366c:	e007      	b.n	801367e <LSM303AGR_ACC_R_TEMP_EN_bits+0x2e>

  *value &= LSM303AGR_ACC_TEMP_EN_MASK; //mask
 801366e:	9b00      	ldr	r3, [sp, #0]
 8013670:	781b      	ldrb	r3, [r3, #0]
 8013672:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013676:	b2da      	uxtb	r2, r3
 8013678:	9b00      	ldr	r3, [sp, #0]
 801367a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801367c:	2301      	movs	r3, #1
}
 801367e:	4618      	mov	r0, r3
 8013680:	b003      	add	sp, #12
 8013682:	f85d fb04 	ldr.w	pc, [sp], #4
 8013686:	bf00      	nop
 8013688:	f3af 8000 	nop.w
 801368c:	f3af 8000 	nop.w

08013690 <LSM303AGR_ACC_W_ADC_PD>:
* Input          : LSM303AGR_ACC_ADC_PD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ADC_PD(void *handle, LSM303AGR_ACC_ADC_PD_t newValue)
{
 8013690:	b500      	push	{lr}
 8013692:	b085      	sub	sp, #20
 8013694:	9001      	str	r0, [sp, #4]
 8013696:	460b      	mov	r3, r1
 8013698:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 801369c:	f10d 030f 	add.w	r3, sp, #15
 80136a0:	9801      	ldr	r0, [sp, #4]
 80136a2:	211f      	movs	r1, #31
 80136a4:	461a      	mov	r2, r3
 80136a6:	2301      	movs	r3, #1
 80136a8:	f7ff fc12 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80136ac:	4603      	mov	r3, r0
 80136ae:	2b00      	cmp	r3, #0
 80136b0:	d101      	bne.n	80136b6 <LSM303AGR_ACC_W_ADC_PD+0x26>
    return MEMS_ERROR;
 80136b2:	2300      	movs	r3, #0
 80136b4:	e01c      	b.n	80136f0 <LSM303AGR_ACC_W_ADC_PD+0x60>

  value &= ~LSM303AGR_ACC_ADC_PD_MASK;
 80136b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80136ba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80136be:	b2db      	uxtb	r3, r3
 80136c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80136c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80136c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80136cc:	4313      	orrs	r3, r2
 80136ce:	b2db      	uxtb	r3, r3
 80136d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 80136d4:	f10d 030f 	add.w	r3, sp, #15
 80136d8:	9801      	ldr	r0, [sp, #4]
 80136da:	211f      	movs	r1, #31
 80136dc:	461a      	mov	r2, r3
 80136de:	2301      	movs	r3, #1
 80136e0:	f7ff fbce 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80136e4:	4603      	mov	r3, r0
 80136e6:	2b00      	cmp	r3, #0
 80136e8:	d101      	bne.n	80136ee <LSM303AGR_ACC_W_ADC_PD+0x5e>
    return MEMS_ERROR;
 80136ea:	2300      	movs	r3, #0
 80136ec:	e000      	b.n	80136f0 <LSM303AGR_ACC_W_ADC_PD+0x60>

  return MEMS_SUCCESS;
 80136ee:	2301      	movs	r3, #1
}
 80136f0:	4618      	mov	r0, r3
 80136f2:	b005      	add	sp, #20
 80136f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80136f8:	f3af 8000 	nop.w
 80136fc:	f3af 8000 	nop.w

08013700 <LSM303AGR_ACC_R_ADC_PD>:
* Input          : Pointer to LSM303AGR_ACC_ADC_PD_t
* Output         : Status of ADC_PD see LSM303AGR_ACC_ADC_PD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ADC_PD(void *handle, LSM303AGR_ACC_ADC_PD_t *value)
{
 8013700:	b500      	push	{lr}
 8013702:	b083      	sub	sp, #12
 8013704:	9001      	str	r0, [sp, #4]
 8013706:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, (u8_t *)value, 1) )
 8013708:	9801      	ldr	r0, [sp, #4]
 801370a:	211f      	movs	r1, #31
 801370c:	9a00      	ldr	r2, [sp, #0]
 801370e:	2301      	movs	r3, #1
 8013710:	f7ff fbde 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013714:	4603      	mov	r3, r0
 8013716:	2b00      	cmp	r3, #0
 8013718:	d101      	bne.n	801371e <LSM303AGR_ACC_R_ADC_PD+0x1e>
    return MEMS_ERROR;
 801371a:	2300      	movs	r3, #0
 801371c:	e007      	b.n	801372e <LSM303AGR_ACC_R_ADC_PD+0x2e>

  *value &= LSM303AGR_ACC_ADC_PD_MASK; //mask
 801371e:	9b00      	ldr	r3, [sp, #0]
 8013720:	781b      	ldrb	r3, [r3, #0]
 8013722:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8013726:	b2da      	uxtb	r2, r3
 8013728:	9b00      	ldr	r3, [sp, #0]
 801372a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801372c:	2301      	movs	r3, #1
}
 801372e:	4618      	mov	r0, r3
 8013730:	b003      	add	sp, #12
 8013732:	f85d fb04 	ldr.w	pc, [sp], #4
 8013736:	bf00      	nop
 8013738:	f3af 8000 	nop.w
 801373c:	f3af 8000 	nop.w

08013740 <LSM303AGR_ACC_W_XEN>:
* Input          : LSM303AGR_ACC_XEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XEN(void *handle, LSM303AGR_ACC_XEN_t newValue)
{
 8013740:	b500      	push	{lr}
 8013742:	b085      	sub	sp, #20
 8013744:	9001      	str	r0, [sp, #4]
 8013746:	460b      	mov	r3, r1
 8013748:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 801374c:	f10d 030f 	add.w	r3, sp, #15
 8013750:	9801      	ldr	r0, [sp, #4]
 8013752:	2120      	movs	r1, #32
 8013754:	461a      	mov	r2, r3
 8013756:	2301      	movs	r3, #1
 8013758:	f7ff fbba 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801375c:	4603      	mov	r3, r0
 801375e:	2b00      	cmp	r3, #0
 8013760:	d101      	bne.n	8013766 <LSM303AGR_ACC_W_XEN+0x26>
    return MEMS_ERROR;
 8013762:	2300      	movs	r3, #0
 8013764:	e01c      	b.n	80137a0 <LSM303AGR_ACC_W_XEN+0x60>

  value &= ~LSM303AGR_ACC_XEN_MASK;
 8013766:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801376a:	f023 0301 	bic.w	r3, r3, #1
 801376e:	b2db      	uxtb	r3, r3
 8013770:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013774:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013778:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801377c:	4313      	orrs	r3, r2
 801377e:	b2db      	uxtb	r3, r3
 8013780:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8013784:	f10d 030f 	add.w	r3, sp, #15
 8013788:	9801      	ldr	r0, [sp, #4]
 801378a:	2120      	movs	r1, #32
 801378c:	461a      	mov	r2, r3
 801378e:	2301      	movs	r3, #1
 8013790:	f7ff fb76 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013794:	4603      	mov	r3, r0
 8013796:	2b00      	cmp	r3, #0
 8013798:	d101      	bne.n	801379e <LSM303AGR_ACC_W_XEN+0x5e>
    return MEMS_ERROR;
 801379a:	2300      	movs	r3, #0
 801379c:	e000      	b.n	80137a0 <LSM303AGR_ACC_W_XEN+0x60>

  return MEMS_SUCCESS;
 801379e:	2301      	movs	r3, #1
}
 80137a0:	4618      	mov	r0, r3
 80137a2:	b005      	add	sp, #20
 80137a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80137a8:	f3af 8000 	nop.w
 80137ac:	f3af 8000 	nop.w

080137b0 <LSM303AGR_ACC_R_XEN>:
* Input          : Pointer to LSM303AGR_ACC_XEN_t
* Output         : Status of XEN see LSM303AGR_ACC_XEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XEN(void *handle, LSM303AGR_ACC_XEN_t *value)
{
 80137b0:	b500      	push	{lr}
 80137b2:	b083      	sub	sp, #12
 80137b4:	9001      	str	r0, [sp, #4]
 80137b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 80137b8:	9801      	ldr	r0, [sp, #4]
 80137ba:	2120      	movs	r1, #32
 80137bc:	9a00      	ldr	r2, [sp, #0]
 80137be:	2301      	movs	r3, #1
 80137c0:	f7ff fb86 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80137c4:	4603      	mov	r3, r0
 80137c6:	2b00      	cmp	r3, #0
 80137c8:	d101      	bne.n	80137ce <LSM303AGR_ACC_R_XEN+0x1e>
    return MEMS_ERROR;
 80137ca:	2300      	movs	r3, #0
 80137cc:	e007      	b.n	80137de <LSM303AGR_ACC_R_XEN+0x2e>

  *value &= LSM303AGR_ACC_XEN_MASK; //mask
 80137ce:	9b00      	ldr	r3, [sp, #0]
 80137d0:	781b      	ldrb	r3, [r3, #0]
 80137d2:	f003 0301 	and.w	r3, r3, #1
 80137d6:	b2da      	uxtb	r2, r3
 80137d8:	9b00      	ldr	r3, [sp, #0]
 80137da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80137dc:	2301      	movs	r3, #1
}
 80137de:	4618      	mov	r0, r3
 80137e0:	b003      	add	sp, #12
 80137e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80137e6:	bf00      	nop
 80137e8:	f3af 8000 	nop.w
 80137ec:	f3af 8000 	nop.w

080137f0 <LSM303AGR_ACC_W_YEN>:
* Input          : LSM303AGR_ACC_YEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YEN(void *handle, LSM303AGR_ACC_YEN_t newValue)
{
 80137f0:	b500      	push	{lr}
 80137f2:	b085      	sub	sp, #20
 80137f4:	9001      	str	r0, [sp, #4]
 80137f6:	460b      	mov	r3, r1
 80137f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 80137fc:	f10d 030f 	add.w	r3, sp, #15
 8013800:	9801      	ldr	r0, [sp, #4]
 8013802:	2120      	movs	r1, #32
 8013804:	461a      	mov	r2, r3
 8013806:	2301      	movs	r3, #1
 8013808:	f7ff fb62 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801380c:	4603      	mov	r3, r0
 801380e:	2b00      	cmp	r3, #0
 8013810:	d101      	bne.n	8013816 <LSM303AGR_ACC_W_YEN+0x26>
    return MEMS_ERROR;
 8013812:	2300      	movs	r3, #0
 8013814:	e01c      	b.n	8013850 <LSM303AGR_ACC_W_YEN+0x60>

  value &= ~LSM303AGR_ACC_YEN_MASK;
 8013816:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801381a:	f023 0302 	bic.w	r3, r3, #2
 801381e:	b2db      	uxtb	r3, r3
 8013820:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013824:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013828:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801382c:	4313      	orrs	r3, r2
 801382e:	b2db      	uxtb	r3, r3
 8013830:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8013834:	f10d 030f 	add.w	r3, sp, #15
 8013838:	9801      	ldr	r0, [sp, #4]
 801383a:	2120      	movs	r1, #32
 801383c:	461a      	mov	r2, r3
 801383e:	2301      	movs	r3, #1
 8013840:	f7ff fb1e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013844:	4603      	mov	r3, r0
 8013846:	2b00      	cmp	r3, #0
 8013848:	d101      	bne.n	801384e <LSM303AGR_ACC_W_YEN+0x5e>
    return MEMS_ERROR;
 801384a:	2300      	movs	r3, #0
 801384c:	e000      	b.n	8013850 <LSM303AGR_ACC_W_YEN+0x60>

  return MEMS_SUCCESS;
 801384e:	2301      	movs	r3, #1
}
 8013850:	4618      	mov	r0, r3
 8013852:	b005      	add	sp, #20
 8013854:	f85d fb04 	ldr.w	pc, [sp], #4
 8013858:	f3af 8000 	nop.w
 801385c:	f3af 8000 	nop.w

08013860 <LSM303AGR_ACC_R_YEN>:
* Input          : Pointer to LSM303AGR_ACC_YEN_t
* Output         : Status of YEN see LSM303AGR_ACC_YEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YEN(void *handle, LSM303AGR_ACC_YEN_t *value)
{
 8013860:	b500      	push	{lr}
 8013862:	b083      	sub	sp, #12
 8013864:	9001      	str	r0, [sp, #4]
 8013866:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8013868:	9801      	ldr	r0, [sp, #4]
 801386a:	2120      	movs	r1, #32
 801386c:	9a00      	ldr	r2, [sp, #0]
 801386e:	2301      	movs	r3, #1
 8013870:	f7ff fb2e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013874:	4603      	mov	r3, r0
 8013876:	2b00      	cmp	r3, #0
 8013878:	d101      	bne.n	801387e <LSM303AGR_ACC_R_YEN+0x1e>
    return MEMS_ERROR;
 801387a:	2300      	movs	r3, #0
 801387c:	e007      	b.n	801388e <LSM303AGR_ACC_R_YEN+0x2e>

  *value &= LSM303AGR_ACC_YEN_MASK; //mask
 801387e:	9b00      	ldr	r3, [sp, #0]
 8013880:	781b      	ldrb	r3, [r3, #0]
 8013882:	f003 0302 	and.w	r3, r3, #2
 8013886:	b2da      	uxtb	r2, r3
 8013888:	9b00      	ldr	r3, [sp, #0]
 801388a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801388c:	2301      	movs	r3, #1
}
 801388e:	4618      	mov	r0, r3
 8013890:	b003      	add	sp, #12
 8013892:	f85d fb04 	ldr.w	pc, [sp], #4
 8013896:	bf00      	nop
 8013898:	f3af 8000 	nop.w
 801389c:	f3af 8000 	nop.w

080138a0 <LSM303AGR_ACC_W_ZEN>:
* Input          : LSM303AGR_ACC_ZEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZEN(void *handle, LSM303AGR_ACC_ZEN_t newValue)
{
 80138a0:	b500      	push	{lr}
 80138a2:	b085      	sub	sp, #20
 80138a4:	9001      	str	r0, [sp, #4]
 80138a6:	460b      	mov	r3, r1
 80138a8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 80138ac:	f10d 030f 	add.w	r3, sp, #15
 80138b0:	9801      	ldr	r0, [sp, #4]
 80138b2:	2120      	movs	r1, #32
 80138b4:	461a      	mov	r2, r3
 80138b6:	2301      	movs	r3, #1
 80138b8:	f7ff fb0a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80138bc:	4603      	mov	r3, r0
 80138be:	2b00      	cmp	r3, #0
 80138c0:	d101      	bne.n	80138c6 <LSM303AGR_ACC_W_ZEN+0x26>
    return MEMS_ERROR;
 80138c2:	2300      	movs	r3, #0
 80138c4:	e01c      	b.n	8013900 <LSM303AGR_ACC_W_ZEN+0x60>

  value &= ~LSM303AGR_ACC_ZEN_MASK;
 80138c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80138ca:	f023 0304 	bic.w	r3, r3, #4
 80138ce:	b2db      	uxtb	r3, r3
 80138d0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80138d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80138d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80138dc:	4313      	orrs	r3, r2
 80138de:	b2db      	uxtb	r3, r3
 80138e0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 80138e4:	f10d 030f 	add.w	r3, sp, #15
 80138e8:	9801      	ldr	r0, [sp, #4]
 80138ea:	2120      	movs	r1, #32
 80138ec:	461a      	mov	r2, r3
 80138ee:	2301      	movs	r3, #1
 80138f0:	f7ff fac6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80138f4:	4603      	mov	r3, r0
 80138f6:	2b00      	cmp	r3, #0
 80138f8:	d101      	bne.n	80138fe <LSM303AGR_ACC_W_ZEN+0x5e>
    return MEMS_ERROR;
 80138fa:	2300      	movs	r3, #0
 80138fc:	e000      	b.n	8013900 <LSM303AGR_ACC_W_ZEN+0x60>

  return MEMS_SUCCESS;
 80138fe:	2301      	movs	r3, #1
}
 8013900:	4618      	mov	r0, r3
 8013902:	b005      	add	sp, #20
 8013904:	f85d fb04 	ldr.w	pc, [sp], #4
 8013908:	f3af 8000 	nop.w
 801390c:	f3af 8000 	nop.w

08013910 <LSM303AGR_ACC_R_ZEN>:
* Input          : Pointer to LSM303AGR_ACC_ZEN_t
* Output         : Status of ZEN see LSM303AGR_ACC_ZEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZEN(void *handle, LSM303AGR_ACC_ZEN_t *value)
{
 8013910:	b500      	push	{lr}
 8013912:	b083      	sub	sp, #12
 8013914:	9001      	str	r0, [sp, #4]
 8013916:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8013918:	9801      	ldr	r0, [sp, #4]
 801391a:	2120      	movs	r1, #32
 801391c:	9a00      	ldr	r2, [sp, #0]
 801391e:	2301      	movs	r3, #1
 8013920:	f7ff fad6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013924:	4603      	mov	r3, r0
 8013926:	2b00      	cmp	r3, #0
 8013928:	d101      	bne.n	801392e <LSM303AGR_ACC_R_ZEN+0x1e>
    return MEMS_ERROR;
 801392a:	2300      	movs	r3, #0
 801392c:	e007      	b.n	801393e <LSM303AGR_ACC_R_ZEN+0x2e>

  *value &= LSM303AGR_ACC_ZEN_MASK; //mask
 801392e:	9b00      	ldr	r3, [sp, #0]
 8013930:	781b      	ldrb	r3, [r3, #0]
 8013932:	f003 0304 	and.w	r3, r3, #4
 8013936:	b2da      	uxtb	r2, r3
 8013938:	9b00      	ldr	r3, [sp, #0]
 801393a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801393c:	2301      	movs	r3, #1
}
 801393e:	4618      	mov	r0, r3
 8013940:	b003      	add	sp, #12
 8013942:	f85d fb04 	ldr.w	pc, [sp], #4
 8013946:	bf00      	nop
 8013948:	f3af 8000 	nop.w
 801394c:	f3af 8000 	nop.w

08013950 <LSM303AGR_ACC_W_LOWPWR_EN>:
* Input          : LSM303AGR_ACC_LPEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LOWPWR_EN(void *handle, LSM303AGR_ACC_LPEN_t newValue)
{
 8013950:	b500      	push	{lr}
 8013952:	b085      	sub	sp, #20
 8013954:	9001      	str	r0, [sp, #4]
 8013956:	460b      	mov	r3, r1
 8013958:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 801395c:	f10d 030f 	add.w	r3, sp, #15
 8013960:	9801      	ldr	r0, [sp, #4]
 8013962:	2120      	movs	r1, #32
 8013964:	461a      	mov	r2, r3
 8013966:	2301      	movs	r3, #1
 8013968:	f7ff fab2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801396c:	4603      	mov	r3, r0
 801396e:	2b00      	cmp	r3, #0
 8013970:	d101      	bne.n	8013976 <LSM303AGR_ACC_W_LOWPWR_EN+0x26>
    return MEMS_ERROR;
 8013972:	2300      	movs	r3, #0
 8013974:	e01c      	b.n	80139b0 <LSM303AGR_ACC_W_LOWPWR_EN+0x60>

  value &= ~LSM303AGR_ACC_LPEN_MASK;
 8013976:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801397a:	f023 0308 	bic.w	r3, r3, #8
 801397e:	b2db      	uxtb	r3, r3
 8013980:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013984:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013988:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801398c:	4313      	orrs	r3, r2
 801398e:	b2db      	uxtb	r3, r3
 8013990:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8013994:	f10d 030f 	add.w	r3, sp, #15
 8013998:	9801      	ldr	r0, [sp, #4]
 801399a:	2120      	movs	r1, #32
 801399c:	461a      	mov	r2, r3
 801399e:	2301      	movs	r3, #1
 80139a0:	f7ff fa6e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80139a4:	4603      	mov	r3, r0
 80139a6:	2b00      	cmp	r3, #0
 80139a8:	d101      	bne.n	80139ae <LSM303AGR_ACC_W_LOWPWR_EN+0x5e>
    return MEMS_ERROR;
 80139aa:	2300      	movs	r3, #0
 80139ac:	e000      	b.n	80139b0 <LSM303AGR_ACC_W_LOWPWR_EN+0x60>

  return MEMS_SUCCESS;
 80139ae:	2301      	movs	r3, #1
}
 80139b0:	4618      	mov	r0, r3
 80139b2:	b005      	add	sp, #20
 80139b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80139b8:	f3af 8000 	nop.w
 80139bc:	f3af 8000 	nop.w

080139c0 <LSM303AGR_ACC_R_LOWPWR_EN>:
* Input          : Pointer to LSM303AGR_ACC_LPEN_t
* Output         : Status of LPEN see LSM303AGR_ACC_LPEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LOWPWR_EN(void *handle, LSM303AGR_ACC_LPEN_t *value)
{
 80139c0:	b500      	push	{lr}
 80139c2:	b083      	sub	sp, #12
 80139c4:	9001      	str	r0, [sp, #4]
 80139c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 80139c8:	9801      	ldr	r0, [sp, #4]
 80139ca:	2120      	movs	r1, #32
 80139cc:	9a00      	ldr	r2, [sp, #0]
 80139ce:	2301      	movs	r3, #1
 80139d0:	f7ff fa7e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80139d4:	4603      	mov	r3, r0
 80139d6:	2b00      	cmp	r3, #0
 80139d8:	d101      	bne.n	80139de <LSM303AGR_ACC_R_LOWPWR_EN+0x1e>
    return MEMS_ERROR;
 80139da:	2300      	movs	r3, #0
 80139dc:	e007      	b.n	80139ee <LSM303AGR_ACC_R_LOWPWR_EN+0x2e>

  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 80139de:	9b00      	ldr	r3, [sp, #0]
 80139e0:	781b      	ldrb	r3, [r3, #0]
 80139e2:	f003 0308 	and.w	r3, r3, #8
 80139e6:	b2da      	uxtb	r2, r3
 80139e8:	9b00      	ldr	r3, [sp, #0]
 80139ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80139ec:	2301      	movs	r3, #1
}
 80139ee:	4618      	mov	r0, r3
 80139f0:	b003      	add	sp, #12
 80139f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80139f6:	bf00      	nop
 80139f8:	f3af 8000 	nop.w
 80139fc:	f3af 8000 	nop.w

08013a00 <LSM303AGR_ACC_W_hpf_aoi_en_int1>:
* Input          : LSM303AGR_ACC_HPIS1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_aoi_en_int1(void *handle, LSM303AGR_ACC_HPIS1_t newValue)
{
 8013a00:	b500      	push	{lr}
 8013a02:	b085      	sub	sp, #20
 8013a04:	9001      	str	r0, [sp, #4]
 8013a06:	460b      	mov	r3, r1
 8013a08:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013a0c:	f10d 030f 	add.w	r3, sp, #15
 8013a10:	9801      	ldr	r0, [sp, #4]
 8013a12:	2121      	movs	r1, #33	; 0x21
 8013a14:	461a      	mov	r2, r3
 8013a16:	2301      	movs	r3, #1
 8013a18:	f7ff fa5a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013a1c:	4603      	mov	r3, r0
 8013a1e:	2b00      	cmp	r3, #0
 8013a20:	d101      	bne.n	8013a26 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x26>
    return MEMS_ERROR;
 8013a22:	2300      	movs	r3, #0
 8013a24:	e01c      	b.n	8013a60 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x60>

  value &= ~LSM303AGR_ACC_HPIS1_MASK;
 8013a26:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013a2a:	f023 0301 	bic.w	r3, r3, #1
 8013a2e:	b2db      	uxtb	r3, r3
 8013a30:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013a34:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013a38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013a3c:	4313      	orrs	r3, r2
 8013a3e:	b2db      	uxtb	r3, r3
 8013a40:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013a44:	f10d 030f 	add.w	r3, sp, #15
 8013a48:	9801      	ldr	r0, [sp, #4]
 8013a4a:	2121      	movs	r1, #33	; 0x21
 8013a4c:	461a      	mov	r2, r3
 8013a4e:	2301      	movs	r3, #1
 8013a50:	f7ff fa16 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013a54:	4603      	mov	r3, r0
 8013a56:	2b00      	cmp	r3, #0
 8013a58:	d101      	bne.n	8013a5e <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x5e>
    return MEMS_ERROR;
 8013a5a:	2300      	movs	r3, #0
 8013a5c:	e000      	b.n	8013a60 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x60>

  return MEMS_SUCCESS;
 8013a5e:	2301      	movs	r3, #1
}
 8013a60:	4618      	mov	r0, r3
 8013a62:	b005      	add	sp, #20
 8013a64:	f85d fb04 	ldr.w	pc, [sp], #4
 8013a68:	f3af 8000 	nop.w
 8013a6c:	f3af 8000 	nop.w

08013a70 <LSM303AGR_ACC_R_hpf_aoi_en_int1>:
* Input          : Pointer to LSM303AGR_ACC_HPIS1_t
* Output         : Status of HPIS1 see LSM303AGR_ACC_HPIS1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_aoi_en_int1(void *handle, LSM303AGR_ACC_HPIS1_t *value)
{
 8013a70:	b500      	push	{lr}
 8013a72:	b083      	sub	sp, #12
 8013a74:	9001      	str	r0, [sp, #4]
 8013a76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8013a78:	9801      	ldr	r0, [sp, #4]
 8013a7a:	2121      	movs	r1, #33	; 0x21
 8013a7c:	9a00      	ldr	r2, [sp, #0]
 8013a7e:	2301      	movs	r3, #1
 8013a80:	f7ff fa26 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013a84:	4603      	mov	r3, r0
 8013a86:	2b00      	cmp	r3, #0
 8013a88:	d101      	bne.n	8013a8e <LSM303AGR_ACC_R_hpf_aoi_en_int1+0x1e>
    return MEMS_ERROR;
 8013a8a:	2300      	movs	r3, #0
 8013a8c:	e007      	b.n	8013a9e <LSM303AGR_ACC_R_hpf_aoi_en_int1+0x2e>

  *value &= LSM303AGR_ACC_HPIS1_MASK; //mask
 8013a8e:	9b00      	ldr	r3, [sp, #0]
 8013a90:	781b      	ldrb	r3, [r3, #0]
 8013a92:	f003 0301 	and.w	r3, r3, #1
 8013a96:	b2da      	uxtb	r2, r3
 8013a98:	9b00      	ldr	r3, [sp, #0]
 8013a9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013a9c:	2301      	movs	r3, #1
}
 8013a9e:	4618      	mov	r0, r3
 8013aa0:	b003      	add	sp, #12
 8013aa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013aa6:	bf00      	nop
 8013aa8:	f3af 8000 	nop.w
 8013aac:	f3af 8000 	nop.w

08013ab0 <LSM303AGR_ACC_W_hpf_aoi_en_int2>:
* Input          : LSM303AGR_ACC_HPIS2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_aoi_en_int2(void *handle, LSM303AGR_ACC_HPIS2_t newValue)
{
 8013ab0:	b500      	push	{lr}
 8013ab2:	b085      	sub	sp, #20
 8013ab4:	9001      	str	r0, [sp, #4]
 8013ab6:	460b      	mov	r3, r1
 8013ab8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013abc:	f10d 030f 	add.w	r3, sp, #15
 8013ac0:	9801      	ldr	r0, [sp, #4]
 8013ac2:	2121      	movs	r1, #33	; 0x21
 8013ac4:	461a      	mov	r2, r3
 8013ac6:	2301      	movs	r3, #1
 8013ac8:	f7ff fa02 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013acc:	4603      	mov	r3, r0
 8013ace:	2b00      	cmp	r3, #0
 8013ad0:	d101      	bne.n	8013ad6 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x26>
    return MEMS_ERROR;
 8013ad2:	2300      	movs	r3, #0
 8013ad4:	e01c      	b.n	8013b10 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x60>

  value &= ~LSM303AGR_ACC_HPIS2_MASK;
 8013ad6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013ada:	f023 0302 	bic.w	r3, r3, #2
 8013ade:	b2db      	uxtb	r3, r3
 8013ae0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013ae4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013ae8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013aec:	4313      	orrs	r3, r2
 8013aee:	b2db      	uxtb	r3, r3
 8013af0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013af4:	f10d 030f 	add.w	r3, sp, #15
 8013af8:	9801      	ldr	r0, [sp, #4]
 8013afa:	2121      	movs	r1, #33	; 0x21
 8013afc:	461a      	mov	r2, r3
 8013afe:	2301      	movs	r3, #1
 8013b00:	f7ff f9be 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013b04:	4603      	mov	r3, r0
 8013b06:	2b00      	cmp	r3, #0
 8013b08:	d101      	bne.n	8013b0e <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x5e>
    return MEMS_ERROR;
 8013b0a:	2300      	movs	r3, #0
 8013b0c:	e000      	b.n	8013b10 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x60>

  return MEMS_SUCCESS;
 8013b0e:	2301      	movs	r3, #1
}
 8013b10:	4618      	mov	r0, r3
 8013b12:	b005      	add	sp, #20
 8013b14:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b18:	f3af 8000 	nop.w
 8013b1c:	f3af 8000 	nop.w

08013b20 <LSM303AGR_ACC_R_hpf_aoi_en_int2>:
* Input          : Pointer to LSM303AGR_ACC_HPIS2_t
* Output         : Status of HPIS2 see LSM303AGR_ACC_HPIS2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_aoi_en_int2(void *handle, LSM303AGR_ACC_HPIS2_t *value)
{
 8013b20:	b500      	push	{lr}
 8013b22:	b083      	sub	sp, #12
 8013b24:	9001      	str	r0, [sp, #4]
 8013b26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8013b28:	9801      	ldr	r0, [sp, #4]
 8013b2a:	2121      	movs	r1, #33	; 0x21
 8013b2c:	9a00      	ldr	r2, [sp, #0]
 8013b2e:	2301      	movs	r3, #1
 8013b30:	f7ff f9ce 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013b34:	4603      	mov	r3, r0
 8013b36:	2b00      	cmp	r3, #0
 8013b38:	d101      	bne.n	8013b3e <LSM303AGR_ACC_R_hpf_aoi_en_int2+0x1e>
    return MEMS_ERROR;
 8013b3a:	2300      	movs	r3, #0
 8013b3c:	e007      	b.n	8013b4e <LSM303AGR_ACC_R_hpf_aoi_en_int2+0x2e>

  *value &= LSM303AGR_ACC_HPIS2_MASK; //mask
 8013b3e:	9b00      	ldr	r3, [sp, #0]
 8013b40:	781b      	ldrb	r3, [r3, #0]
 8013b42:	f003 0302 	and.w	r3, r3, #2
 8013b46:	b2da      	uxtb	r2, r3
 8013b48:	9b00      	ldr	r3, [sp, #0]
 8013b4a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013b4c:	2301      	movs	r3, #1
}
 8013b4e:	4618      	mov	r0, r3
 8013b50:	b003      	add	sp, #12
 8013b52:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b56:	bf00      	nop
 8013b58:	f3af 8000 	nop.w
 8013b5c:	f3af 8000 	nop.w

08013b60 <LSM303AGR_ACC_W_hpf_click_en>:
* Input          : LSM303AGR_ACC_HPCLICK_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_click_en(void *handle, LSM303AGR_ACC_HPCLICK_t newValue)
{
 8013b60:	b500      	push	{lr}
 8013b62:	b085      	sub	sp, #20
 8013b64:	9001      	str	r0, [sp, #4]
 8013b66:	460b      	mov	r3, r1
 8013b68:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013b6c:	f10d 030f 	add.w	r3, sp, #15
 8013b70:	9801      	ldr	r0, [sp, #4]
 8013b72:	2121      	movs	r1, #33	; 0x21
 8013b74:	461a      	mov	r2, r3
 8013b76:	2301      	movs	r3, #1
 8013b78:	f7ff f9aa 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013b7c:	4603      	mov	r3, r0
 8013b7e:	2b00      	cmp	r3, #0
 8013b80:	d101      	bne.n	8013b86 <LSM303AGR_ACC_W_hpf_click_en+0x26>
    return MEMS_ERROR;
 8013b82:	2300      	movs	r3, #0
 8013b84:	e01c      	b.n	8013bc0 <LSM303AGR_ACC_W_hpf_click_en+0x60>

  value &= ~LSM303AGR_ACC_HPCLICK_MASK;
 8013b86:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013b8a:	f023 0304 	bic.w	r3, r3, #4
 8013b8e:	b2db      	uxtb	r3, r3
 8013b90:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013b94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013b98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013b9c:	4313      	orrs	r3, r2
 8013b9e:	b2db      	uxtb	r3, r3
 8013ba0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013ba4:	f10d 030f 	add.w	r3, sp, #15
 8013ba8:	9801      	ldr	r0, [sp, #4]
 8013baa:	2121      	movs	r1, #33	; 0x21
 8013bac:	461a      	mov	r2, r3
 8013bae:	2301      	movs	r3, #1
 8013bb0:	f7ff f966 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013bb4:	4603      	mov	r3, r0
 8013bb6:	2b00      	cmp	r3, #0
 8013bb8:	d101      	bne.n	8013bbe <LSM303AGR_ACC_W_hpf_click_en+0x5e>
    return MEMS_ERROR;
 8013bba:	2300      	movs	r3, #0
 8013bbc:	e000      	b.n	8013bc0 <LSM303AGR_ACC_W_hpf_click_en+0x60>

  return MEMS_SUCCESS;
 8013bbe:	2301      	movs	r3, #1
}
 8013bc0:	4618      	mov	r0, r3
 8013bc2:	b005      	add	sp, #20
 8013bc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013bc8:	f3af 8000 	nop.w
 8013bcc:	f3af 8000 	nop.w

08013bd0 <LSM303AGR_ACC_R_hpf_click_en>:
* Input          : Pointer to LSM303AGR_ACC_HPCLICK_t
* Output         : Status of HPCLICK see LSM303AGR_ACC_HPCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_click_en(void *handle, LSM303AGR_ACC_HPCLICK_t *value)
{
 8013bd0:	b500      	push	{lr}
 8013bd2:	b083      	sub	sp, #12
 8013bd4:	9001      	str	r0, [sp, #4]
 8013bd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8013bd8:	9801      	ldr	r0, [sp, #4]
 8013bda:	2121      	movs	r1, #33	; 0x21
 8013bdc:	9a00      	ldr	r2, [sp, #0]
 8013bde:	2301      	movs	r3, #1
 8013be0:	f7ff f976 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013be4:	4603      	mov	r3, r0
 8013be6:	2b00      	cmp	r3, #0
 8013be8:	d101      	bne.n	8013bee <LSM303AGR_ACC_R_hpf_click_en+0x1e>
    return MEMS_ERROR;
 8013bea:	2300      	movs	r3, #0
 8013bec:	e007      	b.n	8013bfe <LSM303AGR_ACC_R_hpf_click_en+0x2e>

  *value &= LSM303AGR_ACC_HPCLICK_MASK; //mask
 8013bee:	9b00      	ldr	r3, [sp, #0]
 8013bf0:	781b      	ldrb	r3, [r3, #0]
 8013bf2:	f003 0304 	and.w	r3, r3, #4
 8013bf6:	b2da      	uxtb	r2, r3
 8013bf8:	9b00      	ldr	r3, [sp, #0]
 8013bfa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013bfc:	2301      	movs	r3, #1
}
 8013bfe:	4618      	mov	r0, r3
 8013c00:	b003      	add	sp, #12
 8013c02:	f85d fb04 	ldr.w	pc, [sp], #4
 8013c06:	bf00      	nop
 8013c08:	f3af 8000 	nop.w
 8013c0c:	f3af 8000 	nop.w

08013c10 <LSM303AGR_ACC_W_Data_Filter>:
* Input          : LSM303AGR_ACC_FDS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Data_Filter(void *handle, LSM303AGR_ACC_FDS_t newValue)
{
 8013c10:	b500      	push	{lr}
 8013c12:	b085      	sub	sp, #20
 8013c14:	9001      	str	r0, [sp, #4]
 8013c16:	460b      	mov	r3, r1
 8013c18:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013c1c:	f10d 030f 	add.w	r3, sp, #15
 8013c20:	9801      	ldr	r0, [sp, #4]
 8013c22:	2121      	movs	r1, #33	; 0x21
 8013c24:	461a      	mov	r2, r3
 8013c26:	2301      	movs	r3, #1
 8013c28:	f7ff f952 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013c2c:	4603      	mov	r3, r0
 8013c2e:	2b00      	cmp	r3, #0
 8013c30:	d101      	bne.n	8013c36 <LSM303AGR_ACC_W_Data_Filter+0x26>
    return MEMS_ERROR;
 8013c32:	2300      	movs	r3, #0
 8013c34:	e01c      	b.n	8013c70 <LSM303AGR_ACC_W_Data_Filter+0x60>

  value &= ~LSM303AGR_ACC_FDS_MASK;
 8013c36:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013c3a:	f023 0308 	bic.w	r3, r3, #8
 8013c3e:	b2db      	uxtb	r3, r3
 8013c40:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013c44:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013c48:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013c4c:	4313      	orrs	r3, r2
 8013c4e:	b2db      	uxtb	r3, r3
 8013c50:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013c54:	f10d 030f 	add.w	r3, sp, #15
 8013c58:	9801      	ldr	r0, [sp, #4]
 8013c5a:	2121      	movs	r1, #33	; 0x21
 8013c5c:	461a      	mov	r2, r3
 8013c5e:	2301      	movs	r3, #1
 8013c60:	f7ff f90e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013c64:	4603      	mov	r3, r0
 8013c66:	2b00      	cmp	r3, #0
 8013c68:	d101      	bne.n	8013c6e <LSM303AGR_ACC_W_Data_Filter+0x5e>
    return MEMS_ERROR;
 8013c6a:	2300      	movs	r3, #0
 8013c6c:	e000      	b.n	8013c70 <LSM303AGR_ACC_W_Data_Filter+0x60>

  return MEMS_SUCCESS;
 8013c6e:	2301      	movs	r3, #1
}
 8013c70:	4618      	mov	r0, r3
 8013c72:	b005      	add	sp, #20
 8013c74:	f85d fb04 	ldr.w	pc, [sp], #4
 8013c78:	f3af 8000 	nop.w
 8013c7c:	f3af 8000 	nop.w

08013c80 <LSM303AGR_ACC_R_Data_Filter>:
* Input          : Pointer to LSM303AGR_ACC_FDS_t
* Output         : Status of FDS see LSM303AGR_ACC_FDS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Data_Filter(void *handle, LSM303AGR_ACC_FDS_t *value)
{
 8013c80:	b500      	push	{lr}
 8013c82:	b083      	sub	sp, #12
 8013c84:	9001      	str	r0, [sp, #4]
 8013c86:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8013c88:	9801      	ldr	r0, [sp, #4]
 8013c8a:	2121      	movs	r1, #33	; 0x21
 8013c8c:	9a00      	ldr	r2, [sp, #0]
 8013c8e:	2301      	movs	r3, #1
 8013c90:	f7ff f91e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013c94:	4603      	mov	r3, r0
 8013c96:	2b00      	cmp	r3, #0
 8013c98:	d101      	bne.n	8013c9e <LSM303AGR_ACC_R_Data_Filter+0x1e>
    return MEMS_ERROR;
 8013c9a:	2300      	movs	r3, #0
 8013c9c:	e007      	b.n	8013cae <LSM303AGR_ACC_R_Data_Filter+0x2e>

  *value &= LSM303AGR_ACC_FDS_MASK; //mask
 8013c9e:	9b00      	ldr	r3, [sp, #0]
 8013ca0:	781b      	ldrb	r3, [r3, #0]
 8013ca2:	f003 0308 	and.w	r3, r3, #8
 8013ca6:	b2da      	uxtb	r2, r3
 8013ca8:	9b00      	ldr	r3, [sp, #0]
 8013caa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013cac:	2301      	movs	r3, #1
}
 8013cae:	4618      	mov	r0, r3
 8013cb0:	b003      	add	sp, #12
 8013cb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013cb6:	bf00      	nop
 8013cb8:	f3af 8000 	nop.w
 8013cbc:	f3af 8000 	nop.w

08013cc0 <LSM303AGR_ACC_W_hpf_cutoff_freq>:
* Input          : LSM303AGR_ACC_HPCF_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_cutoff_freq(void *handle, LSM303AGR_ACC_HPCF_t newValue)
{
 8013cc0:	b500      	push	{lr}
 8013cc2:	b085      	sub	sp, #20
 8013cc4:	9001      	str	r0, [sp, #4]
 8013cc6:	460b      	mov	r3, r1
 8013cc8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013ccc:	f10d 030f 	add.w	r3, sp, #15
 8013cd0:	9801      	ldr	r0, [sp, #4]
 8013cd2:	2121      	movs	r1, #33	; 0x21
 8013cd4:	461a      	mov	r2, r3
 8013cd6:	2301      	movs	r3, #1
 8013cd8:	f7ff f8fa 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013cdc:	4603      	mov	r3, r0
 8013cde:	2b00      	cmp	r3, #0
 8013ce0:	d101      	bne.n	8013ce6 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x26>
    return MEMS_ERROR;
 8013ce2:	2300      	movs	r3, #0
 8013ce4:	e01c      	b.n	8013d20 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x60>

  value &= ~LSM303AGR_ACC_HPCF_MASK;
 8013ce6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013cea:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8013cee:	b2db      	uxtb	r3, r3
 8013cf0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013cf4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013cf8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013cfc:	4313      	orrs	r3, r2
 8013cfe:	b2db      	uxtb	r3, r3
 8013d00:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013d04:	f10d 030f 	add.w	r3, sp, #15
 8013d08:	9801      	ldr	r0, [sp, #4]
 8013d0a:	2121      	movs	r1, #33	; 0x21
 8013d0c:	461a      	mov	r2, r3
 8013d0e:	2301      	movs	r3, #1
 8013d10:	f7ff f8b6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013d14:	4603      	mov	r3, r0
 8013d16:	2b00      	cmp	r3, #0
 8013d18:	d101      	bne.n	8013d1e <LSM303AGR_ACC_W_hpf_cutoff_freq+0x5e>
    return MEMS_ERROR;
 8013d1a:	2300      	movs	r3, #0
 8013d1c:	e000      	b.n	8013d20 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x60>

  return MEMS_SUCCESS;
 8013d1e:	2301      	movs	r3, #1
}
 8013d20:	4618      	mov	r0, r3
 8013d22:	b005      	add	sp, #20
 8013d24:	f85d fb04 	ldr.w	pc, [sp], #4
 8013d28:	f3af 8000 	nop.w
 8013d2c:	f3af 8000 	nop.w

08013d30 <LSM303AGR_ACC_R_hpf_cutoff_freq>:
* Input          : Pointer to LSM303AGR_ACC_HPCF_t
* Output         : Status of HPCF see LSM303AGR_ACC_HPCF_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_cutoff_freq(void *handle, LSM303AGR_ACC_HPCF_t *value)
{
 8013d30:	b500      	push	{lr}
 8013d32:	b083      	sub	sp, #12
 8013d34:	9001      	str	r0, [sp, #4]
 8013d36:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8013d38:	9801      	ldr	r0, [sp, #4]
 8013d3a:	2121      	movs	r1, #33	; 0x21
 8013d3c:	9a00      	ldr	r2, [sp, #0]
 8013d3e:	2301      	movs	r3, #1
 8013d40:	f7ff f8c6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013d44:	4603      	mov	r3, r0
 8013d46:	2b00      	cmp	r3, #0
 8013d48:	d101      	bne.n	8013d4e <LSM303AGR_ACC_R_hpf_cutoff_freq+0x1e>
    return MEMS_ERROR;
 8013d4a:	2300      	movs	r3, #0
 8013d4c:	e007      	b.n	8013d5e <LSM303AGR_ACC_R_hpf_cutoff_freq+0x2e>

  *value &= LSM303AGR_ACC_HPCF_MASK; //mask
 8013d4e:	9b00      	ldr	r3, [sp, #0]
 8013d50:	781b      	ldrb	r3, [r3, #0]
 8013d52:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8013d56:	b2da      	uxtb	r2, r3
 8013d58:	9b00      	ldr	r3, [sp, #0]
 8013d5a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013d5c:	2301      	movs	r3, #1
}
 8013d5e:	4618      	mov	r0, r3
 8013d60:	b003      	add	sp, #12
 8013d62:	f85d fb04 	ldr.w	pc, [sp], #4
 8013d66:	bf00      	nop
 8013d68:	f3af 8000 	nop.w
 8013d6c:	f3af 8000 	nop.w

08013d70 <LSM303AGR_ACC_W_hpf_mode>:
* Input          : LSM303AGR_ACC_HPM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_mode(void *handle, LSM303AGR_ACC_HPM_t newValue)
{
 8013d70:	b500      	push	{lr}
 8013d72:	b085      	sub	sp, #20
 8013d74:	9001      	str	r0, [sp, #4]
 8013d76:	460b      	mov	r3, r1
 8013d78:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013d7c:	f10d 030f 	add.w	r3, sp, #15
 8013d80:	9801      	ldr	r0, [sp, #4]
 8013d82:	2121      	movs	r1, #33	; 0x21
 8013d84:	461a      	mov	r2, r3
 8013d86:	2301      	movs	r3, #1
 8013d88:	f7ff f8a2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013d8c:	4603      	mov	r3, r0
 8013d8e:	2b00      	cmp	r3, #0
 8013d90:	d101      	bne.n	8013d96 <LSM303AGR_ACC_W_hpf_mode+0x26>
    return MEMS_ERROR;
 8013d92:	2300      	movs	r3, #0
 8013d94:	e01c      	b.n	8013dd0 <LSM303AGR_ACC_W_hpf_mode+0x60>

  value &= ~LSM303AGR_ACC_HPM_MASK;
 8013d96:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013d9a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8013d9e:	b2db      	uxtb	r3, r3
 8013da0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013da4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013da8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013dac:	4313      	orrs	r3, r2
 8013dae:	b2db      	uxtb	r3, r3
 8013db0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013db4:	f10d 030f 	add.w	r3, sp, #15
 8013db8:	9801      	ldr	r0, [sp, #4]
 8013dba:	2121      	movs	r1, #33	; 0x21
 8013dbc:	461a      	mov	r2, r3
 8013dbe:	2301      	movs	r3, #1
 8013dc0:	f7ff f85e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013dc4:	4603      	mov	r3, r0
 8013dc6:	2b00      	cmp	r3, #0
 8013dc8:	d101      	bne.n	8013dce <LSM303AGR_ACC_W_hpf_mode+0x5e>
    return MEMS_ERROR;
 8013dca:	2300      	movs	r3, #0
 8013dcc:	e000      	b.n	8013dd0 <LSM303AGR_ACC_W_hpf_mode+0x60>

  return MEMS_SUCCESS;
 8013dce:	2301      	movs	r3, #1
}
 8013dd0:	4618      	mov	r0, r3
 8013dd2:	b005      	add	sp, #20
 8013dd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013dd8:	f3af 8000 	nop.w
 8013ddc:	f3af 8000 	nop.w

08013de0 <LSM303AGR_ACC_R_hpf_mode>:
* Input          : Pointer to LSM303AGR_ACC_HPM_t
* Output         : Status of HPM see LSM303AGR_ACC_HPM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_mode(void *handle, LSM303AGR_ACC_HPM_t *value)
{
 8013de0:	b500      	push	{lr}
 8013de2:	b083      	sub	sp, #12
 8013de4:	9001      	str	r0, [sp, #4]
 8013de6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8013de8:	9801      	ldr	r0, [sp, #4]
 8013dea:	2121      	movs	r1, #33	; 0x21
 8013dec:	9a00      	ldr	r2, [sp, #0]
 8013dee:	2301      	movs	r3, #1
 8013df0:	f7ff f86e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013df4:	4603      	mov	r3, r0
 8013df6:	2b00      	cmp	r3, #0
 8013df8:	d101      	bne.n	8013dfe <LSM303AGR_ACC_R_hpf_mode+0x1e>
    return MEMS_ERROR;
 8013dfa:	2300      	movs	r3, #0
 8013dfc:	e007      	b.n	8013e0e <LSM303AGR_ACC_R_hpf_mode+0x2e>

  *value &= LSM303AGR_ACC_HPM_MASK; //mask
 8013dfe:	9b00      	ldr	r3, [sp, #0]
 8013e00:	781b      	ldrb	r3, [r3, #0]
 8013e02:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8013e06:	b2da      	uxtb	r2, r3
 8013e08:	9b00      	ldr	r3, [sp, #0]
 8013e0a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013e0c:	2301      	movs	r3, #1
}
 8013e0e:	4618      	mov	r0, r3
 8013e10:	b003      	add	sp, #12
 8013e12:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e16:	bf00      	nop
 8013e18:	f3af 8000 	nop.w
 8013e1c:	f3af 8000 	nop.w

08013e20 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1>:
* Input          : LSM303AGR_ACC_I1_OVERRUN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Overrun_on_INT1(void *handle, LSM303AGR_ACC_I1_OVERRUN_t newValue)
{
 8013e20:	b500      	push	{lr}
 8013e22:	b085      	sub	sp, #20
 8013e24:	9001      	str	r0, [sp, #4]
 8013e26:	460b      	mov	r3, r1
 8013e28:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013e2c:	f10d 030f 	add.w	r3, sp, #15
 8013e30:	9801      	ldr	r0, [sp, #4]
 8013e32:	2122      	movs	r1, #34	; 0x22
 8013e34:	461a      	mov	r2, r3
 8013e36:	2301      	movs	r3, #1
 8013e38:	f7ff f84a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013e3c:	4603      	mov	r3, r0
 8013e3e:	2b00      	cmp	r3, #0
 8013e40:	d101      	bne.n	8013e46 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x26>
    return MEMS_ERROR;
 8013e42:	2300      	movs	r3, #0
 8013e44:	e01c      	b.n	8013e80 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_OVERRUN_MASK;
 8013e46:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013e4a:	f023 0302 	bic.w	r3, r3, #2
 8013e4e:	b2db      	uxtb	r3, r3
 8013e50:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013e54:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013e58:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013e5c:	4313      	orrs	r3, r2
 8013e5e:	b2db      	uxtb	r3, r3
 8013e60:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013e64:	f10d 030f 	add.w	r3, sp, #15
 8013e68:	9801      	ldr	r0, [sp, #4]
 8013e6a:	2122      	movs	r1, #34	; 0x22
 8013e6c:	461a      	mov	r2, r3
 8013e6e:	2301      	movs	r3, #1
 8013e70:	f7ff f806 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013e74:	4603      	mov	r3, r0
 8013e76:	2b00      	cmp	r3, #0
 8013e78:	d101      	bne.n	8013e7e <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x5e>
    return MEMS_ERROR;
 8013e7a:	2300      	movs	r3, #0
 8013e7c:	e000      	b.n	8013e80 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x60>

  return MEMS_SUCCESS;
 8013e7e:	2301      	movs	r3, #1
}
 8013e80:	4618      	mov	r0, r3
 8013e82:	b005      	add	sp, #20
 8013e84:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e88:	f3af 8000 	nop.w
 8013e8c:	f3af 8000 	nop.w

08013e90 <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_OVERRUN_t
* Output         : Status of I1_OVERRUN see LSM303AGR_ACC_I1_OVERRUN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Overrun_on_INT1(void *handle, LSM303AGR_ACC_I1_OVERRUN_t *value)
{
 8013e90:	b500      	push	{lr}
 8013e92:	b083      	sub	sp, #12
 8013e94:	9001      	str	r0, [sp, #4]
 8013e96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8013e98:	9801      	ldr	r0, [sp, #4]
 8013e9a:	2122      	movs	r1, #34	; 0x22
 8013e9c:	9a00      	ldr	r2, [sp, #0]
 8013e9e:	2301      	movs	r3, #1
 8013ea0:	f7ff f816 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013ea4:	4603      	mov	r3, r0
 8013ea6:	2b00      	cmp	r3, #0
 8013ea8:	d101      	bne.n	8013eae <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1+0x1e>
    return MEMS_ERROR;
 8013eaa:	2300      	movs	r3, #0
 8013eac:	e007      	b.n	8013ebe <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_OVERRUN_MASK; //mask
 8013eae:	9b00      	ldr	r3, [sp, #0]
 8013eb0:	781b      	ldrb	r3, [r3, #0]
 8013eb2:	f003 0302 	and.w	r3, r3, #2
 8013eb6:	b2da      	uxtb	r2, r3
 8013eb8:	9b00      	ldr	r3, [sp, #0]
 8013eba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013ebc:	2301      	movs	r3, #1
}
 8013ebe:	4618      	mov	r0, r3
 8013ec0:	b003      	add	sp, #12
 8013ec2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013ec6:	bf00      	nop
 8013ec8:	f3af 8000 	nop.w
 8013ecc:	f3af 8000 	nop.w

08013ed0 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1>:
* Input          : LSM303AGR_ACC_I1_WTM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Watermark_on_INT1(void *handle, LSM303AGR_ACC_I1_WTM_t newValue)
{
 8013ed0:	b500      	push	{lr}
 8013ed2:	b085      	sub	sp, #20
 8013ed4:	9001      	str	r0, [sp, #4]
 8013ed6:	460b      	mov	r3, r1
 8013ed8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013edc:	f10d 030f 	add.w	r3, sp, #15
 8013ee0:	9801      	ldr	r0, [sp, #4]
 8013ee2:	2122      	movs	r1, #34	; 0x22
 8013ee4:	461a      	mov	r2, r3
 8013ee6:	2301      	movs	r3, #1
 8013ee8:	f7fe fff2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013eec:	4603      	mov	r3, r0
 8013eee:	2b00      	cmp	r3, #0
 8013ef0:	d101      	bne.n	8013ef6 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x26>
    return MEMS_ERROR;
 8013ef2:	2300      	movs	r3, #0
 8013ef4:	e01c      	b.n	8013f30 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_WTM_MASK;
 8013ef6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013efa:	f023 0304 	bic.w	r3, r3, #4
 8013efe:	b2db      	uxtb	r3, r3
 8013f00:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013f04:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013f08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013f0c:	4313      	orrs	r3, r2
 8013f0e:	b2db      	uxtb	r3, r3
 8013f10:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013f14:	f10d 030f 	add.w	r3, sp, #15
 8013f18:	9801      	ldr	r0, [sp, #4]
 8013f1a:	2122      	movs	r1, #34	; 0x22
 8013f1c:	461a      	mov	r2, r3
 8013f1e:	2301      	movs	r3, #1
 8013f20:	f7fe ffae 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013f24:	4603      	mov	r3, r0
 8013f26:	2b00      	cmp	r3, #0
 8013f28:	d101      	bne.n	8013f2e <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x5e>
    return MEMS_ERROR;
 8013f2a:	2300      	movs	r3, #0
 8013f2c:	e000      	b.n	8013f30 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x60>

  return MEMS_SUCCESS;
 8013f2e:	2301      	movs	r3, #1
}
 8013f30:	4618      	mov	r0, r3
 8013f32:	b005      	add	sp, #20
 8013f34:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f38:	f3af 8000 	nop.w
 8013f3c:	f3af 8000 	nop.w

08013f40 <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_WTM_t
* Output         : Status of I1_WTM see LSM303AGR_ACC_I1_WTM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Watermark_on_INT1(void *handle, LSM303AGR_ACC_I1_WTM_t *value)
{
 8013f40:	b500      	push	{lr}
 8013f42:	b083      	sub	sp, #12
 8013f44:	9001      	str	r0, [sp, #4]
 8013f46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8013f48:	9801      	ldr	r0, [sp, #4]
 8013f4a:	2122      	movs	r1, #34	; 0x22
 8013f4c:	9a00      	ldr	r2, [sp, #0]
 8013f4e:	2301      	movs	r3, #1
 8013f50:	f7fe ffbe 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013f54:	4603      	mov	r3, r0
 8013f56:	2b00      	cmp	r3, #0
 8013f58:	d101      	bne.n	8013f5e <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1+0x1e>
    return MEMS_ERROR;
 8013f5a:	2300      	movs	r3, #0
 8013f5c:	e007      	b.n	8013f6e <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_WTM_MASK; //mask
 8013f5e:	9b00      	ldr	r3, [sp, #0]
 8013f60:	781b      	ldrb	r3, [r3, #0]
 8013f62:	f003 0304 	and.w	r3, r3, #4
 8013f66:	b2da      	uxtb	r2, r3
 8013f68:	9b00      	ldr	r3, [sp, #0]
 8013f6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013f6c:	2301      	movs	r3, #1
}
 8013f6e:	4618      	mov	r0, r3
 8013f70:	b003      	add	sp, #12
 8013f72:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f76:	bf00      	nop
 8013f78:	f3af 8000 	nop.w
 8013f7c:	f3af 8000 	nop.w

08013f80 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1>:
* Input          : LSM303AGR_ACC_I1_DRDY2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY2_t newValue)
{
 8013f80:	b500      	push	{lr}
 8013f82:	b085      	sub	sp, #20
 8013f84:	9001      	str	r0, [sp, #4]
 8013f86:	460b      	mov	r3, r1
 8013f88:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013f8c:	f10d 030f 	add.w	r3, sp, #15
 8013f90:	9801      	ldr	r0, [sp, #4]
 8013f92:	2122      	movs	r1, #34	; 0x22
 8013f94:	461a      	mov	r2, r3
 8013f96:	2301      	movs	r3, #1
 8013f98:	f7fe ff9a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8013f9c:	4603      	mov	r3, r0
 8013f9e:	2b00      	cmp	r3, #0
 8013fa0:	d101      	bne.n	8013fa6 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x26>
    return MEMS_ERROR;
 8013fa2:	2300      	movs	r3, #0
 8013fa4:	e01c      	b.n	8013fe0 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_DRDY2_MASK;
 8013fa6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013faa:	f023 0308 	bic.w	r3, r3, #8
 8013fae:	b2db      	uxtb	r3, r3
 8013fb0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013fb4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013fb8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013fbc:	4313      	orrs	r3, r2
 8013fbe:	b2db      	uxtb	r3, r3
 8013fc0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013fc4:	f10d 030f 	add.w	r3, sp, #15
 8013fc8:	9801      	ldr	r0, [sp, #4]
 8013fca:	2122      	movs	r1, #34	; 0x22
 8013fcc:	461a      	mov	r2, r3
 8013fce:	2301      	movs	r3, #1
 8013fd0:	f7fe ff56 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8013fd4:	4603      	mov	r3, r0
 8013fd6:	2b00      	cmp	r3, #0
 8013fd8:	d101      	bne.n	8013fde <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x5e>
    return MEMS_ERROR;
 8013fda:	2300      	movs	r3, #0
 8013fdc:	e000      	b.n	8013fe0 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x60>

  return MEMS_SUCCESS;
 8013fde:	2301      	movs	r3, #1
}
 8013fe0:	4618      	mov	r0, r3
 8013fe2:	b005      	add	sp, #20
 8013fe4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013fe8:	f3af 8000 	nop.w
 8013fec:	f3af 8000 	nop.w

08013ff0 <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_DRDY2_t
* Output         : Status of I1_DRDY2 see LSM303AGR_ACC_I1_DRDY2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY2_t *value)
{
 8013ff0:	b500      	push	{lr}
 8013ff2:	b083      	sub	sp, #12
 8013ff4:	9001      	str	r0, [sp, #4]
 8013ff6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8013ff8:	9801      	ldr	r0, [sp, #4]
 8013ffa:	2122      	movs	r1, #34	; 0x22
 8013ffc:	9a00      	ldr	r2, [sp, #0]
 8013ffe:	2301      	movs	r3, #1
 8014000:	f7fe ff66 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014004:	4603      	mov	r3, r0
 8014006:	2b00      	cmp	r3, #0
 8014008:	d101      	bne.n	801400e <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1+0x1e>
    return MEMS_ERROR;
 801400a:	2300      	movs	r3, #0
 801400c:	e007      	b.n	801401e <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_DRDY2_MASK; //mask
 801400e:	9b00      	ldr	r3, [sp, #0]
 8014010:	781b      	ldrb	r3, [r3, #0]
 8014012:	f003 0308 	and.w	r3, r3, #8
 8014016:	b2da      	uxtb	r2, r3
 8014018:	9b00      	ldr	r3, [sp, #0]
 801401a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801401c:	2301      	movs	r3, #1
}
 801401e:	4618      	mov	r0, r3
 8014020:	b003      	add	sp, #12
 8014022:	f85d fb04 	ldr.w	pc, [sp], #4
 8014026:	bf00      	nop
 8014028:	f3af 8000 	nop.w
 801402c:	f3af 8000 	nop.w

08014030 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1>:
* Input          : LSM303AGR_ACC_I1_DRDY1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY1_t newValue)
{
 8014030:	b500      	push	{lr}
 8014032:	b085      	sub	sp, #20
 8014034:	9001      	str	r0, [sp, #4]
 8014036:	460b      	mov	r3, r1
 8014038:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801403c:	f10d 030f 	add.w	r3, sp, #15
 8014040:	9801      	ldr	r0, [sp, #4]
 8014042:	2122      	movs	r1, #34	; 0x22
 8014044:	461a      	mov	r2, r3
 8014046:	2301      	movs	r3, #1
 8014048:	f7fe ff42 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801404c:	4603      	mov	r3, r0
 801404e:	2b00      	cmp	r3, #0
 8014050:	d101      	bne.n	8014056 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x26>
    return MEMS_ERROR;
 8014052:	2300      	movs	r3, #0
 8014054:	e01c      	b.n	8014090 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_DRDY1_MASK;
 8014056:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801405a:	f023 0310 	bic.w	r3, r3, #16
 801405e:	b2db      	uxtb	r3, r3
 8014060:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014064:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014068:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801406c:	4313      	orrs	r3, r2
 801406e:	b2db      	uxtb	r3, r3
 8014070:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8014074:	f10d 030f 	add.w	r3, sp, #15
 8014078:	9801      	ldr	r0, [sp, #4]
 801407a:	2122      	movs	r1, #34	; 0x22
 801407c:	461a      	mov	r2, r3
 801407e:	2301      	movs	r3, #1
 8014080:	f7fe fefe 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014084:	4603      	mov	r3, r0
 8014086:	2b00      	cmp	r3, #0
 8014088:	d101      	bne.n	801408e <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x5e>
    return MEMS_ERROR;
 801408a:	2300      	movs	r3, #0
 801408c:	e000      	b.n	8014090 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x60>

  return MEMS_SUCCESS;
 801408e:	2301      	movs	r3, #1
}
 8014090:	4618      	mov	r0, r3
 8014092:	b005      	add	sp, #20
 8014094:	f85d fb04 	ldr.w	pc, [sp], #4
 8014098:	f3af 8000 	nop.w
 801409c:	f3af 8000 	nop.w

080140a0 <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_DRDY1_t
* Output         : Status of I1_DRDY1 see LSM303AGR_ACC_I1_DRDY1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY1_t *value)
{
 80140a0:	b500      	push	{lr}
 80140a2:	b083      	sub	sp, #12
 80140a4:	9001      	str	r0, [sp, #4]
 80140a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 80140a8:	9801      	ldr	r0, [sp, #4]
 80140aa:	2122      	movs	r1, #34	; 0x22
 80140ac:	9a00      	ldr	r2, [sp, #0]
 80140ae:	2301      	movs	r3, #1
 80140b0:	f7fe ff0e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80140b4:	4603      	mov	r3, r0
 80140b6:	2b00      	cmp	r3, #0
 80140b8:	d101      	bne.n	80140be <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1+0x1e>
    return MEMS_ERROR;
 80140ba:	2300      	movs	r3, #0
 80140bc:	e007      	b.n	80140ce <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_DRDY1_MASK; //mask
 80140be:	9b00      	ldr	r3, [sp, #0]
 80140c0:	781b      	ldrb	r3, [r3, #0]
 80140c2:	f003 0310 	and.w	r3, r3, #16
 80140c6:	b2da      	uxtb	r2, r3
 80140c8:	9b00      	ldr	r3, [sp, #0]
 80140ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80140cc:	2301      	movs	r3, #1
}
 80140ce:	4618      	mov	r0, r3
 80140d0:	b003      	add	sp, #12
 80140d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80140d6:	bf00      	nop
 80140d8:	f3af 8000 	nop.w
 80140dc:	f3af 8000 	nop.w

080140e0 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1>:
* Input          : LSM303AGR_ACC_I1_AOI2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_AOL2_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI2_t newValue)
{
 80140e0:	b500      	push	{lr}
 80140e2:	b085      	sub	sp, #20
 80140e4:	9001      	str	r0, [sp, #4]
 80140e6:	460b      	mov	r3, r1
 80140e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80140ec:	f10d 030f 	add.w	r3, sp, #15
 80140f0:	9801      	ldr	r0, [sp, #4]
 80140f2:	2122      	movs	r1, #34	; 0x22
 80140f4:	461a      	mov	r2, r3
 80140f6:	2301      	movs	r3, #1
 80140f8:	f7fe feea 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80140fc:	4603      	mov	r3, r0
 80140fe:	2b00      	cmp	r3, #0
 8014100:	d101      	bne.n	8014106 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x26>
    return MEMS_ERROR;
 8014102:	2300      	movs	r3, #0
 8014104:	e01c      	b.n	8014140 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_AOI2_MASK;
 8014106:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801410a:	f023 0320 	bic.w	r3, r3, #32
 801410e:	b2db      	uxtb	r3, r3
 8014110:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014114:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014118:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801411c:	4313      	orrs	r3, r2
 801411e:	b2db      	uxtb	r3, r3
 8014120:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8014124:	f10d 030f 	add.w	r3, sp, #15
 8014128:	9801      	ldr	r0, [sp, #4]
 801412a:	2122      	movs	r1, #34	; 0x22
 801412c:	461a      	mov	r2, r3
 801412e:	2301      	movs	r3, #1
 8014130:	f7fe fea6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014134:	4603      	mov	r3, r0
 8014136:	2b00      	cmp	r3, #0
 8014138:	d101      	bne.n	801413e <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x5e>
    return MEMS_ERROR;
 801413a:	2300      	movs	r3, #0
 801413c:	e000      	b.n	8014140 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x60>

  return MEMS_SUCCESS;
 801413e:	2301      	movs	r3, #1
}
 8014140:	4618      	mov	r0, r3
 8014142:	b005      	add	sp, #20
 8014144:	f85d fb04 	ldr.w	pc, [sp], #4
 8014148:	f3af 8000 	nop.w
 801414c:	f3af 8000 	nop.w

08014150 <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_AOI2_t
* Output         : Status of I1_AOI2 see LSM303AGR_ACC_I1_AOI2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_AOL2_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI2_t *value)
{
 8014150:	b500      	push	{lr}
 8014152:	b083      	sub	sp, #12
 8014154:	9001      	str	r0, [sp, #4]
 8014156:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8014158:	9801      	ldr	r0, [sp, #4]
 801415a:	2122      	movs	r1, #34	; 0x22
 801415c:	9a00      	ldr	r2, [sp, #0]
 801415e:	2301      	movs	r3, #1
 8014160:	f7fe feb6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014164:	4603      	mov	r3, r0
 8014166:	2b00      	cmp	r3, #0
 8014168:	d101      	bne.n	801416e <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1+0x1e>
    return MEMS_ERROR;
 801416a:	2300      	movs	r3, #0
 801416c:	e007      	b.n	801417e <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_AOI2_MASK; //mask
 801416e:	9b00      	ldr	r3, [sp, #0]
 8014170:	781b      	ldrb	r3, [r3, #0]
 8014172:	f003 0320 	and.w	r3, r3, #32
 8014176:	b2da      	uxtb	r2, r3
 8014178:	9b00      	ldr	r3, [sp, #0]
 801417a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801417c:	2301      	movs	r3, #1
}
 801417e:	4618      	mov	r0, r3
 8014180:	b003      	add	sp, #12
 8014182:	f85d fb04 	ldr.w	pc, [sp], #4
 8014186:	bf00      	nop
 8014188:	f3af 8000 	nop.w
 801418c:	f3af 8000 	nop.w

08014190 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1>:
* Input          : LSM303AGR_ACC_I1_AOI1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_AOL1_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI1_t newValue)
{
 8014190:	b500      	push	{lr}
 8014192:	b085      	sub	sp, #20
 8014194:	9001      	str	r0, [sp, #4]
 8014196:	460b      	mov	r3, r1
 8014198:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801419c:	f10d 030f 	add.w	r3, sp, #15
 80141a0:	9801      	ldr	r0, [sp, #4]
 80141a2:	2122      	movs	r1, #34	; 0x22
 80141a4:	461a      	mov	r2, r3
 80141a6:	2301      	movs	r3, #1
 80141a8:	f7fe fe92 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80141ac:	4603      	mov	r3, r0
 80141ae:	2b00      	cmp	r3, #0
 80141b0:	d101      	bne.n	80141b6 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x26>
    return MEMS_ERROR;
 80141b2:	2300      	movs	r3, #0
 80141b4:	e01c      	b.n	80141f0 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_AOI1_MASK;
 80141b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80141ba:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80141be:	b2db      	uxtb	r3, r3
 80141c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80141c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80141c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80141cc:	4313      	orrs	r3, r2
 80141ce:	b2db      	uxtb	r3, r3
 80141d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80141d4:	f10d 030f 	add.w	r3, sp, #15
 80141d8:	9801      	ldr	r0, [sp, #4]
 80141da:	2122      	movs	r1, #34	; 0x22
 80141dc:	461a      	mov	r2, r3
 80141de:	2301      	movs	r3, #1
 80141e0:	f7fe fe4e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80141e4:	4603      	mov	r3, r0
 80141e6:	2b00      	cmp	r3, #0
 80141e8:	d101      	bne.n	80141ee <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x5e>
    return MEMS_ERROR;
 80141ea:	2300      	movs	r3, #0
 80141ec:	e000      	b.n	80141f0 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x60>

  return MEMS_SUCCESS;
 80141ee:	2301      	movs	r3, #1
}
 80141f0:	4618      	mov	r0, r3
 80141f2:	b005      	add	sp, #20
 80141f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80141f8:	f3af 8000 	nop.w
 80141fc:	f3af 8000 	nop.w

08014200 <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_AOI1_t
* Output         : Status of I1_AOI1 see LSM303AGR_ACC_I1_AOI1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_AOL1_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI1_t *value)
{
 8014200:	b500      	push	{lr}
 8014202:	b083      	sub	sp, #12
 8014204:	9001      	str	r0, [sp, #4]
 8014206:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8014208:	9801      	ldr	r0, [sp, #4]
 801420a:	2122      	movs	r1, #34	; 0x22
 801420c:	9a00      	ldr	r2, [sp, #0]
 801420e:	2301      	movs	r3, #1
 8014210:	f7fe fe5e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014214:	4603      	mov	r3, r0
 8014216:	2b00      	cmp	r3, #0
 8014218:	d101      	bne.n	801421e <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1+0x1e>
    return MEMS_ERROR;
 801421a:	2300      	movs	r3, #0
 801421c:	e007      	b.n	801422e <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_AOI1_MASK; //mask
 801421e:	9b00      	ldr	r3, [sp, #0]
 8014220:	781b      	ldrb	r3, [r3, #0]
 8014222:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014226:	b2da      	uxtb	r2, r3
 8014228:	9b00      	ldr	r3, [sp, #0]
 801422a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801422c:	2301      	movs	r3, #1
}
 801422e:	4618      	mov	r0, r3
 8014230:	b003      	add	sp, #12
 8014232:	f85d fb04 	ldr.w	pc, [sp], #4
 8014236:	bf00      	nop
 8014238:	f3af 8000 	nop.w
 801423c:	f3af 8000 	nop.w

08014240 <LSM303AGR_ACC_W_FIFO_Click_on_INT1>:
* Input          : LSM303AGR_ACC_I1_CLICK_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Click_on_INT1(void *handle, LSM303AGR_ACC_I1_CLICK_t newValue)
{
 8014240:	b500      	push	{lr}
 8014242:	b085      	sub	sp, #20
 8014244:	9001      	str	r0, [sp, #4]
 8014246:	460b      	mov	r3, r1
 8014248:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801424c:	f10d 030f 	add.w	r3, sp, #15
 8014250:	9801      	ldr	r0, [sp, #4]
 8014252:	2122      	movs	r1, #34	; 0x22
 8014254:	461a      	mov	r2, r3
 8014256:	2301      	movs	r3, #1
 8014258:	f7fe fe3a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801425c:	4603      	mov	r3, r0
 801425e:	2b00      	cmp	r3, #0
 8014260:	d101      	bne.n	8014266 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x26>
    return MEMS_ERROR;
 8014262:	2300      	movs	r3, #0
 8014264:	e01c      	b.n	80142a0 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_CLICK_MASK;
 8014266:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801426a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801426e:	b2db      	uxtb	r3, r3
 8014270:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014274:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014278:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801427c:	4313      	orrs	r3, r2
 801427e:	b2db      	uxtb	r3, r3
 8014280:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8014284:	f10d 030f 	add.w	r3, sp, #15
 8014288:	9801      	ldr	r0, [sp, #4]
 801428a:	2122      	movs	r1, #34	; 0x22
 801428c:	461a      	mov	r2, r3
 801428e:	2301      	movs	r3, #1
 8014290:	f7fe fdf6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014294:	4603      	mov	r3, r0
 8014296:	2b00      	cmp	r3, #0
 8014298:	d101      	bne.n	801429e <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x5e>
    return MEMS_ERROR;
 801429a:	2300      	movs	r3, #0
 801429c:	e000      	b.n	80142a0 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x60>

  return MEMS_SUCCESS;
 801429e:	2301      	movs	r3, #1
}
 80142a0:	4618      	mov	r0, r3
 80142a2:	b005      	add	sp, #20
 80142a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80142a8:	f3af 8000 	nop.w
 80142ac:	f3af 8000 	nop.w

080142b0 <LSM303AGR_ACC_R_FIFO_Click_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_CLICK_t
* Output         : Status of I1_CLICK see LSM303AGR_ACC_I1_CLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Click_on_INT1(void *handle, LSM303AGR_ACC_I1_CLICK_t *value)
{
 80142b0:	b500      	push	{lr}
 80142b2:	b083      	sub	sp, #12
 80142b4:	9001      	str	r0, [sp, #4]
 80142b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 80142b8:	9801      	ldr	r0, [sp, #4]
 80142ba:	2122      	movs	r1, #34	; 0x22
 80142bc:	9a00      	ldr	r2, [sp, #0]
 80142be:	2301      	movs	r3, #1
 80142c0:	f7fe fe06 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80142c4:	4603      	mov	r3, r0
 80142c6:	2b00      	cmp	r3, #0
 80142c8:	d101      	bne.n	80142ce <LSM303AGR_ACC_R_FIFO_Click_on_INT1+0x1e>
    return MEMS_ERROR;
 80142ca:	2300      	movs	r3, #0
 80142cc:	e007      	b.n	80142de <LSM303AGR_ACC_R_FIFO_Click_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_CLICK_MASK; //mask
 80142ce:	9b00      	ldr	r3, [sp, #0]
 80142d0:	781b      	ldrb	r3, [r3, #0]
 80142d2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80142d6:	b2da      	uxtb	r2, r3
 80142d8:	9b00      	ldr	r3, [sp, #0]
 80142da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80142dc:	2301      	movs	r3, #1
}
 80142de:	4618      	mov	r0, r3
 80142e0:	b003      	add	sp, #12
 80142e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80142e6:	bf00      	nop
 80142e8:	f3af 8000 	nop.w
 80142ec:	f3af 8000 	nop.w

080142f0 <LSM303AGR_ACC_W_SPI_mode>:
* Input          : LSM303AGR_ACC_SIM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_SPI_mode(void *handle, LSM303AGR_ACC_SIM_t newValue)
{
 80142f0:	b500      	push	{lr}
 80142f2:	b085      	sub	sp, #20
 80142f4:	9001      	str	r0, [sp, #4]
 80142f6:	460b      	mov	r3, r1
 80142f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80142fc:	f10d 030f 	add.w	r3, sp, #15
 8014300:	9801      	ldr	r0, [sp, #4]
 8014302:	2123      	movs	r1, #35	; 0x23
 8014304:	461a      	mov	r2, r3
 8014306:	2301      	movs	r3, #1
 8014308:	f7fe fde2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801430c:	4603      	mov	r3, r0
 801430e:	2b00      	cmp	r3, #0
 8014310:	d101      	bne.n	8014316 <LSM303AGR_ACC_W_SPI_mode+0x26>
    return MEMS_ERROR;
 8014312:	2300      	movs	r3, #0
 8014314:	e01c      	b.n	8014350 <LSM303AGR_ACC_W_SPI_mode+0x60>

  value &= ~LSM303AGR_ACC_SIM_MASK;
 8014316:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801431a:	f023 0301 	bic.w	r3, r3, #1
 801431e:	b2db      	uxtb	r3, r3
 8014320:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014324:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014328:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801432c:	4313      	orrs	r3, r2
 801432e:	b2db      	uxtb	r3, r3
 8014330:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8014334:	f10d 030f 	add.w	r3, sp, #15
 8014338:	9801      	ldr	r0, [sp, #4]
 801433a:	2123      	movs	r1, #35	; 0x23
 801433c:	461a      	mov	r2, r3
 801433e:	2301      	movs	r3, #1
 8014340:	f7fe fd9e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014344:	4603      	mov	r3, r0
 8014346:	2b00      	cmp	r3, #0
 8014348:	d101      	bne.n	801434e <LSM303AGR_ACC_W_SPI_mode+0x5e>
    return MEMS_ERROR;
 801434a:	2300      	movs	r3, #0
 801434c:	e000      	b.n	8014350 <LSM303AGR_ACC_W_SPI_mode+0x60>

  return MEMS_SUCCESS;
 801434e:	2301      	movs	r3, #1
}
 8014350:	4618      	mov	r0, r3
 8014352:	b005      	add	sp, #20
 8014354:	f85d fb04 	ldr.w	pc, [sp], #4
 8014358:	f3af 8000 	nop.w
 801435c:	f3af 8000 	nop.w

08014360 <LSM303AGR_ACC_R_SPI_mode>:
* Input          : Pointer to LSM303AGR_ACC_SIM_t
* Output         : Status of SIM see LSM303AGR_ACC_SIM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SPI_mode(void *handle, LSM303AGR_ACC_SIM_t *value)
{
 8014360:	b500      	push	{lr}
 8014362:	b083      	sub	sp, #12
 8014364:	9001      	str	r0, [sp, #4]
 8014366:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8014368:	9801      	ldr	r0, [sp, #4]
 801436a:	2123      	movs	r1, #35	; 0x23
 801436c:	9a00      	ldr	r2, [sp, #0]
 801436e:	2301      	movs	r3, #1
 8014370:	f7fe fdae 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014374:	4603      	mov	r3, r0
 8014376:	2b00      	cmp	r3, #0
 8014378:	d101      	bne.n	801437e <LSM303AGR_ACC_R_SPI_mode+0x1e>
    return MEMS_ERROR;
 801437a:	2300      	movs	r3, #0
 801437c:	e007      	b.n	801438e <LSM303AGR_ACC_R_SPI_mode+0x2e>

  *value &= LSM303AGR_ACC_SIM_MASK; //mask
 801437e:	9b00      	ldr	r3, [sp, #0]
 8014380:	781b      	ldrb	r3, [r3, #0]
 8014382:	f003 0301 	and.w	r3, r3, #1
 8014386:	b2da      	uxtb	r2, r3
 8014388:	9b00      	ldr	r3, [sp, #0]
 801438a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801438c:	2301      	movs	r3, #1
}
 801438e:	4618      	mov	r0, r3
 8014390:	b003      	add	sp, #12
 8014392:	f85d fb04 	ldr.w	pc, [sp], #4
 8014396:	bf00      	nop
 8014398:	f3af 8000 	nop.w
 801439c:	f3af 8000 	nop.w

080143a0 <LSM303AGR_ACC_W_SelfTest>:
* Input          : LSM303AGR_ACC_ST_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_SelfTest(void *handle, LSM303AGR_ACC_ST_t newValue)
{
 80143a0:	b500      	push	{lr}
 80143a2:	b085      	sub	sp, #20
 80143a4:	9001      	str	r0, [sp, #4]
 80143a6:	460b      	mov	r3, r1
 80143a8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80143ac:	f10d 030f 	add.w	r3, sp, #15
 80143b0:	9801      	ldr	r0, [sp, #4]
 80143b2:	2123      	movs	r1, #35	; 0x23
 80143b4:	461a      	mov	r2, r3
 80143b6:	2301      	movs	r3, #1
 80143b8:	f7fe fd8a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80143bc:	4603      	mov	r3, r0
 80143be:	2b00      	cmp	r3, #0
 80143c0:	d101      	bne.n	80143c6 <LSM303AGR_ACC_W_SelfTest+0x26>
    return MEMS_ERROR;
 80143c2:	2300      	movs	r3, #0
 80143c4:	e01c      	b.n	8014400 <LSM303AGR_ACC_W_SelfTest+0x60>

  value &= ~LSM303AGR_ACC_ST_MASK;
 80143c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80143ca:	f023 0306 	bic.w	r3, r3, #6
 80143ce:	b2db      	uxtb	r3, r3
 80143d0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80143d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80143d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80143dc:	4313      	orrs	r3, r2
 80143de:	b2db      	uxtb	r3, r3
 80143e0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80143e4:	f10d 030f 	add.w	r3, sp, #15
 80143e8:	9801      	ldr	r0, [sp, #4]
 80143ea:	2123      	movs	r1, #35	; 0x23
 80143ec:	461a      	mov	r2, r3
 80143ee:	2301      	movs	r3, #1
 80143f0:	f7fe fd46 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80143f4:	4603      	mov	r3, r0
 80143f6:	2b00      	cmp	r3, #0
 80143f8:	d101      	bne.n	80143fe <LSM303AGR_ACC_W_SelfTest+0x5e>
    return MEMS_ERROR;
 80143fa:	2300      	movs	r3, #0
 80143fc:	e000      	b.n	8014400 <LSM303AGR_ACC_W_SelfTest+0x60>

  return MEMS_SUCCESS;
 80143fe:	2301      	movs	r3, #1
}
 8014400:	4618      	mov	r0, r3
 8014402:	b005      	add	sp, #20
 8014404:	f85d fb04 	ldr.w	pc, [sp], #4
 8014408:	f3af 8000 	nop.w
 801440c:	f3af 8000 	nop.w

08014410 <LSM303AGR_ACC_R_SelfTest>:
* Input          : Pointer to LSM303AGR_ACC_ST_t
* Output         : Status of ST see LSM303AGR_ACC_ST_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SelfTest(void *handle, LSM303AGR_ACC_ST_t *value)
{
 8014410:	b500      	push	{lr}
 8014412:	b083      	sub	sp, #12
 8014414:	9001      	str	r0, [sp, #4]
 8014416:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8014418:	9801      	ldr	r0, [sp, #4]
 801441a:	2123      	movs	r1, #35	; 0x23
 801441c:	9a00      	ldr	r2, [sp, #0]
 801441e:	2301      	movs	r3, #1
 8014420:	f7fe fd56 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014424:	4603      	mov	r3, r0
 8014426:	2b00      	cmp	r3, #0
 8014428:	d101      	bne.n	801442e <LSM303AGR_ACC_R_SelfTest+0x1e>
    return MEMS_ERROR;
 801442a:	2300      	movs	r3, #0
 801442c:	e007      	b.n	801443e <LSM303AGR_ACC_R_SelfTest+0x2e>

  *value &= LSM303AGR_ACC_ST_MASK; //mask
 801442e:	9b00      	ldr	r3, [sp, #0]
 8014430:	781b      	ldrb	r3, [r3, #0]
 8014432:	f003 0306 	and.w	r3, r3, #6
 8014436:	b2da      	uxtb	r2, r3
 8014438:	9b00      	ldr	r3, [sp, #0]
 801443a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801443c:	2301      	movs	r3, #1
}
 801443e:	4618      	mov	r0, r3
 8014440:	b003      	add	sp, #12
 8014442:	f85d fb04 	ldr.w	pc, [sp], #4
 8014446:	bf00      	nop
 8014448:	f3af 8000 	nop.w
 801444c:	f3af 8000 	nop.w

08014450 <LSM303AGR_ACC_W_HiRes>:
* Input          : LSM303AGR_ACC_HR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_HiRes(void *handle, LSM303AGR_ACC_HR_t newValue)
{
 8014450:	b500      	push	{lr}
 8014452:	b085      	sub	sp, #20
 8014454:	9001      	str	r0, [sp, #4]
 8014456:	460b      	mov	r3, r1
 8014458:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801445c:	f10d 030f 	add.w	r3, sp, #15
 8014460:	9801      	ldr	r0, [sp, #4]
 8014462:	2123      	movs	r1, #35	; 0x23
 8014464:	461a      	mov	r2, r3
 8014466:	2301      	movs	r3, #1
 8014468:	f7fe fd32 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801446c:	4603      	mov	r3, r0
 801446e:	2b00      	cmp	r3, #0
 8014470:	d101      	bne.n	8014476 <LSM303AGR_ACC_W_HiRes+0x26>
    return MEMS_ERROR;
 8014472:	2300      	movs	r3, #0
 8014474:	e01c      	b.n	80144b0 <LSM303AGR_ACC_W_HiRes+0x60>

  value &= ~LSM303AGR_ACC_HR_MASK;
 8014476:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801447a:	f023 0308 	bic.w	r3, r3, #8
 801447e:	b2db      	uxtb	r3, r3
 8014480:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014484:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014488:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801448c:	4313      	orrs	r3, r2
 801448e:	b2db      	uxtb	r3, r3
 8014490:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8014494:	f10d 030f 	add.w	r3, sp, #15
 8014498:	9801      	ldr	r0, [sp, #4]
 801449a:	2123      	movs	r1, #35	; 0x23
 801449c:	461a      	mov	r2, r3
 801449e:	2301      	movs	r3, #1
 80144a0:	f7fe fcee 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80144a4:	4603      	mov	r3, r0
 80144a6:	2b00      	cmp	r3, #0
 80144a8:	d101      	bne.n	80144ae <LSM303AGR_ACC_W_HiRes+0x5e>
    return MEMS_ERROR;
 80144aa:	2300      	movs	r3, #0
 80144ac:	e000      	b.n	80144b0 <LSM303AGR_ACC_W_HiRes+0x60>

  return MEMS_SUCCESS;
 80144ae:	2301      	movs	r3, #1
}
 80144b0:	4618      	mov	r0, r3
 80144b2:	b005      	add	sp, #20
 80144b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80144b8:	f3af 8000 	nop.w
 80144bc:	f3af 8000 	nop.w

080144c0 <LSM303AGR_ACC_R_HiRes>:
* Input          : Pointer to LSM303AGR_ACC_HR_t
* Output         : Status of HR see LSM303AGR_ACC_HR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_HiRes(void *handle, LSM303AGR_ACC_HR_t *value)
{
 80144c0:	b500      	push	{lr}
 80144c2:	b083      	sub	sp, #12
 80144c4:	9001      	str	r0, [sp, #4]
 80144c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 80144c8:	9801      	ldr	r0, [sp, #4]
 80144ca:	2123      	movs	r1, #35	; 0x23
 80144cc:	9a00      	ldr	r2, [sp, #0]
 80144ce:	2301      	movs	r3, #1
 80144d0:	f7fe fcfe 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80144d4:	4603      	mov	r3, r0
 80144d6:	2b00      	cmp	r3, #0
 80144d8:	d101      	bne.n	80144de <LSM303AGR_ACC_R_HiRes+0x1e>
    return MEMS_ERROR;
 80144da:	2300      	movs	r3, #0
 80144dc:	e007      	b.n	80144ee <LSM303AGR_ACC_R_HiRes+0x2e>

  *value &= LSM303AGR_ACC_HR_MASK; //mask
 80144de:	9b00      	ldr	r3, [sp, #0]
 80144e0:	781b      	ldrb	r3, [r3, #0]
 80144e2:	f003 0308 	and.w	r3, r3, #8
 80144e6:	b2da      	uxtb	r2, r3
 80144e8:	9b00      	ldr	r3, [sp, #0]
 80144ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80144ec:	2301      	movs	r3, #1
}
 80144ee:	4618      	mov	r0, r3
 80144f0:	b003      	add	sp, #12
 80144f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80144f6:	bf00      	nop
 80144f8:	f3af 8000 	nop.w
 80144fc:	f3af 8000 	nop.w

08014500 <LSM303AGR_ACC_W_LittleBigEndian>:
* Input          : LSM303AGR_ACC_BLE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LittleBigEndian(void *handle, LSM303AGR_ACC_BLE_t newValue)
{
 8014500:	b500      	push	{lr}
 8014502:	b085      	sub	sp, #20
 8014504:	9001      	str	r0, [sp, #4]
 8014506:	460b      	mov	r3, r1
 8014508:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801450c:	f10d 030f 	add.w	r3, sp, #15
 8014510:	9801      	ldr	r0, [sp, #4]
 8014512:	2123      	movs	r1, #35	; 0x23
 8014514:	461a      	mov	r2, r3
 8014516:	2301      	movs	r3, #1
 8014518:	f7fe fcda 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801451c:	4603      	mov	r3, r0
 801451e:	2b00      	cmp	r3, #0
 8014520:	d101      	bne.n	8014526 <LSM303AGR_ACC_W_LittleBigEndian+0x26>
    return MEMS_ERROR;
 8014522:	2300      	movs	r3, #0
 8014524:	e01c      	b.n	8014560 <LSM303AGR_ACC_W_LittleBigEndian+0x60>

  value &= ~LSM303AGR_ACC_BLE_MASK;
 8014526:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801452a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801452e:	b2db      	uxtb	r3, r3
 8014530:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014534:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014538:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801453c:	4313      	orrs	r3, r2
 801453e:	b2db      	uxtb	r3, r3
 8014540:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8014544:	f10d 030f 	add.w	r3, sp, #15
 8014548:	9801      	ldr	r0, [sp, #4]
 801454a:	2123      	movs	r1, #35	; 0x23
 801454c:	461a      	mov	r2, r3
 801454e:	2301      	movs	r3, #1
 8014550:	f7fe fc96 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014554:	4603      	mov	r3, r0
 8014556:	2b00      	cmp	r3, #0
 8014558:	d101      	bne.n	801455e <LSM303AGR_ACC_W_LittleBigEndian+0x5e>
    return MEMS_ERROR;
 801455a:	2300      	movs	r3, #0
 801455c:	e000      	b.n	8014560 <LSM303AGR_ACC_W_LittleBigEndian+0x60>

  return MEMS_SUCCESS;
 801455e:	2301      	movs	r3, #1
}
 8014560:	4618      	mov	r0, r3
 8014562:	b005      	add	sp, #20
 8014564:	f85d fb04 	ldr.w	pc, [sp], #4
 8014568:	f3af 8000 	nop.w
 801456c:	f3af 8000 	nop.w

08014570 <LSM303AGR_ACC_R_LittleBigEndian>:
* Input          : Pointer to LSM303AGR_ACC_BLE_t
* Output         : Status of BLE see LSM303AGR_ACC_BLE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LittleBigEndian(void *handle, LSM303AGR_ACC_BLE_t *value)
{
 8014570:	b500      	push	{lr}
 8014572:	b083      	sub	sp, #12
 8014574:	9001      	str	r0, [sp, #4]
 8014576:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8014578:	9801      	ldr	r0, [sp, #4]
 801457a:	2123      	movs	r1, #35	; 0x23
 801457c:	9a00      	ldr	r2, [sp, #0]
 801457e:	2301      	movs	r3, #1
 8014580:	f7fe fca6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014584:	4603      	mov	r3, r0
 8014586:	2b00      	cmp	r3, #0
 8014588:	d101      	bne.n	801458e <LSM303AGR_ACC_R_LittleBigEndian+0x1e>
    return MEMS_ERROR;
 801458a:	2300      	movs	r3, #0
 801458c:	e007      	b.n	801459e <LSM303AGR_ACC_R_LittleBigEndian+0x2e>

  *value &= LSM303AGR_ACC_BLE_MASK; //mask
 801458e:	9b00      	ldr	r3, [sp, #0]
 8014590:	781b      	ldrb	r3, [r3, #0]
 8014592:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014596:	b2da      	uxtb	r2, r3
 8014598:	9b00      	ldr	r3, [sp, #0]
 801459a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801459c:	2301      	movs	r3, #1
}
 801459e:	4618      	mov	r0, r3
 80145a0:	b003      	add	sp, #12
 80145a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80145a6:	bf00      	nop
 80145a8:	f3af 8000 	nop.w
 80145ac:	f3af 8000 	nop.w

080145b0 <LSM303AGR_ACC_W_4D_on_INT2>:
* Input          : LSM303AGR_ACC_D4D_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_4D_on_INT2(void *handle, LSM303AGR_ACC_D4D_INT2_t newValue)
{
 80145b0:	b500      	push	{lr}
 80145b2:	b085      	sub	sp, #20
 80145b4:	9001      	str	r0, [sp, #4]
 80145b6:	460b      	mov	r3, r1
 80145b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80145bc:	f10d 030f 	add.w	r3, sp, #15
 80145c0:	9801      	ldr	r0, [sp, #4]
 80145c2:	2124      	movs	r1, #36	; 0x24
 80145c4:	461a      	mov	r2, r3
 80145c6:	2301      	movs	r3, #1
 80145c8:	f7fe fc82 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80145cc:	4603      	mov	r3, r0
 80145ce:	2b00      	cmp	r3, #0
 80145d0:	d101      	bne.n	80145d6 <LSM303AGR_ACC_W_4D_on_INT2+0x26>
    return MEMS_ERROR;
 80145d2:	2300      	movs	r3, #0
 80145d4:	e01c      	b.n	8014610 <LSM303AGR_ACC_W_4D_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_D4D_INT2_MASK;
 80145d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80145da:	f023 0301 	bic.w	r3, r3, #1
 80145de:	b2db      	uxtb	r3, r3
 80145e0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80145e4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80145e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80145ec:	4313      	orrs	r3, r2
 80145ee:	b2db      	uxtb	r3, r3
 80145f0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80145f4:	f10d 030f 	add.w	r3, sp, #15
 80145f8:	9801      	ldr	r0, [sp, #4]
 80145fa:	2124      	movs	r1, #36	; 0x24
 80145fc:	461a      	mov	r2, r3
 80145fe:	2301      	movs	r3, #1
 8014600:	f7fe fc3e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014604:	4603      	mov	r3, r0
 8014606:	2b00      	cmp	r3, #0
 8014608:	d101      	bne.n	801460e <LSM303AGR_ACC_W_4D_on_INT2+0x5e>
    return MEMS_ERROR;
 801460a:	2300      	movs	r3, #0
 801460c:	e000      	b.n	8014610 <LSM303AGR_ACC_W_4D_on_INT2+0x60>

  return MEMS_SUCCESS;
 801460e:	2301      	movs	r3, #1
}
 8014610:	4618      	mov	r0, r3
 8014612:	b005      	add	sp, #20
 8014614:	f85d fb04 	ldr.w	pc, [sp], #4
 8014618:	f3af 8000 	nop.w
 801461c:	f3af 8000 	nop.w

08014620 <LSM303AGR_ACC_R_4D_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_D4D_INT2_t
* Output         : Status of D4D_INT2 see LSM303AGR_ACC_D4D_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_4D_on_INT2(void *handle, LSM303AGR_ACC_D4D_INT2_t *value)
{
 8014620:	b500      	push	{lr}
 8014622:	b083      	sub	sp, #12
 8014624:	9001      	str	r0, [sp, #4]
 8014626:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8014628:	9801      	ldr	r0, [sp, #4]
 801462a:	2124      	movs	r1, #36	; 0x24
 801462c:	9a00      	ldr	r2, [sp, #0]
 801462e:	2301      	movs	r3, #1
 8014630:	f7fe fc4e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014634:	4603      	mov	r3, r0
 8014636:	2b00      	cmp	r3, #0
 8014638:	d101      	bne.n	801463e <LSM303AGR_ACC_R_4D_on_INT2+0x1e>
    return MEMS_ERROR;
 801463a:	2300      	movs	r3, #0
 801463c:	e007      	b.n	801464e <LSM303AGR_ACC_R_4D_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_D4D_INT2_MASK; //mask
 801463e:	9b00      	ldr	r3, [sp, #0]
 8014640:	781b      	ldrb	r3, [r3, #0]
 8014642:	f003 0301 	and.w	r3, r3, #1
 8014646:	b2da      	uxtb	r2, r3
 8014648:	9b00      	ldr	r3, [sp, #0]
 801464a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801464c:	2301      	movs	r3, #1
}
 801464e:	4618      	mov	r0, r3
 8014650:	b003      	add	sp, #12
 8014652:	f85d fb04 	ldr.w	pc, [sp], #4
 8014656:	bf00      	nop
 8014658:	f3af 8000 	nop.w
 801465c:	f3af 8000 	nop.w

08014660 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2>:
* Input          : LSM303AGR_ACC_LIR_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LatchInterrupt_on_INT2(void *handle, LSM303AGR_ACC_LIR_INT2_t newValue)
{
 8014660:	b500      	push	{lr}
 8014662:	b085      	sub	sp, #20
 8014664:	9001      	str	r0, [sp, #4]
 8014666:	460b      	mov	r3, r1
 8014668:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 801466c:	f10d 030f 	add.w	r3, sp, #15
 8014670:	9801      	ldr	r0, [sp, #4]
 8014672:	2124      	movs	r1, #36	; 0x24
 8014674:	461a      	mov	r2, r3
 8014676:	2301      	movs	r3, #1
 8014678:	f7fe fc2a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801467c:	4603      	mov	r3, r0
 801467e:	2b00      	cmp	r3, #0
 8014680:	d101      	bne.n	8014686 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x26>
    return MEMS_ERROR;
 8014682:	2300      	movs	r3, #0
 8014684:	e01c      	b.n	80146c0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_LIR_INT2_MASK;
 8014686:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801468a:	f023 0302 	bic.w	r3, r3, #2
 801468e:	b2db      	uxtb	r3, r3
 8014690:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014694:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014698:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801469c:	4313      	orrs	r3, r2
 801469e:	b2db      	uxtb	r3, r3
 80146a0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80146a4:	f10d 030f 	add.w	r3, sp, #15
 80146a8:	9801      	ldr	r0, [sp, #4]
 80146aa:	2124      	movs	r1, #36	; 0x24
 80146ac:	461a      	mov	r2, r3
 80146ae:	2301      	movs	r3, #1
 80146b0:	f7fe fbe6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80146b4:	4603      	mov	r3, r0
 80146b6:	2b00      	cmp	r3, #0
 80146b8:	d101      	bne.n	80146be <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x5e>
    return MEMS_ERROR;
 80146ba:	2300      	movs	r3, #0
 80146bc:	e000      	b.n	80146c0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x60>

  return MEMS_SUCCESS;
 80146be:	2301      	movs	r3, #1
}
 80146c0:	4618      	mov	r0, r3
 80146c2:	b005      	add	sp, #20
 80146c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80146c8:	f3af 8000 	nop.w
 80146cc:	f3af 8000 	nop.w

080146d0 <LSM303AGR_ACC_R_LatchInterrupt_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_LIR_INT2_t
* Output         : Status of LIR_INT2 see LSM303AGR_ACC_LIR_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LatchInterrupt_on_INT2(void *handle, LSM303AGR_ACC_LIR_INT2_t *value)
{
 80146d0:	b500      	push	{lr}
 80146d2:	b083      	sub	sp, #12
 80146d4:	9001      	str	r0, [sp, #4]
 80146d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 80146d8:	9801      	ldr	r0, [sp, #4]
 80146da:	2124      	movs	r1, #36	; 0x24
 80146dc:	9a00      	ldr	r2, [sp, #0]
 80146de:	2301      	movs	r3, #1
 80146e0:	f7fe fbf6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80146e4:	4603      	mov	r3, r0
 80146e6:	2b00      	cmp	r3, #0
 80146e8:	d101      	bne.n	80146ee <LSM303AGR_ACC_R_LatchInterrupt_on_INT2+0x1e>
    return MEMS_ERROR;
 80146ea:	2300      	movs	r3, #0
 80146ec:	e007      	b.n	80146fe <LSM303AGR_ACC_R_LatchInterrupt_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_LIR_INT2_MASK; //mask
 80146ee:	9b00      	ldr	r3, [sp, #0]
 80146f0:	781b      	ldrb	r3, [r3, #0]
 80146f2:	f003 0302 	and.w	r3, r3, #2
 80146f6:	b2da      	uxtb	r2, r3
 80146f8:	9b00      	ldr	r3, [sp, #0]
 80146fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80146fc:	2301      	movs	r3, #1
}
 80146fe:	4618      	mov	r0, r3
 8014700:	b003      	add	sp, #12
 8014702:	f85d fb04 	ldr.w	pc, [sp], #4
 8014706:	bf00      	nop
 8014708:	f3af 8000 	nop.w
 801470c:	f3af 8000 	nop.w

08014710 <LSM303AGR_ACC_W_4D_on_INT1>:
* Input          : LSM303AGR_ACC_D4D_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_4D_on_INT1(void *handle, LSM303AGR_ACC_D4D_INT1_t newValue)
{
 8014710:	b500      	push	{lr}
 8014712:	b085      	sub	sp, #20
 8014714:	9001      	str	r0, [sp, #4]
 8014716:	460b      	mov	r3, r1
 8014718:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 801471c:	f10d 030f 	add.w	r3, sp, #15
 8014720:	9801      	ldr	r0, [sp, #4]
 8014722:	2124      	movs	r1, #36	; 0x24
 8014724:	461a      	mov	r2, r3
 8014726:	2301      	movs	r3, #1
 8014728:	f7fe fbd2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801472c:	4603      	mov	r3, r0
 801472e:	2b00      	cmp	r3, #0
 8014730:	d101      	bne.n	8014736 <LSM303AGR_ACC_W_4D_on_INT1+0x26>
    return MEMS_ERROR;
 8014732:	2300      	movs	r3, #0
 8014734:	e01c      	b.n	8014770 <LSM303AGR_ACC_W_4D_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_D4D_INT1_MASK;
 8014736:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801473a:	f023 0304 	bic.w	r3, r3, #4
 801473e:	b2db      	uxtb	r3, r3
 8014740:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014744:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014748:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801474c:	4313      	orrs	r3, r2
 801474e:	b2db      	uxtb	r3, r3
 8014750:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8014754:	f10d 030f 	add.w	r3, sp, #15
 8014758:	9801      	ldr	r0, [sp, #4]
 801475a:	2124      	movs	r1, #36	; 0x24
 801475c:	461a      	mov	r2, r3
 801475e:	2301      	movs	r3, #1
 8014760:	f7fe fb8e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014764:	4603      	mov	r3, r0
 8014766:	2b00      	cmp	r3, #0
 8014768:	d101      	bne.n	801476e <LSM303AGR_ACC_W_4D_on_INT1+0x5e>
    return MEMS_ERROR;
 801476a:	2300      	movs	r3, #0
 801476c:	e000      	b.n	8014770 <LSM303AGR_ACC_W_4D_on_INT1+0x60>

  return MEMS_SUCCESS;
 801476e:	2301      	movs	r3, #1
}
 8014770:	4618      	mov	r0, r3
 8014772:	b005      	add	sp, #20
 8014774:	f85d fb04 	ldr.w	pc, [sp], #4
 8014778:	f3af 8000 	nop.w
 801477c:	f3af 8000 	nop.w

08014780 <LSM303AGR_ACC_R_4D_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_D4D_INT1_t
* Output         : Status of D4D_INT1 see LSM303AGR_ACC_D4D_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_4D_on_INT1(void *handle, LSM303AGR_ACC_D4D_INT1_t *value)
{
 8014780:	b500      	push	{lr}
 8014782:	b083      	sub	sp, #12
 8014784:	9001      	str	r0, [sp, #4]
 8014786:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8014788:	9801      	ldr	r0, [sp, #4]
 801478a:	2124      	movs	r1, #36	; 0x24
 801478c:	9a00      	ldr	r2, [sp, #0]
 801478e:	2301      	movs	r3, #1
 8014790:	f7fe fb9e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014794:	4603      	mov	r3, r0
 8014796:	2b00      	cmp	r3, #0
 8014798:	d101      	bne.n	801479e <LSM303AGR_ACC_R_4D_on_INT1+0x1e>
    return MEMS_ERROR;
 801479a:	2300      	movs	r3, #0
 801479c:	e007      	b.n	80147ae <LSM303AGR_ACC_R_4D_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_D4D_INT1_MASK; //mask
 801479e:	9b00      	ldr	r3, [sp, #0]
 80147a0:	781b      	ldrb	r3, [r3, #0]
 80147a2:	f003 0304 	and.w	r3, r3, #4
 80147a6:	b2da      	uxtb	r2, r3
 80147a8:	9b00      	ldr	r3, [sp, #0]
 80147aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80147ac:	2301      	movs	r3, #1
}
 80147ae:	4618      	mov	r0, r3
 80147b0:	b003      	add	sp, #12
 80147b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80147b6:	bf00      	nop
 80147b8:	f3af 8000 	nop.w
 80147bc:	f3af 8000 	nop.w

080147c0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1>:
* Input          : LSM303AGR_ACC_LIR_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LatchInterrupt_on_INT1(void *handle, LSM303AGR_ACC_LIR_INT1_t newValue)
{
 80147c0:	b500      	push	{lr}
 80147c2:	b085      	sub	sp, #20
 80147c4:	9001      	str	r0, [sp, #4]
 80147c6:	460b      	mov	r3, r1
 80147c8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80147cc:	f10d 030f 	add.w	r3, sp, #15
 80147d0:	9801      	ldr	r0, [sp, #4]
 80147d2:	2124      	movs	r1, #36	; 0x24
 80147d4:	461a      	mov	r2, r3
 80147d6:	2301      	movs	r3, #1
 80147d8:	f7fe fb7a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80147dc:	4603      	mov	r3, r0
 80147de:	2b00      	cmp	r3, #0
 80147e0:	d101      	bne.n	80147e6 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x26>
    return MEMS_ERROR;
 80147e2:	2300      	movs	r3, #0
 80147e4:	e01c      	b.n	8014820 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_LIR_INT1_MASK;
 80147e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80147ea:	f023 0308 	bic.w	r3, r3, #8
 80147ee:	b2db      	uxtb	r3, r3
 80147f0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80147f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80147f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80147fc:	4313      	orrs	r3, r2
 80147fe:	b2db      	uxtb	r3, r3
 8014800:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8014804:	f10d 030f 	add.w	r3, sp, #15
 8014808:	9801      	ldr	r0, [sp, #4]
 801480a:	2124      	movs	r1, #36	; 0x24
 801480c:	461a      	mov	r2, r3
 801480e:	2301      	movs	r3, #1
 8014810:	f7fe fb36 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014814:	4603      	mov	r3, r0
 8014816:	2b00      	cmp	r3, #0
 8014818:	d101      	bne.n	801481e <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x5e>
    return MEMS_ERROR;
 801481a:	2300      	movs	r3, #0
 801481c:	e000      	b.n	8014820 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x60>

  return MEMS_SUCCESS;
 801481e:	2301      	movs	r3, #1
}
 8014820:	4618      	mov	r0, r3
 8014822:	b005      	add	sp, #20
 8014824:	f85d fb04 	ldr.w	pc, [sp], #4
 8014828:	f3af 8000 	nop.w
 801482c:	f3af 8000 	nop.w

08014830 <LSM303AGR_ACC_R_LatchInterrupt_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_LIR_INT1_t
* Output         : Status of LIR_INT1 see LSM303AGR_ACC_LIR_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LatchInterrupt_on_INT1(void *handle, LSM303AGR_ACC_LIR_INT1_t *value)
{
 8014830:	b500      	push	{lr}
 8014832:	b083      	sub	sp, #12
 8014834:	9001      	str	r0, [sp, #4]
 8014836:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8014838:	9801      	ldr	r0, [sp, #4]
 801483a:	2124      	movs	r1, #36	; 0x24
 801483c:	9a00      	ldr	r2, [sp, #0]
 801483e:	2301      	movs	r3, #1
 8014840:	f7fe fb46 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014844:	4603      	mov	r3, r0
 8014846:	2b00      	cmp	r3, #0
 8014848:	d101      	bne.n	801484e <LSM303AGR_ACC_R_LatchInterrupt_on_INT1+0x1e>
    return MEMS_ERROR;
 801484a:	2300      	movs	r3, #0
 801484c:	e007      	b.n	801485e <LSM303AGR_ACC_R_LatchInterrupt_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_LIR_INT1_MASK; //mask
 801484e:	9b00      	ldr	r3, [sp, #0]
 8014850:	781b      	ldrb	r3, [r3, #0]
 8014852:	f003 0308 	and.w	r3, r3, #8
 8014856:	b2da      	uxtb	r2, r3
 8014858:	9b00      	ldr	r3, [sp, #0]
 801485a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801485c:	2301      	movs	r3, #1
}
 801485e:	4618      	mov	r0, r3
 8014860:	b003      	add	sp, #12
 8014862:	f85d fb04 	ldr.w	pc, [sp], #4
 8014866:	bf00      	nop
 8014868:	f3af 8000 	nop.w
 801486c:	f3af 8000 	nop.w

08014870 <LSM303AGR_ACC_W_FIFO_EN>:
* Input          : LSM303AGR_ACC_FIFO_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_EN(void *handle, LSM303AGR_ACC_FIFO_EN_t newValue)
{
 8014870:	b500      	push	{lr}
 8014872:	b085      	sub	sp, #20
 8014874:	9001      	str	r0, [sp, #4]
 8014876:	460b      	mov	r3, r1
 8014878:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 801487c:	f10d 030f 	add.w	r3, sp, #15
 8014880:	9801      	ldr	r0, [sp, #4]
 8014882:	2124      	movs	r1, #36	; 0x24
 8014884:	461a      	mov	r2, r3
 8014886:	2301      	movs	r3, #1
 8014888:	f7fe fb22 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801488c:	4603      	mov	r3, r0
 801488e:	2b00      	cmp	r3, #0
 8014890:	d101      	bne.n	8014896 <LSM303AGR_ACC_W_FIFO_EN+0x26>
    return MEMS_ERROR;
 8014892:	2300      	movs	r3, #0
 8014894:	e01c      	b.n	80148d0 <LSM303AGR_ACC_W_FIFO_EN+0x60>

  value &= ~LSM303AGR_ACC_FIFO_EN_MASK;
 8014896:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801489a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801489e:	b2db      	uxtb	r3, r3
 80148a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80148a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80148a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80148ac:	4313      	orrs	r3, r2
 80148ae:	b2db      	uxtb	r3, r3
 80148b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80148b4:	f10d 030f 	add.w	r3, sp, #15
 80148b8:	9801      	ldr	r0, [sp, #4]
 80148ba:	2124      	movs	r1, #36	; 0x24
 80148bc:	461a      	mov	r2, r3
 80148be:	2301      	movs	r3, #1
 80148c0:	f7fe fade 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80148c4:	4603      	mov	r3, r0
 80148c6:	2b00      	cmp	r3, #0
 80148c8:	d101      	bne.n	80148ce <LSM303AGR_ACC_W_FIFO_EN+0x5e>
    return MEMS_ERROR;
 80148ca:	2300      	movs	r3, #0
 80148cc:	e000      	b.n	80148d0 <LSM303AGR_ACC_W_FIFO_EN+0x60>

  return MEMS_SUCCESS;
 80148ce:	2301      	movs	r3, #1
}
 80148d0:	4618      	mov	r0, r3
 80148d2:	b005      	add	sp, #20
 80148d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80148d8:	f3af 8000 	nop.w
 80148dc:	f3af 8000 	nop.w

080148e0 <LSM303AGR_ACC_R_FIFO_EN>:
* Input          : Pointer to LSM303AGR_ACC_FIFO_EN_t
* Output         : Status of FIFO_EN see LSM303AGR_ACC_FIFO_EN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_EN(void *handle, LSM303AGR_ACC_FIFO_EN_t *value)
{
 80148e0:	b500      	push	{lr}
 80148e2:	b083      	sub	sp, #12
 80148e4:	9001      	str	r0, [sp, #4]
 80148e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 80148e8:	9801      	ldr	r0, [sp, #4]
 80148ea:	2124      	movs	r1, #36	; 0x24
 80148ec:	9a00      	ldr	r2, [sp, #0]
 80148ee:	2301      	movs	r3, #1
 80148f0:	f7fe faee 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80148f4:	4603      	mov	r3, r0
 80148f6:	2b00      	cmp	r3, #0
 80148f8:	d101      	bne.n	80148fe <LSM303AGR_ACC_R_FIFO_EN+0x1e>
    return MEMS_ERROR;
 80148fa:	2300      	movs	r3, #0
 80148fc:	e007      	b.n	801490e <LSM303AGR_ACC_R_FIFO_EN+0x2e>

  *value &= LSM303AGR_ACC_FIFO_EN_MASK; //mask
 80148fe:	9b00      	ldr	r3, [sp, #0]
 8014900:	781b      	ldrb	r3, [r3, #0]
 8014902:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014906:	b2da      	uxtb	r2, r3
 8014908:	9b00      	ldr	r3, [sp, #0]
 801490a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801490c:	2301      	movs	r3, #1
}
 801490e:	4618      	mov	r0, r3
 8014910:	b003      	add	sp, #12
 8014912:	f85d fb04 	ldr.w	pc, [sp], #4
 8014916:	bf00      	nop
 8014918:	f3af 8000 	nop.w
 801491c:	f3af 8000 	nop.w

08014920 <LSM303AGR_ACC_W_RebootMemory>:
* Input          : LSM303AGR_ACC_BOOT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_RebootMemory(void *handle, LSM303AGR_ACC_BOOT_t newValue)
{
 8014920:	b500      	push	{lr}
 8014922:	b085      	sub	sp, #20
 8014924:	9001      	str	r0, [sp, #4]
 8014926:	460b      	mov	r3, r1
 8014928:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 801492c:	f10d 030f 	add.w	r3, sp, #15
 8014930:	9801      	ldr	r0, [sp, #4]
 8014932:	2124      	movs	r1, #36	; 0x24
 8014934:	461a      	mov	r2, r3
 8014936:	2301      	movs	r3, #1
 8014938:	f7fe faca 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801493c:	4603      	mov	r3, r0
 801493e:	2b00      	cmp	r3, #0
 8014940:	d101      	bne.n	8014946 <LSM303AGR_ACC_W_RebootMemory+0x26>
    return MEMS_ERROR;
 8014942:	2300      	movs	r3, #0
 8014944:	e01c      	b.n	8014980 <LSM303AGR_ACC_W_RebootMemory+0x60>

  value &= ~LSM303AGR_ACC_BOOT_MASK;
 8014946:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801494a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801494e:	b2db      	uxtb	r3, r3
 8014950:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014954:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014958:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801495c:	4313      	orrs	r3, r2
 801495e:	b2db      	uxtb	r3, r3
 8014960:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8014964:	f10d 030f 	add.w	r3, sp, #15
 8014968:	9801      	ldr	r0, [sp, #4]
 801496a:	2124      	movs	r1, #36	; 0x24
 801496c:	461a      	mov	r2, r3
 801496e:	2301      	movs	r3, #1
 8014970:	f7fe fa86 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014974:	4603      	mov	r3, r0
 8014976:	2b00      	cmp	r3, #0
 8014978:	d101      	bne.n	801497e <LSM303AGR_ACC_W_RebootMemory+0x5e>
    return MEMS_ERROR;
 801497a:	2300      	movs	r3, #0
 801497c:	e000      	b.n	8014980 <LSM303AGR_ACC_W_RebootMemory+0x60>

  return MEMS_SUCCESS;
 801497e:	2301      	movs	r3, #1
}
 8014980:	4618      	mov	r0, r3
 8014982:	b005      	add	sp, #20
 8014984:	f85d fb04 	ldr.w	pc, [sp], #4
 8014988:	f3af 8000 	nop.w
 801498c:	f3af 8000 	nop.w

08014990 <LSM303AGR_ACC_R_RebootMemory>:
* Input          : Pointer to LSM303AGR_ACC_BOOT_t
* Output         : Status of BOOT see LSM303AGR_ACC_BOOT_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_RebootMemory(void *handle, LSM303AGR_ACC_BOOT_t *value)
{
 8014990:	b500      	push	{lr}
 8014992:	b083      	sub	sp, #12
 8014994:	9001      	str	r0, [sp, #4]
 8014996:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8014998:	9801      	ldr	r0, [sp, #4]
 801499a:	2124      	movs	r1, #36	; 0x24
 801499c:	9a00      	ldr	r2, [sp, #0]
 801499e:	2301      	movs	r3, #1
 80149a0:	f7fe fa96 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80149a4:	4603      	mov	r3, r0
 80149a6:	2b00      	cmp	r3, #0
 80149a8:	d101      	bne.n	80149ae <LSM303AGR_ACC_R_RebootMemory+0x1e>
    return MEMS_ERROR;
 80149aa:	2300      	movs	r3, #0
 80149ac:	e007      	b.n	80149be <LSM303AGR_ACC_R_RebootMemory+0x2e>

  *value &= LSM303AGR_ACC_BOOT_MASK; //mask
 80149ae:	9b00      	ldr	r3, [sp, #0]
 80149b0:	781b      	ldrb	r3, [r3, #0]
 80149b2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80149b6:	b2da      	uxtb	r2, r3
 80149b8:	9b00      	ldr	r3, [sp, #0]
 80149ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80149bc:	2301      	movs	r3, #1
}
 80149be:	4618      	mov	r0, r3
 80149c0:	b003      	add	sp, #12
 80149c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80149c6:	bf00      	nop
 80149c8:	f3af 8000 	nop.w
 80149cc:	f3af 8000 	nop.w

080149d0 <LSM303AGR_ACC_W_IntActive>:
* Input          : LSM303AGR_ACC_H_LACTIVE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_IntActive(void *handle, LSM303AGR_ACC_H_LACTIVE_t newValue)
{
 80149d0:	b500      	push	{lr}
 80149d2:	b085      	sub	sp, #20
 80149d4:	9001      	str	r0, [sp, #4]
 80149d6:	460b      	mov	r3, r1
 80149d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 80149dc:	f10d 030f 	add.w	r3, sp, #15
 80149e0:	9801      	ldr	r0, [sp, #4]
 80149e2:	2125      	movs	r1, #37	; 0x25
 80149e4:	461a      	mov	r2, r3
 80149e6:	2301      	movs	r3, #1
 80149e8:	f7fe fa72 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80149ec:	4603      	mov	r3, r0
 80149ee:	2b00      	cmp	r3, #0
 80149f0:	d101      	bne.n	80149f6 <LSM303AGR_ACC_W_IntActive+0x26>
    return MEMS_ERROR;
 80149f2:	2300      	movs	r3, #0
 80149f4:	e01c      	b.n	8014a30 <LSM303AGR_ACC_W_IntActive+0x60>

  value &= ~LSM303AGR_ACC_H_LACTIVE_MASK;
 80149f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80149fa:	f023 0302 	bic.w	r3, r3, #2
 80149fe:	b2db      	uxtb	r3, r3
 8014a00:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014a04:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014a08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014a0c:	4313      	orrs	r3, r2
 8014a0e:	b2db      	uxtb	r3, r3
 8014a10:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014a14:	f10d 030f 	add.w	r3, sp, #15
 8014a18:	9801      	ldr	r0, [sp, #4]
 8014a1a:	2125      	movs	r1, #37	; 0x25
 8014a1c:	461a      	mov	r2, r3
 8014a1e:	2301      	movs	r3, #1
 8014a20:	f7fe fa2e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014a24:	4603      	mov	r3, r0
 8014a26:	2b00      	cmp	r3, #0
 8014a28:	d101      	bne.n	8014a2e <LSM303AGR_ACC_W_IntActive+0x5e>
    return MEMS_ERROR;
 8014a2a:	2300      	movs	r3, #0
 8014a2c:	e000      	b.n	8014a30 <LSM303AGR_ACC_W_IntActive+0x60>

  return MEMS_SUCCESS;
 8014a2e:	2301      	movs	r3, #1
}
 8014a30:	4618      	mov	r0, r3
 8014a32:	b005      	add	sp, #20
 8014a34:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a38:	f3af 8000 	nop.w
 8014a3c:	f3af 8000 	nop.w

08014a40 <LSM303AGR_ACC_R_IntActive>:
* Input          : Pointer to LSM303AGR_ACC_H_LACTIVE_t
* Output         : Status of H_LACTIVE see LSM303AGR_ACC_H_LACTIVE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_IntActive(void *handle, LSM303AGR_ACC_H_LACTIVE_t *value)
{
 8014a40:	b500      	push	{lr}
 8014a42:	b083      	sub	sp, #12
 8014a44:	9001      	str	r0, [sp, #4]
 8014a46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8014a48:	9801      	ldr	r0, [sp, #4]
 8014a4a:	2125      	movs	r1, #37	; 0x25
 8014a4c:	9a00      	ldr	r2, [sp, #0]
 8014a4e:	2301      	movs	r3, #1
 8014a50:	f7fe fa3e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014a54:	4603      	mov	r3, r0
 8014a56:	2b00      	cmp	r3, #0
 8014a58:	d101      	bne.n	8014a5e <LSM303AGR_ACC_R_IntActive+0x1e>
    return MEMS_ERROR;
 8014a5a:	2300      	movs	r3, #0
 8014a5c:	e007      	b.n	8014a6e <LSM303AGR_ACC_R_IntActive+0x2e>

  *value &= LSM303AGR_ACC_H_LACTIVE_MASK; //mask
 8014a5e:	9b00      	ldr	r3, [sp, #0]
 8014a60:	781b      	ldrb	r3, [r3, #0]
 8014a62:	f003 0302 	and.w	r3, r3, #2
 8014a66:	b2da      	uxtb	r2, r3
 8014a68:	9b00      	ldr	r3, [sp, #0]
 8014a6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014a6c:	2301      	movs	r3, #1
}
 8014a6e:	4618      	mov	r0, r3
 8014a70:	b003      	add	sp, #12
 8014a72:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a76:	bf00      	nop
 8014a78:	f3af 8000 	nop.w
 8014a7c:	f3af 8000 	nop.w

08014a80 <LSM303AGR_ACC_W_P2_ACT>:
* Input          : LSM303AGR_ACC_P2_ACT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_P2_ACT(void *handle, LSM303AGR_ACC_P2_ACT_t newValue)
{
 8014a80:	b500      	push	{lr}
 8014a82:	b085      	sub	sp, #20
 8014a84:	9001      	str	r0, [sp, #4]
 8014a86:	460b      	mov	r3, r1
 8014a88:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014a8c:	f10d 030f 	add.w	r3, sp, #15
 8014a90:	9801      	ldr	r0, [sp, #4]
 8014a92:	2125      	movs	r1, #37	; 0x25
 8014a94:	461a      	mov	r2, r3
 8014a96:	2301      	movs	r3, #1
 8014a98:	f7fe fa1a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014a9c:	4603      	mov	r3, r0
 8014a9e:	2b00      	cmp	r3, #0
 8014aa0:	d101      	bne.n	8014aa6 <LSM303AGR_ACC_W_P2_ACT+0x26>
    return MEMS_ERROR;
 8014aa2:	2300      	movs	r3, #0
 8014aa4:	e01c      	b.n	8014ae0 <LSM303AGR_ACC_W_P2_ACT+0x60>

  value &= ~LSM303AGR_ACC_P2_ACT_MASK;
 8014aa6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014aaa:	f023 0308 	bic.w	r3, r3, #8
 8014aae:	b2db      	uxtb	r3, r3
 8014ab0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014ab4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014ab8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014abc:	4313      	orrs	r3, r2
 8014abe:	b2db      	uxtb	r3, r3
 8014ac0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014ac4:	f10d 030f 	add.w	r3, sp, #15
 8014ac8:	9801      	ldr	r0, [sp, #4]
 8014aca:	2125      	movs	r1, #37	; 0x25
 8014acc:	461a      	mov	r2, r3
 8014ace:	2301      	movs	r3, #1
 8014ad0:	f7fe f9d6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014ad4:	4603      	mov	r3, r0
 8014ad6:	2b00      	cmp	r3, #0
 8014ad8:	d101      	bne.n	8014ade <LSM303AGR_ACC_W_P2_ACT+0x5e>
    return MEMS_ERROR;
 8014ada:	2300      	movs	r3, #0
 8014adc:	e000      	b.n	8014ae0 <LSM303AGR_ACC_W_P2_ACT+0x60>

  return MEMS_SUCCESS;
 8014ade:	2301      	movs	r3, #1
}
 8014ae0:	4618      	mov	r0, r3
 8014ae2:	b005      	add	sp, #20
 8014ae4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ae8:	f3af 8000 	nop.w
 8014aec:	f3af 8000 	nop.w

08014af0 <LSM303AGR_ACC_R_P2_ACT>:
* Input          : Pointer to LSM303AGR_ACC_P2_ACT_t
* Output         : Status of P2_ACT see LSM303AGR_ACC_P2_ACT_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_P2_ACT(void *handle, LSM303AGR_ACC_P2_ACT_t *value)
{
 8014af0:	b500      	push	{lr}
 8014af2:	b083      	sub	sp, #12
 8014af4:	9001      	str	r0, [sp, #4]
 8014af6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8014af8:	9801      	ldr	r0, [sp, #4]
 8014afa:	2125      	movs	r1, #37	; 0x25
 8014afc:	9a00      	ldr	r2, [sp, #0]
 8014afe:	2301      	movs	r3, #1
 8014b00:	f7fe f9e6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014b04:	4603      	mov	r3, r0
 8014b06:	2b00      	cmp	r3, #0
 8014b08:	d101      	bne.n	8014b0e <LSM303AGR_ACC_R_P2_ACT+0x1e>
    return MEMS_ERROR;
 8014b0a:	2300      	movs	r3, #0
 8014b0c:	e007      	b.n	8014b1e <LSM303AGR_ACC_R_P2_ACT+0x2e>

  *value &= LSM303AGR_ACC_P2_ACT_MASK; //mask
 8014b0e:	9b00      	ldr	r3, [sp, #0]
 8014b10:	781b      	ldrb	r3, [r3, #0]
 8014b12:	f003 0308 	and.w	r3, r3, #8
 8014b16:	b2da      	uxtb	r2, r3
 8014b18:	9b00      	ldr	r3, [sp, #0]
 8014b1a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014b1c:	2301      	movs	r3, #1
}
 8014b1e:	4618      	mov	r0, r3
 8014b20:	b003      	add	sp, #12
 8014b22:	f85d fb04 	ldr.w	pc, [sp], #4
 8014b26:	bf00      	nop
 8014b28:	f3af 8000 	nop.w
 8014b2c:	f3af 8000 	nop.w

08014b30 <LSM303AGR_ACC_W_Boot_on_INT2>:
* Input          : LSM303AGR_ACC_BOOT_I1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Boot_on_INT2(void *handle, LSM303AGR_ACC_BOOT_I1_t newValue)
{
 8014b30:	b500      	push	{lr}
 8014b32:	b085      	sub	sp, #20
 8014b34:	9001      	str	r0, [sp, #4]
 8014b36:	460b      	mov	r3, r1
 8014b38:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014b3c:	f10d 030f 	add.w	r3, sp, #15
 8014b40:	9801      	ldr	r0, [sp, #4]
 8014b42:	2125      	movs	r1, #37	; 0x25
 8014b44:	461a      	mov	r2, r3
 8014b46:	2301      	movs	r3, #1
 8014b48:	f7fe f9c2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014b4c:	4603      	mov	r3, r0
 8014b4e:	2b00      	cmp	r3, #0
 8014b50:	d101      	bne.n	8014b56 <LSM303AGR_ACC_W_Boot_on_INT2+0x26>
    return MEMS_ERROR;
 8014b52:	2300      	movs	r3, #0
 8014b54:	e01c      	b.n	8014b90 <LSM303AGR_ACC_W_Boot_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_BOOT_I1_MASK;
 8014b56:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014b5a:	f023 0310 	bic.w	r3, r3, #16
 8014b5e:	b2db      	uxtb	r3, r3
 8014b60:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014b64:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014b68:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014b6c:	4313      	orrs	r3, r2
 8014b6e:	b2db      	uxtb	r3, r3
 8014b70:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014b74:	f10d 030f 	add.w	r3, sp, #15
 8014b78:	9801      	ldr	r0, [sp, #4]
 8014b7a:	2125      	movs	r1, #37	; 0x25
 8014b7c:	461a      	mov	r2, r3
 8014b7e:	2301      	movs	r3, #1
 8014b80:	f7fe f97e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014b84:	4603      	mov	r3, r0
 8014b86:	2b00      	cmp	r3, #0
 8014b88:	d101      	bne.n	8014b8e <LSM303AGR_ACC_W_Boot_on_INT2+0x5e>
    return MEMS_ERROR;
 8014b8a:	2300      	movs	r3, #0
 8014b8c:	e000      	b.n	8014b90 <LSM303AGR_ACC_W_Boot_on_INT2+0x60>

  return MEMS_SUCCESS;
 8014b8e:	2301      	movs	r3, #1
}
 8014b90:	4618      	mov	r0, r3
 8014b92:	b005      	add	sp, #20
 8014b94:	f85d fb04 	ldr.w	pc, [sp], #4
 8014b98:	f3af 8000 	nop.w
 8014b9c:	f3af 8000 	nop.w

08014ba0 <LSM303AGR_ACC_R_Boot_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_BOOT_I1_t
* Output         : Status of BOOT_I1 see LSM303AGR_ACC_BOOT_I1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Boot_on_INT2(void *handle, LSM303AGR_ACC_BOOT_I1_t *value)
{
 8014ba0:	b500      	push	{lr}
 8014ba2:	b083      	sub	sp, #12
 8014ba4:	9001      	str	r0, [sp, #4]
 8014ba6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8014ba8:	9801      	ldr	r0, [sp, #4]
 8014baa:	2125      	movs	r1, #37	; 0x25
 8014bac:	9a00      	ldr	r2, [sp, #0]
 8014bae:	2301      	movs	r3, #1
 8014bb0:	f7fe f98e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014bb4:	4603      	mov	r3, r0
 8014bb6:	2b00      	cmp	r3, #0
 8014bb8:	d101      	bne.n	8014bbe <LSM303AGR_ACC_R_Boot_on_INT2+0x1e>
    return MEMS_ERROR;
 8014bba:	2300      	movs	r3, #0
 8014bbc:	e007      	b.n	8014bce <LSM303AGR_ACC_R_Boot_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_BOOT_I1_MASK; //mask
 8014bbe:	9b00      	ldr	r3, [sp, #0]
 8014bc0:	781b      	ldrb	r3, [r3, #0]
 8014bc2:	f003 0310 	and.w	r3, r3, #16
 8014bc6:	b2da      	uxtb	r2, r3
 8014bc8:	9b00      	ldr	r3, [sp, #0]
 8014bca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014bcc:	2301      	movs	r3, #1
}
 8014bce:	4618      	mov	r0, r3
 8014bd0:	b003      	add	sp, #12
 8014bd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014bd6:	bf00      	nop
 8014bd8:	f3af 8000 	nop.w
 8014bdc:	f3af 8000 	nop.w

08014be0 <LSM303AGR_ACC_W_I2_on_INT2>:
* Input          : LSM303AGR_ACC_I2_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_I2_on_INT2(void *handle, LSM303AGR_ACC_I2_INT2_t newValue)
{
 8014be0:	b500      	push	{lr}
 8014be2:	b085      	sub	sp, #20
 8014be4:	9001      	str	r0, [sp, #4]
 8014be6:	460b      	mov	r3, r1
 8014be8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014bec:	f10d 030f 	add.w	r3, sp, #15
 8014bf0:	9801      	ldr	r0, [sp, #4]
 8014bf2:	2125      	movs	r1, #37	; 0x25
 8014bf4:	461a      	mov	r2, r3
 8014bf6:	2301      	movs	r3, #1
 8014bf8:	f7fe f96a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014bfc:	4603      	mov	r3, r0
 8014bfe:	2b00      	cmp	r3, #0
 8014c00:	d101      	bne.n	8014c06 <LSM303AGR_ACC_W_I2_on_INT2+0x26>
    return MEMS_ERROR;
 8014c02:	2300      	movs	r3, #0
 8014c04:	e01c      	b.n	8014c40 <LSM303AGR_ACC_W_I2_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_I2_INT2_MASK;
 8014c06:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014c0a:	f023 0320 	bic.w	r3, r3, #32
 8014c0e:	b2db      	uxtb	r3, r3
 8014c10:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014c14:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014c18:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014c1c:	4313      	orrs	r3, r2
 8014c1e:	b2db      	uxtb	r3, r3
 8014c20:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014c24:	f10d 030f 	add.w	r3, sp, #15
 8014c28:	9801      	ldr	r0, [sp, #4]
 8014c2a:	2125      	movs	r1, #37	; 0x25
 8014c2c:	461a      	mov	r2, r3
 8014c2e:	2301      	movs	r3, #1
 8014c30:	f7fe f926 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014c34:	4603      	mov	r3, r0
 8014c36:	2b00      	cmp	r3, #0
 8014c38:	d101      	bne.n	8014c3e <LSM303AGR_ACC_W_I2_on_INT2+0x5e>
    return MEMS_ERROR;
 8014c3a:	2300      	movs	r3, #0
 8014c3c:	e000      	b.n	8014c40 <LSM303AGR_ACC_W_I2_on_INT2+0x60>

  return MEMS_SUCCESS;
 8014c3e:	2301      	movs	r3, #1
}
 8014c40:	4618      	mov	r0, r3
 8014c42:	b005      	add	sp, #20
 8014c44:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c48:	f3af 8000 	nop.w
 8014c4c:	f3af 8000 	nop.w

08014c50 <LSM303AGR_ACC_R_I2_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_I2_INT2_t
* Output         : Status of I2_INT2 see LSM303AGR_ACC_I2_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_I2_on_INT2(void *handle, LSM303AGR_ACC_I2_INT2_t *value)
{
 8014c50:	b500      	push	{lr}
 8014c52:	b083      	sub	sp, #12
 8014c54:	9001      	str	r0, [sp, #4]
 8014c56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8014c58:	9801      	ldr	r0, [sp, #4]
 8014c5a:	2125      	movs	r1, #37	; 0x25
 8014c5c:	9a00      	ldr	r2, [sp, #0]
 8014c5e:	2301      	movs	r3, #1
 8014c60:	f7fe f936 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014c64:	4603      	mov	r3, r0
 8014c66:	2b00      	cmp	r3, #0
 8014c68:	d101      	bne.n	8014c6e <LSM303AGR_ACC_R_I2_on_INT2+0x1e>
    return MEMS_ERROR;
 8014c6a:	2300      	movs	r3, #0
 8014c6c:	e007      	b.n	8014c7e <LSM303AGR_ACC_R_I2_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_I2_INT2_MASK; //mask
 8014c6e:	9b00      	ldr	r3, [sp, #0]
 8014c70:	781b      	ldrb	r3, [r3, #0]
 8014c72:	f003 0320 	and.w	r3, r3, #32
 8014c76:	b2da      	uxtb	r2, r3
 8014c78:	9b00      	ldr	r3, [sp, #0]
 8014c7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014c7c:	2301      	movs	r3, #1
}
 8014c7e:	4618      	mov	r0, r3
 8014c80:	b003      	add	sp, #12
 8014c82:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c86:	bf00      	nop
 8014c88:	f3af 8000 	nop.w
 8014c8c:	f3af 8000 	nop.w

08014c90 <LSM303AGR_ACC_W_I2_on_INT1>:
* Input          : LSM303AGR_ACC_I2_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_I2_on_INT1(void *handle, LSM303AGR_ACC_I2_INT1_t newValue)
{
 8014c90:	b500      	push	{lr}
 8014c92:	b085      	sub	sp, #20
 8014c94:	9001      	str	r0, [sp, #4]
 8014c96:	460b      	mov	r3, r1
 8014c98:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014c9c:	f10d 030f 	add.w	r3, sp, #15
 8014ca0:	9801      	ldr	r0, [sp, #4]
 8014ca2:	2125      	movs	r1, #37	; 0x25
 8014ca4:	461a      	mov	r2, r3
 8014ca6:	2301      	movs	r3, #1
 8014ca8:	f7fe f912 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014cac:	4603      	mov	r3, r0
 8014cae:	2b00      	cmp	r3, #0
 8014cb0:	d101      	bne.n	8014cb6 <LSM303AGR_ACC_W_I2_on_INT1+0x26>
    return MEMS_ERROR;
 8014cb2:	2300      	movs	r3, #0
 8014cb4:	e01c      	b.n	8014cf0 <LSM303AGR_ACC_W_I2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I2_INT1_MASK;
 8014cb6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014cba:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8014cbe:	b2db      	uxtb	r3, r3
 8014cc0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014cc4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014cc8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014ccc:	4313      	orrs	r3, r2
 8014cce:	b2db      	uxtb	r3, r3
 8014cd0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014cd4:	f10d 030f 	add.w	r3, sp, #15
 8014cd8:	9801      	ldr	r0, [sp, #4]
 8014cda:	2125      	movs	r1, #37	; 0x25
 8014cdc:	461a      	mov	r2, r3
 8014cde:	2301      	movs	r3, #1
 8014ce0:	f7fe f8ce 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014ce4:	4603      	mov	r3, r0
 8014ce6:	2b00      	cmp	r3, #0
 8014ce8:	d101      	bne.n	8014cee <LSM303AGR_ACC_W_I2_on_INT1+0x5e>
    return MEMS_ERROR;
 8014cea:	2300      	movs	r3, #0
 8014cec:	e000      	b.n	8014cf0 <LSM303AGR_ACC_W_I2_on_INT1+0x60>

  return MEMS_SUCCESS;
 8014cee:	2301      	movs	r3, #1
}
 8014cf0:	4618      	mov	r0, r3
 8014cf2:	b005      	add	sp, #20
 8014cf4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014cf8:	f3af 8000 	nop.w
 8014cfc:	f3af 8000 	nop.w

08014d00 <LSM303AGR_ACC_R_I2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I2_INT1_t
* Output         : Status of I2_INT1 see LSM303AGR_ACC_I2_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_I2_on_INT1(void *handle, LSM303AGR_ACC_I2_INT1_t *value)
{
 8014d00:	b500      	push	{lr}
 8014d02:	b083      	sub	sp, #12
 8014d04:	9001      	str	r0, [sp, #4]
 8014d06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8014d08:	9801      	ldr	r0, [sp, #4]
 8014d0a:	2125      	movs	r1, #37	; 0x25
 8014d0c:	9a00      	ldr	r2, [sp, #0]
 8014d0e:	2301      	movs	r3, #1
 8014d10:	f7fe f8de 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014d14:	4603      	mov	r3, r0
 8014d16:	2b00      	cmp	r3, #0
 8014d18:	d101      	bne.n	8014d1e <LSM303AGR_ACC_R_I2_on_INT1+0x1e>
    return MEMS_ERROR;
 8014d1a:	2300      	movs	r3, #0
 8014d1c:	e007      	b.n	8014d2e <LSM303AGR_ACC_R_I2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I2_INT1_MASK; //mask
 8014d1e:	9b00      	ldr	r3, [sp, #0]
 8014d20:	781b      	ldrb	r3, [r3, #0]
 8014d22:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014d26:	b2da      	uxtb	r2, r3
 8014d28:	9b00      	ldr	r3, [sp, #0]
 8014d2a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014d2c:	2301      	movs	r3, #1
}
 8014d2e:	4618      	mov	r0, r3
 8014d30:	b003      	add	sp, #12
 8014d32:	f85d fb04 	ldr.w	pc, [sp], #4
 8014d36:	bf00      	nop
 8014d38:	f3af 8000 	nop.w
 8014d3c:	f3af 8000 	nop.w

08014d40 <LSM303AGR_ACC_W_Click_on_INT2>:
* Input          : LSM303AGR_ACC_I2_CLICKEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Click_on_INT2(void *handle, LSM303AGR_ACC_I2_CLICKEN_t newValue)
{
 8014d40:	b500      	push	{lr}
 8014d42:	b085      	sub	sp, #20
 8014d44:	9001      	str	r0, [sp, #4]
 8014d46:	460b      	mov	r3, r1
 8014d48:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014d4c:	f10d 030f 	add.w	r3, sp, #15
 8014d50:	9801      	ldr	r0, [sp, #4]
 8014d52:	2125      	movs	r1, #37	; 0x25
 8014d54:	461a      	mov	r2, r3
 8014d56:	2301      	movs	r3, #1
 8014d58:	f7fe f8ba 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014d5c:	4603      	mov	r3, r0
 8014d5e:	2b00      	cmp	r3, #0
 8014d60:	d101      	bne.n	8014d66 <LSM303AGR_ACC_W_Click_on_INT2+0x26>
    return MEMS_ERROR;
 8014d62:	2300      	movs	r3, #0
 8014d64:	e01c      	b.n	8014da0 <LSM303AGR_ACC_W_Click_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_I2_CLICKEN_MASK;
 8014d66:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014d6a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8014d6e:	b2db      	uxtb	r3, r3
 8014d70:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014d74:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014d78:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014d7c:	4313      	orrs	r3, r2
 8014d7e:	b2db      	uxtb	r3, r3
 8014d80:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014d84:	f10d 030f 	add.w	r3, sp, #15
 8014d88:	9801      	ldr	r0, [sp, #4]
 8014d8a:	2125      	movs	r1, #37	; 0x25
 8014d8c:	461a      	mov	r2, r3
 8014d8e:	2301      	movs	r3, #1
 8014d90:	f7fe f876 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014d94:	4603      	mov	r3, r0
 8014d96:	2b00      	cmp	r3, #0
 8014d98:	d101      	bne.n	8014d9e <LSM303AGR_ACC_W_Click_on_INT2+0x5e>
    return MEMS_ERROR;
 8014d9a:	2300      	movs	r3, #0
 8014d9c:	e000      	b.n	8014da0 <LSM303AGR_ACC_W_Click_on_INT2+0x60>

  return MEMS_SUCCESS;
 8014d9e:	2301      	movs	r3, #1
}
 8014da0:	4618      	mov	r0, r3
 8014da2:	b005      	add	sp, #20
 8014da4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014da8:	f3af 8000 	nop.w
 8014dac:	f3af 8000 	nop.w

08014db0 <LSM303AGR_ACC_R_Click_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_I2_CLICKEN_t
* Output         : Status of I2_CLICKEN see LSM303AGR_ACC_I2_CLICKEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Click_on_INT2(void *handle, LSM303AGR_ACC_I2_CLICKEN_t *value)
{
 8014db0:	b500      	push	{lr}
 8014db2:	b083      	sub	sp, #12
 8014db4:	9001      	str	r0, [sp, #4]
 8014db6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8014db8:	9801      	ldr	r0, [sp, #4]
 8014dba:	2125      	movs	r1, #37	; 0x25
 8014dbc:	9a00      	ldr	r2, [sp, #0]
 8014dbe:	2301      	movs	r3, #1
 8014dc0:	f7fe f886 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014dc4:	4603      	mov	r3, r0
 8014dc6:	2b00      	cmp	r3, #0
 8014dc8:	d101      	bne.n	8014dce <LSM303AGR_ACC_R_Click_on_INT2+0x1e>
    return MEMS_ERROR;
 8014dca:	2300      	movs	r3, #0
 8014dcc:	e007      	b.n	8014dde <LSM303AGR_ACC_R_Click_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_I2_CLICKEN_MASK; //mask
 8014dce:	9b00      	ldr	r3, [sp, #0]
 8014dd0:	781b      	ldrb	r3, [r3, #0]
 8014dd2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8014dd6:	b2da      	uxtb	r2, r3
 8014dd8:	9b00      	ldr	r3, [sp, #0]
 8014dda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014ddc:	2301      	movs	r3, #1
}
 8014dde:	4618      	mov	r0, r3
 8014de0:	b003      	add	sp, #12
 8014de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014de6:	bf00      	nop
 8014de8:	f3af 8000 	nop.w
 8014dec:	f3af 8000 	nop.w

08014df0 <LSM303AGR_ACC_W_ReferenceVal>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ReferenceVal(void *handle, u8_t newValue)
{
 8014df0:	b500      	push	{lr}
 8014df2:	b085      	sub	sp, #20
 8014df4:	9001      	str	r0, [sp, #4]
 8014df6:	460b      	mov	r3, r1
 8014df8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_REF_POSITION; //mask
  newValue &= LSM303AGR_ACC_REF_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_REFERENCE, &value, 1) )
 8014dfc:	f10d 030f 	add.w	r3, sp, #15
 8014e00:	9801      	ldr	r0, [sp, #4]
 8014e02:	2126      	movs	r1, #38	; 0x26
 8014e04:	461a      	mov	r2, r3
 8014e06:	2301      	movs	r3, #1
 8014e08:	f7fe f862 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014e0c:	4603      	mov	r3, r0
 8014e0e:	2b00      	cmp	r3, #0
 8014e10:	d101      	bne.n	8014e16 <LSM303AGR_ACC_W_ReferenceVal+0x26>
    return MEMS_ERROR;
 8014e12:	2300      	movs	r3, #0
 8014e14:	e018      	b.n	8014e48 <LSM303AGR_ACC_W_ReferenceVal+0x58>

  value &= (u8_t)~LSM303AGR_ACC_REF_MASK;
 8014e16:	2300      	movs	r3, #0
 8014e18:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014e1c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014e20:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014e24:	4313      	orrs	r3, r2
 8014e26:	b2db      	uxtb	r3, r3
 8014e28:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_REFERENCE, &value, 1) )
 8014e2c:	f10d 030f 	add.w	r3, sp, #15
 8014e30:	9801      	ldr	r0, [sp, #4]
 8014e32:	2126      	movs	r1, #38	; 0x26
 8014e34:	461a      	mov	r2, r3
 8014e36:	2301      	movs	r3, #1
 8014e38:	f7fe f822 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8014e3c:	4603      	mov	r3, r0
 8014e3e:	2b00      	cmp	r3, #0
 8014e40:	d101      	bne.n	8014e46 <LSM303AGR_ACC_W_ReferenceVal+0x56>
    return MEMS_ERROR;
 8014e42:	2300      	movs	r3, #0
 8014e44:	e000      	b.n	8014e48 <LSM303AGR_ACC_W_ReferenceVal+0x58>

  return MEMS_SUCCESS;
 8014e46:	2301      	movs	r3, #1
}
 8014e48:	4618      	mov	r0, r3
 8014e4a:	b005      	add	sp, #20
 8014e4c:	f85d fb04 	ldr.w	pc, [sp], #4

08014e50 <LSM303AGR_ACC_R_ReferenceVal>:
* Input          : Pointer to u8_t
* Output         : Status of REF
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ReferenceVal(void *handle, u8_t *value)
{
 8014e50:	b500      	push	{lr}
 8014e52:	b083      	sub	sp, #12
 8014e54:	9001      	str	r0, [sp, #4]
 8014e56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_REFERENCE, (u8_t *)value, 1) )
 8014e58:	9801      	ldr	r0, [sp, #4]
 8014e5a:	2126      	movs	r1, #38	; 0x26
 8014e5c:	9a00      	ldr	r2, [sp, #0]
 8014e5e:	2301      	movs	r3, #1
 8014e60:	f7fe f836 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014e64:	4603      	mov	r3, r0
 8014e66:	2b00      	cmp	r3, #0
 8014e68:	d101      	bne.n	8014e6e <LSM303AGR_ACC_R_ReferenceVal+0x1e>
    return MEMS_ERROR;
 8014e6a:	2300      	movs	r3, #0
 8014e6c:	e008      	b.n	8014e80 <LSM303AGR_ACC_R_ReferenceVal+0x30>

  *value &= LSM303AGR_ACC_REF_MASK; //coerce
 8014e6e:	9b00      	ldr	r3, [sp, #0]
 8014e70:	781a      	ldrb	r2, [r3, #0]
 8014e72:	9b00      	ldr	r3, [sp, #0]
 8014e74:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_REF_POSITION; //mask
 8014e76:	9b00      	ldr	r3, [sp, #0]
 8014e78:	781a      	ldrb	r2, [r3, #0]
 8014e7a:	9b00      	ldr	r3, [sp, #0]
 8014e7c:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014e7e:	2301      	movs	r3, #1
}
 8014e80:	4618      	mov	r0, r3
 8014e82:	b003      	add	sp, #12
 8014e84:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e88:	f3af 8000 	nop.w
 8014e8c:	f3af 8000 	nop.w

08014e90 <LSM303AGR_ACC_R_XDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_XDA_t
* Output         : Status of XDA see LSM303AGR_ACC_XDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataAvail(void *handle, LSM303AGR_ACC_XDA_t *value)
{
 8014e90:	b500      	push	{lr}
 8014e92:	b083      	sub	sp, #12
 8014e94:	9001      	str	r0, [sp, #4]
 8014e96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014e98:	9801      	ldr	r0, [sp, #4]
 8014e9a:	2127      	movs	r1, #39	; 0x27
 8014e9c:	9a00      	ldr	r2, [sp, #0]
 8014e9e:	2301      	movs	r3, #1
 8014ea0:	f7fe f816 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014ea4:	4603      	mov	r3, r0
 8014ea6:	2b00      	cmp	r3, #0
 8014ea8:	d101      	bne.n	8014eae <LSM303AGR_ACC_R_XDataAvail+0x1e>
    return MEMS_ERROR;
 8014eaa:	2300      	movs	r3, #0
 8014eac:	e007      	b.n	8014ebe <LSM303AGR_ACC_R_XDataAvail+0x2e>

  *value &= LSM303AGR_ACC_XDA_MASK; //mask
 8014eae:	9b00      	ldr	r3, [sp, #0]
 8014eb0:	781b      	ldrb	r3, [r3, #0]
 8014eb2:	f003 0301 	and.w	r3, r3, #1
 8014eb6:	b2da      	uxtb	r2, r3
 8014eb8:	9b00      	ldr	r3, [sp, #0]
 8014eba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014ebc:	2301      	movs	r3, #1
}
 8014ebe:	4618      	mov	r0, r3
 8014ec0:	b003      	add	sp, #12
 8014ec2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ec6:	bf00      	nop
 8014ec8:	f3af 8000 	nop.w
 8014ecc:	f3af 8000 	nop.w

08014ed0 <LSM303AGR_ACC_R_YDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_YDA_t
* Output         : Status of YDA see LSM303AGR_ACC_YDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDataAvail(void *handle, LSM303AGR_ACC_YDA_t *value)
{
 8014ed0:	b500      	push	{lr}
 8014ed2:	b083      	sub	sp, #12
 8014ed4:	9001      	str	r0, [sp, #4]
 8014ed6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014ed8:	9801      	ldr	r0, [sp, #4]
 8014eda:	2127      	movs	r1, #39	; 0x27
 8014edc:	9a00      	ldr	r2, [sp, #0]
 8014ede:	2301      	movs	r3, #1
 8014ee0:	f7fd fff6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014ee4:	4603      	mov	r3, r0
 8014ee6:	2b00      	cmp	r3, #0
 8014ee8:	d101      	bne.n	8014eee <LSM303AGR_ACC_R_YDataAvail+0x1e>
    return MEMS_ERROR;
 8014eea:	2300      	movs	r3, #0
 8014eec:	e007      	b.n	8014efe <LSM303AGR_ACC_R_YDataAvail+0x2e>

  *value &= LSM303AGR_ACC_YDA_MASK; //mask
 8014eee:	9b00      	ldr	r3, [sp, #0]
 8014ef0:	781b      	ldrb	r3, [r3, #0]
 8014ef2:	f003 0302 	and.w	r3, r3, #2
 8014ef6:	b2da      	uxtb	r2, r3
 8014ef8:	9b00      	ldr	r3, [sp, #0]
 8014efa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014efc:	2301      	movs	r3, #1
}
 8014efe:	4618      	mov	r0, r3
 8014f00:	b003      	add	sp, #12
 8014f02:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f06:	bf00      	nop
 8014f08:	f3af 8000 	nop.w
 8014f0c:	f3af 8000 	nop.w

08014f10 <LSM303AGR_ACC_R_ZDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_ZDA_t
* Output         : Status of ZDA see LSM303AGR_ACC_ZDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDataAvail(void *handle, LSM303AGR_ACC_ZDA_t *value)
{
 8014f10:	b500      	push	{lr}
 8014f12:	b083      	sub	sp, #12
 8014f14:	9001      	str	r0, [sp, #4]
 8014f16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014f18:	9801      	ldr	r0, [sp, #4]
 8014f1a:	2127      	movs	r1, #39	; 0x27
 8014f1c:	9a00      	ldr	r2, [sp, #0]
 8014f1e:	2301      	movs	r3, #1
 8014f20:	f7fd ffd6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014f24:	4603      	mov	r3, r0
 8014f26:	2b00      	cmp	r3, #0
 8014f28:	d101      	bne.n	8014f2e <LSM303AGR_ACC_R_ZDataAvail+0x1e>
    return MEMS_ERROR;
 8014f2a:	2300      	movs	r3, #0
 8014f2c:	e007      	b.n	8014f3e <LSM303AGR_ACC_R_ZDataAvail+0x2e>

  *value &= LSM303AGR_ACC_ZDA_MASK; //mask
 8014f2e:	9b00      	ldr	r3, [sp, #0]
 8014f30:	781b      	ldrb	r3, [r3, #0]
 8014f32:	f003 0304 	and.w	r3, r3, #4
 8014f36:	b2da      	uxtb	r2, r3
 8014f38:	9b00      	ldr	r3, [sp, #0]
 8014f3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014f3c:	2301      	movs	r3, #1
}
 8014f3e:	4618      	mov	r0, r3
 8014f40:	b003      	add	sp, #12
 8014f42:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f46:	bf00      	nop
 8014f48:	f3af 8000 	nop.w
 8014f4c:	f3af 8000 	nop.w

08014f50 <LSM303AGR_ACC_R_XYZDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_ZYXDA_t
* Output         : Status of ZYXDA see LSM303AGR_ACC_ZYXDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XYZDataAvail(void *handle, LSM303AGR_ACC_ZYXDA_t *value)
{
 8014f50:	b500      	push	{lr}
 8014f52:	b083      	sub	sp, #12
 8014f54:	9001      	str	r0, [sp, #4]
 8014f56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014f58:	9801      	ldr	r0, [sp, #4]
 8014f5a:	2127      	movs	r1, #39	; 0x27
 8014f5c:	9a00      	ldr	r2, [sp, #0]
 8014f5e:	2301      	movs	r3, #1
 8014f60:	f7fd ffb6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014f64:	4603      	mov	r3, r0
 8014f66:	2b00      	cmp	r3, #0
 8014f68:	d101      	bne.n	8014f6e <LSM303AGR_ACC_R_XYZDataAvail+0x1e>
    return MEMS_ERROR;
 8014f6a:	2300      	movs	r3, #0
 8014f6c:	e007      	b.n	8014f7e <LSM303AGR_ACC_R_XYZDataAvail+0x2e>

  *value &= LSM303AGR_ACC_ZYXDA_MASK; //mask
 8014f6e:	9b00      	ldr	r3, [sp, #0]
 8014f70:	781b      	ldrb	r3, [r3, #0]
 8014f72:	f003 0308 	and.w	r3, r3, #8
 8014f76:	b2da      	uxtb	r2, r3
 8014f78:	9b00      	ldr	r3, [sp, #0]
 8014f7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014f7c:	2301      	movs	r3, #1
}
 8014f7e:	4618      	mov	r0, r3
 8014f80:	b003      	add	sp, #12
 8014f82:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f86:	bf00      	nop
 8014f88:	f3af 8000 	nop.w
 8014f8c:	f3af 8000 	nop.w

08014f90 <LSM303AGR_ACC_R_XDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_XOR_t
* Output         : Status of XOR see LSM303AGR_ACC_XOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataOverrun(void *handle, LSM303AGR_ACC_XOR_t *value)
{
 8014f90:	b500      	push	{lr}
 8014f92:	b083      	sub	sp, #12
 8014f94:	9001      	str	r0, [sp, #4]
 8014f96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014f98:	9801      	ldr	r0, [sp, #4]
 8014f9a:	2127      	movs	r1, #39	; 0x27
 8014f9c:	9a00      	ldr	r2, [sp, #0]
 8014f9e:	2301      	movs	r3, #1
 8014fa0:	f7fd ff96 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014fa4:	4603      	mov	r3, r0
 8014fa6:	2b00      	cmp	r3, #0
 8014fa8:	d101      	bne.n	8014fae <LSM303AGR_ACC_R_XDataOverrun+0x1e>
    return MEMS_ERROR;
 8014faa:	2300      	movs	r3, #0
 8014fac:	e007      	b.n	8014fbe <LSM303AGR_ACC_R_XDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_XOR_MASK; //mask
 8014fae:	9b00      	ldr	r3, [sp, #0]
 8014fb0:	781b      	ldrb	r3, [r3, #0]
 8014fb2:	f003 0310 	and.w	r3, r3, #16
 8014fb6:	b2da      	uxtb	r2, r3
 8014fb8:	9b00      	ldr	r3, [sp, #0]
 8014fba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014fbc:	2301      	movs	r3, #1
}
 8014fbe:	4618      	mov	r0, r3
 8014fc0:	b003      	add	sp, #12
 8014fc2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014fc6:	bf00      	nop
 8014fc8:	f3af 8000 	nop.w
 8014fcc:	f3af 8000 	nop.w

08014fd0 <LSM303AGR_ACC_R_YDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_YOR_t
* Output         : Status of YOR see LSM303AGR_ACC_YOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDataOverrun(void *handle, LSM303AGR_ACC_YOR_t *value)
{
 8014fd0:	b500      	push	{lr}
 8014fd2:	b083      	sub	sp, #12
 8014fd4:	9001      	str	r0, [sp, #4]
 8014fd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014fd8:	9801      	ldr	r0, [sp, #4]
 8014fda:	2127      	movs	r1, #39	; 0x27
 8014fdc:	9a00      	ldr	r2, [sp, #0]
 8014fde:	2301      	movs	r3, #1
 8014fe0:	f7fd ff76 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8014fe4:	4603      	mov	r3, r0
 8014fe6:	2b00      	cmp	r3, #0
 8014fe8:	d101      	bne.n	8014fee <LSM303AGR_ACC_R_YDataOverrun+0x1e>
    return MEMS_ERROR;
 8014fea:	2300      	movs	r3, #0
 8014fec:	e007      	b.n	8014ffe <LSM303AGR_ACC_R_YDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_YOR_MASK; //mask
 8014fee:	9b00      	ldr	r3, [sp, #0]
 8014ff0:	781b      	ldrb	r3, [r3, #0]
 8014ff2:	f003 0320 	and.w	r3, r3, #32
 8014ff6:	b2da      	uxtb	r2, r3
 8014ff8:	9b00      	ldr	r3, [sp, #0]
 8014ffa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014ffc:	2301      	movs	r3, #1
}
 8014ffe:	4618      	mov	r0, r3
 8015000:	b003      	add	sp, #12
 8015002:	f85d fb04 	ldr.w	pc, [sp], #4
 8015006:	bf00      	nop
 8015008:	f3af 8000 	nop.w
 801500c:	f3af 8000 	nop.w

08015010 <LSM303AGR_ACC_R_ZDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_ZOR_t
* Output         : Status of ZOR see LSM303AGR_ACC_ZOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDataOverrun(void *handle, LSM303AGR_ACC_ZOR_t *value)
{
 8015010:	b500      	push	{lr}
 8015012:	b083      	sub	sp, #12
 8015014:	9001      	str	r0, [sp, #4]
 8015016:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8015018:	9801      	ldr	r0, [sp, #4]
 801501a:	2127      	movs	r1, #39	; 0x27
 801501c:	9a00      	ldr	r2, [sp, #0]
 801501e:	2301      	movs	r3, #1
 8015020:	f7fd ff56 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015024:	4603      	mov	r3, r0
 8015026:	2b00      	cmp	r3, #0
 8015028:	d101      	bne.n	801502e <LSM303AGR_ACC_R_ZDataOverrun+0x1e>
    return MEMS_ERROR;
 801502a:	2300      	movs	r3, #0
 801502c:	e007      	b.n	801503e <LSM303AGR_ACC_R_ZDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_ZOR_MASK; //mask
 801502e:	9b00      	ldr	r3, [sp, #0]
 8015030:	781b      	ldrb	r3, [r3, #0]
 8015032:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015036:	b2da      	uxtb	r2, r3
 8015038:	9b00      	ldr	r3, [sp, #0]
 801503a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801503c:	2301      	movs	r3, #1
}
 801503e:	4618      	mov	r0, r3
 8015040:	b003      	add	sp, #12
 8015042:	f85d fb04 	ldr.w	pc, [sp], #4
 8015046:	bf00      	nop
 8015048:	f3af 8000 	nop.w
 801504c:	f3af 8000 	nop.w

08015050 <LSM303AGR_ACC_R_XYZDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_ZYXOR_t
* Output         : Status of ZYXOR see LSM303AGR_ACC_ZYXOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XYZDataOverrun(void *handle, LSM303AGR_ACC_ZYXOR_t *value)
{
 8015050:	b500      	push	{lr}
 8015052:	b083      	sub	sp, #12
 8015054:	9001      	str	r0, [sp, #4]
 8015056:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8015058:	9801      	ldr	r0, [sp, #4]
 801505a:	2127      	movs	r1, #39	; 0x27
 801505c:	9a00      	ldr	r2, [sp, #0]
 801505e:	2301      	movs	r3, #1
 8015060:	f7fd ff36 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015064:	4603      	mov	r3, r0
 8015066:	2b00      	cmp	r3, #0
 8015068:	d101      	bne.n	801506e <LSM303AGR_ACC_R_XYZDataOverrun+0x1e>
    return MEMS_ERROR;
 801506a:	2300      	movs	r3, #0
 801506c:	e007      	b.n	801507e <LSM303AGR_ACC_R_XYZDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_ZYXOR_MASK; //mask
 801506e:	9b00      	ldr	r3, [sp, #0]
 8015070:	781b      	ldrb	r3, [r3, #0]
 8015072:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8015076:	b2da      	uxtb	r2, r3
 8015078:	9b00      	ldr	r3, [sp, #0]
 801507a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801507c:	2301      	movs	r3, #1
}
 801507e:	4618      	mov	r0, r3
 8015080:	b003      	add	sp, #12
 8015082:	f85d fb04 	ldr.w	pc, [sp], #4
 8015086:	bf00      	nop
 8015088:	f3af 8000 	nop.w
 801508c:	f3af 8000 	nop.w

08015090 <LSM303AGR_ACC_W_FifoThreshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoThreshold(void *handle, u8_t newValue)
{
 8015090:	b500      	push	{lr}
 8015092:	b085      	sub	sp, #20
 8015094:	9001      	str	r0, [sp, #4]
 8015096:	460b      	mov	r3, r1
 8015098:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_FTH_POSITION; //mask
  newValue &= LSM303AGR_ACC_FTH_MASK; //coerce
 801509c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80150a0:	f003 031f 	and.w	r3, r3, #31
 80150a4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 80150a8:	f10d 030f 	add.w	r3, sp, #15
 80150ac:	9801      	ldr	r0, [sp, #4]
 80150ae:	212e      	movs	r1, #46	; 0x2e
 80150b0:	461a      	mov	r2, r3
 80150b2:	2301      	movs	r3, #1
 80150b4:	f7fd ff0c 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80150b8:	4603      	mov	r3, r0
 80150ba:	2b00      	cmp	r3, #0
 80150bc:	d101      	bne.n	80150c2 <LSM303AGR_ACC_W_FifoThreshold+0x32>
    return MEMS_ERROR;
 80150be:	2300      	movs	r3, #0
 80150c0:	e01c      	b.n	80150fc <LSM303AGR_ACC_W_FifoThreshold+0x6c>

  value &= ~LSM303AGR_ACC_FTH_MASK;
 80150c2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80150c6:	f023 031f 	bic.w	r3, r3, #31
 80150ca:	b2db      	uxtb	r3, r3
 80150cc:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80150d0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80150d4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80150d8:	4313      	orrs	r3, r2
 80150da:	b2db      	uxtb	r3, r3
 80150dc:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 80150e0:	f10d 030f 	add.w	r3, sp, #15
 80150e4:	9801      	ldr	r0, [sp, #4]
 80150e6:	212e      	movs	r1, #46	; 0x2e
 80150e8:	461a      	mov	r2, r3
 80150ea:	2301      	movs	r3, #1
 80150ec:	f7fd fec8 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80150f0:	4603      	mov	r3, r0
 80150f2:	2b00      	cmp	r3, #0
 80150f4:	d101      	bne.n	80150fa <LSM303AGR_ACC_W_FifoThreshold+0x6a>
    return MEMS_ERROR;
 80150f6:	2300      	movs	r3, #0
 80150f8:	e000      	b.n	80150fc <LSM303AGR_ACC_W_FifoThreshold+0x6c>

  return MEMS_SUCCESS;
 80150fa:	2301      	movs	r3, #1
}
 80150fc:	4618      	mov	r0, r3
 80150fe:	b005      	add	sp, #20
 8015100:	f85d fb04 	ldr.w	pc, [sp], #4
 8015104:	f3af 8000 	nop.w
 8015108:	f3af 8000 	nop.w
 801510c:	f3af 8000 	nop.w

08015110 <LSM303AGR_ACC_R_FifoThreshold>:
* Input          : Pointer to u8_t
* Output         : Status of FTH
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoThreshold(void *handle, u8_t *value)
{
 8015110:	b500      	push	{lr}
 8015112:	b083      	sub	sp, #12
 8015114:	9001      	str	r0, [sp, #4]
 8015116:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 8015118:	9801      	ldr	r0, [sp, #4]
 801511a:	212e      	movs	r1, #46	; 0x2e
 801511c:	9a00      	ldr	r2, [sp, #0]
 801511e:	2301      	movs	r3, #1
 8015120:	f7fd fed6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015124:	4603      	mov	r3, r0
 8015126:	2b00      	cmp	r3, #0
 8015128:	d101      	bne.n	801512e <LSM303AGR_ACC_R_FifoThreshold+0x1e>
    return MEMS_ERROR;
 801512a:	2300      	movs	r3, #0
 801512c:	e00b      	b.n	8015146 <LSM303AGR_ACC_R_FifoThreshold+0x36>

  *value &= LSM303AGR_ACC_FTH_MASK; //coerce
 801512e:	9b00      	ldr	r3, [sp, #0]
 8015130:	781b      	ldrb	r3, [r3, #0]
 8015132:	f003 031f 	and.w	r3, r3, #31
 8015136:	b2da      	uxtb	r2, r3
 8015138:	9b00      	ldr	r3, [sp, #0]
 801513a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_FTH_POSITION; //mask
 801513c:	9b00      	ldr	r3, [sp, #0]
 801513e:	781a      	ldrb	r2, [r3, #0]
 8015140:	9b00      	ldr	r3, [sp, #0]
 8015142:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015144:	2301      	movs	r3, #1
}
 8015146:	4618      	mov	r0, r3
 8015148:	b003      	add	sp, #12
 801514a:	f85d fb04 	ldr.w	pc, [sp], #4
 801514e:	bf00      	nop

08015150 <LSM303AGR_ACC_W_TriggerSel>:
* Input          : LSM303AGR_ACC_TR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_TriggerSel(void *handle, LSM303AGR_ACC_TR_t newValue)
{
 8015150:	b500      	push	{lr}
 8015152:	b085      	sub	sp, #20
 8015154:	9001      	str	r0, [sp, #4]
 8015156:	460b      	mov	r3, r1
 8015158:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 801515c:	f10d 030f 	add.w	r3, sp, #15
 8015160:	9801      	ldr	r0, [sp, #4]
 8015162:	212e      	movs	r1, #46	; 0x2e
 8015164:	461a      	mov	r2, r3
 8015166:	2301      	movs	r3, #1
 8015168:	f7fd feb2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801516c:	4603      	mov	r3, r0
 801516e:	2b00      	cmp	r3, #0
 8015170:	d101      	bne.n	8015176 <LSM303AGR_ACC_W_TriggerSel+0x26>
    return MEMS_ERROR;
 8015172:	2300      	movs	r3, #0
 8015174:	e01c      	b.n	80151b0 <LSM303AGR_ACC_W_TriggerSel+0x60>

  value &= ~LSM303AGR_ACC_TR_MASK;
 8015176:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801517a:	f023 0320 	bic.w	r3, r3, #32
 801517e:	b2db      	uxtb	r3, r3
 8015180:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015184:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015188:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801518c:	4313      	orrs	r3, r2
 801518e:	b2db      	uxtb	r3, r3
 8015190:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 8015194:	f10d 030f 	add.w	r3, sp, #15
 8015198:	9801      	ldr	r0, [sp, #4]
 801519a:	212e      	movs	r1, #46	; 0x2e
 801519c:	461a      	mov	r2, r3
 801519e:	2301      	movs	r3, #1
 80151a0:	f7fd fe6e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80151a4:	4603      	mov	r3, r0
 80151a6:	2b00      	cmp	r3, #0
 80151a8:	d101      	bne.n	80151ae <LSM303AGR_ACC_W_TriggerSel+0x5e>
    return MEMS_ERROR;
 80151aa:	2300      	movs	r3, #0
 80151ac:	e000      	b.n	80151b0 <LSM303AGR_ACC_W_TriggerSel+0x60>

  return MEMS_SUCCESS;
 80151ae:	2301      	movs	r3, #1
}
 80151b0:	4618      	mov	r0, r3
 80151b2:	b005      	add	sp, #20
 80151b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80151b8:	f3af 8000 	nop.w
 80151bc:	f3af 8000 	nop.w

080151c0 <LSM303AGR_ACC_R_TriggerSel>:
* Input          : Pointer to LSM303AGR_ACC_TR_t
* Output         : Status of TR see LSM303AGR_ACC_TR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_TriggerSel(void *handle, LSM303AGR_ACC_TR_t *value)
{
 80151c0:	b500      	push	{lr}
 80151c2:	b083      	sub	sp, #12
 80151c4:	9001      	str	r0, [sp, #4]
 80151c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 80151c8:	9801      	ldr	r0, [sp, #4]
 80151ca:	212e      	movs	r1, #46	; 0x2e
 80151cc:	9a00      	ldr	r2, [sp, #0]
 80151ce:	2301      	movs	r3, #1
 80151d0:	f7fd fe7e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80151d4:	4603      	mov	r3, r0
 80151d6:	2b00      	cmp	r3, #0
 80151d8:	d101      	bne.n	80151de <LSM303AGR_ACC_R_TriggerSel+0x1e>
    return MEMS_ERROR;
 80151da:	2300      	movs	r3, #0
 80151dc:	e007      	b.n	80151ee <LSM303AGR_ACC_R_TriggerSel+0x2e>

  *value &= LSM303AGR_ACC_TR_MASK; //mask
 80151de:	9b00      	ldr	r3, [sp, #0]
 80151e0:	781b      	ldrb	r3, [r3, #0]
 80151e2:	f003 0320 	and.w	r3, r3, #32
 80151e6:	b2da      	uxtb	r2, r3
 80151e8:	9b00      	ldr	r3, [sp, #0]
 80151ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80151ec:	2301      	movs	r3, #1
}
 80151ee:	4618      	mov	r0, r3
 80151f0:	b003      	add	sp, #12
 80151f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80151f6:	bf00      	nop
 80151f8:	f3af 8000 	nop.w
 80151fc:	f3af 8000 	nop.w

08015200 <LSM303AGR_ACC_W_FifoMode>:
* Input          : LSM303AGR_ACC_FM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoMode(void *handle, LSM303AGR_ACC_FM_t newValue)
{
 8015200:	b500      	push	{lr}
 8015202:	b085      	sub	sp, #20
 8015204:	9001      	str	r0, [sp, #4]
 8015206:	460b      	mov	r3, r1
 8015208:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 801520c:	f10d 030f 	add.w	r3, sp, #15
 8015210:	9801      	ldr	r0, [sp, #4]
 8015212:	212e      	movs	r1, #46	; 0x2e
 8015214:	461a      	mov	r2, r3
 8015216:	2301      	movs	r3, #1
 8015218:	f7fd fe5a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801521c:	4603      	mov	r3, r0
 801521e:	2b00      	cmp	r3, #0
 8015220:	d101      	bne.n	8015226 <LSM303AGR_ACC_W_FifoMode+0x26>
    return MEMS_ERROR;
 8015222:	2300      	movs	r3, #0
 8015224:	e01c      	b.n	8015260 <LSM303AGR_ACC_W_FifoMode+0x60>

  value &= ~LSM303AGR_ACC_FM_MASK;
 8015226:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801522a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801522e:	b2db      	uxtb	r3, r3
 8015230:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015234:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015238:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801523c:	4313      	orrs	r3, r2
 801523e:	b2db      	uxtb	r3, r3
 8015240:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 8015244:	f10d 030f 	add.w	r3, sp, #15
 8015248:	9801      	ldr	r0, [sp, #4]
 801524a:	212e      	movs	r1, #46	; 0x2e
 801524c:	461a      	mov	r2, r3
 801524e:	2301      	movs	r3, #1
 8015250:	f7fd fe16 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015254:	4603      	mov	r3, r0
 8015256:	2b00      	cmp	r3, #0
 8015258:	d101      	bne.n	801525e <LSM303AGR_ACC_W_FifoMode+0x5e>
    return MEMS_ERROR;
 801525a:	2300      	movs	r3, #0
 801525c:	e000      	b.n	8015260 <LSM303AGR_ACC_W_FifoMode+0x60>

  return MEMS_SUCCESS;
 801525e:	2301      	movs	r3, #1
}
 8015260:	4618      	mov	r0, r3
 8015262:	b005      	add	sp, #20
 8015264:	f85d fb04 	ldr.w	pc, [sp], #4
 8015268:	f3af 8000 	nop.w
 801526c:	f3af 8000 	nop.w

08015270 <LSM303AGR_ACC_R_FifoMode>:
* Input          : Pointer to LSM303AGR_ACC_FM_t
* Output         : Status of FM see LSM303AGR_ACC_FM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoMode(void *handle, LSM303AGR_ACC_FM_t *value)
{
 8015270:	b500      	push	{lr}
 8015272:	b083      	sub	sp, #12
 8015274:	9001      	str	r0, [sp, #4]
 8015276:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 8015278:	9801      	ldr	r0, [sp, #4]
 801527a:	212e      	movs	r1, #46	; 0x2e
 801527c:	9a00      	ldr	r2, [sp, #0]
 801527e:	2301      	movs	r3, #1
 8015280:	f7fd fe26 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015284:	4603      	mov	r3, r0
 8015286:	2b00      	cmp	r3, #0
 8015288:	d101      	bne.n	801528e <LSM303AGR_ACC_R_FifoMode+0x1e>
    return MEMS_ERROR;
 801528a:	2300      	movs	r3, #0
 801528c:	e007      	b.n	801529e <LSM303AGR_ACC_R_FifoMode+0x2e>

  *value &= LSM303AGR_ACC_FM_MASK; //mask
 801528e:	9b00      	ldr	r3, [sp, #0]
 8015290:	781b      	ldrb	r3, [r3, #0]
 8015292:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8015296:	b2da      	uxtb	r2, r3
 8015298:	9b00      	ldr	r3, [sp, #0]
 801529a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801529c:	2301      	movs	r3, #1
}
 801529e:	4618      	mov	r0, r3
 80152a0:	b003      	add	sp, #12
 80152a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80152a6:	bf00      	nop
 80152a8:	f3af 8000 	nop.w
 80152ac:	f3af 8000 	nop.w

080152b0 <LSM303AGR_ACC_R_FifoSamplesAvail>:
* Input          : Pointer to u8_t
* Output         : Status of FSS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoSamplesAvail(void *handle, u8_t *value)
{
 80152b0:	b500      	push	{lr}
 80152b2:	b083      	sub	sp, #12
 80152b4:	9001      	str	r0, [sp, #4]
 80152b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 80152b8:	9801      	ldr	r0, [sp, #4]
 80152ba:	212f      	movs	r1, #47	; 0x2f
 80152bc:	9a00      	ldr	r2, [sp, #0]
 80152be:	2301      	movs	r3, #1
 80152c0:	f7fd fe06 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80152c4:	4603      	mov	r3, r0
 80152c6:	2b00      	cmp	r3, #0
 80152c8:	d101      	bne.n	80152ce <LSM303AGR_ACC_R_FifoSamplesAvail+0x1e>
    return MEMS_ERROR;
 80152ca:	2300      	movs	r3, #0
 80152cc:	e00b      	b.n	80152e6 <LSM303AGR_ACC_R_FifoSamplesAvail+0x36>

  *value &= LSM303AGR_ACC_FSS_MASK; //coerce
 80152ce:	9b00      	ldr	r3, [sp, #0]
 80152d0:	781b      	ldrb	r3, [r3, #0]
 80152d2:	f003 031f 	and.w	r3, r3, #31
 80152d6:	b2da      	uxtb	r2, r3
 80152d8:	9b00      	ldr	r3, [sp, #0]
 80152da:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_FSS_POSITION; //mask
 80152dc:	9b00      	ldr	r3, [sp, #0]
 80152de:	781a      	ldrb	r2, [r3, #0]
 80152e0:	9b00      	ldr	r3, [sp, #0]
 80152e2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80152e4:	2301      	movs	r3, #1
}
 80152e6:	4618      	mov	r0, r3
 80152e8:	b003      	add	sp, #12
 80152ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80152ee:	bf00      	nop

080152f0 <LSM303AGR_ACC_R_FifoEmpty>:
* Input          : Pointer to LSM303AGR_ACC_EMPTY_t
* Output         : Status of EMPTY see LSM303AGR_ACC_EMPTY_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoEmpty(void *handle, LSM303AGR_ACC_EMPTY_t *value)
{
 80152f0:	b500      	push	{lr}
 80152f2:	b083      	sub	sp, #12
 80152f4:	9001      	str	r0, [sp, #4]
 80152f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 80152f8:	9801      	ldr	r0, [sp, #4]
 80152fa:	212f      	movs	r1, #47	; 0x2f
 80152fc:	9a00      	ldr	r2, [sp, #0]
 80152fe:	2301      	movs	r3, #1
 8015300:	f7fd fde6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015304:	4603      	mov	r3, r0
 8015306:	2b00      	cmp	r3, #0
 8015308:	d101      	bne.n	801530e <LSM303AGR_ACC_R_FifoEmpty+0x1e>
    return MEMS_ERROR;
 801530a:	2300      	movs	r3, #0
 801530c:	e007      	b.n	801531e <LSM303AGR_ACC_R_FifoEmpty+0x2e>

  *value &= LSM303AGR_ACC_EMPTY_MASK; //mask
 801530e:	9b00      	ldr	r3, [sp, #0]
 8015310:	781b      	ldrb	r3, [r3, #0]
 8015312:	f003 0320 	and.w	r3, r3, #32
 8015316:	b2da      	uxtb	r2, r3
 8015318:	9b00      	ldr	r3, [sp, #0]
 801531a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801531c:	2301      	movs	r3, #1
}
 801531e:	4618      	mov	r0, r3
 8015320:	b003      	add	sp, #12
 8015322:	f85d fb04 	ldr.w	pc, [sp], #4
 8015326:	bf00      	nop
 8015328:	f3af 8000 	nop.w
 801532c:	f3af 8000 	nop.w

08015330 <LSM303AGR_ACC_R_FifoOverrun>:
* Input          : Pointer to LSM303AGR_ACC_OVRN_FIFO_t
* Output         : Status of OVRN_FIFO see LSM303AGR_ACC_OVRN_FIFO_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoOverrun(void *handle, LSM303AGR_ACC_OVRN_FIFO_t *value)
{
 8015330:	b500      	push	{lr}
 8015332:	b083      	sub	sp, #12
 8015334:	9001      	str	r0, [sp, #4]
 8015336:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8015338:	9801      	ldr	r0, [sp, #4]
 801533a:	212f      	movs	r1, #47	; 0x2f
 801533c:	9a00      	ldr	r2, [sp, #0]
 801533e:	2301      	movs	r3, #1
 8015340:	f7fd fdc6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015344:	4603      	mov	r3, r0
 8015346:	2b00      	cmp	r3, #0
 8015348:	d101      	bne.n	801534e <LSM303AGR_ACC_R_FifoOverrun+0x1e>
    return MEMS_ERROR;
 801534a:	2300      	movs	r3, #0
 801534c:	e007      	b.n	801535e <LSM303AGR_ACC_R_FifoOverrun+0x2e>

  *value &= LSM303AGR_ACC_OVRN_FIFO_MASK; //mask
 801534e:	9b00      	ldr	r3, [sp, #0]
 8015350:	781b      	ldrb	r3, [r3, #0]
 8015352:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015356:	b2da      	uxtb	r2, r3
 8015358:	9b00      	ldr	r3, [sp, #0]
 801535a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801535c:	2301      	movs	r3, #1
}
 801535e:	4618      	mov	r0, r3
 8015360:	b003      	add	sp, #12
 8015362:	f85d fb04 	ldr.w	pc, [sp], #4
 8015366:	bf00      	nop
 8015368:	f3af 8000 	nop.w
 801536c:	f3af 8000 	nop.w

08015370 <LSM303AGR_ACC_R_WatermarkLevel>:
* Input          : Pointer to LSM303AGR_ACC_WTM_t
* Output         : Status of WTM see LSM303AGR_ACC_WTM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WatermarkLevel(void *handle, LSM303AGR_ACC_WTM_t *value)
{
 8015370:	b500      	push	{lr}
 8015372:	b083      	sub	sp, #12
 8015374:	9001      	str	r0, [sp, #4]
 8015376:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8015378:	9801      	ldr	r0, [sp, #4]
 801537a:	212f      	movs	r1, #47	; 0x2f
 801537c:	9a00      	ldr	r2, [sp, #0]
 801537e:	2301      	movs	r3, #1
 8015380:	f7fd fda6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015384:	4603      	mov	r3, r0
 8015386:	2b00      	cmp	r3, #0
 8015388:	d101      	bne.n	801538e <LSM303AGR_ACC_R_WatermarkLevel+0x1e>
    return MEMS_ERROR;
 801538a:	2300      	movs	r3, #0
 801538c:	e007      	b.n	801539e <LSM303AGR_ACC_R_WatermarkLevel+0x2e>

  *value &= LSM303AGR_ACC_WTM_MASK; //mask
 801538e:	9b00      	ldr	r3, [sp, #0]
 8015390:	781b      	ldrb	r3, [r3, #0]
 8015392:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8015396:	b2da      	uxtb	r2, r3
 8015398:	9b00      	ldr	r3, [sp, #0]
 801539a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801539c:	2301      	movs	r3, #1
}
 801539e:	4618      	mov	r0, r3
 80153a0:	b003      	add	sp, #12
 80153a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80153a6:	bf00      	nop
 80153a8:	f3af 8000 	nop.w
 80153ac:	f3af 8000 	nop.w

080153b0 <LSM303AGR_ACC_W_Int1EnXLo>:
* Input          : LSM303AGR_ACC_XLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnXLo(void *handle, LSM303AGR_ACC_XLIE_t newValue)
{
 80153b0:	b500      	push	{lr}
 80153b2:	b085      	sub	sp, #20
 80153b4:	9001      	str	r0, [sp, #4]
 80153b6:	460b      	mov	r3, r1
 80153b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80153bc:	f10d 030f 	add.w	r3, sp, #15
 80153c0:	9801      	ldr	r0, [sp, #4]
 80153c2:	2130      	movs	r1, #48	; 0x30
 80153c4:	461a      	mov	r2, r3
 80153c6:	2301      	movs	r3, #1
 80153c8:	f7fd fd82 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80153cc:	4603      	mov	r3, r0
 80153ce:	2b00      	cmp	r3, #0
 80153d0:	d101      	bne.n	80153d6 <LSM303AGR_ACC_W_Int1EnXLo+0x26>
    return MEMS_ERROR;
 80153d2:	2300      	movs	r3, #0
 80153d4:	e01c      	b.n	8015410 <LSM303AGR_ACC_W_Int1EnXLo+0x60>

  value &= ~LSM303AGR_ACC_XLIE_MASK;
 80153d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80153da:	f023 0301 	bic.w	r3, r3, #1
 80153de:	b2db      	uxtb	r3, r3
 80153e0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80153e4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80153e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80153ec:	4313      	orrs	r3, r2
 80153ee:	b2db      	uxtb	r3, r3
 80153f0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80153f4:	f10d 030f 	add.w	r3, sp, #15
 80153f8:	9801      	ldr	r0, [sp, #4]
 80153fa:	2130      	movs	r1, #48	; 0x30
 80153fc:	461a      	mov	r2, r3
 80153fe:	2301      	movs	r3, #1
 8015400:	f7fd fd3e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015404:	4603      	mov	r3, r0
 8015406:	2b00      	cmp	r3, #0
 8015408:	d101      	bne.n	801540e <LSM303AGR_ACC_W_Int1EnXLo+0x5e>
    return MEMS_ERROR;
 801540a:	2300      	movs	r3, #0
 801540c:	e000      	b.n	8015410 <LSM303AGR_ACC_W_Int1EnXLo+0x60>

  return MEMS_SUCCESS;
 801540e:	2301      	movs	r3, #1
}
 8015410:	4618      	mov	r0, r3
 8015412:	b005      	add	sp, #20
 8015414:	f85d fb04 	ldr.w	pc, [sp], #4
 8015418:	f3af 8000 	nop.w
 801541c:	f3af 8000 	nop.w

08015420 <LSM303AGR_ACC_R_Int1EnXLo>:
* Input          : Pointer to LSM303AGR_ACC_XLIE_t
* Output         : Status of XLIE see LSM303AGR_ACC_XLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnXLo(void *handle, LSM303AGR_ACC_XLIE_t *value)
{
 8015420:	b500      	push	{lr}
 8015422:	b083      	sub	sp, #12
 8015424:	9001      	str	r0, [sp, #4]
 8015426:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8015428:	9801      	ldr	r0, [sp, #4]
 801542a:	2130      	movs	r1, #48	; 0x30
 801542c:	9a00      	ldr	r2, [sp, #0]
 801542e:	2301      	movs	r3, #1
 8015430:	f7fd fd4e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015434:	4603      	mov	r3, r0
 8015436:	2b00      	cmp	r3, #0
 8015438:	d101      	bne.n	801543e <LSM303AGR_ACC_R_Int1EnXLo+0x1e>
    return MEMS_ERROR;
 801543a:	2300      	movs	r3, #0
 801543c:	e007      	b.n	801544e <LSM303AGR_ACC_R_Int1EnXLo+0x2e>

  *value &= LSM303AGR_ACC_XLIE_MASK; //mask
 801543e:	9b00      	ldr	r3, [sp, #0]
 8015440:	781b      	ldrb	r3, [r3, #0]
 8015442:	f003 0301 	and.w	r3, r3, #1
 8015446:	b2da      	uxtb	r2, r3
 8015448:	9b00      	ldr	r3, [sp, #0]
 801544a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801544c:	2301      	movs	r3, #1
}
 801544e:	4618      	mov	r0, r3
 8015450:	b003      	add	sp, #12
 8015452:	f85d fb04 	ldr.w	pc, [sp], #4
 8015456:	bf00      	nop
 8015458:	f3af 8000 	nop.w
 801545c:	f3af 8000 	nop.w

08015460 <LSM303AGR_ACC_W_Int1EnXHi>:
* Input          : LSM303AGR_ACC_XHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnXHi(void *handle, LSM303AGR_ACC_XHIE_t newValue)
{
 8015460:	b500      	push	{lr}
 8015462:	b085      	sub	sp, #20
 8015464:	9001      	str	r0, [sp, #4]
 8015466:	460b      	mov	r3, r1
 8015468:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801546c:	f10d 030f 	add.w	r3, sp, #15
 8015470:	9801      	ldr	r0, [sp, #4]
 8015472:	2130      	movs	r1, #48	; 0x30
 8015474:	461a      	mov	r2, r3
 8015476:	2301      	movs	r3, #1
 8015478:	f7fd fd2a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801547c:	4603      	mov	r3, r0
 801547e:	2b00      	cmp	r3, #0
 8015480:	d101      	bne.n	8015486 <LSM303AGR_ACC_W_Int1EnXHi+0x26>
    return MEMS_ERROR;
 8015482:	2300      	movs	r3, #0
 8015484:	e01c      	b.n	80154c0 <LSM303AGR_ACC_W_Int1EnXHi+0x60>

  value &= ~LSM303AGR_ACC_XHIE_MASK;
 8015486:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801548a:	f023 0302 	bic.w	r3, r3, #2
 801548e:	b2db      	uxtb	r3, r3
 8015490:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015494:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015498:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801549c:	4313      	orrs	r3, r2
 801549e:	b2db      	uxtb	r3, r3
 80154a0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80154a4:	f10d 030f 	add.w	r3, sp, #15
 80154a8:	9801      	ldr	r0, [sp, #4]
 80154aa:	2130      	movs	r1, #48	; 0x30
 80154ac:	461a      	mov	r2, r3
 80154ae:	2301      	movs	r3, #1
 80154b0:	f7fd fce6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80154b4:	4603      	mov	r3, r0
 80154b6:	2b00      	cmp	r3, #0
 80154b8:	d101      	bne.n	80154be <LSM303AGR_ACC_W_Int1EnXHi+0x5e>
    return MEMS_ERROR;
 80154ba:	2300      	movs	r3, #0
 80154bc:	e000      	b.n	80154c0 <LSM303AGR_ACC_W_Int1EnXHi+0x60>

  return MEMS_SUCCESS;
 80154be:	2301      	movs	r3, #1
}
 80154c0:	4618      	mov	r0, r3
 80154c2:	b005      	add	sp, #20
 80154c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80154c8:	f3af 8000 	nop.w
 80154cc:	f3af 8000 	nop.w

080154d0 <LSM303AGR_ACC_R_Int1EnXHi>:
* Input          : Pointer to LSM303AGR_ACC_XHIE_t
* Output         : Status of XHIE see LSM303AGR_ACC_XHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnXHi(void *handle, LSM303AGR_ACC_XHIE_t *value)
{
 80154d0:	b500      	push	{lr}
 80154d2:	b083      	sub	sp, #12
 80154d4:	9001      	str	r0, [sp, #4]
 80154d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 80154d8:	9801      	ldr	r0, [sp, #4]
 80154da:	2130      	movs	r1, #48	; 0x30
 80154dc:	9a00      	ldr	r2, [sp, #0]
 80154de:	2301      	movs	r3, #1
 80154e0:	f7fd fcf6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80154e4:	4603      	mov	r3, r0
 80154e6:	2b00      	cmp	r3, #0
 80154e8:	d101      	bne.n	80154ee <LSM303AGR_ACC_R_Int1EnXHi+0x1e>
    return MEMS_ERROR;
 80154ea:	2300      	movs	r3, #0
 80154ec:	e007      	b.n	80154fe <LSM303AGR_ACC_R_Int1EnXHi+0x2e>

  *value &= LSM303AGR_ACC_XHIE_MASK; //mask
 80154ee:	9b00      	ldr	r3, [sp, #0]
 80154f0:	781b      	ldrb	r3, [r3, #0]
 80154f2:	f003 0302 	and.w	r3, r3, #2
 80154f6:	b2da      	uxtb	r2, r3
 80154f8:	9b00      	ldr	r3, [sp, #0]
 80154fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80154fc:	2301      	movs	r3, #1
}
 80154fe:	4618      	mov	r0, r3
 8015500:	b003      	add	sp, #12
 8015502:	f85d fb04 	ldr.w	pc, [sp], #4
 8015506:	bf00      	nop
 8015508:	f3af 8000 	nop.w
 801550c:	f3af 8000 	nop.w

08015510 <LSM303AGR_ACC_W_Int1EnYLo>:
* Input          : LSM303AGR_ACC_YLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnYLo(void *handle, LSM303AGR_ACC_YLIE_t newValue)
{
 8015510:	b500      	push	{lr}
 8015512:	b085      	sub	sp, #20
 8015514:	9001      	str	r0, [sp, #4]
 8015516:	460b      	mov	r3, r1
 8015518:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801551c:	f10d 030f 	add.w	r3, sp, #15
 8015520:	9801      	ldr	r0, [sp, #4]
 8015522:	2130      	movs	r1, #48	; 0x30
 8015524:	461a      	mov	r2, r3
 8015526:	2301      	movs	r3, #1
 8015528:	f7fd fcd2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801552c:	4603      	mov	r3, r0
 801552e:	2b00      	cmp	r3, #0
 8015530:	d101      	bne.n	8015536 <LSM303AGR_ACC_W_Int1EnYLo+0x26>
    return MEMS_ERROR;
 8015532:	2300      	movs	r3, #0
 8015534:	e01c      	b.n	8015570 <LSM303AGR_ACC_W_Int1EnYLo+0x60>

  value &= ~LSM303AGR_ACC_YLIE_MASK;
 8015536:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801553a:	f023 0304 	bic.w	r3, r3, #4
 801553e:	b2db      	uxtb	r3, r3
 8015540:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015544:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015548:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801554c:	4313      	orrs	r3, r2
 801554e:	b2db      	uxtb	r3, r3
 8015550:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8015554:	f10d 030f 	add.w	r3, sp, #15
 8015558:	9801      	ldr	r0, [sp, #4]
 801555a:	2130      	movs	r1, #48	; 0x30
 801555c:	461a      	mov	r2, r3
 801555e:	2301      	movs	r3, #1
 8015560:	f7fd fc8e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015564:	4603      	mov	r3, r0
 8015566:	2b00      	cmp	r3, #0
 8015568:	d101      	bne.n	801556e <LSM303AGR_ACC_W_Int1EnYLo+0x5e>
    return MEMS_ERROR;
 801556a:	2300      	movs	r3, #0
 801556c:	e000      	b.n	8015570 <LSM303AGR_ACC_W_Int1EnYLo+0x60>

  return MEMS_SUCCESS;
 801556e:	2301      	movs	r3, #1
}
 8015570:	4618      	mov	r0, r3
 8015572:	b005      	add	sp, #20
 8015574:	f85d fb04 	ldr.w	pc, [sp], #4
 8015578:	f3af 8000 	nop.w
 801557c:	f3af 8000 	nop.w

08015580 <LSM303AGR_ACC_R_Int1EnYLo>:
* Input          : Pointer to LSM303AGR_ACC_YLIE_t
* Output         : Status of YLIE see LSM303AGR_ACC_YLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnYLo(void *handle, LSM303AGR_ACC_YLIE_t *value)
{
 8015580:	b500      	push	{lr}
 8015582:	b083      	sub	sp, #12
 8015584:	9001      	str	r0, [sp, #4]
 8015586:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8015588:	9801      	ldr	r0, [sp, #4]
 801558a:	2130      	movs	r1, #48	; 0x30
 801558c:	9a00      	ldr	r2, [sp, #0]
 801558e:	2301      	movs	r3, #1
 8015590:	f7fd fc9e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015594:	4603      	mov	r3, r0
 8015596:	2b00      	cmp	r3, #0
 8015598:	d101      	bne.n	801559e <LSM303AGR_ACC_R_Int1EnYLo+0x1e>
    return MEMS_ERROR;
 801559a:	2300      	movs	r3, #0
 801559c:	e007      	b.n	80155ae <LSM303AGR_ACC_R_Int1EnYLo+0x2e>

  *value &= LSM303AGR_ACC_YLIE_MASK; //mask
 801559e:	9b00      	ldr	r3, [sp, #0]
 80155a0:	781b      	ldrb	r3, [r3, #0]
 80155a2:	f003 0304 	and.w	r3, r3, #4
 80155a6:	b2da      	uxtb	r2, r3
 80155a8:	9b00      	ldr	r3, [sp, #0]
 80155aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80155ac:	2301      	movs	r3, #1
}
 80155ae:	4618      	mov	r0, r3
 80155b0:	b003      	add	sp, #12
 80155b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80155b6:	bf00      	nop
 80155b8:	f3af 8000 	nop.w
 80155bc:	f3af 8000 	nop.w

080155c0 <LSM303AGR_ACC_W_Int1EnYHi>:
* Input          : LSM303AGR_ACC_YHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnYHi(void *handle, LSM303AGR_ACC_YHIE_t newValue)
{
 80155c0:	b500      	push	{lr}
 80155c2:	b085      	sub	sp, #20
 80155c4:	9001      	str	r0, [sp, #4]
 80155c6:	460b      	mov	r3, r1
 80155c8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80155cc:	f10d 030f 	add.w	r3, sp, #15
 80155d0:	9801      	ldr	r0, [sp, #4]
 80155d2:	2130      	movs	r1, #48	; 0x30
 80155d4:	461a      	mov	r2, r3
 80155d6:	2301      	movs	r3, #1
 80155d8:	f7fd fc7a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80155dc:	4603      	mov	r3, r0
 80155de:	2b00      	cmp	r3, #0
 80155e0:	d101      	bne.n	80155e6 <LSM303AGR_ACC_W_Int1EnYHi+0x26>
    return MEMS_ERROR;
 80155e2:	2300      	movs	r3, #0
 80155e4:	e01c      	b.n	8015620 <LSM303AGR_ACC_W_Int1EnYHi+0x60>

  value &= ~LSM303AGR_ACC_YHIE_MASK;
 80155e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80155ea:	f023 0308 	bic.w	r3, r3, #8
 80155ee:	b2db      	uxtb	r3, r3
 80155f0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80155f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80155f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80155fc:	4313      	orrs	r3, r2
 80155fe:	b2db      	uxtb	r3, r3
 8015600:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8015604:	f10d 030f 	add.w	r3, sp, #15
 8015608:	9801      	ldr	r0, [sp, #4]
 801560a:	2130      	movs	r1, #48	; 0x30
 801560c:	461a      	mov	r2, r3
 801560e:	2301      	movs	r3, #1
 8015610:	f7fd fc36 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015614:	4603      	mov	r3, r0
 8015616:	2b00      	cmp	r3, #0
 8015618:	d101      	bne.n	801561e <LSM303AGR_ACC_W_Int1EnYHi+0x5e>
    return MEMS_ERROR;
 801561a:	2300      	movs	r3, #0
 801561c:	e000      	b.n	8015620 <LSM303AGR_ACC_W_Int1EnYHi+0x60>

  return MEMS_SUCCESS;
 801561e:	2301      	movs	r3, #1
}
 8015620:	4618      	mov	r0, r3
 8015622:	b005      	add	sp, #20
 8015624:	f85d fb04 	ldr.w	pc, [sp], #4
 8015628:	f3af 8000 	nop.w
 801562c:	f3af 8000 	nop.w

08015630 <LSM303AGR_ACC_R_Int1EnYHi>:
* Input          : Pointer to LSM303AGR_ACC_YHIE_t
* Output         : Status of YHIE see LSM303AGR_ACC_YHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnYHi(void *handle, LSM303AGR_ACC_YHIE_t *value)
{
 8015630:	b500      	push	{lr}
 8015632:	b083      	sub	sp, #12
 8015634:	9001      	str	r0, [sp, #4]
 8015636:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8015638:	9801      	ldr	r0, [sp, #4]
 801563a:	2130      	movs	r1, #48	; 0x30
 801563c:	9a00      	ldr	r2, [sp, #0]
 801563e:	2301      	movs	r3, #1
 8015640:	f7fd fc46 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015644:	4603      	mov	r3, r0
 8015646:	2b00      	cmp	r3, #0
 8015648:	d101      	bne.n	801564e <LSM303AGR_ACC_R_Int1EnYHi+0x1e>
    return MEMS_ERROR;
 801564a:	2300      	movs	r3, #0
 801564c:	e007      	b.n	801565e <LSM303AGR_ACC_R_Int1EnYHi+0x2e>

  *value &= LSM303AGR_ACC_YHIE_MASK; //mask
 801564e:	9b00      	ldr	r3, [sp, #0]
 8015650:	781b      	ldrb	r3, [r3, #0]
 8015652:	f003 0308 	and.w	r3, r3, #8
 8015656:	b2da      	uxtb	r2, r3
 8015658:	9b00      	ldr	r3, [sp, #0]
 801565a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801565c:	2301      	movs	r3, #1
}
 801565e:	4618      	mov	r0, r3
 8015660:	b003      	add	sp, #12
 8015662:	f85d fb04 	ldr.w	pc, [sp], #4
 8015666:	bf00      	nop
 8015668:	f3af 8000 	nop.w
 801566c:	f3af 8000 	nop.w

08015670 <LSM303AGR_ACC_W_Int1EnZLo>:
* Input          : LSM303AGR_ACC_ZLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t newValue)
{
 8015670:	b500      	push	{lr}
 8015672:	b085      	sub	sp, #20
 8015674:	9001      	str	r0, [sp, #4]
 8015676:	460b      	mov	r3, r1
 8015678:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801567c:	f10d 030f 	add.w	r3, sp, #15
 8015680:	9801      	ldr	r0, [sp, #4]
 8015682:	2130      	movs	r1, #48	; 0x30
 8015684:	461a      	mov	r2, r3
 8015686:	2301      	movs	r3, #1
 8015688:	f7fd fc22 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801568c:	4603      	mov	r3, r0
 801568e:	2b00      	cmp	r3, #0
 8015690:	d101      	bne.n	8015696 <LSM303AGR_ACC_W_Int1EnZLo+0x26>
    return MEMS_ERROR;
 8015692:	2300      	movs	r3, #0
 8015694:	e01c      	b.n	80156d0 <LSM303AGR_ACC_W_Int1EnZLo+0x60>

  value &= ~LSM303AGR_ACC_ZLIE_MASK;
 8015696:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801569a:	f023 0310 	bic.w	r3, r3, #16
 801569e:	b2db      	uxtb	r3, r3
 80156a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80156a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80156a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80156ac:	4313      	orrs	r3, r2
 80156ae:	b2db      	uxtb	r3, r3
 80156b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80156b4:	f10d 030f 	add.w	r3, sp, #15
 80156b8:	9801      	ldr	r0, [sp, #4]
 80156ba:	2130      	movs	r1, #48	; 0x30
 80156bc:	461a      	mov	r2, r3
 80156be:	2301      	movs	r3, #1
 80156c0:	f7fd fbde 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80156c4:	4603      	mov	r3, r0
 80156c6:	2b00      	cmp	r3, #0
 80156c8:	d101      	bne.n	80156ce <LSM303AGR_ACC_W_Int1EnZLo+0x5e>
    return MEMS_ERROR;
 80156ca:	2300      	movs	r3, #0
 80156cc:	e000      	b.n	80156d0 <LSM303AGR_ACC_W_Int1EnZLo+0x60>

  return MEMS_SUCCESS;
 80156ce:	2301      	movs	r3, #1
}
 80156d0:	4618      	mov	r0, r3
 80156d2:	b005      	add	sp, #20
 80156d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80156d8:	f3af 8000 	nop.w
 80156dc:	f3af 8000 	nop.w

080156e0 <LSM303AGR_ACC_R_Int1EnZLo>:
* Input          : Pointer to LSM303AGR_ACC_ZLIE_t
* Output         : Status of ZLIE see LSM303AGR_ACC_ZLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t *value)
{
 80156e0:	b500      	push	{lr}
 80156e2:	b083      	sub	sp, #12
 80156e4:	9001      	str	r0, [sp, #4]
 80156e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 80156e8:	9801      	ldr	r0, [sp, #4]
 80156ea:	2130      	movs	r1, #48	; 0x30
 80156ec:	9a00      	ldr	r2, [sp, #0]
 80156ee:	2301      	movs	r3, #1
 80156f0:	f7fd fbee 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80156f4:	4603      	mov	r3, r0
 80156f6:	2b00      	cmp	r3, #0
 80156f8:	d101      	bne.n	80156fe <LSM303AGR_ACC_R_Int1EnZLo+0x1e>
    return MEMS_ERROR;
 80156fa:	2300      	movs	r3, #0
 80156fc:	e007      	b.n	801570e <LSM303AGR_ACC_R_Int1EnZLo+0x2e>

  *value &= LSM303AGR_ACC_ZLIE_MASK; //mask
 80156fe:	9b00      	ldr	r3, [sp, #0]
 8015700:	781b      	ldrb	r3, [r3, #0]
 8015702:	f003 0310 	and.w	r3, r3, #16
 8015706:	b2da      	uxtb	r2, r3
 8015708:	9b00      	ldr	r3, [sp, #0]
 801570a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801570c:	2301      	movs	r3, #1
}
 801570e:	4618      	mov	r0, r3
 8015710:	b003      	add	sp, #12
 8015712:	f85d fb04 	ldr.w	pc, [sp], #4
 8015716:	bf00      	nop
 8015718:	f3af 8000 	nop.w
 801571c:	f3af 8000 	nop.w

08015720 <LSM303AGR_ACC_W_Int1EnZHi>:
* Input          : LSM303AGR_ACC_ZHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t newValue)
{
 8015720:	b500      	push	{lr}
 8015722:	b085      	sub	sp, #20
 8015724:	9001      	str	r0, [sp, #4]
 8015726:	460b      	mov	r3, r1
 8015728:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801572c:	f10d 030f 	add.w	r3, sp, #15
 8015730:	9801      	ldr	r0, [sp, #4]
 8015732:	2130      	movs	r1, #48	; 0x30
 8015734:	461a      	mov	r2, r3
 8015736:	2301      	movs	r3, #1
 8015738:	f7fd fbca 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801573c:	4603      	mov	r3, r0
 801573e:	2b00      	cmp	r3, #0
 8015740:	d101      	bne.n	8015746 <LSM303AGR_ACC_W_Int1EnZHi+0x26>
    return MEMS_ERROR;
 8015742:	2300      	movs	r3, #0
 8015744:	e01c      	b.n	8015780 <LSM303AGR_ACC_W_Int1EnZHi+0x60>

  value &= ~LSM303AGR_ACC_ZHIE_MASK;
 8015746:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801574a:	f023 0320 	bic.w	r3, r3, #32
 801574e:	b2db      	uxtb	r3, r3
 8015750:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015754:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015758:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801575c:	4313      	orrs	r3, r2
 801575e:	b2db      	uxtb	r3, r3
 8015760:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8015764:	f10d 030f 	add.w	r3, sp, #15
 8015768:	9801      	ldr	r0, [sp, #4]
 801576a:	2130      	movs	r1, #48	; 0x30
 801576c:	461a      	mov	r2, r3
 801576e:	2301      	movs	r3, #1
 8015770:	f7fd fb86 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015774:	4603      	mov	r3, r0
 8015776:	2b00      	cmp	r3, #0
 8015778:	d101      	bne.n	801577e <LSM303AGR_ACC_W_Int1EnZHi+0x5e>
    return MEMS_ERROR;
 801577a:	2300      	movs	r3, #0
 801577c:	e000      	b.n	8015780 <LSM303AGR_ACC_W_Int1EnZHi+0x60>

  return MEMS_SUCCESS;
 801577e:	2301      	movs	r3, #1
}
 8015780:	4618      	mov	r0, r3
 8015782:	b005      	add	sp, #20
 8015784:	f85d fb04 	ldr.w	pc, [sp], #4
 8015788:	f3af 8000 	nop.w
 801578c:	f3af 8000 	nop.w

08015790 <LSM303AGR_ACC_R_Int1EnZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZHIE_t
* Output         : Status of ZHIE see LSM303AGR_ACC_ZHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t *value)
{
 8015790:	b500      	push	{lr}
 8015792:	b083      	sub	sp, #12
 8015794:	9001      	str	r0, [sp, #4]
 8015796:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8015798:	9801      	ldr	r0, [sp, #4]
 801579a:	2130      	movs	r1, #48	; 0x30
 801579c:	9a00      	ldr	r2, [sp, #0]
 801579e:	2301      	movs	r3, #1
 80157a0:	f7fd fb96 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80157a4:	4603      	mov	r3, r0
 80157a6:	2b00      	cmp	r3, #0
 80157a8:	d101      	bne.n	80157ae <LSM303AGR_ACC_R_Int1EnZHi+0x1e>
    return MEMS_ERROR;
 80157aa:	2300      	movs	r3, #0
 80157ac:	e007      	b.n	80157be <LSM303AGR_ACC_R_Int1EnZHi+0x2e>

  *value &= LSM303AGR_ACC_ZHIE_MASK; //mask
 80157ae:	9b00      	ldr	r3, [sp, #0]
 80157b0:	781b      	ldrb	r3, [r3, #0]
 80157b2:	f003 0320 	and.w	r3, r3, #32
 80157b6:	b2da      	uxtb	r2, r3
 80157b8:	9b00      	ldr	r3, [sp, #0]
 80157ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80157bc:	2301      	movs	r3, #1
}
 80157be:	4618      	mov	r0, r3
 80157c0:	b003      	add	sp, #12
 80157c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80157c6:	bf00      	nop
 80157c8:	f3af 8000 	nop.w
 80157cc:	f3af 8000 	nop.w

080157d0 <LSM303AGR_ACC_W_Int1_6D>:
* Input          : LSM303AGR_ACC_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_6D(void *handle, LSM303AGR_ACC_6D_t newValue)
{
 80157d0:	b500      	push	{lr}
 80157d2:	b085      	sub	sp, #20
 80157d4:	9001      	str	r0, [sp, #4]
 80157d6:	460b      	mov	r3, r1
 80157d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80157dc:	f10d 030f 	add.w	r3, sp, #15
 80157e0:	9801      	ldr	r0, [sp, #4]
 80157e2:	2130      	movs	r1, #48	; 0x30
 80157e4:	461a      	mov	r2, r3
 80157e6:	2301      	movs	r3, #1
 80157e8:	f7fd fb72 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80157ec:	4603      	mov	r3, r0
 80157ee:	2b00      	cmp	r3, #0
 80157f0:	d101      	bne.n	80157f6 <LSM303AGR_ACC_W_Int1_6D+0x26>
    return MEMS_ERROR;
 80157f2:	2300      	movs	r3, #0
 80157f4:	e01c      	b.n	8015830 <LSM303AGR_ACC_W_Int1_6D+0x60>

  value &= ~LSM303AGR_ACC_6D_MASK;
 80157f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80157fa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80157fe:	b2db      	uxtb	r3, r3
 8015800:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015804:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015808:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801580c:	4313      	orrs	r3, r2
 801580e:	b2db      	uxtb	r3, r3
 8015810:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8015814:	f10d 030f 	add.w	r3, sp, #15
 8015818:	9801      	ldr	r0, [sp, #4]
 801581a:	2130      	movs	r1, #48	; 0x30
 801581c:	461a      	mov	r2, r3
 801581e:	2301      	movs	r3, #1
 8015820:	f7fd fb2e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015824:	4603      	mov	r3, r0
 8015826:	2b00      	cmp	r3, #0
 8015828:	d101      	bne.n	801582e <LSM303AGR_ACC_W_Int1_6D+0x5e>
    return MEMS_ERROR;
 801582a:	2300      	movs	r3, #0
 801582c:	e000      	b.n	8015830 <LSM303AGR_ACC_W_Int1_6D+0x60>

  return MEMS_SUCCESS;
 801582e:	2301      	movs	r3, #1
}
 8015830:	4618      	mov	r0, r3
 8015832:	b005      	add	sp, #20
 8015834:	f85d fb04 	ldr.w	pc, [sp], #4
 8015838:	f3af 8000 	nop.w
 801583c:	f3af 8000 	nop.w

08015840 <LSM303AGR_ACC_R_Int1_6D>:
* Input          : Pointer to LSM303AGR_ACC_6D_t
* Output         : Status of 6D see LSM303AGR_ACC_6D_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_6D(void *handle, LSM303AGR_ACC_6D_t *value)
{
 8015840:	b500      	push	{lr}
 8015842:	b083      	sub	sp, #12
 8015844:	9001      	str	r0, [sp, #4]
 8015846:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8015848:	9801      	ldr	r0, [sp, #4]
 801584a:	2130      	movs	r1, #48	; 0x30
 801584c:	9a00      	ldr	r2, [sp, #0]
 801584e:	2301      	movs	r3, #1
 8015850:	f7fd fb3e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015854:	4603      	mov	r3, r0
 8015856:	2b00      	cmp	r3, #0
 8015858:	d101      	bne.n	801585e <LSM303AGR_ACC_R_Int1_6D+0x1e>
    return MEMS_ERROR;
 801585a:	2300      	movs	r3, #0
 801585c:	e007      	b.n	801586e <LSM303AGR_ACC_R_Int1_6D+0x2e>

  *value &= LSM303AGR_ACC_6D_MASK; //mask
 801585e:	9b00      	ldr	r3, [sp, #0]
 8015860:	781b      	ldrb	r3, [r3, #0]
 8015862:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015866:	b2da      	uxtb	r2, r3
 8015868:	9b00      	ldr	r3, [sp, #0]
 801586a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801586c:	2301      	movs	r3, #1
}
 801586e:	4618      	mov	r0, r3
 8015870:	b003      	add	sp, #12
 8015872:	f85d fb04 	ldr.w	pc, [sp], #4
 8015876:	bf00      	nop
 8015878:	f3af 8000 	nop.w
 801587c:	f3af 8000 	nop.w

08015880 <LSM303AGR_ACC_W_Int1_AOI>:
* Input          : LSM303AGR_ACC_AOI_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_AOI(void *handle, LSM303AGR_ACC_AOI_t newValue)
{
 8015880:	b500      	push	{lr}
 8015882:	b085      	sub	sp, #20
 8015884:	9001      	str	r0, [sp, #4]
 8015886:	460b      	mov	r3, r1
 8015888:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801588c:	f10d 030f 	add.w	r3, sp, #15
 8015890:	9801      	ldr	r0, [sp, #4]
 8015892:	2130      	movs	r1, #48	; 0x30
 8015894:	461a      	mov	r2, r3
 8015896:	2301      	movs	r3, #1
 8015898:	f7fd fb1a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801589c:	4603      	mov	r3, r0
 801589e:	2b00      	cmp	r3, #0
 80158a0:	d101      	bne.n	80158a6 <LSM303AGR_ACC_W_Int1_AOI+0x26>
    return MEMS_ERROR;
 80158a2:	2300      	movs	r3, #0
 80158a4:	e01c      	b.n	80158e0 <LSM303AGR_ACC_W_Int1_AOI+0x60>

  value &= ~LSM303AGR_ACC_AOI_MASK;
 80158a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80158aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80158ae:	b2db      	uxtb	r3, r3
 80158b0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80158b4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80158b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80158bc:	4313      	orrs	r3, r2
 80158be:	b2db      	uxtb	r3, r3
 80158c0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80158c4:	f10d 030f 	add.w	r3, sp, #15
 80158c8:	9801      	ldr	r0, [sp, #4]
 80158ca:	2130      	movs	r1, #48	; 0x30
 80158cc:	461a      	mov	r2, r3
 80158ce:	2301      	movs	r3, #1
 80158d0:	f7fd fad6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80158d4:	4603      	mov	r3, r0
 80158d6:	2b00      	cmp	r3, #0
 80158d8:	d101      	bne.n	80158de <LSM303AGR_ACC_W_Int1_AOI+0x5e>
    return MEMS_ERROR;
 80158da:	2300      	movs	r3, #0
 80158dc:	e000      	b.n	80158e0 <LSM303AGR_ACC_W_Int1_AOI+0x60>

  return MEMS_SUCCESS;
 80158de:	2301      	movs	r3, #1
}
 80158e0:	4618      	mov	r0, r3
 80158e2:	b005      	add	sp, #20
 80158e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80158e8:	f3af 8000 	nop.w
 80158ec:	f3af 8000 	nop.w

080158f0 <LSM303AGR_ACC_R_Int1_AOI>:
* Input          : Pointer to LSM303AGR_ACC_AOI_t
* Output         : Status of AOI see LSM303AGR_ACC_AOI_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_AOI(void *handle, LSM303AGR_ACC_AOI_t *value)
{
 80158f0:	b500      	push	{lr}
 80158f2:	b083      	sub	sp, #12
 80158f4:	9001      	str	r0, [sp, #4]
 80158f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 80158f8:	9801      	ldr	r0, [sp, #4]
 80158fa:	2130      	movs	r1, #48	; 0x30
 80158fc:	9a00      	ldr	r2, [sp, #0]
 80158fe:	2301      	movs	r3, #1
 8015900:	f7fd fae6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015904:	4603      	mov	r3, r0
 8015906:	2b00      	cmp	r3, #0
 8015908:	d101      	bne.n	801590e <LSM303AGR_ACC_R_Int1_AOI+0x1e>
    return MEMS_ERROR;
 801590a:	2300      	movs	r3, #0
 801590c:	e007      	b.n	801591e <LSM303AGR_ACC_R_Int1_AOI+0x2e>

  *value &= LSM303AGR_ACC_AOI_MASK; //mask
 801590e:	9b00      	ldr	r3, [sp, #0]
 8015910:	781b      	ldrb	r3, [r3, #0]
 8015912:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8015916:	b2da      	uxtb	r2, r3
 8015918:	9b00      	ldr	r3, [sp, #0]
 801591a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801591c:	2301      	movs	r3, #1
}
 801591e:	4618      	mov	r0, r3
 8015920:	b003      	add	sp, #12
 8015922:	f85d fb04 	ldr.w	pc, [sp], #4
 8015926:	bf00      	nop
 8015928:	f3af 8000 	nop.w
 801592c:	f3af 8000 	nop.w

08015930 <LSM303AGR_ACC_W_Int2EnXLo>:
* Input          : LSM303AGR_ACC_XLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnXLo(void *handle, LSM303AGR_ACC_XLIE_t newValue)
{
 8015930:	b500      	push	{lr}
 8015932:	b085      	sub	sp, #20
 8015934:	9001      	str	r0, [sp, #4]
 8015936:	460b      	mov	r3, r1
 8015938:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 801593c:	f10d 030f 	add.w	r3, sp, #15
 8015940:	9801      	ldr	r0, [sp, #4]
 8015942:	2134      	movs	r1, #52	; 0x34
 8015944:	461a      	mov	r2, r3
 8015946:	2301      	movs	r3, #1
 8015948:	f7fd fac2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801594c:	4603      	mov	r3, r0
 801594e:	2b00      	cmp	r3, #0
 8015950:	d101      	bne.n	8015956 <LSM303AGR_ACC_W_Int2EnXLo+0x26>
    return MEMS_ERROR;
 8015952:	2300      	movs	r3, #0
 8015954:	e01c      	b.n	8015990 <LSM303AGR_ACC_W_Int2EnXLo+0x60>

  value &= ~LSM303AGR_ACC_XLIE_MASK;
 8015956:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801595a:	f023 0301 	bic.w	r3, r3, #1
 801595e:	b2db      	uxtb	r3, r3
 8015960:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015964:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015968:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801596c:	4313      	orrs	r3, r2
 801596e:	b2db      	uxtb	r3, r3
 8015970:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015974:	f10d 030f 	add.w	r3, sp, #15
 8015978:	9801      	ldr	r0, [sp, #4]
 801597a:	2134      	movs	r1, #52	; 0x34
 801597c:	461a      	mov	r2, r3
 801597e:	2301      	movs	r3, #1
 8015980:	f7fd fa7e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015984:	4603      	mov	r3, r0
 8015986:	2b00      	cmp	r3, #0
 8015988:	d101      	bne.n	801598e <LSM303AGR_ACC_W_Int2EnXLo+0x5e>
    return MEMS_ERROR;
 801598a:	2300      	movs	r3, #0
 801598c:	e000      	b.n	8015990 <LSM303AGR_ACC_W_Int2EnXLo+0x60>

  return MEMS_SUCCESS;
 801598e:	2301      	movs	r3, #1
}
 8015990:	4618      	mov	r0, r3
 8015992:	b005      	add	sp, #20
 8015994:	f85d fb04 	ldr.w	pc, [sp], #4
 8015998:	f3af 8000 	nop.w
 801599c:	f3af 8000 	nop.w

080159a0 <LSM303AGR_ACC_R_Int2EnXLo>:
* Input          : Pointer to LSM303AGR_ACC_XLIE_t
* Output         : Status of XLIE see LSM303AGR_ACC_XLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnXLo(void *handle, LSM303AGR_ACC_XLIE_t *value)
{
 80159a0:	b500      	push	{lr}
 80159a2:	b083      	sub	sp, #12
 80159a4:	9001      	str	r0, [sp, #4]
 80159a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 80159a8:	9801      	ldr	r0, [sp, #4]
 80159aa:	2134      	movs	r1, #52	; 0x34
 80159ac:	9a00      	ldr	r2, [sp, #0]
 80159ae:	2301      	movs	r3, #1
 80159b0:	f7fd fa8e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80159b4:	4603      	mov	r3, r0
 80159b6:	2b00      	cmp	r3, #0
 80159b8:	d101      	bne.n	80159be <LSM303AGR_ACC_R_Int2EnXLo+0x1e>
    return MEMS_ERROR;
 80159ba:	2300      	movs	r3, #0
 80159bc:	e007      	b.n	80159ce <LSM303AGR_ACC_R_Int2EnXLo+0x2e>

  *value &= LSM303AGR_ACC_XLIE_MASK; //mask
 80159be:	9b00      	ldr	r3, [sp, #0]
 80159c0:	781b      	ldrb	r3, [r3, #0]
 80159c2:	f003 0301 	and.w	r3, r3, #1
 80159c6:	b2da      	uxtb	r2, r3
 80159c8:	9b00      	ldr	r3, [sp, #0]
 80159ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80159cc:	2301      	movs	r3, #1
}
 80159ce:	4618      	mov	r0, r3
 80159d0:	b003      	add	sp, #12
 80159d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80159d6:	bf00      	nop
 80159d8:	f3af 8000 	nop.w
 80159dc:	f3af 8000 	nop.w

080159e0 <LSM303AGR_ACC_W_Int2EnXHi>:
* Input          : LSM303AGR_ACC_XHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnXHi(void *handle, LSM303AGR_ACC_XHIE_t newValue)
{
 80159e0:	b500      	push	{lr}
 80159e2:	b085      	sub	sp, #20
 80159e4:	9001      	str	r0, [sp, #4]
 80159e6:	460b      	mov	r3, r1
 80159e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 80159ec:	f10d 030f 	add.w	r3, sp, #15
 80159f0:	9801      	ldr	r0, [sp, #4]
 80159f2:	2134      	movs	r1, #52	; 0x34
 80159f4:	461a      	mov	r2, r3
 80159f6:	2301      	movs	r3, #1
 80159f8:	f7fd fa6a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80159fc:	4603      	mov	r3, r0
 80159fe:	2b00      	cmp	r3, #0
 8015a00:	d101      	bne.n	8015a06 <LSM303AGR_ACC_W_Int2EnXHi+0x26>
    return MEMS_ERROR;
 8015a02:	2300      	movs	r3, #0
 8015a04:	e01c      	b.n	8015a40 <LSM303AGR_ACC_W_Int2EnXHi+0x60>

  value &= ~LSM303AGR_ACC_XHIE_MASK;
 8015a06:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015a0a:	f023 0302 	bic.w	r3, r3, #2
 8015a0e:	b2db      	uxtb	r3, r3
 8015a10:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015a14:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015a18:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a1c:	4313      	orrs	r3, r2
 8015a1e:	b2db      	uxtb	r3, r3
 8015a20:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015a24:	f10d 030f 	add.w	r3, sp, #15
 8015a28:	9801      	ldr	r0, [sp, #4]
 8015a2a:	2134      	movs	r1, #52	; 0x34
 8015a2c:	461a      	mov	r2, r3
 8015a2e:	2301      	movs	r3, #1
 8015a30:	f7fd fa26 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015a34:	4603      	mov	r3, r0
 8015a36:	2b00      	cmp	r3, #0
 8015a38:	d101      	bne.n	8015a3e <LSM303AGR_ACC_W_Int2EnXHi+0x5e>
    return MEMS_ERROR;
 8015a3a:	2300      	movs	r3, #0
 8015a3c:	e000      	b.n	8015a40 <LSM303AGR_ACC_W_Int2EnXHi+0x60>

  return MEMS_SUCCESS;
 8015a3e:	2301      	movs	r3, #1
}
 8015a40:	4618      	mov	r0, r3
 8015a42:	b005      	add	sp, #20
 8015a44:	f85d fb04 	ldr.w	pc, [sp], #4
 8015a48:	f3af 8000 	nop.w
 8015a4c:	f3af 8000 	nop.w

08015a50 <LSM303AGR_ACC_R_Int2EnXHi>:
* Input          : Pointer to LSM303AGR_ACC_XHIE_t
* Output         : Status of XHIE see LSM303AGR_ACC_XHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnXHi(void *handle, LSM303AGR_ACC_XHIE_t *value)
{
 8015a50:	b500      	push	{lr}
 8015a52:	b083      	sub	sp, #12
 8015a54:	9001      	str	r0, [sp, #4]
 8015a56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8015a58:	9801      	ldr	r0, [sp, #4]
 8015a5a:	2134      	movs	r1, #52	; 0x34
 8015a5c:	9a00      	ldr	r2, [sp, #0]
 8015a5e:	2301      	movs	r3, #1
 8015a60:	f7fd fa36 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015a64:	4603      	mov	r3, r0
 8015a66:	2b00      	cmp	r3, #0
 8015a68:	d101      	bne.n	8015a6e <LSM303AGR_ACC_R_Int2EnXHi+0x1e>
    return MEMS_ERROR;
 8015a6a:	2300      	movs	r3, #0
 8015a6c:	e007      	b.n	8015a7e <LSM303AGR_ACC_R_Int2EnXHi+0x2e>

  *value &= LSM303AGR_ACC_XHIE_MASK; //mask
 8015a6e:	9b00      	ldr	r3, [sp, #0]
 8015a70:	781b      	ldrb	r3, [r3, #0]
 8015a72:	f003 0302 	and.w	r3, r3, #2
 8015a76:	b2da      	uxtb	r2, r3
 8015a78:	9b00      	ldr	r3, [sp, #0]
 8015a7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015a7c:	2301      	movs	r3, #1
}
 8015a7e:	4618      	mov	r0, r3
 8015a80:	b003      	add	sp, #12
 8015a82:	f85d fb04 	ldr.w	pc, [sp], #4
 8015a86:	bf00      	nop
 8015a88:	f3af 8000 	nop.w
 8015a8c:	f3af 8000 	nop.w

08015a90 <LSM303AGR_ACC_W_Int2EnYLo>:
* Input          : LSM303AGR_ACC_YLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnYLo(void *handle, LSM303AGR_ACC_YLIE_t newValue)
{
 8015a90:	b500      	push	{lr}
 8015a92:	b085      	sub	sp, #20
 8015a94:	9001      	str	r0, [sp, #4]
 8015a96:	460b      	mov	r3, r1
 8015a98:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015a9c:	f10d 030f 	add.w	r3, sp, #15
 8015aa0:	9801      	ldr	r0, [sp, #4]
 8015aa2:	2134      	movs	r1, #52	; 0x34
 8015aa4:	461a      	mov	r2, r3
 8015aa6:	2301      	movs	r3, #1
 8015aa8:	f7fd fa12 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015aac:	4603      	mov	r3, r0
 8015aae:	2b00      	cmp	r3, #0
 8015ab0:	d101      	bne.n	8015ab6 <LSM303AGR_ACC_W_Int2EnYLo+0x26>
    return MEMS_ERROR;
 8015ab2:	2300      	movs	r3, #0
 8015ab4:	e01c      	b.n	8015af0 <LSM303AGR_ACC_W_Int2EnYLo+0x60>

  value &= ~LSM303AGR_ACC_YLIE_MASK;
 8015ab6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015aba:	f023 0304 	bic.w	r3, r3, #4
 8015abe:	b2db      	uxtb	r3, r3
 8015ac0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015ac4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015ac8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015acc:	4313      	orrs	r3, r2
 8015ace:	b2db      	uxtb	r3, r3
 8015ad0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015ad4:	f10d 030f 	add.w	r3, sp, #15
 8015ad8:	9801      	ldr	r0, [sp, #4]
 8015ada:	2134      	movs	r1, #52	; 0x34
 8015adc:	461a      	mov	r2, r3
 8015ade:	2301      	movs	r3, #1
 8015ae0:	f7fd f9ce 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015ae4:	4603      	mov	r3, r0
 8015ae6:	2b00      	cmp	r3, #0
 8015ae8:	d101      	bne.n	8015aee <LSM303AGR_ACC_W_Int2EnYLo+0x5e>
    return MEMS_ERROR;
 8015aea:	2300      	movs	r3, #0
 8015aec:	e000      	b.n	8015af0 <LSM303AGR_ACC_W_Int2EnYLo+0x60>

  return MEMS_SUCCESS;
 8015aee:	2301      	movs	r3, #1
}
 8015af0:	4618      	mov	r0, r3
 8015af2:	b005      	add	sp, #20
 8015af4:	f85d fb04 	ldr.w	pc, [sp], #4
 8015af8:	f3af 8000 	nop.w
 8015afc:	f3af 8000 	nop.w

08015b00 <LSM303AGR_ACC_R_Int2EnYLo>:
* Input          : Pointer to LSM303AGR_ACC_YLIE_t
* Output         : Status of YLIE see LSM303AGR_ACC_YLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnYLo(void *handle, LSM303AGR_ACC_YLIE_t *value)
{
 8015b00:	b500      	push	{lr}
 8015b02:	b083      	sub	sp, #12
 8015b04:	9001      	str	r0, [sp, #4]
 8015b06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8015b08:	9801      	ldr	r0, [sp, #4]
 8015b0a:	2134      	movs	r1, #52	; 0x34
 8015b0c:	9a00      	ldr	r2, [sp, #0]
 8015b0e:	2301      	movs	r3, #1
 8015b10:	f7fd f9de 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015b14:	4603      	mov	r3, r0
 8015b16:	2b00      	cmp	r3, #0
 8015b18:	d101      	bne.n	8015b1e <LSM303AGR_ACC_R_Int2EnYLo+0x1e>
    return MEMS_ERROR;
 8015b1a:	2300      	movs	r3, #0
 8015b1c:	e007      	b.n	8015b2e <LSM303AGR_ACC_R_Int2EnYLo+0x2e>

  *value &= LSM303AGR_ACC_YLIE_MASK; //mask
 8015b1e:	9b00      	ldr	r3, [sp, #0]
 8015b20:	781b      	ldrb	r3, [r3, #0]
 8015b22:	f003 0304 	and.w	r3, r3, #4
 8015b26:	b2da      	uxtb	r2, r3
 8015b28:	9b00      	ldr	r3, [sp, #0]
 8015b2a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015b2c:	2301      	movs	r3, #1
}
 8015b2e:	4618      	mov	r0, r3
 8015b30:	b003      	add	sp, #12
 8015b32:	f85d fb04 	ldr.w	pc, [sp], #4
 8015b36:	bf00      	nop
 8015b38:	f3af 8000 	nop.w
 8015b3c:	f3af 8000 	nop.w

08015b40 <LSM303AGR_ACC_W_Int2EnYHi>:
* Input          : LSM303AGR_ACC_YHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnYHi(void *handle, LSM303AGR_ACC_YHIE_t newValue)
{
 8015b40:	b500      	push	{lr}
 8015b42:	b085      	sub	sp, #20
 8015b44:	9001      	str	r0, [sp, #4]
 8015b46:	460b      	mov	r3, r1
 8015b48:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015b4c:	f10d 030f 	add.w	r3, sp, #15
 8015b50:	9801      	ldr	r0, [sp, #4]
 8015b52:	2134      	movs	r1, #52	; 0x34
 8015b54:	461a      	mov	r2, r3
 8015b56:	2301      	movs	r3, #1
 8015b58:	f7fd f9ba 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015b5c:	4603      	mov	r3, r0
 8015b5e:	2b00      	cmp	r3, #0
 8015b60:	d101      	bne.n	8015b66 <LSM303AGR_ACC_W_Int2EnYHi+0x26>
    return MEMS_ERROR;
 8015b62:	2300      	movs	r3, #0
 8015b64:	e01c      	b.n	8015ba0 <LSM303AGR_ACC_W_Int2EnYHi+0x60>

  value &= ~LSM303AGR_ACC_YHIE_MASK;
 8015b66:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015b6a:	f023 0308 	bic.w	r3, r3, #8
 8015b6e:	b2db      	uxtb	r3, r3
 8015b70:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015b74:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015b78:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015b7c:	4313      	orrs	r3, r2
 8015b7e:	b2db      	uxtb	r3, r3
 8015b80:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015b84:	f10d 030f 	add.w	r3, sp, #15
 8015b88:	9801      	ldr	r0, [sp, #4]
 8015b8a:	2134      	movs	r1, #52	; 0x34
 8015b8c:	461a      	mov	r2, r3
 8015b8e:	2301      	movs	r3, #1
 8015b90:	f7fd f976 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015b94:	4603      	mov	r3, r0
 8015b96:	2b00      	cmp	r3, #0
 8015b98:	d101      	bne.n	8015b9e <LSM303AGR_ACC_W_Int2EnYHi+0x5e>
    return MEMS_ERROR;
 8015b9a:	2300      	movs	r3, #0
 8015b9c:	e000      	b.n	8015ba0 <LSM303AGR_ACC_W_Int2EnYHi+0x60>

  return MEMS_SUCCESS;
 8015b9e:	2301      	movs	r3, #1
}
 8015ba0:	4618      	mov	r0, r3
 8015ba2:	b005      	add	sp, #20
 8015ba4:	f85d fb04 	ldr.w	pc, [sp], #4
 8015ba8:	f3af 8000 	nop.w
 8015bac:	f3af 8000 	nop.w

08015bb0 <LSM303AGR_ACC_R_Int2EnYHi>:
* Input          : Pointer to LSM303AGR_ACC_YHIE_t
* Output         : Status of YHIE see LSM303AGR_ACC_YHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnYHi(void *handle, LSM303AGR_ACC_YHIE_t *value)
{
 8015bb0:	b500      	push	{lr}
 8015bb2:	b083      	sub	sp, #12
 8015bb4:	9001      	str	r0, [sp, #4]
 8015bb6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8015bb8:	9801      	ldr	r0, [sp, #4]
 8015bba:	2134      	movs	r1, #52	; 0x34
 8015bbc:	9a00      	ldr	r2, [sp, #0]
 8015bbe:	2301      	movs	r3, #1
 8015bc0:	f7fd f986 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015bc4:	4603      	mov	r3, r0
 8015bc6:	2b00      	cmp	r3, #0
 8015bc8:	d101      	bne.n	8015bce <LSM303AGR_ACC_R_Int2EnYHi+0x1e>
    return MEMS_ERROR;
 8015bca:	2300      	movs	r3, #0
 8015bcc:	e007      	b.n	8015bde <LSM303AGR_ACC_R_Int2EnYHi+0x2e>

  *value &= LSM303AGR_ACC_YHIE_MASK; //mask
 8015bce:	9b00      	ldr	r3, [sp, #0]
 8015bd0:	781b      	ldrb	r3, [r3, #0]
 8015bd2:	f003 0308 	and.w	r3, r3, #8
 8015bd6:	b2da      	uxtb	r2, r3
 8015bd8:	9b00      	ldr	r3, [sp, #0]
 8015bda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015bdc:	2301      	movs	r3, #1
}
 8015bde:	4618      	mov	r0, r3
 8015be0:	b003      	add	sp, #12
 8015be2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015be6:	bf00      	nop
 8015be8:	f3af 8000 	nop.w
 8015bec:	f3af 8000 	nop.w

08015bf0 <LSM303AGR_ACC_W_Int2EnZLo>:
* Input          : LSM303AGR_ACC_ZLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t newValue)
{
 8015bf0:	b500      	push	{lr}
 8015bf2:	b085      	sub	sp, #20
 8015bf4:	9001      	str	r0, [sp, #4]
 8015bf6:	460b      	mov	r3, r1
 8015bf8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015bfc:	f10d 030f 	add.w	r3, sp, #15
 8015c00:	9801      	ldr	r0, [sp, #4]
 8015c02:	2134      	movs	r1, #52	; 0x34
 8015c04:	461a      	mov	r2, r3
 8015c06:	2301      	movs	r3, #1
 8015c08:	f7fd f962 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015c0c:	4603      	mov	r3, r0
 8015c0e:	2b00      	cmp	r3, #0
 8015c10:	d101      	bne.n	8015c16 <LSM303AGR_ACC_W_Int2EnZLo+0x26>
    return MEMS_ERROR;
 8015c12:	2300      	movs	r3, #0
 8015c14:	e01c      	b.n	8015c50 <LSM303AGR_ACC_W_Int2EnZLo+0x60>

  value &= ~LSM303AGR_ACC_ZLIE_MASK;
 8015c16:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015c1a:	f023 0310 	bic.w	r3, r3, #16
 8015c1e:	b2db      	uxtb	r3, r3
 8015c20:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015c24:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015c28:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015c2c:	4313      	orrs	r3, r2
 8015c2e:	b2db      	uxtb	r3, r3
 8015c30:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015c34:	f10d 030f 	add.w	r3, sp, #15
 8015c38:	9801      	ldr	r0, [sp, #4]
 8015c3a:	2134      	movs	r1, #52	; 0x34
 8015c3c:	461a      	mov	r2, r3
 8015c3e:	2301      	movs	r3, #1
 8015c40:	f7fd f91e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015c44:	4603      	mov	r3, r0
 8015c46:	2b00      	cmp	r3, #0
 8015c48:	d101      	bne.n	8015c4e <LSM303AGR_ACC_W_Int2EnZLo+0x5e>
    return MEMS_ERROR;
 8015c4a:	2300      	movs	r3, #0
 8015c4c:	e000      	b.n	8015c50 <LSM303AGR_ACC_W_Int2EnZLo+0x60>

  return MEMS_SUCCESS;
 8015c4e:	2301      	movs	r3, #1
}
 8015c50:	4618      	mov	r0, r3
 8015c52:	b005      	add	sp, #20
 8015c54:	f85d fb04 	ldr.w	pc, [sp], #4
 8015c58:	f3af 8000 	nop.w
 8015c5c:	f3af 8000 	nop.w

08015c60 <LSM303AGR_ACC_R_Int2EnZLo>:
* Input          : Pointer to LSM303AGR_ACC_ZLIE_t
* Output         : Status of ZLIE see LSM303AGR_ACC_ZLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t *value)
{
 8015c60:	b500      	push	{lr}
 8015c62:	b083      	sub	sp, #12
 8015c64:	9001      	str	r0, [sp, #4]
 8015c66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8015c68:	9801      	ldr	r0, [sp, #4]
 8015c6a:	2134      	movs	r1, #52	; 0x34
 8015c6c:	9a00      	ldr	r2, [sp, #0]
 8015c6e:	2301      	movs	r3, #1
 8015c70:	f7fd f92e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015c74:	4603      	mov	r3, r0
 8015c76:	2b00      	cmp	r3, #0
 8015c78:	d101      	bne.n	8015c7e <LSM303AGR_ACC_R_Int2EnZLo+0x1e>
    return MEMS_ERROR;
 8015c7a:	2300      	movs	r3, #0
 8015c7c:	e007      	b.n	8015c8e <LSM303AGR_ACC_R_Int2EnZLo+0x2e>

  *value &= LSM303AGR_ACC_ZLIE_MASK; //mask
 8015c7e:	9b00      	ldr	r3, [sp, #0]
 8015c80:	781b      	ldrb	r3, [r3, #0]
 8015c82:	f003 0310 	and.w	r3, r3, #16
 8015c86:	b2da      	uxtb	r2, r3
 8015c88:	9b00      	ldr	r3, [sp, #0]
 8015c8a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015c8c:	2301      	movs	r3, #1
}
 8015c8e:	4618      	mov	r0, r3
 8015c90:	b003      	add	sp, #12
 8015c92:	f85d fb04 	ldr.w	pc, [sp], #4
 8015c96:	bf00      	nop
 8015c98:	f3af 8000 	nop.w
 8015c9c:	f3af 8000 	nop.w

08015ca0 <LSM303AGR_ACC_W_Int2EnZHi>:
* Input          : LSM303AGR_ACC_ZHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t newValue)
{
 8015ca0:	b500      	push	{lr}
 8015ca2:	b085      	sub	sp, #20
 8015ca4:	9001      	str	r0, [sp, #4]
 8015ca6:	460b      	mov	r3, r1
 8015ca8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015cac:	f10d 030f 	add.w	r3, sp, #15
 8015cb0:	9801      	ldr	r0, [sp, #4]
 8015cb2:	2134      	movs	r1, #52	; 0x34
 8015cb4:	461a      	mov	r2, r3
 8015cb6:	2301      	movs	r3, #1
 8015cb8:	f7fd f90a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015cbc:	4603      	mov	r3, r0
 8015cbe:	2b00      	cmp	r3, #0
 8015cc0:	d101      	bne.n	8015cc6 <LSM303AGR_ACC_W_Int2EnZHi+0x26>
    return MEMS_ERROR;
 8015cc2:	2300      	movs	r3, #0
 8015cc4:	e01c      	b.n	8015d00 <LSM303AGR_ACC_W_Int2EnZHi+0x60>

  value &= ~LSM303AGR_ACC_ZHIE_MASK;
 8015cc6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015cca:	f023 0320 	bic.w	r3, r3, #32
 8015cce:	b2db      	uxtb	r3, r3
 8015cd0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015cd4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015cd8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015cdc:	4313      	orrs	r3, r2
 8015cde:	b2db      	uxtb	r3, r3
 8015ce0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015ce4:	f10d 030f 	add.w	r3, sp, #15
 8015ce8:	9801      	ldr	r0, [sp, #4]
 8015cea:	2134      	movs	r1, #52	; 0x34
 8015cec:	461a      	mov	r2, r3
 8015cee:	2301      	movs	r3, #1
 8015cf0:	f7fd f8c6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015cf4:	4603      	mov	r3, r0
 8015cf6:	2b00      	cmp	r3, #0
 8015cf8:	d101      	bne.n	8015cfe <LSM303AGR_ACC_W_Int2EnZHi+0x5e>
    return MEMS_ERROR;
 8015cfa:	2300      	movs	r3, #0
 8015cfc:	e000      	b.n	8015d00 <LSM303AGR_ACC_W_Int2EnZHi+0x60>

  return MEMS_SUCCESS;
 8015cfe:	2301      	movs	r3, #1
}
 8015d00:	4618      	mov	r0, r3
 8015d02:	b005      	add	sp, #20
 8015d04:	f85d fb04 	ldr.w	pc, [sp], #4
 8015d08:	f3af 8000 	nop.w
 8015d0c:	f3af 8000 	nop.w

08015d10 <LSM303AGR_ACC_R_Int2EnZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZHIE_t
* Output         : Status of ZHIE see LSM303AGR_ACC_ZHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t *value)
{
 8015d10:	b500      	push	{lr}
 8015d12:	b083      	sub	sp, #12
 8015d14:	9001      	str	r0, [sp, #4]
 8015d16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8015d18:	9801      	ldr	r0, [sp, #4]
 8015d1a:	2134      	movs	r1, #52	; 0x34
 8015d1c:	9a00      	ldr	r2, [sp, #0]
 8015d1e:	2301      	movs	r3, #1
 8015d20:	f7fd f8d6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015d24:	4603      	mov	r3, r0
 8015d26:	2b00      	cmp	r3, #0
 8015d28:	d101      	bne.n	8015d2e <LSM303AGR_ACC_R_Int2EnZHi+0x1e>
    return MEMS_ERROR;
 8015d2a:	2300      	movs	r3, #0
 8015d2c:	e007      	b.n	8015d3e <LSM303AGR_ACC_R_Int2EnZHi+0x2e>

  *value &= LSM303AGR_ACC_ZHIE_MASK; //mask
 8015d2e:	9b00      	ldr	r3, [sp, #0]
 8015d30:	781b      	ldrb	r3, [r3, #0]
 8015d32:	f003 0320 	and.w	r3, r3, #32
 8015d36:	b2da      	uxtb	r2, r3
 8015d38:	9b00      	ldr	r3, [sp, #0]
 8015d3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015d3c:	2301      	movs	r3, #1
}
 8015d3e:	4618      	mov	r0, r3
 8015d40:	b003      	add	sp, #12
 8015d42:	f85d fb04 	ldr.w	pc, [sp], #4
 8015d46:	bf00      	nop
 8015d48:	f3af 8000 	nop.w
 8015d4c:	f3af 8000 	nop.w

08015d50 <LSM303AGR_ACC_W_Int2_6D>:
* Input          : LSM303AGR_ACC_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_6D(void *handle, LSM303AGR_ACC_6D_t newValue)
{
 8015d50:	b500      	push	{lr}
 8015d52:	b085      	sub	sp, #20
 8015d54:	9001      	str	r0, [sp, #4]
 8015d56:	460b      	mov	r3, r1
 8015d58:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015d5c:	f10d 030f 	add.w	r3, sp, #15
 8015d60:	9801      	ldr	r0, [sp, #4]
 8015d62:	2134      	movs	r1, #52	; 0x34
 8015d64:	461a      	mov	r2, r3
 8015d66:	2301      	movs	r3, #1
 8015d68:	f7fd f8b2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015d6c:	4603      	mov	r3, r0
 8015d6e:	2b00      	cmp	r3, #0
 8015d70:	d101      	bne.n	8015d76 <LSM303AGR_ACC_W_Int2_6D+0x26>
    return MEMS_ERROR;
 8015d72:	2300      	movs	r3, #0
 8015d74:	e01c      	b.n	8015db0 <LSM303AGR_ACC_W_Int2_6D+0x60>

  value &= ~LSM303AGR_ACC_6D_MASK;
 8015d76:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015d7a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8015d7e:	b2db      	uxtb	r3, r3
 8015d80:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015d84:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015d88:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015d8c:	4313      	orrs	r3, r2
 8015d8e:	b2db      	uxtb	r3, r3
 8015d90:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015d94:	f10d 030f 	add.w	r3, sp, #15
 8015d98:	9801      	ldr	r0, [sp, #4]
 8015d9a:	2134      	movs	r1, #52	; 0x34
 8015d9c:	461a      	mov	r2, r3
 8015d9e:	2301      	movs	r3, #1
 8015da0:	f7fd f86e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015da4:	4603      	mov	r3, r0
 8015da6:	2b00      	cmp	r3, #0
 8015da8:	d101      	bne.n	8015dae <LSM303AGR_ACC_W_Int2_6D+0x5e>
    return MEMS_ERROR;
 8015daa:	2300      	movs	r3, #0
 8015dac:	e000      	b.n	8015db0 <LSM303AGR_ACC_W_Int2_6D+0x60>

  return MEMS_SUCCESS;
 8015dae:	2301      	movs	r3, #1
}
 8015db0:	4618      	mov	r0, r3
 8015db2:	b005      	add	sp, #20
 8015db4:	f85d fb04 	ldr.w	pc, [sp], #4
 8015db8:	f3af 8000 	nop.w
 8015dbc:	f3af 8000 	nop.w

08015dc0 <LSM303AGR_ACC_R_Int2_6D>:
* Input          : Pointer to LSM303AGR_ACC_6D_t
* Output         : Status of 6D see LSM303AGR_ACC_6D_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_6D(void *handle, LSM303AGR_ACC_6D_t *value)
{
 8015dc0:	b500      	push	{lr}
 8015dc2:	b083      	sub	sp, #12
 8015dc4:	9001      	str	r0, [sp, #4]
 8015dc6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8015dc8:	9801      	ldr	r0, [sp, #4]
 8015dca:	2134      	movs	r1, #52	; 0x34
 8015dcc:	9a00      	ldr	r2, [sp, #0]
 8015dce:	2301      	movs	r3, #1
 8015dd0:	f7fd f87e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015dd4:	4603      	mov	r3, r0
 8015dd6:	2b00      	cmp	r3, #0
 8015dd8:	d101      	bne.n	8015dde <LSM303AGR_ACC_R_Int2_6D+0x1e>
    return MEMS_ERROR;
 8015dda:	2300      	movs	r3, #0
 8015ddc:	e007      	b.n	8015dee <LSM303AGR_ACC_R_Int2_6D+0x2e>

  *value &= LSM303AGR_ACC_6D_MASK; //mask
 8015dde:	9b00      	ldr	r3, [sp, #0]
 8015de0:	781b      	ldrb	r3, [r3, #0]
 8015de2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015de6:	b2da      	uxtb	r2, r3
 8015de8:	9b00      	ldr	r3, [sp, #0]
 8015dea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015dec:	2301      	movs	r3, #1
}
 8015dee:	4618      	mov	r0, r3
 8015df0:	b003      	add	sp, #12
 8015df2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015df6:	bf00      	nop
 8015df8:	f3af 8000 	nop.w
 8015dfc:	f3af 8000 	nop.w

08015e00 <LSM303AGR_ACC_W_Int2_AOI>:
* Input          : LSM303AGR_ACC_AOI_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_AOI(void *handle, LSM303AGR_ACC_AOI_t newValue)
{
 8015e00:	b500      	push	{lr}
 8015e02:	b085      	sub	sp, #20
 8015e04:	9001      	str	r0, [sp, #4]
 8015e06:	460b      	mov	r3, r1
 8015e08:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015e0c:	f10d 030f 	add.w	r3, sp, #15
 8015e10:	9801      	ldr	r0, [sp, #4]
 8015e12:	2134      	movs	r1, #52	; 0x34
 8015e14:	461a      	mov	r2, r3
 8015e16:	2301      	movs	r3, #1
 8015e18:	f7fd f85a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015e1c:	4603      	mov	r3, r0
 8015e1e:	2b00      	cmp	r3, #0
 8015e20:	d101      	bne.n	8015e26 <LSM303AGR_ACC_W_Int2_AOI+0x26>
    return MEMS_ERROR;
 8015e22:	2300      	movs	r3, #0
 8015e24:	e01c      	b.n	8015e60 <LSM303AGR_ACC_W_Int2_AOI+0x60>

  value &= ~LSM303AGR_ACC_AOI_MASK;
 8015e26:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015e2a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015e2e:	b2db      	uxtb	r3, r3
 8015e30:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015e34:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015e38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015e3c:	4313      	orrs	r3, r2
 8015e3e:	b2db      	uxtb	r3, r3
 8015e40:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015e44:	f10d 030f 	add.w	r3, sp, #15
 8015e48:	9801      	ldr	r0, [sp, #4]
 8015e4a:	2134      	movs	r1, #52	; 0x34
 8015e4c:	461a      	mov	r2, r3
 8015e4e:	2301      	movs	r3, #1
 8015e50:	f7fd f816 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8015e54:	4603      	mov	r3, r0
 8015e56:	2b00      	cmp	r3, #0
 8015e58:	d101      	bne.n	8015e5e <LSM303AGR_ACC_W_Int2_AOI+0x5e>
    return MEMS_ERROR;
 8015e5a:	2300      	movs	r3, #0
 8015e5c:	e000      	b.n	8015e60 <LSM303AGR_ACC_W_Int2_AOI+0x60>

  return MEMS_SUCCESS;
 8015e5e:	2301      	movs	r3, #1
}
 8015e60:	4618      	mov	r0, r3
 8015e62:	b005      	add	sp, #20
 8015e64:	f85d fb04 	ldr.w	pc, [sp], #4
 8015e68:	f3af 8000 	nop.w
 8015e6c:	f3af 8000 	nop.w

08015e70 <LSM303AGR_ACC_R_Int2_AOI>:
* Input          : Pointer to LSM303AGR_ACC_AOI_t
* Output         : Status of AOI see LSM303AGR_ACC_AOI_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_AOI(void *handle, LSM303AGR_ACC_AOI_t *value)
{
 8015e70:	b500      	push	{lr}
 8015e72:	b083      	sub	sp, #12
 8015e74:	9001      	str	r0, [sp, #4]
 8015e76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8015e78:	9801      	ldr	r0, [sp, #4]
 8015e7a:	2134      	movs	r1, #52	; 0x34
 8015e7c:	9a00      	ldr	r2, [sp, #0]
 8015e7e:	2301      	movs	r3, #1
 8015e80:	f7fd f826 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015e84:	4603      	mov	r3, r0
 8015e86:	2b00      	cmp	r3, #0
 8015e88:	d101      	bne.n	8015e8e <LSM303AGR_ACC_R_Int2_AOI+0x1e>
    return MEMS_ERROR;
 8015e8a:	2300      	movs	r3, #0
 8015e8c:	e007      	b.n	8015e9e <LSM303AGR_ACC_R_Int2_AOI+0x2e>

  *value &= LSM303AGR_ACC_AOI_MASK; //mask
 8015e8e:	9b00      	ldr	r3, [sp, #0]
 8015e90:	781b      	ldrb	r3, [r3, #0]
 8015e92:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8015e96:	b2da      	uxtb	r2, r3
 8015e98:	9b00      	ldr	r3, [sp, #0]
 8015e9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015e9c:	2301      	movs	r3, #1
}
 8015e9e:	4618      	mov	r0, r3
 8015ea0:	b003      	add	sp, #12
 8015ea2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015ea6:	bf00      	nop
 8015ea8:	f3af 8000 	nop.w
 8015eac:	f3af 8000 	nop.w

08015eb0 <LSM303AGR_ACC_R_Int1_Xlo>:
* Input          : Pointer to LSM303AGR_ACC_XL_t
* Output         : Status of XL see LSM303AGR_ACC_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Xlo(void *handle, LSM303AGR_ACC_XL_t *value)
{
 8015eb0:	b500      	push	{lr}
 8015eb2:	b083      	sub	sp, #12
 8015eb4:	9001      	str	r0, [sp, #4]
 8015eb6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015eb8:	9801      	ldr	r0, [sp, #4]
 8015eba:	2131      	movs	r1, #49	; 0x31
 8015ebc:	9a00      	ldr	r2, [sp, #0]
 8015ebe:	2301      	movs	r3, #1
 8015ec0:	f7fd f806 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015ec4:	4603      	mov	r3, r0
 8015ec6:	2b00      	cmp	r3, #0
 8015ec8:	d101      	bne.n	8015ece <LSM303AGR_ACC_R_Int1_Xlo+0x1e>
    return MEMS_ERROR;
 8015eca:	2300      	movs	r3, #0
 8015ecc:	e007      	b.n	8015ede <LSM303AGR_ACC_R_Int1_Xlo+0x2e>

  *value &= LSM303AGR_ACC_XL_MASK; //mask
 8015ece:	9b00      	ldr	r3, [sp, #0]
 8015ed0:	781b      	ldrb	r3, [r3, #0]
 8015ed2:	f003 0301 	and.w	r3, r3, #1
 8015ed6:	b2da      	uxtb	r2, r3
 8015ed8:	9b00      	ldr	r3, [sp, #0]
 8015eda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015edc:	2301      	movs	r3, #1
}
 8015ede:	4618      	mov	r0, r3
 8015ee0:	b003      	add	sp, #12
 8015ee2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015ee6:	bf00      	nop
 8015ee8:	f3af 8000 	nop.w
 8015eec:	f3af 8000 	nop.w

08015ef0 <LSM303AGR_ACC_R_Int1_XHi>:
* Input          : Pointer to LSM303AGR_ACC_XH_t
* Output         : Status of XH see LSM303AGR_ACC_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_XHi(void *handle, LSM303AGR_ACC_XH_t *value)
{
 8015ef0:	b500      	push	{lr}
 8015ef2:	b083      	sub	sp, #12
 8015ef4:	9001      	str	r0, [sp, #4]
 8015ef6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015ef8:	9801      	ldr	r0, [sp, #4]
 8015efa:	2131      	movs	r1, #49	; 0x31
 8015efc:	9a00      	ldr	r2, [sp, #0]
 8015efe:	2301      	movs	r3, #1
 8015f00:	f7fc ffe6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015f04:	4603      	mov	r3, r0
 8015f06:	2b00      	cmp	r3, #0
 8015f08:	d101      	bne.n	8015f0e <LSM303AGR_ACC_R_Int1_XHi+0x1e>
    return MEMS_ERROR;
 8015f0a:	2300      	movs	r3, #0
 8015f0c:	e007      	b.n	8015f1e <LSM303AGR_ACC_R_Int1_XHi+0x2e>

  *value &= LSM303AGR_ACC_XH_MASK; //mask
 8015f0e:	9b00      	ldr	r3, [sp, #0]
 8015f10:	781b      	ldrb	r3, [r3, #0]
 8015f12:	f003 0302 	and.w	r3, r3, #2
 8015f16:	b2da      	uxtb	r2, r3
 8015f18:	9b00      	ldr	r3, [sp, #0]
 8015f1a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015f1c:	2301      	movs	r3, #1
}
 8015f1e:	4618      	mov	r0, r3
 8015f20:	b003      	add	sp, #12
 8015f22:	f85d fb04 	ldr.w	pc, [sp], #4
 8015f26:	bf00      	nop
 8015f28:	f3af 8000 	nop.w
 8015f2c:	f3af 8000 	nop.w

08015f30 <LSM303AGR_ACC_R_Int1_YLo>:
* Input          : Pointer to LSM303AGR_ACC_YL_t
* Output         : Status of YL see LSM303AGR_ACC_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_YLo(void *handle, LSM303AGR_ACC_YL_t *value)
{
 8015f30:	b500      	push	{lr}
 8015f32:	b083      	sub	sp, #12
 8015f34:	9001      	str	r0, [sp, #4]
 8015f36:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015f38:	9801      	ldr	r0, [sp, #4]
 8015f3a:	2131      	movs	r1, #49	; 0x31
 8015f3c:	9a00      	ldr	r2, [sp, #0]
 8015f3e:	2301      	movs	r3, #1
 8015f40:	f7fc ffc6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015f44:	4603      	mov	r3, r0
 8015f46:	2b00      	cmp	r3, #0
 8015f48:	d101      	bne.n	8015f4e <LSM303AGR_ACC_R_Int1_YLo+0x1e>
    return MEMS_ERROR;
 8015f4a:	2300      	movs	r3, #0
 8015f4c:	e007      	b.n	8015f5e <LSM303AGR_ACC_R_Int1_YLo+0x2e>

  *value &= LSM303AGR_ACC_YL_MASK; //mask
 8015f4e:	9b00      	ldr	r3, [sp, #0]
 8015f50:	781b      	ldrb	r3, [r3, #0]
 8015f52:	f003 0304 	and.w	r3, r3, #4
 8015f56:	b2da      	uxtb	r2, r3
 8015f58:	9b00      	ldr	r3, [sp, #0]
 8015f5a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015f5c:	2301      	movs	r3, #1
}
 8015f5e:	4618      	mov	r0, r3
 8015f60:	b003      	add	sp, #12
 8015f62:	f85d fb04 	ldr.w	pc, [sp], #4
 8015f66:	bf00      	nop
 8015f68:	f3af 8000 	nop.w
 8015f6c:	f3af 8000 	nop.w

08015f70 <LSM303AGR_ACC_R_Int1_YHi>:
* Input          : Pointer to LSM303AGR_ACC_YH_t
* Output         : Status of YH see LSM303AGR_ACC_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_YHi(void *handle, LSM303AGR_ACC_YH_t *value)
{
 8015f70:	b500      	push	{lr}
 8015f72:	b083      	sub	sp, #12
 8015f74:	9001      	str	r0, [sp, #4]
 8015f76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015f78:	9801      	ldr	r0, [sp, #4]
 8015f7a:	2131      	movs	r1, #49	; 0x31
 8015f7c:	9a00      	ldr	r2, [sp, #0]
 8015f7e:	2301      	movs	r3, #1
 8015f80:	f7fc ffa6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015f84:	4603      	mov	r3, r0
 8015f86:	2b00      	cmp	r3, #0
 8015f88:	d101      	bne.n	8015f8e <LSM303AGR_ACC_R_Int1_YHi+0x1e>
    return MEMS_ERROR;
 8015f8a:	2300      	movs	r3, #0
 8015f8c:	e007      	b.n	8015f9e <LSM303AGR_ACC_R_Int1_YHi+0x2e>

  *value &= LSM303AGR_ACC_YH_MASK; //mask
 8015f8e:	9b00      	ldr	r3, [sp, #0]
 8015f90:	781b      	ldrb	r3, [r3, #0]
 8015f92:	f003 0308 	and.w	r3, r3, #8
 8015f96:	b2da      	uxtb	r2, r3
 8015f98:	9b00      	ldr	r3, [sp, #0]
 8015f9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015f9c:	2301      	movs	r3, #1
}
 8015f9e:	4618      	mov	r0, r3
 8015fa0:	b003      	add	sp, #12
 8015fa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015fa6:	bf00      	nop
 8015fa8:	f3af 8000 	nop.w
 8015fac:	f3af 8000 	nop.w

08015fb0 <LSM303AGR_ACC_R_Int1_Zlo>:
* Input          : Pointer to LSM303AGR_ACC_ZL_t
* Output         : Status of ZL see LSM303AGR_ACC_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Zlo(void *handle, LSM303AGR_ACC_ZL_t *value)
{
 8015fb0:	b500      	push	{lr}
 8015fb2:	b083      	sub	sp, #12
 8015fb4:	9001      	str	r0, [sp, #4]
 8015fb6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015fb8:	9801      	ldr	r0, [sp, #4]
 8015fba:	2131      	movs	r1, #49	; 0x31
 8015fbc:	9a00      	ldr	r2, [sp, #0]
 8015fbe:	2301      	movs	r3, #1
 8015fc0:	f7fc ff86 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8015fc4:	4603      	mov	r3, r0
 8015fc6:	2b00      	cmp	r3, #0
 8015fc8:	d101      	bne.n	8015fce <LSM303AGR_ACC_R_Int1_Zlo+0x1e>
    return MEMS_ERROR;
 8015fca:	2300      	movs	r3, #0
 8015fcc:	e007      	b.n	8015fde <LSM303AGR_ACC_R_Int1_Zlo+0x2e>

  *value &= LSM303AGR_ACC_ZL_MASK; //mask
 8015fce:	9b00      	ldr	r3, [sp, #0]
 8015fd0:	781b      	ldrb	r3, [r3, #0]
 8015fd2:	f003 0310 	and.w	r3, r3, #16
 8015fd6:	b2da      	uxtb	r2, r3
 8015fd8:	9b00      	ldr	r3, [sp, #0]
 8015fda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015fdc:	2301      	movs	r3, #1
}
 8015fde:	4618      	mov	r0, r3
 8015fe0:	b003      	add	sp, #12
 8015fe2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015fe6:	bf00      	nop
 8015fe8:	f3af 8000 	nop.w
 8015fec:	f3af 8000 	nop.w

08015ff0 <LSM303AGR_ACC_R_Int1_ZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZH_t
* Output         : Status of ZH see LSM303AGR_ACC_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_ZHi(void *handle, LSM303AGR_ACC_ZH_t *value)
{
 8015ff0:	b500      	push	{lr}
 8015ff2:	b083      	sub	sp, #12
 8015ff4:	9001      	str	r0, [sp, #4]
 8015ff6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015ff8:	9801      	ldr	r0, [sp, #4]
 8015ffa:	2131      	movs	r1, #49	; 0x31
 8015ffc:	9a00      	ldr	r2, [sp, #0]
 8015ffe:	2301      	movs	r3, #1
 8016000:	f7fc ff66 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016004:	4603      	mov	r3, r0
 8016006:	2b00      	cmp	r3, #0
 8016008:	d101      	bne.n	801600e <LSM303AGR_ACC_R_Int1_ZHi+0x1e>
    return MEMS_ERROR;
 801600a:	2300      	movs	r3, #0
 801600c:	e007      	b.n	801601e <LSM303AGR_ACC_R_Int1_ZHi+0x2e>

  *value &= LSM303AGR_ACC_ZH_MASK; //mask
 801600e:	9b00      	ldr	r3, [sp, #0]
 8016010:	781b      	ldrb	r3, [r3, #0]
 8016012:	f003 0320 	and.w	r3, r3, #32
 8016016:	b2da      	uxtb	r2, r3
 8016018:	9b00      	ldr	r3, [sp, #0]
 801601a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801601c:	2301      	movs	r3, #1
}
 801601e:	4618      	mov	r0, r3
 8016020:	b003      	add	sp, #12
 8016022:	f85d fb04 	ldr.w	pc, [sp], #4
 8016026:	bf00      	nop
 8016028:	f3af 8000 	nop.w
 801602c:	f3af 8000 	nop.w

08016030 <LSM303AGR_ACC_R_Int1_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_IA(void *handle, LSM303AGR_ACC_IA_t *value)
{
 8016030:	b500      	push	{lr}
 8016032:	b083      	sub	sp, #12
 8016034:	9001      	str	r0, [sp, #4]
 8016036:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8016038:	9801      	ldr	r0, [sp, #4]
 801603a:	2131      	movs	r1, #49	; 0x31
 801603c:	9a00      	ldr	r2, [sp, #0]
 801603e:	2301      	movs	r3, #1
 8016040:	f7fc ff46 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016044:	4603      	mov	r3, r0
 8016046:	2b00      	cmp	r3, #0
 8016048:	d101      	bne.n	801604e <LSM303AGR_ACC_R_Int1_IA+0x1e>
    return MEMS_ERROR;
 801604a:	2300      	movs	r3, #0
 801604c:	e007      	b.n	801605e <LSM303AGR_ACC_R_Int1_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 801604e:	9b00      	ldr	r3, [sp, #0]
 8016050:	781b      	ldrb	r3, [r3, #0]
 8016052:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016056:	b2da      	uxtb	r2, r3
 8016058:	9b00      	ldr	r3, [sp, #0]
 801605a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801605c:	2301      	movs	r3, #1
}
 801605e:	4618      	mov	r0, r3
 8016060:	b003      	add	sp, #12
 8016062:	f85d fb04 	ldr.w	pc, [sp], #4
 8016066:	bf00      	nop
 8016068:	f3af 8000 	nop.w
 801606c:	f3af 8000 	nop.w

08016070 <LSM303AGR_ACC_R_Int2_Xlo>:
* Input          : Pointer to LSM303AGR_ACC_XL_t
* Output         : Status of XL see LSM303AGR_ACC_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Xlo(void *handle, LSM303AGR_ACC_XL_t *value)
{
 8016070:	b500      	push	{lr}
 8016072:	b083      	sub	sp, #12
 8016074:	9001      	str	r0, [sp, #4]
 8016076:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8016078:	9801      	ldr	r0, [sp, #4]
 801607a:	2135      	movs	r1, #53	; 0x35
 801607c:	9a00      	ldr	r2, [sp, #0]
 801607e:	2301      	movs	r3, #1
 8016080:	f7fc ff26 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016084:	4603      	mov	r3, r0
 8016086:	2b00      	cmp	r3, #0
 8016088:	d101      	bne.n	801608e <LSM303AGR_ACC_R_Int2_Xlo+0x1e>
    return MEMS_ERROR;
 801608a:	2300      	movs	r3, #0
 801608c:	e007      	b.n	801609e <LSM303AGR_ACC_R_Int2_Xlo+0x2e>

  *value &= LSM303AGR_ACC_XL_MASK; //mask
 801608e:	9b00      	ldr	r3, [sp, #0]
 8016090:	781b      	ldrb	r3, [r3, #0]
 8016092:	f003 0301 	and.w	r3, r3, #1
 8016096:	b2da      	uxtb	r2, r3
 8016098:	9b00      	ldr	r3, [sp, #0]
 801609a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801609c:	2301      	movs	r3, #1
}
 801609e:	4618      	mov	r0, r3
 80160a0:	b003      	add	sp, #12
 80160a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80160a6:	bf00      	nop
 80160a8:	f3af 8000 	nop.w
 80160ac:	f3af 8000 	nop.w

080160b0 <LSM303AGR_ACC_R_Int2_XHi>:
* Input          : Pointer to LSM303AGR_ACC_XH_t
* Output         : Status of XH see LSM303AGR_ACC_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_XHi(void *handle, LSM303AGR_ACC_XH_t *value)
{
 80160b0:	b500      	push	{lr}
 80160b2:	b083      	sub	sp, #12
 80160b4:	9001      	str	r0, [sp, #4]
 80160b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80160b8:	9801      	ldr	r0, [sp, #4]
 80160ba:	2135      	movs	r1, #53	; 0x35
 80160bc:	9a00      	ldr	r2, [sp, #0]
 80160be:	2301      	movs	r3, #1
 80160c0:	f7fc ff06 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80160c4:	4603      	mov	r3, r0
 80160c6:	2b00      	cmp	r3, #0
 80160c8:	d101      	bne.n	80160ce <LSM303AGR_ACC_R_Int2_XHi+0x1e>
    return MEMS_ERROR;
 80160ca:	2300      	movs	r3, #0
 80160cc:	e007      	b.n	80160de <LSM303AGR_ACC_R_Int2_XHi+0x2e>

  *value &= LSM303AGR_ACC_XH_MASK; //mask
 80160ce:	9b00      	ldr	r3, [sp, #0]
 80160d0:	781b      	ldrb	r3, [r3, #0]
 80160d2:	f003 0302 	and.w	r3, r3, #2
 80160d6:	b2da      	uxtb	r2, r3
 80160d8:	9b00      	ldr	r3, [sp, #0]
 80160da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80160dc:	2301      	movs	r3, #1
}
 80160de:	4618      	mov	r0, r3
 80160e0:	b003      	add	sp, #12
 80160e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80160e6:	bf00      	nop
 80160e8:	f3af 8000 	nop.w
 80160ec:	f3af 8000 	nop.w

080160f0 <LSM303AGR_ACC_R_Int2_YLo>:
* Input          : Pointer to LSM303AGR_ACC_YL_t
* Output         : Status of YL see LSM303AGR_ACC_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_YLo(void *handle, LSM303AGR_ACC_YL_t *value)
{
 80160f0:	b500      	push	{lr}
 80160f2:	b083      	sub	sp, #12
 80160f4:	9001      	str	r0, [sp, #4]
 80160f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80160f8:	9801      	ldr	r0, [sp, #4]
 80160fa:	2135      	movs	r1, #53	; 0x35
 80160fc:	9a00      	ldr	r2, [sp, #0]
 80160fe:	2301      	movs	r3, #1
 8016100:	f7fc fee6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016104:	4603      	mov	r3, r0
 8016106:	2b00      	cmp	r3, #0
 8016108:	d101      	bne.n	801610e <LSM303AGR_ACC_R_Int2_YLo+0x1e>
    return MEMS_ERROR;
 801610a:	2300      	movs	r3, #0
 801610c:	e007      	b.n	801611e <LSM303AGR_ACC_R_Int2_YLo+0x2e>

  *value &= LSM303AGR_ACC_YL_MASK; //mask
 801610e:	9b00      	ldr	r3, [sp, #0]
 8016110:	781b      	ldrb	r3, [r3, #0]
 8016112:	f003 0304 	and.w	r3, r3, #4
 8016116:	b2da      	uxtb	r2, r3
 8016118:	9b00      	ldr	r3, [sp, #0]
 801611a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801611c:	2301      	movs	r3, #1
}
 801611e:	4618      	mov	r0, r3
 8016120:	b003      	add	sp, #12
 8016122:	f85d fb04 	ldr.w	pc, [sp], #4
 8016126:	bf00      	nop
 8016128:	f3af 8000 	nop.w
 801612c:	f3af 8000 	nop.w

08016130 <LSM303AGR_ACC_R_Int2_YHi>:
* Input          : Pointer to LSM303AGR_ACC_YH_t
* Output         : Status of YH see LSM303AGR_ACC_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_YHi(void *handle, LSM303AGR_ACC_YH_t *value)
{
 8016130:	b500      	push	{lr}
 8016132:	b083      	sub	sp, #12
 8016134:	9001      	str	r0, [sp, #4]
 8016136:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8016138:	9801      	ldr	r0, [sp, #4]
 801613a:	2135      	movs	r1, #53	; 0x35
 801613c:	9a00      	ldr	r2, [sp, #0]
 801613e:	2301      	movs	r3, #1
 8016140:	f7fc fec6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016144:	4603      	mov	r3, r0
 8016146:	2b00      	cmp	r3, #0
 8016148:	d101      	bne.n	801614e <LSM303AGR_ACC_R_Int2_YHi+0x1e>
    return MEMS_ERROR;
 801614a:	2300      	movs	r3, #0
 801614c:	e007      	b.n	801615e <LSM303AGR_ACC_R_Int2_YHi+0x2e>

  *value &= LSM303AGR_ACC_YH_MASK; //mask
 801614e:	9b00      	ldr	r3, [sp, #0]
 8016150:	781b      	ldrb	r3, [r3, #0]
 8016152:	f003 0308 	and.w	r3, r3, #8
 8016156:	b2da      	uxtb	r2, r3
 8016158:	9b00      	ldr	r3, [sp, #0]
 801615a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801615c:	2301      	movs	r3, #1
}
 801615e:	4618      	mov	r0, r3
 8016160:	b003      	add	sp, #12
 8016162:	f85d fb04 	ldr.w	pc, [sp], #4
 8016166:	bf00      	nop
 8016168:	f3af 8000 	nop.w
 801616c:	f3af 8000 	nop.w

08016170 <LSM303AGR_ACC_R_Int2_Zlo>:
* Input          : Pointer to LSM303AGR_ACC_ZL_t
* Output         : Status of ZL see LSM303AGR_ACC_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Zlo(void *handle, LSM303AGR_ACC_ZL_t *value)
{
 8016170:	b500      	push	{lr}
 8016172:	b083      	sub	sp, #12
 8016174:	9001      	str	r0, [sp, #4]
 8016176:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8016178:	9801      	ldr	r0, [sp, #4]
 801617a:	2135      	movs	r1, #53	; 0x35
 801617c:	9a00      	ldr	r2, [sp, #0]
 801617e:	2301      	movs	r3, #1
 8016180:	f7fc fea6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016184:	4603      	mov	r3, r0
 8016186:	2b00      	cmp	r3, #0
 8016188:	d101      	bne.n	801618e <LSM303AGR_ACC_R_Int2_Zlo+0x1e>
    return MEMS_ERROR;
 801618a:	2300      	movs	r3, #0
 801618c:	e007      	b.n	801619e <LSM303AGR_ACC_R_Int2_Zlo+0x2e>

  *value &= LSM303AGR_ACC_ZL_MASK; //mask
 801618e:	9b00      	ldr	r3, [sp, #0]
 8016190:	781b      	ldrb	r3, [r3, #0]
 8016192:	f003 0310 	and.w	r3, r3, #16
 8016196:	b2da      	uxtb	r2, r3
 8016198:	9b00      	ldr	r3, [sp, #0]
 801619a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801619c:	2301      	movs	r3, #1
}
 801619e:	4618      	mov	r0, r3
 80161a0:	b003      	add	sp, #12
 80161a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80161a6:	bf00      	nop
 80161a8:	f3af 8000 	nop.w
 80161ac:	f3af 8000 	nop.w

080161b0 <LSM303AGR_ACC_R_Int2_ZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZH_t
* Output         : Status of ZH see LSM303AGR_ACC_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_ZHi(void *handle, LSM303AGR_ACC_ZH_t *value)
{
 80161b0:	b500      	push	{lr}
 80161b2:	b083      	sub	sp, #12
 80161b4:	9001      	str	r0, [sp, #4]
 80161b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80161b8:	9801      	ldr	r0, [sp, #4]
 80161ba:	2135      	movs	r1, #53	; 0x35
 80161bc:	9a00      	ldr	r2, [sp, #0]
 80161be:	2301      	movs	r3, #1
 80161c0:	f7fc fe86 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80161c4:	4603      	mov	r3, r0
 80161c6:	2b00      	cmp	r3, #0
 80161c8:	d101      	bne.n	80161ce <LSM303AGR_ACC_R_Int2_ZHi+0x1e>
    return MEMS_ERROR;
 80161ca:	2300      	movs	r3, #0
 80161cc:	e007      	b.n	80161de <LSM303AGR_ACC_R_Int2_ZHi+0x2e>

  *value &= LSM303AGR_ACC_ZH_MASK; //mask
 80161ce:	9b00      	ldr	r3, [sp, #0]
 80161d0:	781b      	ldrb	r3, [r3, #0]
 80161d2:	f003 0320 	and.w	r3, r3, #32
 80161d6:	b2da      	uxtb	r2, r3
 80161d8:	9b00      	ldr	r3, [sp, #0]
 80161da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80161dc:	2301      	movs	r3, #1
}
 80161de:	4618      	mov	r0, r3
 80161e0:	b003      	add	sp, #12
 80161e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80161e6:	bf00      	nop
 80161e8:	f3af 8000 	nop.w
 80161ec:	f3af 8000 	nop.w

080161f0 <LSM303AGR_ACC_R_Int2_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_IA(void *handle, LSM303AGR_ACC_IA_t *value)
{
 80161f0:	b500      	push	{lr}
 80161f2:	b083      	sub	sp, #12
 80161f4:	9001      	str	r0, [sp, #4]
 80161f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80161f8:	9801      	ldr	r0, [sp, #4]
 80161fa:	2135      	movs	r1, #53	; 0x35
 80161fc:	9a00      	ldr	r2, [sp, #0]
 80161fe:	2301      	movs	r3, #1
 8016200:	f7fc fe66 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016204:	4603      	mov	r3, r0
 8016206:	2b00      	cmp	r3, #0
 8016208:	d101      	bne.n	801620e <LSM303AGR_ACC_R_Int2_IA+0x1e>
    return MEMS_ERROR;
 801620a:	2300      	movs	r3, #0
 801620c:	e007      	b.n	801621e <LSM303AGR_ACC_R_Int2_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 801620e:	9b00      	ldr	r3, [sp, #0]
 8016210:	781b      	ldrb	r3, [r3, #0]
 8016212:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016216:	b2da      	uxtb	r2, r3
 8016218:	9b00      	ldr	r3, [sp, #0]
 801621a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801621c:	2301      	movs	r3, #1
}
 801621e:	4618      	mov	r0, r3
 8016220:	b003      	add	sp, #12
 8016222:	f85d fb04 	ldr.w	pc, [sp], #4
 8016226:	bf00      	nop
 8016228:	f3af 8000 	nop.w
 801622c:	f3af 8000 	nop.w

08016230 <LSM303AGR_ACC_W_Int1_Threshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_Threshold(void *handle, u8_t newValue)
{
 8016230:	b500      	push	{lr}
 8016232:	b085      	sub	sp, #20
 8016234:	9001      	str	r0, [sp, #4]
 8016236:	460b      	mov	r3, r1
 8016238:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 801623c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016240:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016244:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_THS, &value, 1) )
 8016248:	f10d 030f 	add.w	r3, sp, #15
 801624c:	9801      	ldr	r0, [sp, #4]
 801624e:	2132      	movs	r1, #50	; 0x32
 8016250:	461a      	mov	r2, r3
 8016252:	2301      	movs	r3, #1
 8016254:	f7fc fe3c 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016258:	4603      	mov	r3, r0
 801625a:	2b00      	cmp	r3, #0
 801625c:	d101      	bne.n	8016262 <LSM303AGR_ACC_W_Int1_Threshold+0x32>
    return MEMS_ERROR;
 801625e:	2300      	movs	r3, #0
 8016260:	e01c      	b.n	801629c <LSM303AGR_ACC_W_Int1_Threshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8016262:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016266:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801626a:	b2db      	uxtb	r3, r3
 801626c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016270:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016274:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016278:	4313      	orrs	r3, r2
 801627a:	b2db      	uxtb	r3, r3
 801627c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_THS, &value, 1) )
 8016280:	f10d 030f 	add.w	r3, sp, #15
 8016284:	9801      	ldr	r0, [sp, #4]
 8016286:	2132      	movs	r1, #50	; 0x32
 8016288:	461a      	mov	r2, r3
 801628a:	2301      	movs	r3, #1
 801628c:	f7fc fdf8 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016290:	4603      	mov	r3, r0
 8016292:	2b00      	cmp	r3, #0
 8016294:	d101      	bne.n	801629a <LSM303AGR_ACC_W_Int1_Threshold+0x6a>
    return MEMS_ERROR;
 8016296:	2300      	movs	r3, #0
 8016298:	e000      	b.n	801629c <LSM303AGR_ACC_W_Int1_Threshold+0x6c>

  return MEMS_SUCCESS;
 801629a:	2301      	movs	r3, #1
}
 801629c:	4618      	mov	r0, r3
 801629e:	b005      	add	sp, #20
 80162a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80162a4:	f3af 8000 	nop.w
 80162a8:	f3af 8000 	nop.w
 80162ac:	f3af 8000 	nop.w

080162b0 <LSM303AGR_ACC_R_Int1_Threshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Threshold(void *handle, u8_t *value)
{
 80162b0:	b500      	push	{lr}
 80162b2:	b083      	sub	sp, #12
 80162b4:	9001      	str	r0, [sp, #4]
 80162b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_THS, (u8_t *)value, 1) )
 80162b8:	9801      	ldr	r0, [sp, #4]
 80162ba:	2132      	movs	r1, #50	; 0x32
 80162bc:	9a00      	ldr	r2, [sp, #0]
 80162be:	2301      	movs	r3, #1
 80162c0:	f7fc fe06 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80162c4:	4603      	mov	r3, r0
 80162c6:	2b00      	cmp	r3, #0
 80162c8:	d101      	bne.n	80162ce <LSM303AGR_ACC_R_Int1_Threshold+0x1e>
    return MEMS_ERROR;
 80162ca:	2300      	movs	r3, #0
 80162cc:	e00b      	b.n	80162e6 <LSM303AGR_ACC_R_Int1_Threshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 80162ce:	9b00      	ldr	r3, [sp, #0]
 80162d0:	781b      	ldrb	r3, [r3, #0]
 80162d2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80162d6:	b2da      	uxtb	r2, r3
 80162d8:	9b00      	ldr	r3, [sp, #0]
 80162da:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 80162dc:	9b00      	ldr	r3, [sp, #0]
 80162de:	781a      	ldrb	r2, [r3, #0]
 80162e0:	9b00      	ldr	r3, [sp, #0]
 80162e2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80162e4:	2301      	movs	r3, #1
}
 80162e6:	4618      	mov	r0, r3
 80162e8:	b003      	add	sp, #12
 80162ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80162ee:	bf00      	nop

080162f0 <LSM303AGR_ACC_W_Int2_Threshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_Threshold(void *handle, u8_t newValue)
{
 80162f0:	b500      	push	{lr}
 80162f2:	b085      	sub	sp, #20
 80162f4:	9001      	str	r0, [sp, #4]
 80162f6:	460b      	mov	r3, r1
 80162f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 80162fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016300:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016304:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_THS, &value, 1) )
 8016308:	f10d 030f 	add.w	r3, sp, #15
 801630c:	9801      	ldr	r0, [sp, #4]
 801630e:	2136      	movs	r1, #54	; 0x36
 8016310:	461a      	mov	r2, r3
 8016312:	2301      	movs	r3, #1
 8016314:	f7fc fddc 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016318:	4603      	mov	r3, r0
 801631a:	2b00      	cmp	r3, #0
 801631c:	d101      	bne.n	8016322 <LSM303AGR_ACC_W_Int2_Threshold+0x32>
    return MEMS_ERROR;
 801631e:	2300      	movs	r3, #0
 8016320:	e01c      	b.n	801635c <LSM303AGR_ACC_W_Int2_Threshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8016322:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016326:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801632a:	b2db      	uxtb	r3, r3
 801632c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016330:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016334:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016338:	4313      	orrs	r3, r2
 801633a:	b2db      	uxtb	r3, r3
 801633c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_THS, &value, 1) )
 8016340:	f10d 030f 	add.w	r3, sp, #15
 8016344:	9801      	ldr	r0, [sp, #4]
 8016346:	2136      	movs	r1, #54	; 0x36
 8016348:	461a      	mov	r2, r3
 801634a:	2301      	movs	r3, #1
 801634c:	f7fc fd98 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016350:	4603      	mov	r3, r0
 8016352:	2b00      	cmp	r3, #0
 8016354:	d101      	bne.n	801635a <LSM303AGR_ACC_W_Int2_Threshold+0x6a>
    return MEMS_ERROR;
 8016356:	2300      	movs	r3, #0
 8016358:	e000      	b.n	801635c <LSM303AGR_ACC_W_Int2_Threshold+0x6c>

  return MEMS_SUCCESS;
 801635a:	2301      	movs	r3, #1
}
 801635c:	4618      	mov	r0, r3
 801635e:	b005      	add	sp, #20
 8016360:	f85d fb04 	ldr.w	pc, [sp], #4
 8016364:	f3af 8000 	nop.w
 8016368:	f3af 8000 	nop.w
 801636c:	f3af 8000 	nop.w

08016370 <LSM303AGR_ACC_R_Int2_Threshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Threshold(void *handle, u8_t *value)
{
 8016370:	b500      	push	{lr}
 8016372:	b083      	sub	sp, #12
 8016374:	9001      	str	r0, [sp, #4]
 8016376:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_THS, (u8_t *)value, 1) )
 8016378:	9801      	ldr	r0, [sp, #4]
 801637a:	2136      	movs	r1, #54	; 0x36
 801637c:	9a00      	ldr	r2, [sp, #0]
 801637e:	2301      	movs	r3, #1
 8016380:	f7fc fda6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016384:	4603      	mov	r3, r0
 8016386:	2b00      	cmp	r3, #0
 8016388:	d101      	bne.n	801638e <LSM303AGR_ACC_R_Int2_Threshold+0x1e>
    return MEMS_ERROR;
 801638a:	2300      	movs	r3, #0
 801638c:	e00b      	b.n	80163a6 <LSM303AGR_ACC_R_Int2_Threshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 801638e:	9b00      	ldr	r3, [sp, #0]
 8016390:	781b      	ldrb	r3, [r3, #0]
 8016392:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016396:	b2da      	uxtb	r2, r3
 8016398:	9b00      	ldr	r3, [sp, #0]
 801639a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 801639c:	9b00      	ldr	r3, [sp, #0]
 801639e:	781a      	ldrb	r2, [r3, #0]
 80163a0:	9b00      	ldr	r3, [sp, #0]
 80163a2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80163a4:	2301      	movs	r3, #1
}
 80163a6:	4618      	mov	r0, r3
 80163a8:	b003      	add	sp, #12
 80163aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80163ae:	bf00      	nop

080163b0 <LSM303AGR_ACC_W_Int1_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_Duration(void *handle, u8_t newValue)
{
 80163b0:	b500      	push	{lr}
 80163b2:	b085      	sub	sp, #20
 80163b4:	9001      	str	r0, [sp, #4]
 80163b6:	460b      	mov	r3, r1
 80163b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_D_POSITION; //mask
  newValue &= LSM303AGR_ACC_D_MASK; //coerce
 80163bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80163c0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80163c4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_DURATION, &value, 1) )
 80163c8:	f10d 030f 	add.w	r3, sp, #15
 80163cc:	9801      	ldr	r0, [sp, #4]
 80163ce:	2133      	movs	r1, #51	; 0x33
 80163d0:	461a      	mov	r2, r3
 80163d2:	2301      	movs	r3, #1
 80163d4:	f7fc fd7c 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80163d8:	4603      	mov	r3, r0
 80163da:	2b00      	cmp	r3, #0
 80163dc:	d101      	bne.n	80163e2 <LSM303AGR_ACC_W_Int1_Duration+0x32>
    return MEMS_ERROR;
 80163de:	2300      	movs	r3, #0
 80163e0:	e01c      	b.n	801641c <LSM303AGR_ACC_W_Int1_Duration+0x6c>

  value &= ~LSM303AGR_ACC_D_MASK;
 80163e2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80163e6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80163ea:	b2db      	uxtb	r3, r3
 80163ec:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80163f0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80163f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80163f8:	4313      	orrs	r3, r2
 80163fa:	b2db      	uxtb	r3, r3
 80163fc:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_DURATION, &value, 1) )
 8016400:	f10d 030f 	add.w	r3, sp, #15
 8016404:	9801      	ldr	r0, [sp, #4]
 8016406:	2133      	movs	r1, #51	; 0x33
 8016408:	461a      	mov	r2, r3
 801640a:	2301      	movs	r3, #1
 801640c:	f7fc fd38 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016410:	4603      	mov	r3, r0
 8016412:	2b00      	cmp	r3, #0
 8016414:	d101      	bne.n	801641a <LSM303AGR_ACC_W_Int1_Duration+0x6a>
    return MEMS_ERROR;
 8016416:	2300      	movs	r3, #0
 8016418:	e000      	b.n	801641c <LSM303AGR_ACC_W_Int1_Duration+0x6c>

  return MEMS_SUCCESS;
 801641a:	2301      	movs	r3, #1
}
 801641c:	4618      	mov	r0, r3
 801641e:	b005      	add	sp, #20
 8016420:	f85d fb04 	ldr.w	pc, [sp], #4
 8016424:	f3af 8000 	nop.w
 8016428:	f3af 8000 	nop.w
 801642c:	f3af 8000 	nop.w

08016430 <LSM303AGR_ACC_R_Int1_Duration>:
* Input          : Pointer to u8_t
* Output         : Status of D
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Duration(void *handle, u8_t *value)
{
 8016430:	b500      	push	{lr}
 8016432:	b083      	sub	sp, #12
 8016434:	9001      	str	r0, [sp, #4]
 8016436:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_DURATION, (u8_t *)value, 1) )
 8016438:	9801      	ldr	r0, [sp, #4]
 801643a:	2133      	movs	r1, #51	; 0x33
 801643c:	9a00      	ldr	r2, [sp, #0]
 801643e:	2301      	movs	r3, #1
 8016440:	f7fc fd46 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016444:	4603      	mov	r3, r0
 8016446:	2b00      	cmp	r3, #0
 8016448:	d101      	bne.n	801644e <LSM303AGR_ACC_R_Int1_Duration+0x1e>
    return MEMS_ERROR;
 801644a:	2300      	movs	r3, #0
 801644c:	e00b      	b.n	8016466 <LSM303AGR_ACC_R_Int1_Duration+0x36>

  *value &= LSM303AGR_ACC_D_MASK; //coerce
 801644e:	9b00      	ldr	r3, [sp, #0]
 8016450:	781b      	ldrb	r3, [r3, #0]
 8016452:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016456:	b2da      	uxtb	r2, r3
 8016458:	9b00      	ldr	r3, [sp, #0]
 801645a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_D_POSITION; //mask
 801645c:	9b00      	ldr	r3, [sp, #0]
 801645e:	781a      	ldrb	r2, [r3, #0]
 8016460:	9b00      	ldr	r3, [sp, #0]
 8016462:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016464:	2301      	movs	r3, #1
}
 8016466:	4618      	mov	r0, r3
 8016468:	b003      	add	sp, #12
 801646a:	f85d fb04 	ldr.w	pc, [sp], #4
 801646e:	bf00      	nop

08016470 <LSM303AGR_ACC_W_Int2_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_Duration(void *handle, u8_t newValue)
{
 8016470:	b500      	push	{lr}
 8016472:	b085      	sub	sp, #20
 8016474:	9001      	str	r0, [sp, #4]
 8016476:	460b      	mov	r3, r1
 8016478:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_D_POSITION; //mask
  newValue &= LSM303AGR_ACC_D_MASK; //coerce
 801647c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016480:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016484:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_DURATION, &value, 1) )
 8016488:	f10d 030f 	add.w	r3, sp, #15
 801648c:	9801      	ldr	r0, [sp, #4]
 801648e:	2137      	movs	r1, #55	; 0x37
 8016490:	461a      	mov	r2, r3
 8016492:	2301      	movs	r3, #1
 8016494:	f7fc fd1c 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016498:	4603      	mov	r3, r0
 801649a:	2b00      	cmp	r3, #0
 801649c:	d101      	bne.n	80164a2 <LSM303AGR_ACC_W_Int2_Duration+0x32>
    return MEMS_ERROR;
 801649e:	2300      	movs	r3, #0
 80164a0:	e01c      	b.n	80164dc <LSM303AGR_ACC_W_Int2_Duration+0x6c>

  value &= ~LSM303AGR_ACC_D_MASK;
 80164a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80164a6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80164aa:	b2db      	uxtb	r3, r3
 80164ac:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80164b0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80164b4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80164b8:	4313      	orrs	r3, r2
 80164ba:	b2db      	uxtb	r3, r3
 80164bc:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_DURATION, &value, 1) )
 80164c0:	f10d 030f 	add.w	r3, sp, #15
 80164c4:	9801      	ldr	r0, [sp, #4]
 80164c6:	2137      	movs	r1, #55	; 0x37
 80164c8:	461a      	mov	r2, r3
 80164ca:	2301      	movs	r3, #1
 80164cc:	f7fc fcd8 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80164d0:	4603      	mov	r3, r0
 80164d2:	2b00      	cmp	r3, #0
 80164d4:	d101      	bne.n	80164da <LSM303AGR_ACC_W_Int2_Duration+0x6a>
    return MEMS_ERROR;
 80164d6:	2300      	movs	r3, #0
 80164d8:	e000      	b.n	80164dc <LSM303AGR_ACC_W_Int2_Duration+0x6c>

  return MEMS_SUCCESS;
 80164da:	2301      	movs	r3, #1
}
 80164dc:	4618      	mov	r0, r3
 80164de:	b005      	add	sp, #20
 80164e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80164e4:	f3af 8000 	nop.w
 80164e8:	f3af 8000 	nop.w
 80164ec:	f3af 8000 	nop.w

080164f0 <LSM303AGR_ACC_R_Int2_Duration>:
* Input          : Pointer to u8_t
* Output         : Status of D
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Duration(void *handle, u8_t *value)
{
 80164f0:	b500      	push	{lr}
 80164f2:	b083      	sub	sp, #12
 80164f4:	9001      	str	r0, [sp, #4]
 80164f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_DURATION, (u8_t *)value, 1) )
 80164f8:	9801      	ldr	r0, [sp, #4]
 80164fa:	2137      	movs	r1, #55	; 0x37
 80164fc:	9a00      	ldr	r2, [sp, #0]
 80164fe:	2301      	movs	r3, #1
 8016500:	f7fc fce6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016504:	4603      	mov	r3, r0
 8016506:	2b00      	cmp	r3, #0
 8016508:	d101      	bne.n	801650e <LSM303AGR_ACC_R_Int2_Duration+0x1e>
    return MEMS_ERROR;
 801650a:	2300      	movs	r3, #0
 801650c:	e00b      	b.n	8016526 <LSM303AGR_ACC_R_Int2_Duration+0x36>

  *value &= LSM303AGR_ACC_D_MASK; //coerce
 801650e:	9b00      	ldr	r3, [sp, #0]
 8016510:	781b      	ldrb	r3, [r3, #0]
 8016512:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016516:	b2da      	uxtb	r2, r3
 8016518:	9b00      	ldr	r3, [sp, #0]
 801651a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_D_POSITION; //mask
 801651c:	9b00      	ldr	r3, [sp, #0]
 801651e:	781a      	ldrb	r2, [r3, #0]
 8016520:	9b00      	ldr	r3, [sp, #0]
 8016522:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016524:	2301      	movs	r3, #1
}
 8016526:	4618      	mov	r0, r3
 8016528:	b003      	add	sp, #12
 801652a:	f85d fb04 	ldr.w	pc, [sp], #4
 801652e:	bf00      	nop

08016530 <LSM303AGR_ACC_W_XSingle>:
* Input          : LSM303AGR_ACC_XS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XSingle(void *handle, LSM303AGR_ACC_XS_t newValue)
{
 8016530:	b500      	push	{lr}
 8016532:	b085      	sub	sp, #20
 8016534:	9001      	str	r0, [sp, #4]
 8016536:	460b      	mov	r3, r1
 8016538:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 801653c:	f10d 030f 	add.w	r3, sp, #15
 8016540:	9801      	ldr	r0, [sp, #4]
 8016542:	2138      	movs	r1, #56	; 0x38
 8016544:	461a      	mov	r2, r3
 8016546:	2301      	movs	r3, #1
 8016548:	f7fc fcc2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801654c:	4603      	mov	r3, r0
 801654e:	2b00      	cmp	r3, #0
 8016550:	d101      	bne.n	8016556 <LSM303AGR_ACC_W_XSingle+0x26>
    return MEMS_ERROR;
 8016552:	2300      	movs	r3, #0
 8016554:	e01c      	b.n	8016590 <LSM303AGR_ACC_W_XSingle+0x60>

  value &= ~LSM303AGR_ACC_XS_MASK;
 8016556:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801655a:	f023 0301 	bic.w	r3, r3, #1
 801655e:	b2db      	uxtb	r3, r3
 8016560:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016564:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016568:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801656c:	4313      	orrs	r3, r2
 801656e:	b2db      	uxtb	r3, r3
 8016570:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8016574:	f10d 030f 	add.w	r3, sp, #15
 8016578:	9801      	ldr	r0, [sp, #4]
 801657a:	2138      	movs	r1, #56	; 0x38
 801657c:	461a      	mov	r2, r3
 801657e:	2301      	movs	r3, #1
 8016580:	f7fc fc7e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016584:	4603      	mov	r3, r0
 8016586:	2b00      	cmp	r3, #0
 8016588:	d101      	bne.n	801658e <LSM303AGR_ACC_W_XSingle+0x5e>
    return MEMS_ERROR;
 801658a:	2300      	movs	r3, #0
 801658c:	e000      	b.n	8016590 <LSM303AGR_ACC_W_XSingle+0x60>

  return MEMS_SUCCESS;
 801658e:	2301      	movs	r3, #1
}
 8016590:	4618      	mov	r0, r3
 8016592:	b005      	add	sp, #20
 8016594:	f85d fb04 	ldr.w	pc, [sp], #4
 8016598:	f3af 8000 	nop.w
 801659c:	f3af 8000 	nop.w

080165a0 <LSM303AGR_ACC_R_XSingle>:
* Input          : Pointer to LSM303AGR_ACC_XS_t
* Output         : Status of XS see LSM303AGR_ACC_XS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XSingle(void *handle, LSM303AGR_ACC_XS_t *value)
{
 80165a0:	b500      	push	{lr}
 80165a2:	b083      	sub	sp, #12
 80165a4:	9001      	str	r0, [sp, #4]
 80165a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 80165a8:	9801      	ldr	r0, [sp, #4]
 80165aa:	2138      	movs	r1, #56	; 0x38
 80165ac:	9a00      	ldr	r2, [sp, #0]
 80165ae:	2301      	movs	r3, #1
 80165b0:	f7fc fc8e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80165b4:	4603      	mov	r3, r0
 80165b6:	2b00      	cmp	r3, #0
 80165b8:	d101      	bne.n	80165be <LSM303AGR_ACC_R_XSingle+0x1e>
    return MEMS_ERROR;
 80165ba:	2300      	movs	r3, #0
 80165bc:	e007      	b.n	80165ce <LSM303AGR_ACC_R_XSingle+0x2e>

  *value &= LSM303AGR_ACC_XS_MASK; //mask
 80165be:	9b00      	ldr	r3, [sp, #0]
 80165c0:	781b      	ldrb	r3, [r3, #0]
 80165c2:	f003 0301 	and.w	r3, r3, #1
 80165c6:	b2da      	uxtb	r2, r3
 80165c8:	9b00      	ldr	r3, [sp, #0]
 80165ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80165cc:	2301      	movs	r3, #1
}
 80165ce:	4618      	mov	r0, r3
 80165d0:	b003      	add	sp, #12
 80165d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80165d6:	bf00      	nop
 80165d8:	f3af 8000 	nop.w
 80165dc:	f3af 8000 	nop.w

080165e0 <LSM303AGR_ACC_W_XDouble>:
* Input          : LSM303AGR_ACC_XD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XDouble(void *handle, LSM303AGR_ACC_XD_t newValue)
{
 80165e0:	b500      	push	{lr}
 80165e2:	b085      	sub	sp, #20
 80165e4:	9001      	str	r0, [sp, #4]
 80165e6:	460b      	mov	r3, r1
 80165e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80165ec:	f10d 030f 	add.w	r3, sp, #15
 80165f0:	9801      	ldr	r0, [sp, #4]
 80165f2:	2138      	movs	r1, #56	; 0x38
 80165f4:	461a      	mov	r2, r3
 80165f6:	2301      	movs	r3, #1
 80165f8:	f7fc fc6a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80165fc:	4603      	mov	r3, r0
 80165fe:	2b00      	cmp	r3, #0
 8016600:	d101      	bne.n	8016606 <LSM303AGR_ACC_W_XDouble+0x26>
    return MEMS_ERROR;
 8016602:	2300      	movs	r3, #0
 8016604:	e01c      	b.n	8016640 <LSM303AGR_ACC_W_XDouble+0x60>

  value &= ~LSM303AGR_ACC_XD_MASK;
 8016606:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801660a:	f023 0302 	bic.w	r3, r3, #2
 801660e:	b2db      	uxtb	r3, r3
 8016610:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016614:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016618:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801661c:	4313      	orrs	r3, r2
 801661e:	b2db      	uxtb	r3, r3
 8016620:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8016624:	f10d 030f 	add.w	r3, sp, #15
 8016628:	9801      	ldr	r0, [sp, #4]
 801662a:	2138      	movs	r1, #56	; 0x38
 801662c:	461a      	mov	r2, r3
 801662e:	2301      	movs	r3, #1
 8016630:	f7fc fc26 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016634:	4603      	mov	r3, r0
 8016636:	2b00      	cmp	r3, #0
 8016638:	d101      	bne.n	801663e <LSM303AGR_ACC_W_XDouble+0x5e>
    return MEMS_ERROR;
 801663a:	2300      	movs	r3, #0
 801663c:	e000      	b.n	8016640 <LSM303AGR_ACC_W_XDouble+0x60>

  return MEMS_SUCCESS;
 801663e:	2301      	movs	r3, #1
}
 8016640:	4618      	mov	r0, r3
 8016642:	b005      	add	sp, #20
 8016644:	f85d fb04 	ldr.w	pc, [sp], #4
 8016648:	f3af 8000 	nop.w
 801664c:	f3af 8000 	nop.w

08016650 <LSM303AGR_ACC_R_XDouble>:
* Input          : Pointer to LSM303AGR_ACC_XD_t
* Output         : Status of XD see LSM303AGR_ACC_XD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDouble(void *handle, LSM303AGR_ACC_XD_t *value)
{
 8016650:	b500      	push	{lr}
 8016652:	b083      	sub	sp, #12
 8016654:	9001      	str	r0, [sp, #4]
 8016656:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8016658:	9801      	ldr	r0, [sp, #4]
 801665a:	2138      	movs	r1, #56	; 0x38
 801665c:	9a00      	ldr	r2, [sp, #0]
 801665e:	2301      	movs	r3, #1
 8016660:	f7fc fc36 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016664:	4603      	mov	r3, r0
 8016666:	2b00      	cmp	r3, #0
 8016668:	d101      	bne.n	801666e <LSM303AGR_ACC_R_XDouble+0x1e>
    return MEMS_ERROR;
 801666a:	2300      	movs	r3, #0
 801666c:	e007      	b.n	801667e <LSM303AGR_ACC_R_XDouble+0x2e>

  *value &= LSM303AGR_ACC_XD_MASK; //mask
 801666e:	9b00      	ldr	r3, [sp, #0]
 8016670:	781b      	ldrb	r3, [r3, #0]
 8016672:	f003 0302 	and.w	r3, r3, #2
 8016676:	b2da      	uxtb	r2, r3
 8016678:	9b00      	ldr	r3, [sp, #0]
 801667a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801667c:	2301      	movs	r3, #1
}
 801667e:	4618      	mov	r0, r3
 8016680:	b003      	add	sp, #12
 8016682:	f85d fb04 	ldr.w	pc, [sp], #4
 8016686:	bf00      	nop
 8016688:	f3af 8000 	nop.w
 801668c:	f3af 8000 	nop.w

08016690 <LSM303AGR_ACC_W_YSingle>:
* Input          : LSM303AGR_ACC_YS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YSingle(void *handle, LSM303AGR_ACC_YS_t newValue)
{
 8016690:	b500      	push	{lr}
 8016692:	b085      	sub	sp, #20
 8016694:	9001      	str	r0, [sp, #4]
 8016696:	460b      	mov	r3, r1
 8016698:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 801669c:	f10d 030f 	add.w	r3, sp, #15
 80166a0:	9801      	ldr	r0, [sp, #4]
 80166a2:	2138      	movs	r1, #56	; 0x38
 80166a4:	461a      	mov	r2, r3
 80166a6:	2301      	movs	r3, #1
 80166a8:	f7fc fc12 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80166ac:	4603      	mov	r3, r0
 80166ae:	2b00      	cmp	r3, #0
 80166b0:	d101      	bne.n	80166b6 <LSM303AGR_ACC_W_YSingle+0x26>
    return MEMS_ERROR;
 80166b2:	2300      	movs	r3, #0
 80166b4:	e01c      	b.n	80166f0 <LSM303AGR_ACC_W_YSingle+0x60>

  value &= ~LSM303AGR_ACC_YS_MASK;
 80166b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80166ba:	f023 0304 	bic.w	r3, r3, #4
 80166be:	b2db      	uxtb	r3, r3
 80166c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80166c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80166c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80166cc:	4313      	orrs	r3, r2
 80166ce:	b2db      	uxtb	r3, r3
 80166d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80166d4:	f10d 030f 	add.w	r3, sp, #15
 80166d8:	9801      	ldr	r0, [sp, #4]
 80166da:	2138      	movs	r1, #56	; 0x38
 80166dc:	461a      	mov	r2, r3
 80166de:	2301      	movs	r3, #1
 80166e0:	f7fc fbce 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80166e4:	4603      	mov	r3, r0
 80166e6:	2b00      	cmp	r3, #0
 80166e8:	d101      	bne.n	80166ee <LSM303AGR_ACC_W_YSingle+0x5e>
    return MEMS_ERROR;
 80166ea:	2300      	movs	r3, #0
 80166ec:	e000      	b.n	80166f0 <LSM303AGR_ACC_W_YSingle+0x60>

  return MEMS_SUCCESS;
 80166ee:	2301      	movs	r3, #1
}
 80166f0:	4618      	mov	r0, r3
 80166f2:	b005      	add	sp, #20
 80166f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80166f8:	f3af 8000 	nop.w
 80166fc:	f3af 8000 	nop.w

08016700 <LSM303AGR_ACC_R_YSingle>:
* Input          : Pointer to LSM303AGR_ACC_YS_t
* Output         : Status of YS see LSM303AGR_ACC_YS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YSingle(void *handle, LSM303AGR_ACC_YS_t *value)
{
 8016700:	b500      	push	{lr}
 8016702:	b083      	sub	sp, #12
 8016704:	9001      	str	r0, [sp, #4]
 8016706:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8016708:	9801      	ldr	r0, [sp, #4]
 801670a:	2138      	movs	r1, #56	; 0x38
 801670c:	9a00      	ldr	r2, [sp, #0]
 801670e:	2301      	movs	r3, #1
 8016710:	f7fc fbde 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016714:	4603      	mov	r3, r0
 8016716:	2b00      	cmp	r3, #0
 8016718:	d101      	bne.n	801671e <LSM303AGR_ACC_R_YSingle+0x1e>
    return MEMS_ERROR;
 801671a:	2300      	movs	r3, #0
 801671c:	e007      	b.n	801672e <LSM303AGR_ACC_R_YSingle+0x2e>

  *value &= LSM303AGR_ACC_YS_MASK; //mask
 801671e:	9b00      	ldr	r3, [sp, #0]
 8016720:	781b      	ldrb	r3, [r3, #0]
 8016722:	f003 0304 	and.w	r3, r3, #4
 8016726:	b2da      	uxtb	r2, r3
 8016728:	9b00      	ldr	r3, [sp, #0]
 801672a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801672c:	2301      	movs	r3, #1
}
 801672e:	4618      	mov	r0, r3
 8016730:	b003      	add	sp, #12
 8016732:	f85d fb04 	ldr.w	pc, [sp], #4
 8016736:	bf00      	nop
 8016738:	f3af 8000 	nop.w
 801673c:	f3af 8000 	nop.w

08016740 <LSM303AGR_ACC_W_YDouble>:
* Input          : LSM303AGR_ACC_YD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YDouble(void *handle, LSM303AGR_ACC_YD_t newValue)
{
 8016740:	b500      	push	{lr}
 8016742:	b085      	sub	sp, #20
 8016744:	9001      	str	r0, [sp, #4]
 8016746:	460b      	mov	r3, r1
 8016748:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 801674c:	f10d 030f 	add.w	r3, sp, #15
 8016750:	9801      	ldr	r0, [sp, #4]
 8016752:	2138      	movs	r1, #56	; 0x38
 8016754:	461a      	mov	r2, r3
 8016756:	2301      	movs	r3, #1
 8016758:	f7fc fbba 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801675c:	4603      	mov	r3, r0
 801675e:	2b00      	cmp	r3, #0
 8016760:	d101      	bne.n	8016766 <LSM303AGR_ACC_W_YDouble+0x26>
    return MEMS_ERROR;
 8016762:	2300      	movs	r3, #0
 8016764:	e01c      	b.n	80167a0 <LSM303AGR_ACC_W_YDouble+0x60>

  value &= ~LSM303AGR_ACC_YD_MASK;
 8016766:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801676a:	f023 0308 	bic.w	r3, r3, #8
 801676e:	b2db      	uxtb	r3, r3
 8016770:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016774:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016778:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801677c:	4313      	orrs	r3, r2
 801677e:	b2db      	uxtb	r3, r3
 8016780:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8016784:	f10d 030f 	add.w	r3, sp, #15
 8016788:	9801      	ldr	r0, [sp, #4]
 801678a:	2138      	movs	r1, #56	; 0x38
 801678c:	461a      	mov	r2, r3
 801678e:	2301      	movs	r3, #1
 8016790:	f7fc fb76 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016794:	4603      	mov	r3, r0
 8016796:	2b00      	cmp	r3, #0
 8016798:	d101      	bne.n	801679e <LSM303AGR_ACC_W_YDouble+0x5e>
    return MEMS_ERROR;
 801679a:	2300      	movs	r3, #0
 801679c:	e000      	b.n	80167a0 <LSM303AGR_ACC_W_YDouble+0x60>

  return MEMS_SUCCESS;
 801679e:	2301      	movs	r3, #1
}
 80167a0:	4618      	mov	r0, r3
 80167a2:	b005      	add	sp, #20
 80167a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80167a8:	f3af 8000 	nop.w
 80167ac:	f3af 8000 	nop.w

080167b0 <LSM303AGR_ACC_R_YDouble>:
* Input          : Pointer to LSM303AGR_ACC_YD_t
* Output         : Status of YD see LSM303AGR_ACC_YD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDouble(void *handle, LSM303AGR_ACC_YD_t *value)
{
 80167b0:	b500      	push	{lr}
 80167b2:	b083      	sub	sp, #12
 80167b4:	9001      	str	r0, [sp, #4]
 80167b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 80167b8:	9801      	ldr	r0, [sp, #4]
 80167ba:	2138      	movs	r1, #56	; 0x38
 80167bc:	9a00      	ldr	r2, [sp, #0]
 80167be:	2301      	movs	r3, #1
 80167c0:	f7fc fb86 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80167c4:	4603      	mov	r3, r0
 80167c6:	2b00      	cmp	r3, #0
 80167c8:	d101      	bne.n	80167ce <LSM303AGR_ACC_R_YDouble+0x1e>
    return MEMS_ERROR;
 80167ca:	2300      	movs	r3, #0
 80167cc:	e007      	b.n	80167de <LSM303AGR_ACC_R_YDouble+0x2e>

  *value &= LSM303AGR_ACC_YD_MASK; //mask
 80167ce:	9b00      	ldr	r3, [sp, #0]
 80167d0:	781b      	ldrb	r3, [r3, #0]
 80167d2:	f003 0308 	and.w	r3, r3, #8
 80167d6:	b2da      	uxtb	r2, r3
 80167d8:	9b00      	ldr	r3, [sp, #0]
 80167da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80167dc:	2301      	movs	r3, #1
}
 80167de:	4618      	mov	r0, r3
 80167e0:	b003      	add	sp, #12
 80167e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80167e6:	bf00      	nop
 80167e8:	f3af 8000 	nop.w
 80167ec:	f3af 8000 	nop.w

080167f0 <LSM303AGR_ACC_W_ZSingle>:
* Input          : LSM303AGR_ACC_ZS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZSingle(void *handle, LSM303AGR_ACC_ZS_t newValue)
{
 80167f0:	b500      	push	{lr}
 80167f2:	b085      	sub	sp, #20
 80167f4:	9001      	str	r0, [sp, #4]
 80167f6:	460b      	mov	r3, r1
 80167f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80167fc:	f10d 030f 	add.w	r3, sp, #15
 8016800:	9801      	ldr	r0, [sp, #4]
 8016802:	2138      	movs	r1, #56	; 0x38
 8016804:	461a      	mov	r2, r3
 8016806:	2301      	movs	r3, #1
 8016808:	f7fc fb62 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 801680c:	4603      	mov	r3, r0
 801680e:	2b00      	cmp	r3, #0
 8016810:	d101      	bne.n	8016816 <LSM303AGR_ACC_W_ZSingle+0x26>
    return MEMS_ERROR;
 8016812:	2300      	movs	r3, #0
 8016814:	e01c      	b.n	8016850 <LSM303AGR_ACC_W_ZSingle+0x60>

  value &= ~LSM303AGR_ACC_ZS_MASK;
 8016816:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801681a:	f023 0310 	bic.w	r3, r3, #16
 801681e:	b2db      	uxtb	r3, r3
 8016820:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016824:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016828:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801682c:	4313      	orrs	r3, r2
 801682e:	b2db      	uxtb	r3, r3
 8016830:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8016834:	f10d 030f 	add.w	r3, sp, #15
 8016838:	9801      	ldr	r0, [sp, #4]
 801683a:	2138      	movs	r1, #56	; 0x38
 801683c:	461a      	mov	r2, r3
 801683e:	2301      	movs	r3, #1
 8016840:	f7fc fb1e 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016844:	4603      	mov	r3, r0
 8016846:	2b00      	cmp	r3, #0
 8016848:	d101      	bne.n	801684e <LSM303AGR_ACC_W_ZSingle+0x5e>
    return MEMS_ERROR;
 801684a:	2300      	movs	r3, #0
 801684c:	e000      	b.n	8016850 <LSM303AGR_ACC_W_ZSingle+0x60>

  return MEMS_SUCCESS;
 801684e:	2301      	movs	r3, #1
}
 8016850:	4618      	mov	r0, r3
 8016852:	b005      	add	sp, #20
 8016854:	f85d fb04 	ldr.w	pc, [sp], #4
 8016858:	f3af 8000 	nop.w
 801685c:	f3af 8000 	nop.w

08016860 <LSM303AGR_ACC_R_ZSingle>:
* Input          : Pointer to LSM303AGR_ACC_ZS_t
* Output         : Status of ZS see LSM303AGR_ACC_ZS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZSingle(void *handle, LSM303AGR_ACC_ZS_t *value)
{
 8016860:	b500      	push	{lr}
 8016862:	b083      	sub	sp, #12
 8016864:	9001      	str	r0, [sp, #4]
 8016866:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8016868:	9801      	ldr	r0, [sp, #4]
 801686a:	2138      	movs	r1, #56	; 0x38
 801686c:	9a00      	ldr	r2, [sp, #0]
 801686e:	2301      	movs	r3, #1
 8016870:	f7fc fb2e 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016874:	4603      	mov	r3, r0
 8016876:	2b00      	cmp	r3, #0
 8016878:	d101      	bne.n	801687e <LSM303AGR_ACC_R_ZSingle+0x1e>
    return MEMS_ERROR;
 801687a:	2300      	movs	r3, #0
 801687c:	e007      	b.n	801688e <LSM303AGR_ACC_R_ZSingle+0x2e>

  *value &= LSM303AGR_ACC_ZS_MASK; //mask
 801687e:	9b00      	ldr	r3, [sp, #0]
 8016880:	781b      	ldrb	r3, [r3, #0]
 8016882:	f003 0310 	and.w	r3, r3, #16
 8016886:	b2da      	uxtb	r2, r3
 8016888:	9b00      	ldr	r3, [sp, #0]
 801688a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801688c:	2301      	movs	r3, #1
}
 801688e:	4618      	mov	r0, r3
 8016890:	b003      	add	sp, #12
 8016892:	f85d fb04 	ldr.w	pc, [sp], #4
 8016896:	bf00      	nop
 8016898:	f3af 8000 	nop.w
 801689c:	f3af 8000 	nop.w

080168a0 <LSM303AGR_ACC_W_ZDouble>:
* Input          : LSM303AGR_ACC_ZD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZDouble(void *handle, LSM303AGR_ACC_ZD_t newValue)
{
 80168a0:	b500      	push	{lr}
 80168a2:	b085      	sub	sp, #20
 80168a4:	9001      	str	r0, [sp, #4]
 80168a6:	460b      	mov	r3, r1
 80168a8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80168ac:	f10d 030f 	add.w	r3, sp, #15
 80168b0:	9801      	ldr	r0, [sp, #4]
 80168b2:	2138      	movs	r1, #56	; 0x38
 80168b4:	461a      	mov	r2, r3
 80168b6:	2301      	movs	r3, #1
 80168b8:	f7fc fb0a 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80168bc:	4603      	mov	r3, r0
 80168be:	2b00      	cmp	r3, #0
 80168c0:	d101      	bne.n	80168c6 <LSM303AGR_ACC_W_ZDouble+0x26>
    return MEMS_ERROR;
 80168c2:	2300      	movs	r3, #0
 80168c4:	e01c      	b.n	8016900 <LSM303AGR_ACC_W_ZDouble+0x60>

  value &= ~LSM303AGR_ACC_ZD_MASK;
 80168c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80168ca:	f023 0320 	bic.w	r3, r3, #32
 80168ce:	b2db      	uxtb	r3, r3
 80168d0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80168d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80168d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80168dc:	4313      	orrs	r3, r2
 80168de:	b2db      	uxtb	r3, r3
 80168e0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80168e4:	f10d 030f 	add.w	r3, sp, #15
 80168e8:	9801      	ldr	r0, [sp, #4]
 80168ea:	2138      	movs	r1, #56	; 0x38
 80168ec:	461a      	mov	r2, r3
 80168ee:	2301      	movs	r3, #1
 80168f0:	f7fc fac6 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 80168f4:	4603      	mov	r3, r0
 80168f6:	2b00      	cmp	r3, #0
 80168f8:	d101      	bne.n	80168fe <LSM303AGR_ACC_W_ZDouble+0x5e>
    return MEMS_ERROR;
 80168fa:	2300      	movs	r3, #0
 80168fc:	e000      	b.n	8016900 <LSM303AGR_ACC_W_ZDouble+0x60>

  return MEMS_SUCCESS;
 80168fe:	2301      	movs	r3, #1
}
 8016900:	4618      	mov	r0, r3
 8016902:	b005      	add	sp, #20
 8016904:	f85d fb04 	ldr.w	pc, [sp], #4
 8016908:	f3af 8000 	nop.w
 801690c:	f3af 8000 	nop.w

08016910 <LSM303AGR_ACC_R_ZDouble>:
* Input          : Pointer to LSM303AGR_ACC_ZD_t
* Output         : Status of ZD see LSM303AGR_ACC_ZD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDouble(void *handle, LSM303AGR_ACC_ZD_t *value)
{
 8016910:	b500      	push	{lr}
 8016912:	b083      	sub	sp, #12
 8016914:	9001      	str	r0, [sp, #4]
 8016916:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8016918:	9801      	ldr	r0, [sp, #4]
 801691a:	2138      	movs	r1, #56	; 0x38
 801691c:	9a00      	ldr	r2, [sp, #0]
 801691e:	2301      	movs	r3, #1
 8016920:	f7fc fad6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016924:	4603      	mov	r3, r0
 8016926:	2b00      	cmp	r3, #0
 8016928:	d101      	bne.n	801692e <LSM303AGR_ACC_R_ZDouble+0x1e>
    return MEMS_ERROR;
 801692a:	2300      	movs	r3, #0
 801692c:	e007      	b.n	801693e <LSM303AGR_ACC_R_ZDouble+0x2e>

  *value &= LSM303AGR_ACC_ZD_MASK; //mask
 801692e:	9b00      	ldr	r3, [sp, #0]
 8016930:	781b      	ldrb	r3, [r3, #0]
 8016932:	f003 0320 	and.w	r3, r3, #32
 8016936:	b2da      	uxtb	r2, r3
 8016938:	9b00      	ldr	r3, [sp, #0]
 801693a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801693c:	2301      	movs	r3, #1
}
 801693e:	4618      	mov	r0, r3
 8016940:	b003      	add	sp, #12
 8016942:	f85d fb04 	ldr.w	pc, [sp], #4
 8016946:	bf00      	nop
 8016948:	f3af 8000 	nop.w
 801694c:	f3af 8000 	nop.w

08016950 <LSM303AGR_ACC_R_ClickX>:
* Input          : Pointer to LSM303AGR_ACC_X_t
* Output         : Status of X see LSM303AGR_ACC_X_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickX(void *handle, LSM303AGR_ACC_X_t *value)
{
 8016950:	b500      	push	{lr}
 8016952:	b083      	sub	sp, #12
 8016954:	9001      	str	r0, [sp, #4]
 8016956:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8016958:	9801      	ldr	r0, [sp, #4]
 801695a:	2139      	movs	r1, #57	; 0x39
 801695c:	9a00      	ldr	r2, [sp, #0]
 801695e:	2301      	movs	r3, #1
 8016960:	f7fc fab6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016964:	4603      	mov	r3, r0
 8016966:	2b00      	cmp	r3, #0
 8016968:	d101      	bne.n	801696e <LSM303AGR_ACC_R_ClickX+0x1e>
    return MEMS_ERROR;
 801696a:	2300      	movs	r3, #0
 801696c:	e007      	b.n	801697e <LSM303AGR_ACC_R_ClickX+0x2e>

  *value &= LSM303AGR_ACC_X_MASK; //mask
 801696e:	9b00      	ldr	r3, [sp, #0]
 8016970:	781b      	ldrb	r3, [r3, #0]
 8016972:	f003 0301 	and.w	r3, r3, #1
 8016976:	b2da      	uxtb	r2, r3
 8016978:	9b00      	ldr	r3, [sp, #0]
 801697a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801697c:	2301      	movs	r3, #1
}
 801697e:	4618      	mov	r0, r3
 8016980:	b003      	add	sp, #12
 8016982:	f85d fb04 	ldr.w	pc, [sp], #4
 8016986:	bf00      	nop
 8016988:	f3af 8000 	nop.w
 801698c:	f3af 8000 	nop.w

08016990 <LSM303AGR_ACC_R_ClickY>:
* Input          : Pointer to LSM303AGR_ACC_Y_t
* Output         : Status of Y see LSM303AGR_ACC_Y_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickY(void *handle, LSM303AGR_ACC_Y_t *value)
{
 8016990:	b500      	push	{lr}
 8016992:	b083      	sub	sp, #12
 8016994:	9001      	str	r0, [sp, #4]
 8016996:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8016998:	9801      	ldr	r0, [sp, #4]
 801699a:	2139      	movs	r1, #57	; 0x39
 801699c:	9a00      	ldr	r2, [sp, #0]
 801699e:	2301      	movs	r3, #1
 80169a0:	f7fc fa96 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80169a4:	4603      	mov	r3, r0
 80169a6:	2b00      	cmp	r3, #0
 80169a8:	d101      	bne.n	80169ae <LSM303AGR_ACC_R_ClickY+0x1e>
    return MEMS_ERROR;
 80169aa:	2300      	movs	r3, #0
 80169ac:	e007      	b.n	80169be <LSM303AGR_ACC_R_ClickY+0x2e>

  *value &= LSM303AGR_ACC_Y_MASK; //mask
 80169ae:	9b00      	ldr	r3, [sp, #0]
 80169b0:	781b      	ldrb	r3, [r3, #0]
 80169b2:	f003 0302 	and.w	r3, r3, #2
 80169b6:	b2da      	uxtb	r2, r3
 80169b8:	9b00      	ldr	r3, [sp, #0]
 80169ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80169bc:	2301      	movs	r3, #1
}
 80169be:	4618      	mov	r0, r3
 80169c0:	b003      	add	sp, #12
 80169c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80169c6:	bf00      	nop
 80169c8:	f3af 8000 	nop.w
 80169cc:	f3af 8000 	nop.w

080169d0 <LSM303AGR_ACC_R_ClickZ>:
* Input          : Pointer to LSM303AGR_ACC_Z_t
* Output         : Status of Z see LSM303AGR_ACC_Z_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickZ(void *handle, LSM303AGR_ACC_Z_t *value)
{
 80169d0:	b500      	push	{lr}
 80169d2:	b083      	sub	sp, #12
 80169d4:	9001      	str	r0, [sp, #4]
 80169d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 80169d8:	9801      	ldr	r0, [sp, #4]
 80169da:	2139      	movs	r1, #57	; 0x39
 80169dc:	9a00      	ldr	r2, [sp, #0]
 80169de:	2301      	movs	r3, #1
 80169e0:	f7fc fa76 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 80169e4:	4603      	mov	r3, r0
 80169e6:	2b00      	cmp	r3, #0
 80169e8:	d101      	bne.n	80169ee <LSM303AGR_ACC_R_ClickZ+0x1e>
    return MEMS_ERROR;
 80169ea:	2300      	movs	r3, #0
 80169ec:	e007      	b.n	80169fe <LSM303AGR_ACC_R_ClickZ+0x2e>

  *value &= LSM303AGR_ACC_Z_MASK; //mask
 80169ee:	9b00      	ldr	r3, [sp, #0]
 80169f0:	781b      	ldrb	r3, [r3, #0]
 80169f2:	f003 0304 	and.w	r3, r3, #4
 80169f6:	b2da      	uxtb	r2, r3
 80169f8:	9b00      	ldr	r3, [sp, #0]
 80169fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80169fc:	2301      	movs	r3, #1
}
 80169fe:	4618      	mov	r0, r3
 8016a00:	b003      	add	sp, #12
 8016a02:	f85d fb04 	ldr.w	pc, [sp], #4
 8016a06:	bf00      	nop
 8016a08:	f3af 8000 	nop.w
 8016a0c:	f3af 8000 	nop.w

08016a10 <LSM303AGR_ACC_R_ClickSign>:
* Input          : Pointer to LSM303AGR_ACC_SIGN_t
* Output         : Status of SIGN see LSM303AGR_ACC_SIGN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickSign(void *handle, LSM303AGR_ACC_SIGN_t *value)
{
 8016a10:	b500      	push	{lr}
 8016a12:	b083      	sub	sp, #12
 8016a14:	9001      	str	r0, [sp, #4]
 8016a16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8016a18:	9801      	ldr	r0, [sp, #4]
 8016a1a:	2139      	movs	r1, #57	; 0x39
 8016a1c:	9a00      	ldr	r2, [sp, #0]
 8016a1e:	2301      	movs	r3, #1
 8016a20:	f7fc fa56 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016a24:	4603      	mov	r3, r0
 8016a26:	2b00      	cmp	r3, #0
 8016a28:	d101      	bne.n	8016a2e <LSM303AGR_ACC_R_ClickSign+0x1e>
    return MEMS_ERROR;
 8016a2a:	2300      	movs	r3, #0
 8016a2c:	e007      	b.n	8016a3e <LSM303AGR_ACC_R_ClickSign+0x2e>

  *value &= LSM303AGR_ACC_SIGN_MASK; //mask
 8016a2e:	9b00      	ldr	r3, [sp, #0]
 8016a30:	781b      	ldrb	r3, [r3, #0]
 8016a32:	f003 0308 	and.w	r3, r3, #8
 8016a36:	b2da      	uxtb	r2, r3
 8016a38:	9b00      	ldr	r3, [sp, #0]
 8016a3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016a3c:	2301      	movs	r3, #1
}
 8016a3e:	4618      	mov	r0, r3
 8016a40:	b003      	add	sp, #12
 8016a42:	f85d fb04 	ldr.w	pc, [sp], #4
 8016a46:	bf00      	nop
 8016a48:	f3af 8000 	nop.w
 8016a4c:	f3af 8000 	nop.w

08016a50 <LSM303AGR_ACC_R_SingleCLICK>:
* Input          : Pointer to LSM303AGR_ACC_SCLICK_t
* Output         : Status of SCLICK see LSM303AGR_ACC_SCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SingleCLICK(void *handle, LSM303AGR_ACC_SCLICK_t *value)
{
 8016a50:	b500      	push	{lr}
 8016a52:	b083      	sub	sp, #12
 8016a54:	9001      	str	r0, [sp, #4]
 8016a56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8016a58:	9801      	ldr	r0, [sp, #4]
 8016a5a:	2139      	movs	r1, #57	; 0x39
 8016a5c:	9a00      	ldr	r2, [sp, #0]
 8016a5e:	2301      	movs	r3, #1
 8016a60:	f7fc fa36 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016a64:	4603      	mov	r3, r0
 8016a66:	2b00      	cmp	r3, #0
 8016a68:	d101      	bne.n	8016a6e <LSM303AGR_ACC_R_SingleCLICK+0x1e>
    return MEMS_ERROR;
 8016a6a:	2300      	movs	r3, #0
 8016a6c:	e007      	b.n	8016a7e <LSM303AGR_ACC_R_SingleCLICK+0x2e>

  *value &= LSM303AGR_ACC_SCLICK_MASK; //mask
 8016a6e:	9b00      	ldr	r3, [sp, #0]
 8016a70:	781b      	ldrb	r3, [r3, #0]
 8016a72:	f003 0310 	and.w	r3, r3, #16
 8016a76:	b2da      	uxtb	r2, r3
 8016a78:	9b00      	ldr	r3, [sp, #0]
 8016a7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016a7c:	2301      	movs	r3, #1
}
 8016a7e:	4618      	mov	r0, r3
 8016a80:	b003      	add	sp, #12
 8016a82:	f85d fb04 	ldr.w	pc, [sp], #4
 8016a86:	bf00      	nop
 8016a88:	f3af 8000 	nop.w
 8016a8c:	f3af 8000 	nop.w

08016a90 <LSM303AGR_ACC_R_DoubleCLICK>:
* Input          : Pointer to LSM303AGR_ACC_DCLICK_t
* Output         : Status of DCLICK see LSM303AGR_ACC_DCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DoubleCLICK(void *handle, LSM303AGR_ACC_DCLICK_t *value)
{
 8016a90:	b500      	push	{lr}
 8016a92:	b083      	sub	sp, #12
 8016a94:	9001      	str	r0, [sp, #4]
 8016a96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8016a98:	9801      	ldr	r0, [sp, #4]
 8016a9a:	2139      	movs	r1, #57	; 0x39
 8016a9c:	9a00      	ldr	r2, [sp, #0]
 8016a9e:	2301      	movs	r3, #1
 8016aa0:	f7fc fa16 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016aa4:	4603      	mov	r3, r0
 8016aa6:	2b00      	cmp	r3, #0
 8016aa8:	d101      	bne.n	8016aae <LSM303AGR_ACC_R_DoubleCLICK+0x1e>
    return MEMS_ERROR;
 8016aaa:	2300      	movs	r3, #0
 8016aac:	e007      	b.n	8016abe <LSM303AGR_ACC_R_DoubleCLICK+0x2e>

  *value &= LSM303AGR_ACC_DCLICK_MASK; //mask
 8016aae:	9b00      	ldr	r3, [sp, #0]
 8016ab0:	781b      	ldrb	r3, [r3, #0]
 8016ab2:	f003 0320 	and.w	r3, r3, #32
 8016ab6:	b2da      	uxtb	r2, r3
 8016ab8:	9b00      	ldr	r3, [sp, #0]
 8016aba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016abc:	2301      	movs	r3, #1
}
 8016abe:	4618      	mov	r0, r3
 8016ac0:	b003      	add	sp, #12
 8016ac2:	f85d fb04 	ldr.w	pc, [sp], #4
 8016ac6:	bf00      	nop
 8016ac8:	f3af 8000 	nop.w
 8016acc:	f3af 8000 	nop.w

08016ad0 <LSM303AGR_ACC_R_CLICK_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_CLICK_IA(void *handle, LSM303AGR_ACC_CLICK_IA_t *value)
{
 8016ad0:	b500      	push	{lr}
 8016ad2:	b083      	sub	sp, #12
 8016ad4:	9001      	str	r0, [sp, #4]
 8016ad6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8016ad8:	9801      	ldr	r0, [sp, #4]
 8016ada:	2139      	movs	r1, #57	; 0x39
 8016adc:	9a00      	ldr	r2, [sp, #0]
 8016ade:	2301      	movs	r3, #1
 8016ae0:	f7fc f9f6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016ae4:	4603      	mov	r3, r0
 8016ae6:	2b00      	cmp	r3, #0
 8016ae8:	d101      	bne.n	8016aee <LSM303AGR_ACC_R_CLICK_IA+0x1e>
    return MEMS_ERROR;
 8016aea:	2300      	movs	r3, #0
 8016aec:	e007      	b.n	8016afe <LSM303AGR_ACC_R_CLICK_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 8016aee:	9b00      	ldr	r3, [sp, #0]
 8016af0:	781b      	ldrb	r3, [r3, #0]
 8016af2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016af6:	b2da      	uxtb	r2, r3
 8016af8:	9b00      	ldr	r3, [sp, #0]
 8016afa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016afc:	2301      	movs	r3, #1
}
 8016afe:	4618      	mov	r0, r3
 8016b00:	b003      	add	sp, #12
 8016b02:	f85d fb04 	ldr.w	pc, [sp], #4
 8016b06:	bf00      	nop
 8016b08:	f3af 8000 	nop.w
 8016b0c:	f3af 8000 	nop.w

08016b10 <LSM303AGR_ACC_W_ClickThreshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickThreshold(void *handle, u8_t newValue)
{
 8016b10:	b500      	push	{lr}
 8016b12:	b085      	sub	sp, #20
 8016b14:	9001      	str	r0, [sp, #4]
 8016b16:	460b      	mov	r3, r1
 8016b18:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 8016b1c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016b20:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016b24:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_THS, &value, 1) )
 8016b28:	f10d 030f 	add.w	r3, sp, #15
 8016b2c:	9801      	ldr	r0, [sp, #4]
 8016b2e:	213a      	movs	r1, #58	; 0x3a
 8016b30:	461a      	mov	r2, r3
 8016b32:	2301      	movs	r3, #1
 8016b34:	f7fc f9cc 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016b38:	4603      	mov	r3, r0
 8016b3a:	2b00      	cmp	r3, #0
 8016b3c:	d101      	bne.n	8016b42 <LSM303AGR_ACC_W_ClickThreshold+0x32>
    return MEMS_ERROR;
 8016b3e:	2300      	movs	r3, #0
 8016b40:	e01c      	b.n	8016b7c <LSM303AGR_ACC_W_ClickThreshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8016b42:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016b46:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8016b4a:	b2db      	uxtb	r3, r3
 8016b4c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016b50:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016b54:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016b58:	4313      	orrs	r3, r2
 8016b5a:	b2db      	uxtb	r3, r3
 8016b5c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_THS, &value, 1) )
 8016b60:	f10d 030f 	add.w	r3, sp, #15
 8016b64:	9801      	ldr	r0, [sp, #4]
 8016b66:	213a      	movs	r1, #58	; 0x3a
 8016b68:	461a      	mov	r2, r3
 8016b6a:	2301      	movs	r3, #1
 8016b6c:	f7fc f988 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016b70:	4603      	mov	r3, r0
 8016b72:	2b00      	cmp	r3, #0
 8016b74:	d101      	bne.n	8016b7a <LSM303AGR_ACC_W_ClickThreshold+0x6a>
    return MEMS_ERROR;
 8016b76:	2300      	movs	r3, #0
 8016b78:	e000      	b.n	8016b7c <LSM303AGR_ACC_W_ClickThreshold+0x6c>

  return MEMS_SUCCESS;
 8016b7a:	2301      	movs	r3, #1
}
 8016b7c:	4618      	mov	r0, r3
 8016b7e:	b005      	add	sp, #20
 8016b80:	f85d fb04 	ldr.w	pc, [sp], #4
 8016b84:	f3af 8000 	nop.w
 8016b88:	f3af 8000 	nop.w
 8016b8c:	f3af 8000 	nop.w

08016b90 <LSM303AGR_ACC_R_ClickThreshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickThreshold(void *handle, u8_t *value)
{
 8016b90:	b500      	push	{lr}
 8016b92:	b083      	sub	sp, #12
 8016b94:	9001      	str	r0, [sp, #4]
 8016b96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_THS, (u8_t *)value, 1) )
 8016b98:	9801      	ldr	r0, [sp, #4]
 8016b9a:	213a      	movs	r1, #58	; 0x3a
 8016b9c:	9a00      	ldr	r2, [sp, #0]
 8016b9e:	2301      	movs	r3, #1
 8016ba0:	f7fc f996 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016ba4:	4603      	mov	r3, r0
 8016ba6:	2b00      	cmp	r3, #0
 8016ba8:	d101      	bne.n	8016bae <LSM303AGR_ACC_R_ClickThreshold+0x1e>
    return MEMS_ERROR;
 8016baa:	2300      	movs	r3, #0
 8016bac:	e00b      	b.n	8016bc6 <LSM303AGR_ACC_R_ClickThreshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 8016bae:	9b00      	ldr	r3, [sp, #0]
 8016bb0:	781b      	ldrb	r3, [r3, #0]
 8016bb2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016bb6:	b2da      	uxtb	r2, r3
 8016bb8:	9b00      	ldr	r3, [sp, #0]
 8016bba:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 8016bbc:	9b00      	ldr	r3, [sp, #0]
 8016bbe:	781a      	ldrb	r2, [r3, #0]
 8016bc0:	9b00      	ldr	r3, [sp, #0]
 8016bc2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016bc4:	2301      	movs	r3, #1
}
 8016bc6:	4618      	mov	r0, r3
 8016bc8:	b003      	add	sp, #12
 8016bca:	f85d fb04 	ldr.w	pc, [sp], #4
 8016bce:	bf00      	nop

08016bd0 <LSM303AGR_ACC_W_ClickTimeLimit>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeLimit(void *handle, u8_t newValue)
{
 8016bd0:	b500      	push	{lr}
 8016bd2:	b085      	sub	sp, #20
 8016bd4:	9001      	str	r0, [sp, #4]
 8016bd6:	460b      	mov	r3, r1
 8016bd8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TLI_POSITION; //mask
  newValue &= LSM303AGR_ACC_TLI_MASK; //coerce
 8016bdc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016be0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016be4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LIMIT, &value, 1) )
 8016be8:	f10d 030f 	add.w	r3, sp, #15
 8016bec:	9801      	ldr	r0, [sp, #4]
 8016bee:	213b      	movs	r1, #59	; 0x3b
 8016bf0:	461a      	mov	r2, r3
 8016bf2:	2301      	movs	r3, #1
 8016bf4:	f7fc f96c 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016bf8:	4603      	mov	r3, r0
 8016bfa:	2b00      	cmp	r3, #0
 8016bfc:	d101      	bne.n	8016c02 <LSM303AGR_ACC_W_ClickTimeLimit+0x32>
    return MEMS_ERROR;
 8016bfe:	2300      	movs	r3, #0
 8016c00:	e01c      	b.n	8016c3c <LSM303AGR_ACC_W_ClickTimeLimit+0x6c>

  value &= ~LSM303AGR_ACC_TLI_MASK;
 8016c02:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016c06:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8016c0a:	b2db      	uxtb	r3, r3
 8016c0c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016c10:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016c14:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016c18:	4313      	orrs	r3, r2
 8016c1a:	b2db      	uxtb	r3, r3
 8016c1c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_LIMIT, &value, 1) )
 8016c20:	f10d 030f 	add.w	r3, sp, #15
 8016c24:	9801      	ldr	r0, [sp, #4]
 8016c26:	213b      	movs	r1, #59	; 0x3b
 8016c28:	461a      	mov	r2, r3
 8016c2a:	2301      	movs	r3, #1
 8016c2c:	f7fc f928 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016c30:	4603      	mov	r3, r0
 8016c32:	2b00      	cmp	r3, #0
 8016c34:	d101      	bne.n	8016c3a <LSM303AGR_ACC_W_ClickTimeLimit+0x6a>
    return MEMS_ERROR;
 8016c36:	2300      	movs	r3, #0
 8016c38:	e000      	b.n	8016c3c <LSM303AGR_ACC_W_ClickTimeLimit+0x6c>

  return MEMS_SUCCESS;
 8016c3a:	2301      	movs	r3, #1
}
 8016c3c:	4618      	mov	r0, r3
 8016c3e:	b005      	add	sp, #20
 8016c40:	f85d fb04 	ldr.w	pc, [sp], #4
 8016c44:	f3af 8000 	nop.w
 8016c48:	f3af 8000 	nop.w
 8016c4c:	f3af 8000 	nop.w

08016c50 <LSM303AGR_ACC_R_ClickTimeLimit>:
* Input          : Pointer to u8_t
* Output         : Status of TLI
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeLimit(void *handle, u8_t *value)
{
 8016c50:	b500      	push	{lr}
 8016c52:	b083      	sub	sp, #12
 8016c54:	9001      	str	r0, [sp, #4]
 8016c56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LIMIT, (u8_t *)value, 1) )
 8016c58:	9801      	ldr	r0, [sp, #4]
 8016c5a:	213b      	movs	r1, #59	; 0x3b
 8016c5c:	9a00      	ldr	r2, [sp, #0]
 8016c5e:	2301      	movs	r3, #1
 8016c60:	f7fc f936 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016c64:	4603      	mov	r3, r0
 8016c66:	2b00      	cmp	r3, #0
 8016c68:	d101      	bne.n	8016c6e <LSM303AGR_ACC_R_ClickTimeLimit+0x1e>
    return MEMS_ERROR;
 8016c6a:	2300      	movs	r3, #0
 8016c6c:	e00b      	b.n	8016c86 <LSM303AGR_ACC_R_ClickTimeLimit+0x36>

  *value &= LSM303AGR_ACC_TLI_MASK; //coerce
 8016c6e:	9b00      	ldr	r3, [sp, #0]
 8016c70:	781b      	ldrb	r3, [r3, #0]
 8016c72:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016c76:	b2da      	uxtb	r2, r3
 8016c78:	9b00      	ldr	r3, [sp, #0]
 8016c7a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TLI_POSITION; //mask
 8016c7c:	9b00      	ldr	r3, [sp, #0]
 8016c7e:	781a      	ldrb	r2, [r3, #0]
 8016c80:	9b00      	ldr	r3, [sp, #0]
 8016c82:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016c84:	2301      	movs	r3, #1
}
 8016c86:	4618      	mov	r0, r3
 8016c88:	b003      	add	sp, #12
 8016c8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8016c8e:	bf00      	nop

08016c90 <LSM303AGR_ACC_W_ClickTimeLatency>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeLatency(void *handle, u8_t newValue)
{
 8016c90:	b500      	push	{lr}
 8016c92:	b085      	sub	sp, #20
 8016c94:	9001      	str	r0, [sp, #4]
 8016c96:	460b      	mov	r3, r1
 8016c98:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TLA_POSITION; //mask
  newValue &= LSM303AGR_ACC_TLA_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LATENCY, &value, 1) )
 8016c9c:	f10d 030f 	add.w	r3, sp, #15
 8016ca0:	9801      	ldr	r0, [sp, #4]
 8016ca2:	213c      	movs	r1, #60	; 0x3c
 8016ca4:	461a      	mov	r2, r3
 8016ca6:	2301      	movs	r3, #1
 8016ca8:	f7fc f912 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016cac:	4603      	mov	r3, r0
 8016cae:	2b00      	cmp	r3, #0
 8016cb0:	d101      	bne.n	8016cb6 <LSM303AGR_ACC_W_ClickTimeLatency+0x26>
    return MEMS_ERROR;
 8016cb2:	2300      	movs	r3, #0
 8016cb4:	e018      	b.n	8016ce8 <LSM303AGR_ACC_W_ClickTimeLatency+0x58>

  value &= (u8_t)~LSM303AGR_ACC_TLA_MASK;
 8016cb6:	2300      	movs	r3, #0
 8016cb8:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016cbc:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016cc0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016cc4:	4313      	orrs	r3, r2
 8016cc6:	b2db      	uxtb	r3, r3
 8016cc8:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_LATENCY, &value, 1) )
 8016ccc:	f10d 030f 	add.w	r3, sp, #15
 8016cd0:	9801      	ldr	r0, [sp, #4]
 8016cd2:	213c      	movs	r1, #60	; 0x3c
 8016cd4:	461a      	mov	r2, r3
 8016cd6:	2301      	movs	r3, #1
 8016cd8:	f7fc f8d2 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016cdc:	4603      	mov	r3, r0
 8016cde:	2b00      	cmp	r3, #0
 8016ce0:	d101      	bne.n	8016ce6 <LSM303AGR_ACC_W_ClickTimeLatency+0x56>
    return MEMS_ERROR;
 8016ce2:	2300      	movs	r3, #0
 8016ce4:	e000      	b.n	8016ce8 <LSM303AGR_ACC_W_ClickTimeLatency+0x58>

  return MEMS_SUCCESS;
 8016ce6:	2301      	movs	r3, #1
}
 8016ce8:	4618      	mov	r0, r3
 8016cea:	b005      	add	sp, #20
 8016cec:	f85d fb04 	ldr.w	pc, [sp], #4

08016cf0 <LSM303AGR_ACC_R_ClickTimeLatency>:
* Input          : Pointer to u8_t
* Output         : Status of TLA
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeLatency(void *handle, u8_t *value)
{
 8016cf0:	b500      	push	{lr}
 8016cf2:	b083      	sub	sp, #12
 8016cf4:	9001      	str	r0, [sp, #4]
 8016cf6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LATENCY, (u8_t *)value, 1) )
 8016cf8:	9801      	ldr	r0, [sp, #4]
 8016cfa:	213c      	movs	r1, #60	; 0x3c
 8016cfc:	9a00      	ldr	r2, [sp, #0]
 8016cfe:	2301      	movs	r3, #1
 8016d00:	f7fc f8e6 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016d04:	4603      	mov	r3, r0
 8016d06:	2b00      	cmp	r3, #0
 8016d08:	d101      	bne.n	8016d0e <LSM303AGR_ACC_R_ClickTimeLatency+0x1e>
    return MEMS_ERROR;
 8016d0a:	2300      	movs	r3, #0
 8016d0c:	e008      	b.n	8016d20 <LSM303AGR_ACC_R_ClickTimeLatency+0x30>

  *value &= LSM303AGR_ACC_TLA_MASK; //coerce
 8016d0e:	9b00      	ldr	r3, [sp, #0]
 8016d10:	781a      	ldrb	r2, [r3, #0]
 8016d12:	9b00      	ldr	r3, [sp, #0]
 8016d14:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TLA_POSITION; //mask
 8016d16:	9b00      	ldr	r3, [sp, #0]
 8016d18:	781a      	ldrb	r2, [r3, #0]
 8016d1a:	9b00      	ldr	r3, [sp, #0]
 8016d1c:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016d1e:	2301      	movs	r3, #1
}
 8016d20:	4618      	mov	r0, r3
 8016d22:	b003      	add	sp, #12
 8016d24:	f85d fb04 	ldr.w	pc, [sp], #4
 8016d28:	f3af 8000 	nop.w
 8016d2c:	f3af 8000 	nop.w

08016d30 <LSM303AGR_ACC_W_ClickTimeWindow>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeWindow(void *handle, u8_t newValue)
{
 8016d30:	b500      	push	{lr}
 8016d32:	b085      	sub	sp, #20
 8016d34:	9001      	str	r0, [sp, #4]
 8016d36:	460b      	mov	r3, r1
 8016d38:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TW_POSITION; //mask
  newValue &= LSM303AGR_ACC_TW_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_WINDOW, &value, 1) )
 8016d3c:	f10d 030f 	add.w	r3, sp, #15
 8016d40:	9801      	ldr	r0, [sp, #4]
 8016d42:	213d      	movs	r1, #61	; 0x3d
 8016d44:	461a      	mov	r2, r3
 8016d46:	2301      	movs	r3, #1
 8016d48:	f7fc f8c2 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016d4c:	4603      	mov	r3, r0
 8016d4e:	2b00      	cmp	r3, #0
 8016d50:	d101      	bne.n	8016d56 <LSM303AGR_ACC_W_ClickTimeWindow+0x26>
    return MEMS_ERROR;
 8016d52:	2300      	movs	r3, #0
 8016d54:	e018      	b.n	8016d88 <LSM303AGR_ACC_W_ClickTimeWindow+0x58>

  value &= (u8_t)~LSM303AGR_ACC_TW_MASK;
 8016d56:	2300      	movs	r3, #0
 8016d58:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016d5c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016d60:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016d64:	4313      	orrs	r3, r2
 8016d66:	b2db      	uxtb	r3, r3
 8016d68:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_WINDOW, &value, 1) )
 8016d6c:	f10d 030f 	add.w	r3, sp, #15
 8016d70:	9801      	ldr	r0, [sp, #4]
 8016d72:	213d      	movs	r1, #61	; 0x3d
 8016d74:	461a      	mov	r2, r3
 8016d76:	2301      	movs	r3, #1
 8016d78:	f7fc f882 	bl	8012e80 <LSM303AGR_ACC_WriteReg>
 8016d7c:	4603      	mov	r3, r0
 8016d7e:	2b00      	cmp	r3, #0
 8016d80:	d101      	bne.n	8016d86 <LSM303AGR_ACC_W_ClickTimeWindow+0x56>
    return MEMS_ERROR;
 8016d82:	2300      	movs	r3, #0
 8016d84:	e000      	b.n	8016d88 <LSM303AGR_ACC_W_ClickTimeWindow+0x58>

  return MEMS_SUCCESS;
 8016d86:	2301      	movs	r3, #1
}
 8016d88:	4618      	mov	r0, r3
 8016d8a:	b005      	add	sp, #20
 8016d8c:	f85d fb04 	ldr.w	pc, [sp], #4

08016d90 <LSM303AGR_ACC_R_ClickTimeWindow>:
* Input          : Pointer to u8_t
* Output         : Status of TW
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeWindow(void *handle, u8_t *value)
{
 8016d90:	b500      	push	{lr}
 8016d92:	b083      	sub	sp, #12
 8016d94:	9001      	str	r0, [sp, #4]
 8016d96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_WINDOW, (u8_t *)value, 1) )
 8016d98:	9801      	ldr	r0, [sp, #4]
 8016d9a:	213d      	movs	r1, #61	; 0x3d
 8016d9c:	9a00      	ldr	r2, [sp, #0]
 8016d9e:	2301      	movs	r3, #1
 8016da0:	f7fc f896 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016da4:	4603      	mov	r3, r0
 8016da6:	2b00      	cmp	r3, #0
 8016da8:	d101      	bne.n	8016dae <LSM303AGR_ACC_R_ClickTimeWindow+0x1e>
    return MEMS_ERROR;
 8016daa:	2300      	movs	r3, #0
 8016dac:	e008      	b.n	8016dc0 <LSM303AGR_ACC_R_ClickTimeWindow+0x30>

  *value &= LSM303AGR_ACC_TW_MASK; //coerce
 8016dae:	9b00      	ldr	r3, [sp, #0]
 8016db0:	781a      	ldrb	r2, [r3, #0]
 8016db2:	9b00      	ldr	r3, [sp, #0]
 8016db4:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TW_POSITION; //mask
 8016db6:	9b00      	ldr	r3, [sp, #0]
 8016db8:	781a      	ldrb	r2, [r3, #0]
 8016dba:	9b00      	ldr	r3, [sp, #0]
 8016dbc:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016dbe:	2301      	movs	r3, #1
}
 8016dc0:	4618      	mov	r0, r3
 8016dc2:	b003      	add	sp, #12
 8016dc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8016dc8:	f3af 8000 	nop.w
 8016dcc:	f3af 8000 	nop.w

08016dd0 <LSM303AGR_ACC_Get_Voltage_ADC>:
* Input          : pointer to [u8_t]
* Output         : Voltage_ADC buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Voltage_ADC(void *handle, u8_t *buff)
{
 8016dd0:	b500      	push	{lr}
 8016dd2:	b085      	sub	sp, #20
 8016dd4:	9001      	str	r0, [sp, #4]
 8016dd6:	9100      	str	r1, [sp, #0]
  u8_t i, j, k;
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;
 8016dd8:	2302      	movs	r3, #2
 8016dda:	f88d 300c 	strb.w	r3, [sp, #12]

  k = 0;
 8016dde:	2300      	movs	r3, #0
 8016de0:	f88d 300d 	strb.w	r3, [sp, #13]
  for (i = 0; i < 3; i++ )
 8016de4:	2300      	movs	r3, #0
 8016de6:	f88d 300f 	strb.w	r3, [sp, #15]
 8016dea:	e02b      	b.n	8016e44 <LSM303AGR_ACC_Get_Voltage_ADC+0x74>
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
 8016dec:	2300      	movs	r3, #0
 8016dee:	f88d 300e 	strb.w	r3, [sp, #14]
 8016df2:	e01c      	b.n	8016e2e <LSM303AGR_ACC_Get_Voltage_ADC+0x5e>
    {
      if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_ADC1_L + k, &buff[k], 1 ))
 8016df4:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8016df8:	3308      	adds	r3, #8
 8016dfa:	b2da      	uxtb	r2, r3
 8016dfc:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8016e00:	9900      	ldr	r1, [sp, #0]
 8016e02:	440b      	add	r3, r1
 8016e04:	9801      	ldr	r0, [sp, #4]
 8016e06:	4611      	mov	r1, r2
 8016e08:	461a      	mov	r2, r3
 8016e0a:	2301      	movs	r3, #1
 8016e0c:	f7fc f860 	bl	8012ed0 <LSM303AGR_ACC_ReadReg>
 8016e10:	4603      	mov	r3, r0
 8016e12:	2b00      	cmp	r3, #0
 8016e14:	d101      	bne.n	8016e1a <LSM303AGR_ACC_Get_Voltage_ADC+0x4a>
        return MEMS_ERROR;
 8016e16:	2300      	movs	r3, #0
 8016e18:	e019      	b.n	8016e4e <LSM303AGR_ACC_Get_Voltage_ADC+0x7e>
      k++;
 8016e1a:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8016e1e:	3301      	adds	r3, #1
 8016e20:	f88d 300d 	strb.w	r3, [sp, #13]
  numberOfByteForDimension = 6 / 3;

  k = 0;
  for (i = 0; i < 3; i++ )
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
 8016e24:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8016e28:	3301      	adds	r3, #1
 8016e2a:	f88d 300e 	strb.w	r3, [sp, #14]
 8016e2e:	f89d 200e 	ldrb.w	r2, [sp, #14]
 8016e32:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8016e36:	429a      	cmp	r2, r3
 8016e38:	d3dc      	bcc.n	8016df4 <LSM303AGR_ACC_Get_Voltage_ADC+0x24>
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;

  k = 0;
  for (i = 0; i < 3; i++ )
 8016e3a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016e3e:	3301      	adds	r3, #1
 8016e40:	f88d 300f 	strb.w	r3, [sp, #15]
 8016e44:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016e48:	2b02      	cmp	r3, #2
 8016e4a:	d9cf      	bls.n	8016dec <LSM303AGR_ACC_Get_Voltage_ADC+0x1c>
        return MEMS_ERROR;
      k++;
    }
  }

  return MEMS_SUCCESS;
 8016e4c:	2301      	movs	r3, #1
}
 8016e4e:	4618      	mov	r0, r3
 8016e50:	b005      	add	sp, #20
 8016e52:	f85d fb04 	ldr.w	pc, [sp], #4
 8016e56:	bf00      	nop
 8016e58:	f3af 8000 	nop.w
 8016e5c:	f3af 8000 	nop.w

08016e60 <Sensor_IO_SPI_Write>:
#define SPI_1LINE_ENABLE(__HANDLE__) ((__HANDLE__)->spi->CR1 |= SPI_CR1_SPE)
#define SPI_1LINE_DISABLE(__HANDLE__) ((__HANDLE__)->spi->CR1 &= (~SPI_CR1_SPE))
#define SPI_DMA_DISABLE(__HANDLE__) ((__HANDLE__)->spi->CR2 &= (~(SPI_CR2_RXDMAEN|SPI_CR2_TXDMAEN)))
#define SPI_DMA_ENABLE(__HANDLE__) ((__HANDLE__)->spi->CR2 |= (SPI_CR2_RXDMAEN|SPI_CR2_TXDMAEN))

uint8_t Sensor_IO_SPI_Write(SPIDriver *bus, SPIConfig *cfg, uint8_t WriteAddr, uint8_t *pBuffer, uint16_t nBytesToWrite ) {
 8016e60:	b500      	push	{lr}
 8016e62:	b087      	sub	sp, #28
 8016e64:	9003      	str	r0, [sp, #12]
 8016e66:	9102      	str	r1, [sp, #8]
 8016e68:	9300      	str	r3, [sp, #0]
 8016e6a:	4613      	mov	r3, r2
 8016e6c:	f88d 3007 	strb.w	r3, [sp, #7]
  int i;

  if (nBytesToWrite > 1) {                /* Set bit 6 of the address if multiple bytes will be sent. */
 8016e70:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8016e74:	2b01      	cmp	r3, #1
 8016e76:	d905      	bls.n	8016e84 <Sensor_IO_SPI_Write+0x24>
    WriteAddr |= 0x40;
 8016e78:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8016e7c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8016e80:	f88d 3007 	strb.w	r3, [sp, #7]
  }
  WriteAddr = WriteAddr & (~0x80);        /* Clear the write bit (bit 7)      */
 8016e84:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8016e88:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016e8c:	f88d 3007 	strb.w	r3, [sp, #7]
  spiAcquireBus(bus);                     /* Acquire ownership of the bus.    */
 8016e90:	9803      	ldr	r0, [sp, #12]
 8016e92:	f7ef fc1d 	bl	80066d0 <spiAcquireBus>
  spiStart(bus, cfg);                     /* Setup transfer parameters.       */
 8016e96:	9803      	ldr	r0, [sp, #12]
 8016e98:	9902      	ldr	r1, [sp, #8]
 8016e9a:	f7ef faf9 	bl	8006490 <spiStart>
  SPI_DMA_DISABLE(bus);                   /* Turn off the DMA interrupt since this bus is polled */
 8016e9e:	9b03      	ldr	r3, [sp, #12]
 8016ea0:	69db      	ldr	r3, [r3, #28]
 8016ea2:	9a03      	ldr	r2, [sp, #12]
 8016ea4:	69d2      	ldr	r2, [r2, #28]
 8016ea6:	6852      	ldr	r2, [r2, #4]
 8016ea8:	f022 0203 	bic.w	r2, r2, #3
 8016eac:	605a      	str	r2, [r3, #4]
  SPI_1LINE_ENABLE(bus);
 8016eae:	9b03      	ldr	r3, [sp, #12]
 8016eb0:	69db      	ldr	r3, [r3, #28]
 8016eb2:	9a03      	ldr	r2, [sp, #12]
 8016eb4:	69d2      	ldr	r2, [r2, #28]
 8016eb6:	6812      	ldr	r2, [r2, #0]
 8016eb8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8016ebc:	601a      	str	r2, [r3, #0]
  SPI_1LINE_TX(bus);                      /* Make sure that the MOSI pin is output */
 8016ebe:	9b03      	ldr	r3, [sp, #12]
 8016ec0:	69db      	ldr	r3, [r3, #28]
 8016ec2:	9a03      	ldr	r2, [sp, #12]
 8016ec4:	69d2      	ldr	r2, [r2, #28]
 8016ec6:	6812      	ldr	r2, [r2, #0]
 8016ec8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8016ecc:	601a      	str	r2, [r3, #0]
  spiSelect(bus);                         /* Slave Select assertion.          */
 8016ece:	9803      	ldr	r0, [sp, #12]
 8016ed0:	f7ef fb06 	bl	80064e0 <spiSelect>
  spiPolledTx(bus, WriteAddr);            /* Send the address byte            */
 8016ed4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8016ed8:	9803      	ldr	r0, [sp, #12]
 8016eda:	4619      	mov	r1, r3
 8016edc:	f7f4 fbb0 	bl	800b640 <spi_lld_polled_tx>
  for(i=0;i<nBytesToWrite;i++) {
 8016ee0:	2300      	movs	r3, #0
 8016ee2:	9305      	str	r3, [sp, #20]
 8016ee4:	e00a      	b.n	8016efc <Sensor_IO_SPI_Write+0x9c>
    spiPolledTx(bus, *pBuffer++);         /* Send the address byte            */
 8016ee6:	9b00      	ldr	r3, [sp, #0]
 8016ee8:	1c5a      	adds	r2, r3, #1
 8016eea:	9200      	str	r2, [sp, #0]
 8016eec:	781b      	ldrb	r3, [r3, #0]
 8016eee:	9803      	ldr	r0, [sp, #12]
 8016ef0:	4619      	mov	r1, r3
 8016ef2:	f7f4 fba5 	bl	800b640 <spi_lld_polled_tx>
  SPI_DMA_DISABLE(bus);                   /* Turn off the DMA interrupt since this bus is polled */
  SPI_1LINE_ENABLE(bus);
  SPI_1LINE_TX(bus);                      /* Make sure that the MOSI pin is output */
  spiSelect(bus);                         /* Slave Select assertion.          */
  spiPolledTx(bus, WriteAddr);            /* Send the address byte            */
  for(i=0;i<nBytesToWrite;i++) {
 8016ef6:	9b05      	ldr	r3, [sp, #20]
 8016ef8:	3301      	adds	r3, #1
 8016efa:	9305      	str	r3, [sp, #20]
 8016efc:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 8016f00:	9b05      	ldr	r3, [sp, #20]
 8016f02:	429a      	cmp	r2, r3
 8016f04:	dcef      	bgt.n	8016ee6 <Sensor_IO_SPI_Write+0x86>
    spiPolledTx(bus, *pBuffer++);         /* Send the address byte            */
  }
  spiUnselect(bus);                       /* Slave Select de-assertion.       */
 8016f06:	9803      	ldr	r0, [sp, #12]
 8016f08:	f7ef fafa 	bl	8006500 <spiUnselect>
  spiReleaseBus(bus);                     /* Ownership release.               */
 8016f0c:	9803      	ldr	r0, [sp, #12]
 8016f0e:	f7ef fbef 	bl	80066f0 <spiReleaseBus>
  return 0;
 8016f12:	2300      	movs	r3, #0
}
 8016f14:	4618      	mov	r0, r3
 8016f16:	b007      	add	sp, #28
 8016f18:	f85d fb04 	ldr.w	pc, [sp], #4
 8016f1c:	f3af 8000 	nop.w

08016f20 <Sensor_IO_SPI_Read>:

uint8_t Sensor_IO_SPI_Read(SPIDriver *bus, SPIConfig *cfg, uint8_t ReadAddr, uint8_t *pBuffer, uint16_t nBytesToRead ) {
 8016f20:	b510      	push	{r4, lr}
 8016f22:	b086      	sub	sp, #24
 8016f24:	9003      	str	r0, [sp, #12]
 8016f26:	9102      	str	r1, [sp, #8]
 8016f28:	9300      	str	r3, [sp, #0]
 8016f2a:	4613      	mov	r3, r2
 8016f2c:	f88d 3007 	strb.w	r3, [sp, #7]
  int i;
  if (nBytesToRead > 1) {                  /* Set bit 6 of the address if multiple bytes will be sent. */
 8016f30:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8016f34:	2b01      	cmp	r3, #1
 8016f36:	d905      	bls.n	8016f44 <Sensor_IO_SPI_Read+0x24>
    ReadAddr |= 0x40;
 8016f38:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8016f3c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8016f40:	f88d 3007 	strb.w	r3, [sp, #7]
  }
  ReadAddr = ReadAddr | 0x80;             /* Set the read bit (bit 7)         */
 8016f44:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8016f48:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8016f4c:	f88d 3007 	strb.w	r3, [sp, #7]
  spiAcquireBus(bus);                     /* Acquire ownership of the bus.    */
 8016f50:	9803      	ldr	r0, [sp, #12]
 8016f52:	f7ef fbbd 	bl	80066d0 <spiAcquireBus>
  spiStart(bus, cfg);                     /* Setup transfer parameters.       */
 8016f56:	9803      	ldr	r0, [sp, #12]
 8016f58:	9902      	ldr	r1, [sp, #8]
 8016f5a:	f7ef fa99 	bl	8006490 <spiStart>
  SPI_DMA_DISABLE(bus);                   /* Turn off the DMA interrupt since this bus is polled */
 8016f5e:	9b03      	ldr	r3, [sp, #12]
 8016f60:	69db      	ldr	r3, [r3, #28]
 8016f62:	9a03      	ldr	r2, [sp, #12]
 8016f64:	69d2      	ldr	r2, [r2, #28]
 8016f66:	6852      	ldr	r2, [r2, #4]
 8016f68:	f022 0203 	bic.w	r2, r2, #3
 8016f6c:	605a      	str	r2, [r3, #4]
  SPI_1LINE_ENABLE(bus);
 8016f6e:	9b03      	ldr	r3, [sp, #12]
 8016f70:	69db      	ldr	r3, [r3, #28]
 8016f72:	9a03      	ldr	r2, [sp, #12]
 8016f74:	69d2      	ldr	r2, [r2, #28]
 8016f76:	6812      	ldr	r2, [r2, #0]
 8016f78:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8016f7c:	601a      	str	r2, [r3, #0]
  spiSelect(bus);                         /* Slave Select assertion.          */
 8016f7e:	9803      	ldr	r0, [sp, #12]
 8016f80:	f7ef faae 	bl	80064e0 <spiSelect>
  spiPolledTx(bus, ReadAddr);             /* Send the address byte            */
 8016f84:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8016f88:	9803      	ldr	r0, [sp, #12]
 8016f8a:	4619      	mov	r1, r3
 8016f8c:	f7f4 fb58 	bl	800b640 <spi_lld_polled_tx>
  SPI_1LINE_DISABLE(bus);
 8016f90:	9b03      	ldr	r3, [sp, #12]
 8016f92:	69db      	ldr	r3, [r3, #28]
 8016f94:	9a03      	ldr	r2, [sp, #12]
 8016f96:	69d2      	ldr	r2, [r2, #28]
 8016f98:	6812      	ldr	r2, [r2, #0]
 8016f9a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8016f9e:	601a      	str	r2, [r3, #0]
  SPI_1LINE_RX(bus);
 8016fa0:	9b03      	ldr	r3, [sp, #12]
 8016fa2:	69db      	ldr	r3, [r3, #28]
 8016fa4:	9a03      	ldr	r2, [sp, #12]
 8016fa6:	69d2      	ldr	r2, [r2, #28]
 8016fa8:	6812      	ldr	r2, [r2, #0]
 8016faa:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8016fae:	601a      	str	r2, [r3, #0]
  for(i=0;i<nBytesToRead;i++) {
 8016fb0:	2300      	movs	r3, #0
 8016fb2:	9305      	str	r3, [sp, #20]
 8016fb4:	e00b      	b.n	8016fce <Sensor_IO_SPI_Read+0xae>
    *pBuffer++ = spiPolledRx(bus);     /* Receive data from the wire       */
 8016fb6:	9c00      	ldr	r4, [sp, #0]
 8016fb8:	1c63      	adds	r3, r4, #1
 8016fba:	9300      	str	r3, [sp, #0]
 8016fbc:	9803      	ldr	r0, [sp, #12]
 8016fbe:	f7f4 fb6f 	bl	800b6a0 <spi_lld_polled_rx>
 8016fc2:	4603      	mov	r3, r0
 8016fc4:	b2db      	uxtb	r3, r3
 8016fc6:	7023      	strb	r3, [r4, #0]
  SPI_1LINE_ENABLE(bus);
  spiSelect(bus);                         /* Slave Select assertion.          */
  spiPolledTx(bus, ReadAddr);             /* Send the address byte            */
  SPI_1LINE_DISABLE(bus);
  SPI_1LINE_RX(bus);
  for(i=0;i<nBytesToRead;i++) {
 8016fc8:	9b05      	ldr	r3, [sp, #20]
 8016fca:	3301      	adds	r3, #1
 8016fcc:	9305      	str	r3, [sp, #20]
 8016fce:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 8016fd2:	9b05      	ldr	r3, [sp, #20]
 8016fd4:	429a      	cmp	r2, r3
 8016fd6:	dcee      	bgt.n	8016fb6 <Sensor_IO_SPI_Read+0x96>
    *pBuffer++ = spiPolledRx(bus);     /* Receive data from the wire       */
  }
  spiUnselect(bus);                       /* Slave Select de-assertion.       */
 8016fd8:	9803      	ldr	r0, [sp, #12]
 8016fda:	f7ef fa91 	bl	8006500 <spiUnselect>
  SPI_1LINE_TX(bus);
 8016fde:	9b03      	ldr	r3, [sp, #12]
 8016fe0:	69db      	ldr	r3, [r3, #28]
 8016fe2:	9a03      	ldr	r2, [sp, #12]
 8016fe4:	69d2      	ldr	r2, [r2, #28]
 8016fe6:	6812      	ldr	r2, [r2, #0]
 8016fe8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8016fec:	601a      	str	r2, [r3, #0]
  spiReleaseBus(bus);                     /* Ownership release.               */
 8016fee:	9803      	ldr	r0, [sp, #12]
 8016ff0:	f7ef fb7e 	bl	80066f0 <spiReleaseBus>
  return 0;
 8016ff4:	2300      	movs	r3, #0
}
 8016ff6:	4618      	mov	r0, r3
 8016ff8:	b006      	add	sp, #24
 8016ffa:	bd10      	pop	{r4, pc}
 8016ffc:	f3af 8000 	nop.w

08017000 <__aeabi_ldivmod>:
 8017000:	b973      	cbnz	r3, 8017020 <__aeabi_ldivmod+0x20>
 8017002:	b96a      	cbnz	r2, 8017020 <__aeabi_ldivmod+0x20>
 8017004:	2900      	cmp	r1, #0
 8017006:	bf08      	it	eq
 8017008:	2800      	cmpeq	r0, #0
 801700a:	bfbc      	itt	lt
 801700c:	2000      	movlt	r0, #0
 801700e:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 8017012:	bfc4      	itt	gt
 8017014:	f06f 4100 	mvngt.w	r1, #2147483648	; 0x80000000
 8017018:	f04f 30ff 	movgt.w	r0, #4294967295
 801701c:	f000 b840 	b.w	80170a0 <__aeabi_idiv0>
 8017020:	b082      	sub	sp, #8
 8017022:	46ec      	mov	ip, sp
 8017024:	e92d 5000 	stmdb	sp!, {ip, lr}
 8017028:	f000 f80a 	bl	8017040 <__gnu_ldivmod_helper>
 801702c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8017030:	b002      	add	sp, #8
 8017032:	bc0c      	pop	{r2, r3}
 8017034:	4770      	bx	lr
 8017036:	bf00      	nop
	...

08017040 <__gnu_ldivmod_helper>:
 8017040:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 8017044:	9e06      	ldr	r6, [sp, #24]
 8017046:	4614      	mov	r4, r2
 8017048:	461d      	mov	r5, r3
 801704a:	4680      	mov	r8, r0
 801704c:	4689      	mov	r9, r1
 801704e:	f000 f82f 	bl	80170b0 <__divdi3>
 8017052:	fb04 f301 	mul.w	r3, r4, r1
 8017056:	fb00 3305 	mla	r3, r0, r5, r3
 801705a:	fba4 4500 	umull	r4, r5, r4, r0
 801705e:	441d      	add	r5, r3
 8017060:	ebb8 0404 	subs.w	r4, r8, r4
 8017064:	eb69 0505 	sbc.w	r5, r9, r5
 8017068:	e9c6 4500 	strd	r4, r5, [r6]
 801706c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

08017070 <__gnu_uldivmod_helper>:
 8017070:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 8017074:	9e06      	ldr	r6, [sp, #24]
 8017076:	4614      	mov	r4, r2
 8017078:	4680      	mov	r8, r0
 801707a:	4689      	mov	r9, r1
 801707c:	461d      	mov	r5, r3
 801707e:	f000 f967 	bl	8017350 <__udivdi3>
 8017082:	fb00 f505 	mul.w	r5, r0, r5
 8017086:	fb04 5301 	mla	r3, r4, r1, r5
 801708a:	fba0 4504 	umull	r4, r5, r0, r4
 801708e:	441d      	add	r5, r3
 8017090:	ebb8 0404 	subs.w	r4, r8, r4
 8017094:	eb69 0505 	sbc.w	r5, r9, r5
 8017098:	e9c6 4500 	strd	r4, r5, [r6]
 801709c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

080170a0 <__aeabi_idiv0>:
 80170a0:	4770      	bx	lr
 80170a2:	bf00      	nop
	...

080170b0 <__divdi3>:
 80170b0:	2900      	cmp	r1, #0
 80170b2:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80170b6:	f2c0 809f 	blt.w	80171f8 <__divdi3+0x148>
 80170ba:	2400      	movs	r4, #0
 80170bc:	2b00      	cmp	r3, #0
 80170be:	f2c0 8096 	blt.w	80171ee <__divdi3+0x13e>
 80170c2:	4615      	mov	r5, r2
 80170c4:	4606      	mov	r6, r0
 80170c6:	460f      	mov	r7, r1
 80170c8:	2b00      	cmp	r3, #0
 80170ca:	d13e      	bne.n	801714a <__divdi3+0x9a>
 80170cc:	428a      	cmp	r2, r1
 80170ce:	d957      	bls.n	8017180 <__divdi3+0xd0>
 80170d0:	fab2 f382 	clz	r3, r2
 80170d4:	b14b      	cbz	r3, 80170ea <__divdi3+0x3a>
 80170d6:	f1c3 0220 	rsb	r2, r3, #32
 80170da:	fa01 f703 	lsl.w	r7, r1, r3
 80170de:	fa20 f202 	lsr.w	r2, r0, r2
 80170e2:	409d      	lsls	r5, r3
 80170e4:	4317      	orrs	r7, r2
 80170e6:	fa00 f603 	lsl.w	r6, r0, r3
 80170ea:	0c29      	lsrs	r1, r5, #16
 80170ec:	fbb7 f2f1 	udiv	r2, r7, r1
 80170f0:	0c33      	lsrs	r3, r6, #16
 80170f2:	fb01 7c12 	mls	ip, r1, r2, r7
 80170f6:	b2a8      	uxth	r0, r5
 80170f8:	ea43 470c 	orr.w	r7, r3, ip, lsl #16
 80170fc:	fb00 f302 	mul.w	r3, r0, r2
 8017100:	42bb      	cmp	r3, r7
 8017102:	d909      	bls.n	8017118 <__divdi3+0x68>
 8017104:	197f      	adds	r7, r7, r5
 8017106:	f102 3cff 	add.w	ip, r2, #4294967295
 801710a:	f080 8101 	bcs.w	8017310 <__divdi3+0x260>
 801710e:	42bb      	cmp	r3, r7
 8017110:	f240 80fe 	bls.w	8017310 <__divdi3+0x260>
 8017114:	3a02      	subs	r2, #2
 8017116:	442f      	add	r7, r5
 8017118:	1aff      	subs	r7, r7, r3
 801711a:	fbb7 f3f1 	udiv	r3, r7, r1
 801711e:	b2b6      	uxth	r6, r6
 8017120:	fb01 7113 	mls	r1, r1, r3, r7
 8017124:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
 8017128:	fb00 f003 	mul.w	r0, r0, r3
 801712c:	4288      	cmp	r0, r1
 801712e:	d908      	bls.n	8017142 <__divdi3+0x92>
 8017130:	1949      	adds	r1, r1, r5
 8017132:	f103 37ff 	add.w	r7, r3, #4294967295
 8017136:	f080 80ed 	bcs.w	8017314 <__divdi3+0x264>
 801713a:	4288      	cmp	r0, r1
 801713c:	f240 80ea 	bls.w	8017314 <__divdi3+0x264>
 8017140:	3b02      	subs	r3, #2
 8017142:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 8017146:	2300      	movs	r3, #0
 8017148:	e003      	b.n	8017152 <__divdi3+0xa2>
 801714a:	428b      	cmp	r3, r1
 801714c:	d90a      	bls.n	8017164 <__divdi3+0xb4>
 801714e:	2300      	movs	r3, #0
 8017150:	461a      	mov	r2, r3
 8017152:	4610      	mov	r0, r2
 8017154:	4619      	mov	r1, r3
 8017156:	b114      	cbz	r4, 801715e <__divdi3+0xae>
 8017158:	4240      	negs	r0, r0
 801715a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 801715e:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8017162:	4770      	bx	lr
 8017164:	fab3 f883 	clz	r8, r3
 8017168:	f1b8 0f00 	cmp.w	r8, #0
 801716c:	f040 8084 	bne.w	8017278 <__divdi3+0x1c8>
 8017170:	428b      	cmp	r3, r1
 8017172:	d302      	bcc.n	801717a <__divdi3+0xca>
 8017174:	4282      	cmp	r2, r0
 8017176:	f200 80de 	bhi.w	8017336 <__divdi3+0x286>
 801717a:	2300      	movs	r3, #0
 801717c:	2201      	movs	r2, #1
 801717e:	e7e8      	b.n	8017152 <__divdi3+0xa2>
 8017180:	b912      	cbnz	r2, 8017188 <__divdi3+0xd8>
 8017182:	2301      	movs	r3, #1
 8017184:	fbb3 f5f2 	udiv	r5, r3, r2
 8017188:	fab5 f285 	clz	r2, r5
 801718c:	2a00      	cmp	r2, #0
 801718e:	d139      	bne.n	8017204 <__divdi3+0x154>
 8017190:	1b7f      	subs	r7, r7, r5
 8017192:	0c28      	lsrs	r0, r5, #16
 8017194:	fa1f fc85 	uxth.w	ip, r5
 8017198:	2301      	movs	r3, #1
 801719a:	fbb7 f1f0 	udiv	r1, r7, r0
 801719e:	0c32      	lsrs	r2, r6, #16
 80171a0:	fb00 7711 	mls	r7, r0, r1, r7
 80171a4:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 80171a8:	fb0c f201 	mul.w	r2, ip, r1
 80171ac:	42ba      	cmp	r2, r7
 80171ae:	d907      	bls.n	80171c0 <__divdi3+0x110>
 80171b0:	197f      	adds	r7, r7, r5
 80171b2:	f101 38ff 	add.w	r8, r1, #4294967295
 80171b6:	d202      	bcs.n	80171be <__divdi3+0x10e>
 80171b8:	42ba      	cmp	r2, r7
 80171ba:	f200 80c1 	bhi.w	8017340 <__divdi3+0x290>
 80171be:	4641      	mov	r1, r8
 80171c0:	1abf      	subs	r7, r7, r2
 80171c2:	fbb7 f2f0 	udiv	r2, r7, r0
 80171c6:	b2b6      	uxth	r6, r6
 80171c8:	fb00 7012 	mls	r0, r0, r2, r7
 80171cc:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
 80171d0:	fb0c fc02 	mul.w	ip, ip, r2
 80171d4:	4584      	cmp	ip, r0
 80171d6:	d907      	bls.n	80171e8 <__divdi3+0x138>
 80171d8:	1940      	adds	r0, r0, r5
 80171da:	f102 37ff 	add.w	r7, r2, #4294967295
 80171de:	d202      	bcs.n	80171e6 <__divdi3+0x136>
 80171e0:	4584      	cmp	ip, r0
 80171e2:	f200 80ab 	bhi.w	801733c <__divdi3+0x28c>
 80171e6:	463a      	mov	r2, r7
 80171e8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80171ec:	e7b1      	b.n	8017152 <__divdi3+0xa2>
 80171ee:	43e4      	mvns	r4, r4
 80171f0:	4252      	negs	r2, r2
 80171f2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80171f6:	e764      	b.n	80170c2 <__divdi3+0x12>
 80171f8:	4240      	negs	r0, r0
 80171fa:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80171fe:	f04f 34ff 	mov.w	r4, #4294967295
 8017202:	e75b      	b.n	80170bc <__divdi3+0xc>
 8017204:	4095      	lsls	r5, r2
 8017206:	f1c2 0320 	rsb	r3, r2, #32
 801720a:	fa27 f103 	lsr.w	r1, r7, r3
 801720e:	0c28      	lsrs	r0, r5, #16
 8017210:	fa26 f303 	lsr.w	r3, r6, r3
 8017214:	4097      	lsls	r7, r2
 8017216:	fbb1 f8f0 	udiv	r8, r1, r0
 801721a:	431f      	orrs	r7, r3
 801721c:	0c3b      	lsrs	r3, r7, #16
 801721e:	fb00 1118 	mls	r1, r0, r8, r1
 8017222:	fa1f fc85 	uxth.w	ip, r5
 8017226:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 801722a:	fb0c f308 	mul.w	r3, ip, r8
 801722e:	428b      	cmp	r3, r1
 8017230:	fa06 f602 	lsl.w	r6, r6, r2
 8017234:	d908      	bls.n	8017248 <__divdi3+0x198>
 8017236:	1949      	adds	r1, r1, r5
 8017238:	f108 32ff 	add.w	r2, r8, #4294967295
 801723c:	d279      	bcs.n	8017332 <__divdi3+0x282>
 801723e:	428b      	cmp	r3, r1
 8017240:	d977      	bls.n	8017332 <__divdi3+0x282>
 8017242:	f1a8 0802 	sub.w	r8, r8, #2
 8017246:	4429      	add	r1, r5
 8017248:	1ac9      	subs	r1, r1, r3
 801724a:	fbb1 f3f0 	udiv	r3, r1, r0
 801724e:	b2bf      	uxth	r7, r7
 8017250:	fb00 1113 	mls	r1, r0, r3, r1
 8017254:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8017258:	fb0c f203 	mul.w	r2, ip, r3
 801725c:	42ba      	cmp	r2, r7
 801725e:	d907      	bls.n	8017270 <__divdi3+0x1c0>
 8017260:	197f      	adds	r7, r7, r5
 8017262:	f103 31ff 	add.w	r1, r3, #4294967295
 8017266:	d260      	bcs.n	801732a <__divdi3+0x27a>
 8017268:	42ba      	cmp	r2, r7
 801726a:	d95e      	bls.n	801732a <__divdi3+0x27a>
 801726c:	3b02      	subs	r3, #2
 801726e:	442f      	add	r7, r5
 8017270:	1abf      	subs	r7, r7, r2
 8017272:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8017276:	e790      	b.n	801719a <__divdi3+0xea>
 8017278:	f1c8 0220 	rsb	r2, r8, #32
 801727c:	fa03 fc08 	lsl.w	ip, r3, r8
 8017280:	fa25 f302 	lsr.w	r3, r5, r2
 8017284:	ea43 0c0c 	orr.w	ip, r3, ip
 8017288:	ea4f 491c 	mov.w	r9, ip, lsr #16
 801728c:	fa21 f302 	lsr.w	r3, r1, r2
 8017290:	fa01 f708 	lsl.w	r7, r1, r8
 8017294:	fa20 f202 	lsr.w	r2, r0, r2
 8017298:	fbb3 f1f9 	udiv	r1, r3, r9
 801729c:	4317      	orrs	r7, r2
 801729e:	fb09 3311 	mls	r3, r9, r1, r3
 80172a2:	0c3a      	lsrs	r2, r7, #16
 80172a4:	fa1f fb8c 	uxth.w	fp, ip
 80172a8:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 80172ac:	fb0b fa01 	mul.w	sl, fp, r1
 80172b0:	459a      	cmp	sl, r3
 80172b2:	fa05 f008 	lsl.w	r0, r5, r8
 80172b6:	d908      	bls.n	80172ca <__divdi3+0x21a>
 80172b8:	eb13 030c 	adds.w	r3, r3, ip
 80172bc:	f101 32ff 	add.w	r2, r1, #4294967295
 80172c0:	d235      	bcs.n	801732e <__divdi3+0x27e>
 80172c2:	459a      	cmp	sl, r3
 80172c4:	d933      	bls.n	801732e <__divdi3+0x27e>
 80172c6:	3902      	subs	r1, #2
 80172c8:	4463      	add	r3, ip
 80172ca:	ebca 0303 	rsb	r3, sl, r3
 80172ce:	fbb3 f2f9 	udiv	r2, r3, r9
 80172d2:	fb09 3312 	mls	r3, r9, r2, r3
 80172d6:	b2bf      	uxth	r7, r7
 80172d8:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 80172dc:	fb0b f902 	mul.w	r9, fp, r2
 80172e0:	45b9      	cmp	r9, r7
 80172e2:	d908      	bls.n	80172f6 <__divdi3+0x246>
 80172e4:	eb17 070c 	adds.w	r7, r7, ip
 80172e8:	f102 33ff 	add.w	r3, r2, #4294967295
 80172ec:	d21b      	bcs.n	8017326 <__divdi3+0x276>
 80172ee:	45b9      	cmp	r9, r7
 80172f0:	d919      	bls.n	8017326 <__divdi3+0x276>
 80172f2:	3a02      	subs	r2, #2
 80172f4:	4467      	add	r7, ip
 80172f6:	ea42 4501 	orr.w	r5, r2, r1, lsl #16
 80172fa:	fba5 0100 	umull	r0, r1, r5, r0
 80172fe:	ebc9 0707 	rsb	r7, r9, r7
 8017302:	428f      	cmp	r7, r1
 8017304:	f04f 0300 	mov.w	r3, #0
 8017308:	d30a      	bcc.n	8017320 <__divdi3+0x270>
 801730a:	d005      	beq.n	8017318 <__divdi3+0x268>
 801730c:	462a      	mov	r2, r5
 801730e:	e720      	b.n	8017152 <__divdi3+0xa2>
 8017310:	4662      	mov	r2, ip
 8017312:	e701      	b.n	8017118 <__divdi3+0x68>
 8017314:	463b      	mov	r3, r7
 8017316:	e714      	b.n	8017142 <__divdi3+0x92>
 8017318:	fa06 f608 	lsl.w	r6, r6, r8
 801731c:	4286      	cmp	r6, r0
 801731e:	d2f5      	bcs.n	801730c <__divdi3+0x25c>
 8017320:	1e6a      	subs	r2, r5, #1
 8017322:	2300      	movs	r3, #0
 8017324:	e715      	b.n	8017152 <__divdi3+0xa2>
 8017326:	461a      	mov	r2, r3
 8017328:	e7e5      	b.n	80172f6 <__divdi3+0x246>
 801732a:	460b      	mov	r3, r1
 801732c:	e7a0      	b.n	8017270 <__divdi3+0x1c0>
 801732e:	4611      	mov	r1, r2
 8017330:	e7cb      	b.n	80172ca <__divdi3+0x21a>
 8017332:	4690      	mov	r8, r2
 8017334:	e788      	b.n	8017248 <__divdi3+0x198>
 8017336:	4643      	mov	r3, r8
 8017338:	4642      	mov	r2, r8
 801733a:	e70a      	b.n	8017152 <__divdi3+0xa2>
 801733c:	3a02      	subs	r2, #2
 801733e:	e753      	b.n	80171e8 <__divdi3+0x138>
 8017340:	3902      	subs	r1, #2
 8017342:	442f      	add	r7, r5
 8017344:	e73c      	b.n	80171c0 <__divdi3+0x110>
 8017346:	bf00      	nop
	...

08017350 <__udivdi3>:
 8017350:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8017354:	4614      	mov	r4, r2
 8017356:	4605      	mov	r5, r0
 8017358:	460e      	mov	r6, r1
 801735a:	2b00      	cmp	r3, #0
 801735c:	d143      	bne.n	80173e6 <__udivdi3+0x96>
 801735e:	428a      	cmp	r2, r1
 8017360:	d953      	bls.n	801740a <__udivdi3+0xba>
 8017362:	fab2 f782 	clz	r7, r2
 8017366:	b157      	cbz	r7, 801737e <__udivdi3+0x2e>
 8017368:	f1c7 0620 	rsb	r6, r7, #32
 801736c:	fa20 f606 	lsr.w	r6, r0, r6
 8017370:	fa01 f307 	lsl.w	r3, r1, r7
 8017374:	fa02 f407 	lsl.w	r4, r2, r7
 8017378:	431e      	orrs	r6, r3
 801737a:	fa00 f507 	lsl.w	r5, r0, r7
 801737e:	0c21      	lsrs	r1, r4, #16
 8017380:	fbb6 f2f1 	udiv	r2, r6, r1
 8017384:	0c2b      	lsrs	r3, r5, #16
 8017386:	fb01 6712 	mls	r7, r1, r2, r6
 801738a:	b2a0      	uxth	r0, r4
 801738c:	ea43 4607 	orr.w	r6, r3, r7, lsl #16
 8017390:	fb00 f302 	mul.w	r3, r0, r2
 8017394:	42b3      	cmp	r3, r6
 8017396:	d909      	bls.n	80173ac <__udivdi3+0x5c>
 8017398:	1936      	adds	r6, r6, r4
 801739a:	f102 37ff 	add.w	r7, r2, #4294967295
 801739e:	f080 80f6 	bcs.w	801758e <__udivdi3+0x23e>
 80173a2:	42b3      	cmp	r3, r6
 80173a4:	f240 80f3 	bls.w	801758e <__udivdi3+0x23e>
 80173a8:	3a02      	subs	r2, #2
 80173aa:	4426      	add	r6, r4
 80173ac:	1af6      	subs	r6, r6, r3
 80173ae:	fbb6 f3f1 	udiv	r3, r6, r1
 80173b2:	b2ad      	uxth	r5, r5
 80173b4:	fb01 6113 	mls	r1, r1, r3, r6
 80173b8:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
 80173bc:	fb00 f003 	mul.w	r0, r0, r3
 80173c0:	4288      	cmp	r0, r1
 80173c2:	d908      	bls.n	80173d6 <__udivdi3+0x86>
 80173c4:	1909      	adds	r1, r1, r4
 80173c6:	f103 36ff 	add.w	r6, r3, #4294967295
 80173ca:	f080 80e2 	bcs.w	8017592 <__udivdi3+0x242>
 80173ce:	4288      	cmp	r0, r1
 80173d0:	f240 80df 	bls.w	8017592 <__udivdi3+0x242>
 80173d4:	3b02      	subs	r3, #2
 80173d6:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80173da:	2300      	movs	r3, #0
 80173dc:	4610      	mov	r0, r2
 80173de:	4619      	mov	r1, r3
 80173e0:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80173e4:	4770      	bx	lr
 80173e6:	428b      	cmp	r3, r1
 80173e8:	d84a      	bhi.n	8017480 <__udivdi3+0x130>
 80173ea:	fab3 f683 	clz	r6, r3
 80173ee:	2e00      	cmp	r6, #0
 80173f0:	d14d      	bne.n	801748e <__udivdi3+0x13e>
 80173f2:	428b      	cmp	r3, r1
 80173f4:	d302      	bcc.n	80173fc <__udivdi3+0xac>
 80173f6:	4282      	cmp	r2, r0
 80173f8:	f200 80d6 	bhi.w	80175a8 <__udivdi3+0x258>
 80173fc:	2300      	movs	r3, #0
 80173fe:	2201      	movs	r2, #1
 8017400:	4610      	mov	r0, r2
 8017402:	4619      	mov	r1, r3
 8017404:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8017408:	4770      	bx	lr
 801740a:	b912      	cbnz	r2, 8017412 <__udivdi3+0xc2>
 801740c:	2401      	movs	r4, #1
 801740e:	fbb4 f4f2 	udiv	r4, r4, r2
 8017412:	fab4 f284 	clz	r2, r4
 8017416:	2a00      	cmp	r2, #0
 8017418:	d17c      	bne.n	8017514 <__udivdi3+0x1c4>
 801741a:	1b09      	subs	r1, r1, r4
 801741c:	0c26      	lsrs	r6, r4, #16
 801741e:	b2a7      	uxth	r7, r4
 8017420:	2301      	movs	r3, #1
 8017422:	fbb1 f0f6 	udiv	r0, r1, r6
 8017426:	0c2a      	lsrs	r2, r5, #16
 8017428:	fb06 1110 	mls	r1, r6, r0, r1
 801742c:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
 8017430:	fb07 f200 	mul.w	r2, r7, r0
 8017434:	428a      	cmp	r2, r1
 8017436:	d907      	bls.n	8017448 <__udivdi3+0xf8>
 8017438:	1909      	adds	r1, r1, r4
 801743a:	f100 3cff 	add.w	ip, r0, #4294967295
 801743e:	d202      	bcs.n	8017446 <__udivdi3+0xf6>
 8017440:	428a      	cmp	r2, r1
 8017442:	f200 80c3 	bhi.w	80175cc <__udivdi3+0x27c>
 8017446:	4660      	mov	r0, ip
 8017448:	1a89      	subs	r1, r1, r2
 801744a:	fbb1 f2f6 	udiv	r2, r1, r6
 801744e:	b2ad      	uxth	r5, r5
 8017450:	fb06 1112 	mls	r1, r6, r2, r1
 8017454:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 8017458:	fb07 f702 	mul.w	r7, r7, r2
 801745c:	42af      	cmp	r7, r5
 801745e:	d908      	bls.n	8017472 <__udivdi3+0x122>
 8017460:	192c      	adds	r4, r5, r4
 8017462:	f102 31ff 	add.w	r1, r2, #4294967295
 8017466:	f080 8096 	bcs.w	8017596 <__udivdi3+0x246>
 801746a:	42a7      	cmp	r7, r4
 801746c:	f240 8093 	bls.w	8017596 <__udivdi3+0x246>
 8017470:	3a02      	subs	r2, #2
 8017472:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8017476:	4610      	mov	r0, r2
 8017478:	4619      	mov	r1, r3
 801747a:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801747e:	4770      	bx	lr
 8017480:	2300      	movs	r3, #0
 8017482:	461a      	mov	r2, r3
 8017484:	4610      	mov	r0, r2
 8017486:	4619      	mov	r1, r3
 8017488:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801748c:	4770      	bx	lr
 801748e:	f1c6 0520 	rsb	r5, r6, #32
 8017492:	fa22 f405 	lsr.w	r4, r2, r5
 8017496:	40b3      	lsls	r3, r6
 8017498:	431c      	orrs	r4, r3
 801749a:	ea4f 4814 	mov.w	r8, r4, lsr #16
 801749e:	fa21 f305 	lsr.w	r3, r1, r5
 80174a2:	fa01 f706 	lsl.w	r7, r1, r6
 80174a6:	fa20 f505 	lsr.w	r5, r0, r5
 80174aa:	fbb3 fcf8 	udiv	ip, r3, r8
 80174ae:	432f      	orrs	r7, r5
 80174b0:	fb08 331c 	mls	r3, r8, ip, r3
 80174b4:	0c3d      	lsrs	r5, r7, #16
 80174b6:	fa1f fa84 	uxth.w	sl, r4
 80174ba:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 80174be:	fb0a f90c 	mul.w	r9, sl, ip
 80174c2:	4599      	cmp	r9, r3
 80174c4:	fa02 fb06 	lsl.w	fp, r2, r6
 80174c8:	d904      	bls.n	80174d4 <__udivdi3+0x184>
 80174ca:	191b      	adds	r3, r3, r4
 80174cc:	f10c 32ff 	add.w	r2, ip, #4294967295
 80174d0:	d36d      	bcc.n	80175ae <__udivdi3+0x25e>
 80174d2:	4694      	mov	ip, r2
 80174d4:	ebc9 0303 	rsb	r3, r9, r3
 80174d8:	fbb3 f5f8 	udiv	r5, r3, r8
 80174dc:	fb08 3315 	mls	r3, r8, r5, r3
 80174e0:	b2bf      	uxth	r7, r7
 80174e2:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 80174e6:	fb0a f805 	mul.w	r8, sl, r5
 80174ea:	45b8      	cmp	r8, r7
 80174ec:	d904      	bls.n	80174f8 <__udivdi3+0x1a8>
 80174ee:	193f      	adds	r7, r7, r4
 80174f0:	f105 33ff 	add.w	r3, r5, #4294967295
 80174f4:	d361      	bcc.n	80175ba <__udivdi3+0x26a>
 80174f6:	461d      	mov	r5, r3
 80174f8:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
 80174fc:	fbac 230b 	umull	r2, r3, ip, fp
 8017500:	ebc8 0707 	rsb	r7, r8, r7
 8017504:	429f      	cmp	r7, r3
 8017506:	f04f 0500 	mov.w	r5, #0
 801750a:	d349      	bcc.n	80175a0 <__udivdi3+0x250>
 801750c:	d045      	beq.n	801759a <__udivdi3+0x24a>
 801750e:	4662      	mov	r2, ip
 8017510:	462b      	mov	r3, r5
 8017512:	e763      	b.n	80173dc <__udivdi3+0x8c>
 8017514:	4094      	lsls	r4, r2
 8017516:	f1c2 0320 	rsb	r3, r2, #32
 801751a:	fa21 fc03 	lsr.w	ip, r1, r3
 801751e:	0c26      	lsrs	r6, r4, #16
 8017520:	fa20 f303 	lsr.w	r3, r0, r3
 8017524:	fa01 f502 	lsl.w	r5, r1, r2
 8017528:	fbbc f8f6 	udiv	r8, ip, r6
 801752c:	ea43 0105 	orr.w	r1, r3, r5
 8017530:	0c0b      	lsrs	r3, r1, #16
 8017532:	fb06 cc18 	mls	ip, r6, r8, ip
 8017536:	b2a7      	uxth	r7, r4
 8017538:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
 801753c:	fb07 f308 	mul.w	r3, r7, r8
 8017540:	4563      	cmp	r3, ip
 8017542:	fa00 f502 	lsl.w	r5, r0, r2
 8017546:	d909      	bls.n	801755c <__udivdi3+0x20c>
 8017548:	eb1c 0c04 	adds.w	ip, ip, r4
 801754c:	f108 32ff 	add.w	r2, r8, #4294967295
 8017550:	d23a      	bcs.n	80175c8 <__udivdi3+0x278>
 8017552:	4563      	cmp	r3, ip
 8017554:	d938      	bls.n	80175c8 <__udivdi3+0x278>
 8017556:	f1a8 0802 	sub.w	r8, r8, #2
 801755a:	44a4      	add	ip, r4
 801755c:	ebc3 0c0c 	rsb	ip, r3, ip
 8017560:	fbbc f3f6 	udiv	r3, ip, r6
 8017564:	b289      	uxth	r1, r1
 8017566:	fb06 cc13 	mls	ip, r6, r3, ip
 801756a:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 801756e:	fb07 f203 	mul.w	r2, r7, r3
 8017572:	428a      	cmp	r2, r1
 8017574:	d907      	bls.n	8017586 <__udivdi3+0x236>
 8017576:	1909      	adds	r1, r1, r4
 8017578:	f103 30ff 	add.w	r0, r3, #4294967295
 801757c:	d222      	bcs.n	80175c4 <__udivdi3+0x274>
 801757e:	428a      	cmp	r2, r1
 8017580:	d920      	bls.n	80175c4 <__udivdi3+0x274>
 8017582:	3b02      	subs	r3, #2
 8017584:	4421      	add	r1, r4
 8017586:	1a89      	subs	r1, r1, r2
 8017588:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 801758c:	e749      	b.n	8017422 <__udivdi3+0xd2>
 801758e:	463a      	mov	r2, r7
 8017590:	e70c      	b.n	80173ac <__udivdi3+0x5c>
 8017592:	4633      	mov	r3, r6
 8017594:	e71f      	b.n	80173d6 <__udivdi3+0x86>
 8017596:	460a      	mov	r2, r1
 8017598:	e76b      	b.n	8017472 <__udivdi3+0x122>
 801759a:	40b0      	lsls	r0, r6
 801759c:	4290      	cmp	r0, r2
 801759e:	d2b6      	bcs.n	801750e <__udivdi3+0x1be>
 80175a0:	f10c 32ff 	add.w	r2, ip, #4294967295
 80175a4:	2300      	movs	r3, #0
 80175a6:	e719      	b.n	80173dc <__udivdi3+0x8c>
 80175a8:	4633      	mov	r3, r6
 80175aa:	4632      	mov	r2, r6
 80175ac:	e716      	b.n	80173dc <__udivdi3+0x8c>
 80175ae:	4599      	cmp	r9, r3
 80175b0:	d98f      	bls.n	80174d2 <__udivdi3+0x182>
 80175b2:	f1ac 0c02 	sub.w	ip, ip, #2
 80175b6:	4423      	add	r3, r4
 80175b8:	e78c      	b.n	80174d4 <__udivdi3+0x184>
 80175ba:	45b8      	cmp	r8, r7
 80175bc:	d99b      	bls.n	80174f6 <__udivdi3+0x1a6>
 80175be:	3d02      	subs	r5, #2
 80175c0:	4427      	add	r7, r4
 80175c2:	e799      	b.n	80174f8 <__udivdi3+0x1a8>
 80175c4:	4603      	mov	r3, r0
 80175c6:	e7de      	b.n	8017586 <__udivdi3+0x236>
 80175c8:	4690      	mov	r8, r2
 80175ca:	e7c7      	b.n	801755c <__udivdi3+0x20c>
 80175cc:	3802      	subs	r0, #2
 80175ce:	4421      	add	r1, r4
 80175d0:	e73a      	b.n	8017448 <__udivdi3+0xf8>
 80175d2:	bf00      	nop
	...

080175e0 <memcpy>:
 80175e0:	4684      	mov	ip, r0
 80175e2:	ea41 0300 	orr.w	r3, r1, r0
 80175e6:	f013 0303 	ands.w	r3, r3, #3
 80175ea:	d16d      	bne.n	80176c8 <memcpy+0xe8>
 80175ec:	3a40      	subs	r2, #64	; 0x40
 80175ee:	d341      	bcc.n	8017674 <memcpy+0x94>
 80175f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80175f4:	f840 3b04 	str.w	r3, [r0], #4
 80175f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80175fc:	f840 3b04 	str.w	r3, [r0], #4
 8017600:	f851 3b04 	ldr.w	r3, [r1], #4
 8017604:	f840 3b04 	str.w	r3, [r0], #4
 8017608:	f851 3b04 	ldr.w	r3, [r1], #4
 801760c:	f840 3b04 	str.w	r3, [r0], #4
 8017610:	f851 3b04 	ldr.w	r3, [r1], #4
 8017614:	f840 3b04 	str.w	r3, [r0], #4
 8017618:	f851 3b04 	ldr.w	r3, [r1], #4
 801761c:	f840 3b04 	str.w	r3, [r0], #4
 8017620:	f851 3b04 	ldr.w	r3, [r1], #4
 8017624:	f840 3b04 	str.w	r3, [r0], #4
 8017628:	f851 3b04 	ldr.w	r3, [r1], #4
 801762c:	f840 3b04 	str.w	r3, [r0], #4
 8017630:	f851 3b04 	ldr.w	r3, [r1], #4
 8017634:	f840 3b04 	str.w	r3, [r0], #4
 8017638:	f851 3b04 	ldr.w	r3, [r1], #4
 801763c:	f840 3b04 	str.w	r3, [r0], #4
 8017640:	f851 3b04 	ldr.w	r3, [r1], #4
 8017644:	f840 3b04 	str.w	r3, [r0], #4
 8017648:	f851 3b04 	ldr.w	r3, [r1], #4
 801764c:	f840 3b04 	str.w	r3, [r0], #4
 8017650:	f851 3b04 	ldr.w	r3, [r1], #4
 8017654:	f840 3b04 	str.w	r3, [r0], #4
 8017658:	f851 3b04 	ldr.w	r3, [r1], #4
 801765c:	f840 3b04 	str.w	r3, [r0], #4
 8017660:	f851 3b04 	ldr.w	r3, [r1], #4
 8017664:	f840 3b04 	str.w	r3, [r0], #4
 8017668:	f851 3b04 	ldr.w	r3, [r1], #4
 801766c:	f840 3b04 	str.w	r3, [r0], #4
 8017670:	3a40      	subs	r2, #64	; 0x40
 8017672:	d2bd      	bcs.n	80175f0 <memcpy+0x10>
 8017674:	3230      	adds	r2, #48	; 0x30
 8017676:	d311      	bcc.n	801769c <memcpy+0xbc>
 8017678:	f851 3b04 	ldr.w	r3, [r1], #4
 801767c:	f840 3b04 	str.w	r3, [r0], #4
 8017680:	f851 3b04 	ldr.w	r3, [r1], #4
 8017684:	f840 3b04 	str.w	r3, [r0], #4
 8017688:	f851 3b04 	ldr.w	r3, [r1], #4
 801768c:	f840 3b04 	str.w	r3, [r0], #4
 8017690:	f851 3b04 	ldr.w	r3, [r1], #4
 8017694:	f840 3b04 	str.w	r3, [r0], #4
 8017698:	3a10      	subs	r2, #16
 801769a:	d2ed      	bcs.n	8017678 <memcpy+0x98>
 801769c:	320c      	adds	r2, #12
 801769e:	d305      	bcc.n	80176ac <memcpy+0xcc>
 80176a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80176a4:	f840 3b04 	str.w	r3, [r0], #4
 80176a8:	3a04      	subs	r2, #4
 80176aa:	d2f9      	bcs.n	80176a0 <memcpy+0xc0>
 80176ac:	3204      	adds	r2, #4
 80176ae:	d008      	beq.n	80176c2 <memcpy+0xe2>
 80176b0:	07d2      	lsls	r2, r2, #31
 80176b2:	bf1c      	itt	ne
 80176b4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80176b8:	f800 3b01 	strbne.w	r3, [r0], #1
 80176bc:	d301      	bcc.n	80176c2 <memcpy+0xe2>
 80176be:	880b      	ldrh	r3, [r1, #0]
 80176c0:	8003      	strh	r3, [r0, #0]
 80176c2:	4660      	mov	r0, ip
 80176c4:	4770      	bx	lr
 80176c6:	bf00      	nop
 80176c8:	2a08      	cmp	r2, #8
 80176ca:	d313      	bcc.n	80176f4 <memcpy+0x114>
 80176cc:	078b      	lsls	r3, r1, #30
 80176ce:	d08d      	beq.n	80175ec <memcpy+0xc>
 80176d0:	f010 0303 	ands.w	r3, r0, #3
 80176d4:	d08a      	beq.n	80175ec <memcpy+0xc>
 80176d6:	f1c3 0304 	rsb	r3, r3, #4
 80176da:	1ad2      	subs	r2, r2, r3
 80176dc:	07db      	lsls	r3, r3, #31
 80176de:	bf1c      	itt	ne
 80176e0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80176e4:	f800 3b01 	strbne.w	r3, [r0], #1
 80176e8:	d380      	bcc.n	80175ec <memcpy+0xc>
 80176ea:	f831 3b02 	ldrh.w	r3, [r1], #2
 80176ee:	f820 3b02 	strh.w	r3, [r0], #2
 80176f2:	e77b      	b.n	80175ec <memcpy+0xc>
 80176f4:	3a04      	subs	r2, #4
 80176f6:	d3d9      	bcc.n	80176ac <memcpy+0xcc>
 80176f8:	3a01      	subs	r2, #1
 80176fa:	f811 3b01 	ldrb.w	r3, [r1], #1
 80176fe:	f800 3b01 	strb.w	r3, [r0], #1
 8017702:	d2f9      	bcs.n	80176f8 <memcpy+0x118>
 8017704:	780b      	ldrb	r3, [r1, #0]
 8017706:	7003      	strb	r3, [r0, #0]
 8017708:	784b      	ldrb	r3, [r1, #1]
 801770a:	7043      	strb	r3, [r0, #1]
 801770c:	788b      	ldrb	r3, [r1, #2]
 801770e:	7083      	strb	r3, [r0, #2]
 8017710:	4660      	mov	r0, ip
 8017712:	4770      	bx	lr
	...

08017720 <strcmp>:
 8017720:	ea40 0c01 	orr.w	ip, r0, r1
 8017724:	f01c 0f07 	tst.w	ip, #7
 8017728:	d123      	bne.n	8017772 <strcmp+0x52>
 801772a:	f1bd 0d10 	subs.w	sp, sp, #16
 801772e:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8017732:	e9cd 6700 	strd	r6, r7, [sp]
 8017736:	f06f 0600 	mvn.w	r6, #0
 801773a:	f04f 0700 	mov.w	r7, #0
 801773e:	bf00      	nop
 8017740:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 8017744:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 8017748:	42a2      	cmp	r2, r4
 801774a:	fa82 fc46 	uadd8	ip, r2, r6
 801774e:	faa7 fc86 	sel	ip, r7, r6
 8017752:	bf08      	it	eq
 8017754:	f1bc 0f00 	cmpeq.w	ip, #0
 8017758:	f040 80d7 	bne.w	801790a <strcmp+0x1ea>
 801775c:	42ab      	cmp	r3, r5
 801775e:	fa83 fc46 	uadd8	ip, r3, r6
 8017762:	faa7 fc86 	sel	ip, r7, r6
 8017766:	bf08      	it	eq
 8017768:	f1bc 0f00 	cmpeq.w	ip, #0
 801776c:	f040 80ca 	bne.w	8017904 <strcmp+0x1e4>
 8017770:	e7e6      	b.n	8017740 <strcmp+0x20>
 8017772:	f010 0c03 	ands.w	ip, r0, #3
 8017776:	d021      	beq.n	80177bc <strcmp+0x9c>
 8017778:	f020 0003 	bic.w	r0, r0, #3
 801777c:	f850 2b04 	ldr.w	r2, [r0], #4
 8017780:	ea5f 7ccc 	movs.w	ip, ip, lsl #31
 8017784:	d008      	beq.n	8017798 <strcmp+0x78>
 8017786:	d20f      	bcs.n	80177a8 <strcmp+0x88>
 8017788:	f811 cb01 	ldrb.w	ip, [r1], #1
 801778c:	fa5f f392 	uxtb.w	r3, r2, ror #8
 8017790:	ebb3 0c0c 	subs.w	ip, r3, ip
 8017794:	d110      	bne.n	80177b8 <strcmp+0x98>
 8017796:	b17b      	cbz	r3, 80177b8 <strcmp+0x98>
 8017798:	f811 cb01 	ldrb.w	ip, [r1], #1
 801779c:	fa5f f3a2 	uxtb.w	r3, r2, ror #16
 80177a0:	ebb3 0c0c 	subs.w	ip, r3, ip
 80177a4:	d108      	bne.n	80177b8 <strcmp+0x98>
 80177a6:	b13b      	cbz	r3, 80177b8 <strcmp+0x98>
 80177a8:	f811 cb01 	ldrb.w	ip, [r1], #1
 80177ac:	fa5f f3b2 	uxtb.w	r3, r2, ror #24
 80177b0:	ebb3 0c0c 	subs.w	ip, r3, ip
 80177b4:	d100      	bne.n	80177b8 <strcmp+0x98>
 80177b6:	b90b      	cbnz	r3, 80177bc <strcmp+0x9c>
 80177b8:	4660      	mov	r0, ip
 80177ba:	4770      	bx	lr
 80177bc:	f1bd 0d10 	subs.w	sp, sp, #16
 80177c0:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80177c4:	e9cd 6700 	strd	r6, r7, [sp]
 80177c8:	f06f 0600 	mvn.w	r6, #0
 80177cc:	f04f 0700 	mov.w	r7, #0
 80177d0:	f011 0c03 	ands.w	ip, r1, #3
 80177d4:	d12d      	bne.n	8017832 <strcmp+0x112>
 80177d6:	f010 0f04 	tst.w	r0, #4
 80177da:	d00d      	beq.n	80177f8 <strcmp+0xd8>
 80177dc:	f850 2b04 	ldr.w	r2, [r0], #4
 80177e0:	f851 4b04 	ldr.w	r4, [r1], #4
 80177e4:	42a2      	cmp	r2, r4
 80177e6:	fa82 fc46 	uadd8	ip, r2, r6
 80177ea:	faa7 fc86 	sel	ip, r7, r6
 80177ee:	bf08      	it	eq
 80177f0:	f1bc 0f00 	cmpeq.w	ip, #0
 80177f4:	f040 8089 	bne.w	801790a <strcmp+0x1ea>
 80177f8:	f011 0f04 	tst.w	r1, #4
 80177fc:	d09f      	beq.n	801773e <strcmp+0x1e>
 80177fe:	f851 5b04 	ldr.w	r5, [r1], #4
 8017802:	bf00      	nop
 8017804:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 8017808:	42aa      	cmp	r2, r5
 801780a:	fa82 fc46 	uadd8	ip, r2, r6
 801780e:	faa7 fc86 	sel	ip, r7, r6
 8017812:	bf08      	it	eq
 8017814:	f1bc 0f00 	cmpeq.w	ip, #0
 8017818:	d171      	bne.n	80178fe <strcmp+0x1de>
 801781a:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 801781e:	42a3      	cmp	r3, r4
 8017820:	fa83 fc46 	uadd8	ip, r3, r6
 8017824:	faa7 fc86 	sel	ip, r7, r6
 8017828:	bf08      	it	eq
 801782a:	f1bc 0f00 	cmpeq.w	ip, #0
 801782e:	d163      	bne.n	80178f8 <strcmp+0x1d8>
 8017830:	e7e8      	b.n	8017804 <strcmp+0xe4>
 8017832:	f021 0103 	bic.w	r1, r1, #3
 8017836:	f1bc 0f02 	cmp.w	ip, #2
 801783a:	d01e      	beq.n	801787a <strcmp+0x15a>
 801783c:	da3b      	bge.n	80178b6 <strcmp+0x196>
 801783e:	f851 5b04 	ldr.w	r5, [r1], #4
 8017842:	bf00      	nop
 8017844:	f850 3b04 	ldr.w	r3, [r0], #4
 8017848:	ea4f 2515 	mov.w	r5, r5, lsr #8
 801784c:	fa83 fc46 	uadd8	ip, r3, r6
 8017850:	faa7 fc86 	sel	ip, r7, r6
 8017854:	ebb7 2f0c 	cmp.w	r7, ip, lsl #8
 8017858:	ea03 2216 	and.w	r2, r3, r6, lsr #8
 801785c:	bf08      	it	eq
 801785e:	42aa      	cmpeq	r2, r5
 8017860:	d14d      	bne.n	80178fe <strcmp+0x1de>
 8017862:	f851 5b04 	ldr.w	r5, [r1], #4
 8017866:	f1bc 0f00 	cmp.w	ip, #0
 801786a:	ea82 0303 	eor.w	r3, r2, r3
 801786e:	ea4f 6205 	mov.w	r2, r5, lsl #24
 8017872:	bf08      	it	eq
 8017874:	4293      	cmpeq	r3, r2
 8017876:	d13c      	bne.n	80178f2 <strcmp+0x1d2>
 8017878:	e7e4      	b.n	8017844 <strcmp+0x124>
 801787a:	f851 5b04 	ldr.w	r5, [r1], #4
 801787e:	bf00      	nop
 8017880:	f850 3b04 	ldr.w	r3, [r0], #4
 8017884:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8017888:	fa83 fc46 	uadd8	ip, r3, r6
 801788c:	faa7 fc86 	sel	ip, r7, r6
 8017890:	ebb7 4f0c 	cmp.w	r7, ip, lsl #16
 8017894:	ea03 4216 	and.w	r2, r3, r6, lsr #16
 8017898:	bf08      	it	eq
 801789a:	42aa      	cmpeq	r2, r5
 801789c:	d12f      	bne.n	80178fe <strcmp+0x1de>
 801789e:	f851 5b04 	ldr.w	r5, [r1], #4
 80178a2:	f1bc 0f00 	cmp.w	ip, #0
 80178a6:	ea82 0303 	eor.w	r3, r2, r3
 80178aa:	ea4f 4205 	mov.w	r2, r5, lsl #16
 80178ae:	bf08      	it	eq
 80178b0:	4293      	cmpeq	r3, r2
 80178b2:	d11e      	bne.n	80178f2 <strcmp+0x1d2>
 80178b4:	e7e4      	b.n	8017880 <strcmp+0x160>
 80178b6:	f851 5b04 	ldr.w	r5, [r1], #4
 80178ba:	bf00      	nop
 80178bc:	f850 3b04 	ldr.w	r3, [r0], #4
 80178c0:	ea4f 6515 	mov.w	r5, r5, lsr #24
 80178c4:	fa83 fc46 	uadd8	ip, r3, r6
 80178c8:	faa7 fc86 	sel	ip, r7, r6
 80178cc:	ebb7 6f0c 	cmp.w	r7, ip, lsl #24
 80178d0:	ea03 6216 	and.w	r2, r3, r6, lsr #24
 80178d4:	bf08      	it	eq
 80178d6:	42aa      	cmpeq	r2, r5
 80178d8:	d111      	bne.n	80178fe <strcmp+0x1de>
 80178da:	f851 5b04 	ldr.w	r5, [r1], #4
 80178de:	f1bc 0f00 	cmp.w	ip, #0
 80178e2:	ea82 0303 	eor.w	r3, r2, r3
 80178e6:	ea4f 2205 	mov.w	r2, r5, lsl #8
 80178ea:	bf08      	it	eq
 80178ec:	4293      	cmpeq	r3, r2
 80178ee:	d100      	bne.n	80178f2 <strcmp+0x1d2>
 80178f0:	e7e4      	b.n	80178bc <strcmp+0x19c>
 80178f2:	ba19      	rev	r1, r3
 80178f4:	ba12      	rev	r2, r2
 80178f6:	e00a      	b.n	801790e <strcmp+0x1ee>
 80178f8:	ba19      	rev	r1, r3
 80178fa:	ba22      	rev	r2, r4
 80178fc:	e007      	b.n	801790e <strcmp+0x1ee>
 80178fe:	ba11      	rev	r1, r2
 8017900:	ba2a      	rev	r2, r5
 8017902:	e004      	b.n	801790e <strcmp+0x1ee>
 8017904:	ba19      	rev	r1, r3
 8017906:	ba2a      	rev	r2, r5
 8017908:	e001      	b.n	801790e <strcmp+0x1ee>
 801790a:	ba11      	rev	r1, r2
 801790c:	ba22      	rev	r2, r4
 801790e:	fa9c f08c 	rev.w	r0, ip
 8017912:	e9dd 6700 	ldrd	r6, r7, [sp]
 8017916:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 801791a:	f11d 0d10 	adds.w	sp, sp, #16
 801791e:	b138      	cbz	r0, 8017930 <strcmp+0x210>
 8017920:	fab0 f080 	clz	r0, r0
 8017924:	f1c0 0018 	rsb	r0, r0, #24
 8017928:	fa21 f100 	lsr.w	r1, r1, r0
 801792c:	fa22 f200 	lsr.w	r2, r2, r0
 8017930:	2001      	movs	r0, #1
 8017932:	4291      	cmp	r1, r2
 8017934:	bf98      	it	ls
 8017936:	4180      	sbcls	r0, r0
 8017938:	4770      	bx	lr
 801793a:	bf00      	nop
 801793c:	0000      	movs	r0, r0
	...

08017940 <__aeabi_uldivmod>:
 8017940:	b94b      	cbnz	r3, 8017956 <__aeabi_uldivmod+0x16>
 8017942:	b942      	cbnz	r2, 8017956 <__aeabi_uldivmod+0x16>
 8017944:	2900      	cmp	r1, #0
 8017946:	bf08      	it	eq
 8017948:	2800      	cmpeq	r0, #0
 801794a:	d002      	beq.n	8017952 <__aeabi_uldivmod+0x12>
 801794c:	f04f 31ff 	mov.w	r1, #4294967295
 8017950:	4608      	mov	r0, r1
 8017952:	f7ff bba5 	b.w	80170a0 <__aeabi_idiv0>
 8017956:	b082      	sub	sp, #8
 8017958:	46ec      	mov	ip, sp
 801795a:	e92d 5000 	stmdb	sp!, {ip, lr}
 801795e:	f7ff fb87 	bl	8017070 <__gnu_uldivmod_helper>
 8017962:	f8dd e004 	ldr.w	lr, [sp, #4]
 8017966:	b002      	add	sp, #8
 8017968:	bc0c      	pop	{r2, r3}
 801796a:	4770      	bx	lr
 801796c:	0000      	movs	r0, r0
	...

08017970 <atoi>:
 8017970:	2100      	movs	r1, #0
 8017972:	220a      	movs	r2, #10
 8017974:	f001 b81c 	b.w	80189b0 <strtol>
	...

08017980 <_atoi_r>:
 8017980:	2200      	movs	r2, #0
 8017982:	230a      	movs	r3, #10
 8017984:	f000 bf84 	b.w	8018890 <_strtol_r>
	...

08017990 <memset>:
 8017990:	b4f0      	push	{r4, r5, r6, r7}
 8017992:	0784      	lsls	r4, r0, #30
 8017994:	d043      	beq.n	8017a1e <memset+0x8e>
 8017996:	1e54      	subs	r4, r2, #1
 8017998:	2a00      	cmp	r2, #0
 801799a:	d03e      	beq.n	8017a1a <memset+0x8a>
 801799c:	b2cd      	uxtb	r5, r1
 801799e:	4603      	mov	r3, r0
 80179a0:	e003      	b.n	80179aa <memset+0x1a>
 80179a2:	1e62      	subs	r2, r4, #1
 80179a4:	2c00      	cmp	r4, #0
 80179a6:	d038      	beq.n	8017a1a <memset+0x8a>
 80179a8:	4614      	mov	r4, r2
 80179aa:	f803 5b01 	strb.w	r5, [r3], #1
 80179ae:	079a      	lsls	r2, r3, #30
 80179b0:	d1f7      	bne.n	80179a2 <memset+0x12>
 80179b2:	2c03      	cmp	r4, #3
 80179b4:	d92a      	bls.n	8017a0c <memset+0x7c>
 80179b6:	b2cd      	uxtb	r5, r1
 80179b8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80179bc:	2c0f      	cmp	r4, #15
 80179be:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80179c2:	d915      	bls.n	80179f0 <memset+0x60>
 80179c4:	f1a4 0710 	sub.w	r7, r4, #16
 80179c8:	093f      	lsrs	r7, r7, #4
 80179ca:	f103 0610 	add.w	r6, r3, #16
 80179ce:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 80179d2:	461a      	mov	r2, r3
 80179d4:	6015      	str	r5, [r2, #0]
 80179d6:	6055      	str	r5, [r2, #4]
 80179d8:	6095      	str	r5, [r2, #8]
 80179da:	60d5      	str	r5, [r2, #12]
 80179dc:	3210      	adds	r2, #16
 80179de:	42b2      	cmp	r2, r6
 80179e0:	d1f8      	bne.n	80179d4 <memset+0x44>
 80179e2:	f004 040f 	and.w	r4, r4, #15
 80179e6:	3701      	adds	r7, #1
 80179e8:	2c03      	cmp	r4, #3
 80179ea:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 80179ee:	d90d      	bls.n	8017a0c <memset+0x7c>
 80179f0:	461e      	mov	r6, r3
 80179f2:	4622      	mov	r2, r4
 80179f4:	3a04      	subs	r2, #4
 80179f6:	2a03      	cmp	r2, #3
 80179f8:	f846 5b04 	str.w	r5, [r6], #4
 80179fc:	d8fa      	bhi.n	80179f4 <memset+0x64>
 80179fe:	1f22      	subs	r2, r4, #4
 8017a00:	f022 0203 	bic.w	r2, r2, #3
 8017a04:	3204      	adds	r2, #4
 8017a06:	4413      	add	r3, r2
 8017a08:	f004 0403 	and.w	r4, r4, #3
 8017a0c:	b12c      	cbz	r4, 8017a1a <memset+0x8a>
 8017a0e:	b2c9      	uxtb	r1, r1
 8017a10:	441c      	add	r4, r3
 8017a12:	f803 1b01 	strb.w	r1, [r3], #1
 8017a16:	42a3      	cmp	r3, r4
 8017a18:	d1fb      	bne.n	8017a12 <memset+0x82>
 8017a1a:	bcf0      	pop	{r4, r5, r6, r7}
 8017a1c:	4770      	bx	lr
 8017a1e:	4614      	mov	r4, r2
 8017a20:	4603      	mov	r3, r0
 8017a22:	e7c6      	b.n	80179b2 <memset+0x22>
	...

08017a30 <strcat>:
 8017a30:	0783      	lsls	r3, r0, #30
 8017a32:	b570      	push	{r4, r5, r6, lr}
 8017a34:	4606      	mov	r6, r0
 8017a36:	d11f      	bne.n	8017a78 <strcat+0x48>
 8017a38:	6803      	ldr	r3, [r0, #0]
 8017a3a:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8017a3e:	ea22 0303 	bic.w	r3, r2, r3
 8017a42:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8017a46:	bf08      	it	eq
 8017a48:	1d03      	addeq	r3, r0, #4
 8017a4a:	d115      	bne.n	8017a78 <strcat+0x48>
 8017a4c:	4618      	mov	r0, r3
 8017a4e:	f853 4b04 	ldr.w	r4, [r3], #4
 8017a52:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8017a56:	ea25 0404 	bic.w	r4, r5, r4
 8017a5a:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8017a5e:	d0f5      	beq.n	8017a4c <strcat+0x1c>
 8017a60:	7803      	ldrb	r3, [r0, #0]
 8017a62:	b12b      	cbz	r3, 8017a70 <strcat+0x40>
 8017a64:	1c43      	adds	r3, r0, #1
 8017a66:	4618      	mov	r0, r3
 8017a68:	3301      	adds	r3, #1
 8017a6a:	7804      	ldrb	r4, [r0, #0]
 8017a6c:	2c00      	cmp	r4, #0
 8017a6e:	d1fa      	bne.n	8017a66 <strcat+0x36>
 8017a70:	f000 f806 	bl	8017a80 <strcpy>
 8017a74:	4630      	mov	r0, r6
 8017a76:	bd70      	pop	{r4, r5, r6, pc}
 8017a78:	4630      	mov	r0, r6
 8017a7a:	e7f1      	b.n	8017a60 <strcat+0x30>
 8017a7c:	0000      	movs	r0, r0
	...

08017a80 <strcpy>:
 8017a80:	ea80 0201 	eor.w	r2, r0, r1
 8017a84:	4684      	mov	ip, r0
 8017a86:	f012 0f03 	tst.w	r2, #3
 8017a8a:	d14f      	bne.n	8017b2c <strcpy+0xac>
 8017a8c:	f011 0f03 	tst.w	r1, #3
 8017a90:	d132      	bne.n	8017af8 <strcpy+0x78>
 8017a92:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8017a96:	f011 0f04 	tst.w	r1, #4
 8017a9a:	f851 3b04 	ldr.w	r3, [r1], #4
 8017a9e:	d00b      	beq.n	8017ab8 <strcpy+0x38>
 8017aa0:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8017aa4:	439a      	bics	r2, r3
 8017aa6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8017aaa:	bf04      	itt	eq
 8017aac:	f84c 3b04 	streq.w	r3, [ip], #4
 8017ab0:	f851 3b04 	ldreq.w	r3, [r1], #4
 8017ab4:	d116      	bne.n	8017ae4 <strcpy+0x64>
 8017ab6:	bf00      	nop
 8017ab8:	f851 4b04 	ldr.w	r4, [r1], #4
 8017abc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8017ac0:	439a      	bics	r2, r3
 8017ac2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8017ac6:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 8017aca:	d10b      	bne.n	8017ae4 <strcpy+0x64>
 8017acc:	f84c 3b04 	str.w	r3, [ip], #4
 8017ad0:	43a2      	bics	r2, r4
 8017ad2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8017ad6:	bf04      	itt	eq
 8017ad8:	f851 3b04 	ldreq.w	r3, [r1], #4
 8017adc:	f84c 4b04 	streq.w	r4, [ip], #4
 8017ae0:	d0ea      	beq.n	8017ab8 <strcpy+0x38>
 8017ae2:	4623      	mov	r3, r4
 8017ae4:	f80c 3b01 	strb.w	r3, [ip], #1
 8017ae8:	f013 0fff 	tst.w	r3, #255	; 0xff
 8017aec:	ea4f 2333 	mov.w	r3, r3, ror #8
 8017af0:	d1f8      	bne.n	8017ae4 <strcpy+0x64>
 8017af2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8017af6:	4770      	bx	lr
 8017af8:	f011 0f01 	tst.w	r1, #1
 8017afc:	d006      	beq.n	8017b0c <strcpy+0x8c>
 8017afe:	f811 2b01 	ldrb.w	r2, [r1], #1
 8017b02:	f80c 2b01 	strb.w	r2, [ip], #1
 8017b06:	2a00      	cmp	r2, #0
 8017b08:	bf08      	it	eq
 8017b0a:	4770      	bxeq	lr
 8017b0c:	f011 0f02 	tst.w	r1, #2
 8017b10:	d0bf      	beq.n	8017a92 <strcpy+0x12>
 8017b12:	f831 2b02 	ldrh.w	r2, [r1], #2
 8017b16:	f012 0fff 	tst.w	r2, #255	; 0xff
 8017b1a:	bf16      	itet	ne
 8017b1c:	f82c 2b02 	strhne.w	r2, [ip], #2
 8017b20:	f88c 2000 	strbeq.w	r2, [ip]
 8017b24:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 8017b28:	d1b3      	bne.n	8017a92 <strcpy+0x12>
 8017b2a:	4770      	bx	lr
 8017b2c:	f811 2b01 	ldrb.w	r2, [r1], #1
 8017b30:	f80c 2b01 	strb.w	r2, [ip], #1
 8017b34:	2a00      	cmp	r2, #0
 8017b36:	d1f9      	bne.n	8017b2c <strcpy+0xac>
 8017b38:	4770      	bx	lr
 8017b3a:	bf00      	nop
 8017b3c:	0000      	movs	r0, r0
	...

08017b40 <iso_year_adjust>:
 8017b40:	6943      	ldr	r3, [r0, #20]
 8017b42:	2b00      	cmp	r3, #0
 8017b44:	b410      	push	{r4}
 8017b46:	db0c      	blt.n	8017b62 <iso_year_adjust+0x22>
 8017b48:	f1a3 0264 	sub.w	r2, r3, #100	; 0x64
 8017b4c:	0794      	lsls	r4, r2, #30
 8017b4e:	d105      	bne.n	8017b5c <iso_year_adjust+0x1c>
 8017b50:	2164      	movs	r1, #100	; 0x64
 8017b52:	fb92 f4f1 	sdiv	r4, r2, r1
 8017b56:	fb01 2214 	mls	r2, r1, r4, r2
 8017b5a:	b96a      	cbnz	r2, 8017b78 <iso_year_adjust+0x38>
 8017b5c:	f06f 0263 	mvn.w	r2, #99	; 0x63
 8017b60:	e04f      	b.n	8017c02 <iso_year_adjust+0xc2>
 8017b62:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 8017b66:	0791      	lsls	r1, r2, #30
 8017b68:	d149      	bne.n	8017bfe <iso_year_adjust+0xbe>
 8017b6a:	2164      	movs	r1, #100	; 0x64
 8017b6c:	fb92 f4f1 	sdiv	r4, r2, r1
 8017b70:	fb01 2214 	mls	r2, r1, r4, r2
 8017b74:	2a00      	cmp	r2, #0
 8017b76:	d042      	beq.n	8017bfe <iso_year_adjust+0xbe>
 8017b78:	2201      	movs	r2, #1
 8017b7a:	6981      	ldr	r1, [r0, #24]
 8017b7c:	69c0      	ldr	r0, [r0, #28]
 8017b7e:	0049      	lsls	r1, r1, #1
 8017b80:	eb01 1300 	add.w	r3, r1, r0, lsl #4
 8017b84:	4413      	add	r3, r2
 8017b86:	2b21      	cmp	r3, #33	; 0x21
 8017b88:	dc0b      	bgt.n	8017ba2 <iso_year_adjust+0x62>
 8017b8a:	2b20      	cmp	r3, #32
 8017b8c:	da1f      	bge.n	8017bce <iso_year_adjust+0x8e>
 8017b8e:	2b0d      	cmp	r3, #13
 8017b90:	dc2f      	bgt.n	8017bf2 <iso_year_adjust+0xb2>
 8017b92:	2b0a      	cmp	r3, #10
 8017b94:	da1b      	bge.n	8017bce <iso_year_adjust+0x8e>
 8017b96:	2b01      	cmp	r3, #1
 8017b98:	d919      	bls.n	8017bce <iso_year_adjust+0x8e>
 8017b9a:	2000      	movs	r0, #0
 8017b9c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8017ba0:	4770      	bx	lr
 8017ba2:	f241 62c6 	movw	r2, #5830	; 0x16c6
 8017ba6:	4293      	cmp	r3, r2
 8017ba8:	dc16      	bgt.n	8017bd8 <iso_year_adjust+0x98>
 8017baa:	f241 62c2 	movw	r2, #5826	; 0x16c2
 8017bae:	4293      	cmp	r3, r2
 8017bb0:	da09      	bge.n	8017bc6 <iso_year_adjust+0x86>
 8017bb2:	f241 62a2 	movw	r2, #5794	; 0x16a2
 8017bb6:	4293      	cmp	r3, r2
 8017bb8:	d005      	beq.n	8017bc6 <iso_year_adjust+0x86>
 8017bba:	dbee      	blt.n	8017b9a <iso_year_adjust+0x5a>
 8017bbc:	f5a3 53b5 	sub.w	r3, r3, #5792	; 0x16a0
 8017bc0:	3b12      	subs	r3, #18
 8017bc2:	2b02      	cmp	r3, #2
 8017bc4:	d8e9      	bhi.n	8017b9a <iso_year_adjust+0x5a>
 8017bc6:	2001      	movs	r0, #1
 8017bc8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8017bcc:	4770      	bx	lr
 8017bce:	f04f 30ff 	mov.w	r0, #4294967295
 8017bd2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8017bd6:	4770      	bx	lr
 8017bd8:	f241 62d5 	movw	r2, #5845	; 0x16d5
 8017bdc:	4293      	cmp	r3, r2
 8017bde:	d0f2      	beq.n	8017bc6 <iso_year_adjust+0x86>
 8017be0:	f241 62d7 	movw	r2, #5847	; 0x16d7
 8017be4:	4293      	cmp	r3, r2
 8017be6:	d0ee      	beq.n	8017bc6 <iso_year_adjust+0x86>
 8017be8:	f241 62d3 	movw	r2, #5843	; 0x16d3
 8017bec:	4293      	cmp	r3, r2
 8017bee:	d1d4      	bne.n	8017b9a <iso_year_adjust+0x5a>
 8017bf0:	e7e9      	b.n	8017bc6 <iso_year_adjust+0x86>
 8017bf2:	2b10      	cmp	r3, #16
 8017bf4:	dbd1      	blt.n	8017b9a <iso_year_adjust+0x5a>
 8017bf6:	2b11      	cmp	r3, #17
 8017bf8:	dde9      	ble.n	8017bce <iso_year_adjust+0x8e>
 8017bfa:	3b1c      	subs	r3, #28
 8017bfc:	e7cb      	b.n	8017b96 <iso_year_adjust+0x56>
 8017bfe:	f240 726c 	movw	r2, #1900	; 0x76c
 8017c02:	4908      	ldr	r1, [pc, #32]	; (8017c24 <iso_year_adjust+0xe4>)
 8017c04:	441a      	add	r2, r3
 8017c06:	fb81 4302 	smull	r4, r3, r1, r2
 8017c0a:	17d1      	asrs	r1, r2, #31
 8017c0c:	ebc1 13e3 	rsb	r3, r1, r3, asr #7
 8017c10:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8017c14:	fb01 2213 	mls	r2, r1, r3, r2
 8017c18:	f1d2 0201 	rsbs	r2, r2, #1
 8017c1c:	bf38      	it	cc
 8017c1e:	2200      	movcc	r2, #0
 8017c20:	e7ab      	b.n	8017b7a <iso_year_adjust+0x3a>
 8017c22:	bf00      	nop
 8017c24:	51eb851f 	.word	0x51eb851f
	...

08017c30 <strftime>:
 8017c30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017c34:	b08f      	sub	sp, #60	; 0x3c
 8017c36:	4606      	mov	r6, r0
 8017c38:	460d      	mov	r5, r1
 8017c3a:	4614      	mov	r4, r2
 8017c3c:	461f      	mov	r7, r3
 8017c3e:	f000 ff67 	bl	8018b10 <__get_current_time_locale>
 8017c42:	f04f 0900 	mov.w	r9, #0
 8017c46:	9005      	str	r0, [sp, #20]
 8017c48:	7823      	ldrb	r3, [r4, #0]
 8017c4a:	b16b      	cbz	r3, 8017c68 <strftime+0x38>
 8017c4c:	2b25      	cmp	r3, #37	; 0x25
 8017c4e:	d015      	beq.n	8017c7c <strftime+0x4c>
 8017c50:	1e6a      	subs	r2, r5, #1
 8017c52:	4591      	cmp	r9, r2
 8017c54:	f080 80a8 	bcs.w	8017da8 <strftime+0x178>
 8017c58:	f806 3009 	strb.w	r3, [r6, r9]
 8017c5c:	3401      	adds	r4, #1
 8017c5e:	7823      	ldrb	r3, [r4, #0]
 8017c60:	f109 0901 	add.w	r9, r9, #1
 8017c64:	2b00      	cmp	r3, #0
 8017c66:	d1f1      	bne.n	8017c4c <strftime+0x1c>
 8017c68:	2d00      	cmp	r5, #0
 8017c6a:	f000 8404 	beq.w	8018476 <strftime+0x846>
 8017c6e:	2300      	movs	r3, #0
 8017c70:	4648      	mov	r0, r9
 8017c72:	f806 3009 	strb.w	r3, [r6, r9]
 8017c76:	b00f      	add	sp, #60	; 0x3c
 8017c78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017c7c:	f894 8001 	ldrb.w	r8, [r4, #1]
 8017c80:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 8017c84:	f000 8094 	beq.w	8017db0 <strftime+0x180>
 8017c88:	f1b8 0f2b 	cmp.w	r8, #43	; 0x2b
 8017c8c:	f000 8090 	beq.w	8017db0 <strftime+0x180>
 8017c90:	4641      	mov	r1, r8
 8017c92:	f1a1 0331 	sub.w	r3, r1, #49	; 0x31
 8017c96:	2b08      	cmp	r3, #8
 8017c98:	f104 0401 	add.w	r4, r4, #1
 8017c9c:	f04f 0800 	mov.w	r8, #0
 8017ca0:	f240 808e 	bls.w	8017dc0 <strftime+0x190>
 8017ca4:	2945      	cmp	r1, #69	; 0x45
 8017ca6:	f04f 0a00 	mov.w	sl, #0
 8017caa:	f000 8094 	beq.w	8017dd6 <strftime+0x1a6>
 8017cae:	294f      	cmp	r1, #79	; 0x4f
 8017cb0:	f000 8091 	beq.w	8017dd6 <strftime+0x1a6>
 8017cb4:	f1a1 0225 	sub.w	r2, r1, #37	; 0x25
 8017cb8:	2a55      	cmp	r2, #85	; 0x55
 8017cba:	d875      	bhi.n	8017da8 <strftime+0x178>
 8017cbc:	e8df f012 	tbh	[pc, r2, lsl #1]
 8017cc0:	007400ad 	.word	0x007400ad
 8017cc4:	00740074 	.word	0x00740074
 8017cc8:	00740074 	.word	0x00740074
 8017ccc:	00740074 	.word	0x00740074
 8017cd0:	00740074 	.word	0x00740074
 8017cd4:	00740074 	.word	0x00740074
 8017cd8:	00740074 	.word	0x00740074
 8017cdc:	00740074 	.word	0x00740074
 8017ce0:	00740074 	.word	0x00740074
 8017ce4:	00740074 	.word	0x00740074
 8017ce8:	00740074 	.word	0x00740074
 8017cec:	00740074 	.word	0x00740074
 8017cf0:	00740074 	.word	0x00740074
 8017cf4:	00740074 	.word	0x00740074
 8017cf8:	00d900b6 	.word	0x00d900b6
 8017cfc:	038003bc 	.word	0x038003bc
 8017d00:	00560074 	.word	0x00560074
 8017d04:	03560319 	.word	0x03560319
 8017d08:	0074035d 	.word	0x0074035d
 8017d0c:	00740074 	.word	0x00740074
 8017d10:	00740374 	.word	0x00740374
 8017d14:	027a0074 	.word	0x027a0074
 8017d18:	02bb0074 	.word	0x02bb0074
 8017d1c:	02d502c9 	.word	0x02d502c9
 8017d20:	02f102e4 	.word	0x02f102e4
 8017d24:	031102ff 	.word	0x031102ff
 8017d28:	011000fa 	.word	0x011000fa
 8017d2c:	00740074 	.word	0x00740074
 8017d30:	00740074 	.word	0x00740074
 8017d34:	00740074 	.word	0x00740074
 8017d38:	01690145 	.word	0x01690145
 8017d3c:	01a5018c 	.word	0x01a5018c
 8017d40:	007401a5 	.word	0x007401a5
 8017d44:	016901b5 	.word	0x016901b5
 8017d48:	01e70074 	.word	0x01e70074
 8017d4c:	035d0356 	.word	0x035d0356
 8017d50:	023f023b 	.word	0x023f023b
 8017d54:	027a0074 	.word	0x027a0074
 8017d58:	02490074 	.word	0x02490074
 8017d5c:	02510074 	.word	0x02510074
 8017d60:	0074025b 	.word	0x0074025b
 8017d64:	02720267 	.word	0x02720267
 8017d68:	01fa008e 	.word	0x01fa008e
 8017d6c:	2325      	movs	r3, #37	; 0x25
 8017d6e:	f88d 3018 	strb.w	r3, [sp, #24]
 8017d72:	f1b8 0f00 	cmp.w	r8, #0
 8017d76:	f000 83aa 	beq.w	80184ce <strftime+0x89e>
 8017d7a:	f1ba 0f05 	cmp.w	sl, #5
 8017d7e:	f88d 8019 	strb.w	r8, [sp, #25]
 8017d82:	f200 849c 	bhi.w	80186be <strftime+0xa8e>
 8017d86:	f10d 081a 	add.w	r8, sp, #26
 8017d8a:	4640      	mov	r0, r8
 8017d8c:	49c2      	ldr	r1, [pc, #776]	; (8018098 <strftime+0x468>)
 8017d8e:	f7ff fe77 	bl	8017a80 <strcpy>
 8017d92:	eb06 0009 	add.w	r0, r6, r9
 8017d96:	ebc9 0105 	rsb	r1, r9, r5
 8017d9a:	aa06      	add	r2, sp, #24
 8017d9c:	463b      	mov	r3, r7
 8017d9e:	f7ff ff47 	bl	8017c30 <strftime>
 8017da2:	2800      	cmp	r0, #0
 8017da4:	f300 812f 	bgt.w	8018006 <strftime+0x3d6>
 8017da8:	2000      	movs	r0, #0
 8017daa:	b00f      	add	sp, #60	; 0x3c
 8017dac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017db0:	78a1      	ldrb	r1, [r4, #2]
 8017db2:	f1a1 0331 	sub.w	r3, r1, #49	; 0x31
 8017db6:	2b08      	cmp	r3, #8
 8017db8:	f104 0402 	add.w	r4, r4, #2
 8017dbc:	f63f af72 	bhi.w	8017ca4 <strftime+0x74>
 8017dc0:	4620      	mov	r0, r4
 8017dc2:	a906      	add	r1, sp, #24
 8017dc4:	220a      	movs	r2, #10
 8017dc6:	f000 fe93 	bl	8018af0 <strtoul>
 8017dca:	9c06      	ldr	r4, [sp, #24]
 8017dcc:	7821      	ldrb	r1, [r4, #0]
 8017dce:	2945      	cmp	r1, #69	; 0x45
 8017dd0:	4682      	mov	sl, r0
 8017dd2:	f47f af6c 	bne.w	8017cae <strftime+0x7e>
 8017dd6:	7861      	ldrb	r1, [r4, #1]
 8017dd8:	3401      	adds	r4, #1
 8017dda:	e76b      	b.n	8017cb4 <strftime+0x84>
 8017ddc:	6978      	ldr	r0, [r7, #20]
 8017dde:	2800      	cmp	r0, #0
 8017de0:	f2c0 83e5 	blt.w	80185ae <strftime+0x97e>
 8017de4:	49ad      	ldr	r1, [pc, #692]	; (801809c <strftime+0x46c>)
 8017de6:	17c3      	asrs	r3, r0, #31
 8017de8:	fb81 1200 	smull	r1, r2, r1, r0
 8017dec:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 8017df0:	2264      	movs	r2, #100	; 0x64
 8017df2:	fb02 0313 	mls	r3, r2, r3, r0
 8017df6:	eb06 0009 	add.w	r0, r6, r9
 8017dfa:	ebc9 0105 	rsb	r1, r9, r5
 8017dfe:	4aa8      	ldr	r2, [pc, #672]	; (80180a0 <strftime+0x470>)
 8017e00:	f001 fcfe 	bl	8019800 <sniprintf>
 8017e04:	2800      	cmp	r0, #0
 8017e06:	dbcf      	blt.n	8017da8 <strftime+0x178>
 8017e08:	4481      	add	r9, r0
 8017e0a:	454d      	cmp	r5, r9
 8017e0c:	d9cc      	bls.n	8017da8 <strftime+0x178>
 8017e0e:	7823      	ldrb	r3, [r4, #0]
 8017e10:	2b00      	cmp	r3, #0
 8017e12:	f43f af29 	beq.w	8017c68 <strftime+0x38>
 8017e16:	3401      	adds	r4, #1
 8017e18:	e716      	b.n	8017c48 <strftime+0x18>
 8017e1a:	1e6b      	subs	r3, r5, #1
 8017e1c:	4599      	cmp	r9, r3
 8017e1e:	d2c3      	bcs.n	8017da8 <strftime+0x178>
 8017e20:	2325      	movs	r3, #37	; 0x25
 8017e22:	f806 3009 	strb.w	r3, [r6, r9]
 8017e26:	f109 0901 	add.w	r9, r9, #1
 8017e2a:	e7f0      	b.n	8017e0e <strftime+0x1de>
 8017e2c:	69bb      	ldr	r3, [r7, #24]
 8017e2e:	f8dd b014 	ldr.w	fp, [sp, #20]
 8017e32:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 8017e36:	f8d3 807c 	ldr.w	r8, [r3, #124]	; 0x7c
 8017e3a:	4640      	mov	r0, r8
 8017e3c:	f000 fc68 	bl	8018710 <strlen>
 8017e40:	2800      	cmp	r0, #0
 8017e42:	d0e4      	beq.n	8017e0e <strftime+0x1de>
 8017e44:	f105 3aff 	add.w	sl, r5, #4294967295
 8017e48:	45d1      	cmp	r9, sl
 8017e4a:	d2ad      	bcs.n	8017da8 <strftime+0x178>
 8017e4c:	464a      	mov	r2, r9
 8017e4e:	f04f 0c00 	mov.w	ip, #0
 8017e52:	4481      	add	r9, r0
 8017e54:	18b3      	adds	r3, r6, r2
 8017e56:	4661      	mov	r1, ip
 8017e58:	e001      	b.n	8017e5e <strftime+0x22e>
 8017e5a:	4592      	cmp	sl, r2
 8017e5c:	d9a4      	bls.n	8017da8 <strftime+0x178>
 8017e5e:	f818 000c 	ldrb.w	r0, [r8, ip]
 8017e62:	5458      	strb	r0, [r3, r1]
 8017e64:	3201      	adds	r2, #1
 8017e66:	3101      	adds	r1, #1
 8017e68:	454a      	cmp	r2, r9
 8017e6a:	468c      	mov	ip, r1
 8017e6c:	d1f5      	bne.n	8017e5a <strftime+0x22a>
 8017e6e:	4691      	mov	r9, r2
 8017e70:	e7cd      	b.n	8017e0e <strftime+0x1de>
 8017e72:	693b      	ldr	r3, [r7, #16]
 8017e74:	f8dd b014 	ldr.w	fp, [sp, #20]
 8017e78:	330c      	adds	r3, #12
 8017e7a:	f85b 8023 	ldr.w	r8, [fp, r3, lsl #2]
 8017e7e:	4640      	mov	r0, r8
 8017e80:	f000 fc46 	bl	8018710 <strlen>
 8017e84:	2800      	cmp	r0, #0
 8017e86:	d0c2      	beq.n	8017e0e <strftime+0x1de>
 8017e88:	f105 3aff 	add.w	sl, r5, #4294967295
 8017e8c:	45d1      	cmp	r9, sl
 8017e8e:	d28b      	bcs.n	8017da8 <strftime+0x178>
 8017e90:	464a      	mov	r2, r9
 8017e92:	f04f 0c00 	mov.w	ip, #0
 8017e96:	4481      	add	r9, r0
 8017e98:	18b3      	adds	r3, r6, r2
 8017e9a:	4661      	mov	r1, ip
 8017e9c:	e001      	b.n	8017ea2 <strftime+0x272>
 8017e9e:	4552      	cmp	r2, sl
 8017ea0:	d282      	bcs.n	8017da8 <strftime+0x178>
 8017ea2:	f818 000c 	ldrb.w	r0, [r8, ip]
 8017ea6:	5458      	strb	r0, [r3, r1]
 8017ea8:	3201      	adds	r2, #1
 8017eaa:	3101      	adds	r1, #1
 8017eac:	454a      	cmp	r2, r9
 8017eae:	468c      	mov	ip, r1
 8017eb0:	d1f5      	bne.n	8017e9e <strftime+0x26e>
 8017eb2:	e7dc      	b.n	8017e6e <strftime+0x23e>
 8017eb4:	697a      	ldr	r2, [r7, #20]
 8017eb6:	497b      	ldr	r1, [pc, #492]	; (80180a4 <strftime+0x474>)
 8017eb8:	428a      	cmp	r2, r1
 8017eba:	f202 736c 	addw	r3, r2, #1900	; 0x76c
 8017ebe:	f280 82de 	bge.w	801847e <strftime+0x84e>
 8017ec2:	222d      	movs	r2, #45	; 0x2d
 8017ec4:	425b      	negs	r3, r3
 8017ec6:	f88d 2018 	strb.w	r2, [sp, #24]
 8017eca:	f1ba 0f00 	cmp.w	sl, #0
 8017ece:	f000 83fe 	beq.w	80186ce <strftime+0xa9e>
 8017ed2:	f10a 3aff 	add.w	sl, sl, #4294967295
 8017ed6:	f10d 0019 	add.w	r0, sp, #25
 8017eda:	f10d 0b18 	add.w	fp, sp, #24
 8017ede:	e2d4      	b.n	801848a <strftime+0x85a>
 8017ee0:	6a3b      	ldr	r3, [r7, #32]
 8017ee2:	2b00      	cmp	r3, #0
 8017ee4:	db97      	blt.n	8017e16 <strftime+0x1e6>
 8017ee6:	f000 fe3b 	bl	8018b60 <__tz_lock>
 8017eea:	6a3b      	ldr	r3, [r7, #32]
 8017eec:	f8df a1c0 	ldr.w	sl, [pc, #448]	; 80180b0 <strftime+0x480>
 8017ef0:	2b00      	cmp	r3, #0
 8017ef2:	bfd4      	ite	le
 8017ef4:	2300      	movle	r3, #0
 8017ef6:	2301      	movgt	r3, #1
 8017ef8:	f85a 0023 	ldr.w	r0, [sl, r3, lsl #2]
 8017efc:	f000 fc08 	bl	8018710 <strlen>
 8017f00:	2800      	cmp	r0, #0
 8017f02:	bfd8      	it	le
 8017f04:	46c8      	movle	r8, r9
 8017f06:	dd1c      	ble.n	8017f42 <strftime+0x312>
 8017f08:	f105 3eff 	add.w	lr, r5, #4294967295
 8017f0c:	45f1      	cmp	r9, lr
 8017f0e:	f080 8336 	bcs.w	801857e <strftime+0x94e>
 8017f12:	46c8      	mov	r8, r9
 8017f14:	eb06 0308 	add.w	r3, r6, r8
 8017f18:	4481      	add	r9, r0
 8017f1a:	2200      	movs	r2, #0
 8017f1c:	e002      	b.n	8017f24 <strftime+0x2f4>
 8017f1e:	45f0      	cmp	r8, lr
 8017f20:	f080 832d 	bcs.w	801857e <strftime+0x94e>
 8017f24:	6a39      	ldr	r1, [r7, #32]
 8017f26:	2900      	cmp	r1, #0
 8017f28:	bfd4      	ite	le
 8017f2a:	2100      	movle	r1, #0
 8017f2c:	2101      	movgt	r1, #1
 8017f2e:	f108 0801 	add.w	r8, r8, #1
 8017f32:	f85a 1021 	ldr.w	r1, [sl, r1, lsl #2]
 8017f36:	45c8      	cmp	r8, r9
 8017f38:	5c89      	ldrb	r1, [r1, r2]
 8017f3a:	5499      	strb	r1, [r3, r2]
 8017f3c:	f102 0201 	add.w	r2, r2, #1
 8017f40:	d1ed      	bne.n	8017f1e <strftime+0x2ee>
 8017f42:	f000 fe15 	bl	8018b70 <__tz_unlock>
 8017f46:	46c1      	mov	r9, r8
 8017f48:	e761      	b.n	8017e0e <strftime+0x1de>
 8017f4a:	69bb      	ldr	r3, [r7, #24]
 8017f4c:	f8dd b014 	ldr.w	fp, [sp, #20]
 8017f50:	3318      	adds	r3, #24
 8017f52:	f85b 8023 	ldr.w	r8, [fp, r3, lsl #2]
 8017f56:	4640      	mov	r0, r8
 8017f58:	f000 fbda 	bl	8018710 <strlen>
 8017f5c:	2800      	cmp	r0, #0
 8017f5e:	f43f af56 	beq.w	8017e0e <strftime+0x1de>
 8017f62:	f105 3aff 	add.w	sl, r5, #4294967295
 8017f66:	45d1      	cmp	r9, sl
 8017f68:	f4bf af1e 	bcs.w	8017da8 <strftime+0x178>
 8017f6c:	464a      	mov	r2, r9
 8017f6e:	f04f 0c00 	mov.w	ip, #0
 8017f72:	4481      	add	r9, r0
 8017f74:	18b3      	adds	r3, r6, r2
 8017f76:	4661      	mov	r1, ip
 8017f78:	e002      	b.n	8017f80 <strftime+0x350>
 8017f7a:	4552      	cmp	r2, sl
 8017f7c:	f4bf af14 	bcs.w	8017da8 <strftime+0x178>
 8017f80:	f818 000c 	ldrb.w	r0, [r8, ip]
 8017f84:	5458      	strb	r0, [r3, r1]
 8017f86:	3201      	adds	r2, #1
 8017f88:	3101      	adds	r1, #1
 8017f8a:	454a      	cmp	r2, r9
 8017f8c:	468c      	mov	ip, r1
 8017f8e:	d1f4      	bne.n	8017f7a <strftime+0x34a>
 8017f90:	e76d      	b.n	8017e6e <strftime+0x23e>
 8017f92:	693b      	ldr	r3, [r7, #16]
 8017f94:	f8dd b014 	ldr.w	fp, [sp, #20]
 8017f98:	f85b 8023 	ldr.w	r8, [fp, r3, lsl #2]
 8017f9c:	4640      	mov	r0, r8
 8017f9e:	f000 fbb7 	bl	8018710 <strlen>
 8017fa2:	2800      	cmp	r0, #0
 8017fa4:	f43f af33 	beq.w	8017e0e <strftime+0x1de>
 8017fa8:	f105 3aff 	add.w	sl, r5, #4294967295
 8017fac:	45d1      	cmp	r9, sl
 8017fae:	f4bf aefb 	bcs.w	8017da8 <strftime+0x178>
 8017fb2:	464a      	mov	r2, r9
 8017fb4:	f04f 0c00 	mov.w	ip, #0
 8017fb8:	4481      	add	r9, r0
 8017fba:	18b3      	adds	r3, r6, r2
 8017fbc:	4661      	mov	r1, ip
 8017fbe:	e002      	b.n	8017fc6 <strftime+0x396>
 8017fc0:	4552      	cmp	r2, sl
 8017fc2:	f4bf aef1 	bcs.w	8017da8 <strftime+0x178>
 8017fc6:	f818 000c 	ldrb.w	r0, [r8, ip]
 8017fca:	5458      	strb	r0, [r3, r1]
 8017fcc:	3201      	adds	r2, #1
 8017fce:	3101      	adds	r1, #1
 8017fd0:	454a      	cmp	r2, r9
 8017fd2:	468c      	mov	ip, r1
 8017fd4:	d1f4      	bne.n	8017fc0 <strftime+0x390>
 8017fd6:	e74a      	b.n	8017e6e <strftime+0x23e>
 8017fd8:	f8dd b014 	ldr.w	fp, [sp, #20]
 8017fdc:	f8db 80a0 	ldr.w	r8, [fp, #160]	; 0xa0
 8017fe0:	4640      	mov	r0, r8
 8017fe2:	f000 fb95 	bl	8018710 <strlen>
 8017fe6:	f898 3000 	ldrb.w	r3, [r8]
 8017fea:	2b00      	cmp	r3, #0
 8017fec:	f43f af0f 	beq.w	8017e0e <strftime+0x1de>
 8017ff0:	4642      	mov	r2, r8
 8017ff2:	eb06 0009 	add.w	r0, r6, r9
 8017ff6:	ebc9 0105 	rsb	r1, r9, r5
 8017ffa:	463b      	mov	r3, r7
 8017ffc:	f7ff fe18 	bl	8017c30 <strftime>
 8018000:	2800      	cmp	r0, #0
 8018002:	f77f aed1 	ble.w	8017da8 <strftime+0x178>
 8018006:	4481      	add	r9, r0
 8018008:	e701      	b.n	8017e0e <strftime+0x1de>
 801800a:	4827      	ldr	r0, [pc, #156]	; (80180a8 <strftime+0x478>)
 801800c:	4a24      	ldr	r2, [pc, #144]	; (80180a0 <strftime+0x470>)
 801800e:	68fb      	ldr	r3, [r7, #12]
 8018010:	2964      	cmp	r1, #100	; 0x64
 8018012:	bf18      	it	ne
 8018014:	4602      	movne	r2, r0
 8018016:	eb06 0009 	add.w	r0, r6, r9
 801801a:	ebc9 0105 	rsb	r1, r9, r5
 801801e:	f001 fbef 	bl	8019800 <sniprintf>
 8018022:	2800      	cmp	r0, #0
 8018024:	f6bf aef0 	bge.w	8017e08 <strftime+0x1d8>
 8018028:	e6be      	b.n	8017da8 <strftime+0x178>
 801802a:	4638      	mov	r0, r7
 801802c:	f7ff fd88 	bl	8017b40 <iso_year_adjust>
 8018030:	4680      	mov	r8, r0
 8018032:	6978      	ldr	r0, [r7, #20]
 8018034:	2800      	cmp	r0, #0
 8018036:	f2c0 82c8 	blt.w	80185ca <strftime+0x99a>
 801803a:	4b18      	ldr	r3, [pc, #96]	; (801809c <strftime+0x46c>)
 801803c:	fb83 3200 	smull	r3, r2, r3, r0
 8018040:	17c3      	asrs	r3, r0, #31
 8018042:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 8018046:	2264      	movs	r2, #100	; 0x64
 8018048:	fb02 0313 	mls	r3, r2, r3, r0
 801804c:	f1b8 0f00 	cmp.w	r8, #0
 8018050:	f2c0 8283 	blt.w	801855a <strftime+0x92a>
 8018054:	d005      	beq.n	8018062 <strftime+0x432>
 8018056:	4913      	ldr	r1, [pc, #76]	; (80180a4 <strftime+0x474>)
 8018058:	697a      	ldr	r2, [r7, #20]
 801805a:	428a      	cmp	r2, r1
 801805c:	bfb8      	it	lt
 801805e:	f04f 38ff 	movlt.w	r8, #4294967295
 8018062:	480e      	ldr	r0, [pc, #56]	; (801809c <strftime+0x46c>)
 8018064:	490d      	ldr	r1, [pc, #52]	; (801809c <strftime+0x46c>)
 8018066:	4498      	add	r8, r3
 8018068:	fb80 0208 	smull	r0, r2, r0, r8
 801806c:	ea4f 73e8 	mov.w	r3, r8, asr #31
 8018070:	ebc3 1262 	rsb	r2, r3, r2, asr #5
 8018074:	2364      	movs	r3, #100	; 0x64
 8018076:	fb03 8812 	mls	r8, r3, r2, r8
 801807a:	eb08 0203 	add.w	r2, r8, r3
 801807e:	fb81 1002 	smull	r1, r0, r1, r2
 8018082:	17d1      	asrs	r1, r2, #31
 8018084:	ebc1 1160 	rsb	r1, r1, r0, asr #5
 8018088:	fb03 2311 	mls	r3, r3, r1, r2
 801808c:	e6b3      	b.n	8017df6 <strftime+0x1c6>
 801808e:	69fb      	ldr	r3, [r7, #28]
 8018090:	4a06      	ldr	r2, [pc, #24]	; (80180ac <strftime+0x47c>)
 8018092:	3301      	adds	r3, #1
 8018094:	e7bf      	b.n	8018016 <strftime+0x3e6>
 8018096:	bf00      	nop
 8018098:	0801c1f8 	.word	0x0801c1f8
 801809c:	51eb851f 	.word	0x51eb851f
 80180a0:	0801c1d8 	.word	0x0801c1d8
 80180a4:	fffff894 	.word	0xfffff894
 80180a8:	0801c1e0 	.word	0x0801c1e0
 80180ac:	0801c204 	.word	0x0801c204
 80180b0:	20000910 	.word	0x20000910
 80180b4:	6a3b      	ldr	r3, [r7, #32]
 80180b6:	2b00      	cmp	r3, #0
 80180b8:	f6ff aead 	blt.w	8017e16 <strftime+0x1e6>
 80180bc:	f000 fd68 	bl	8018b90 <__gettzinfo>
 80180c0:	4680      	mov	r8, r0
 80180c2:	f000 fd4d 	bl	8018b60 <__tz_lock>
 80180c6:	6a3b      	ldr	r3, [r7, #32]
 80180c8:	f8df a364 	ldr.w	sl, [pc, #868]	; 8018430 <strftime+0x800>
 80180cc:	2b00      	cmp	r3, #0
 80180ce:	bfcc      	ite	gt
 80180d0:	231c      	movgt	r3, #28
 80180d2:	2300      	movle	r3, #0
 80180d4:	4498      	add	r8, r3
 80180d6:	eb06 0b09 	add.w	fp, r6, r9
 80180da:	f8d8 3020 	ldr.w	r3, [r8, #32]
 80180de:	f1c3 0800 	rsb	r8, r3, #0
 80180e2:	f000 fd45 	bl	8018b70 <__tz_unlock>
 80180e6:	fb8a 1008 	smull	r1, r0, sl, r8
 80180ea:	ea4f 7ce8 	mov.w	ip, r8, asr #31
 80180ee:	4440      	add	r0, r8
 80180f0:	ebcc 1060 	rsb	r0, ip, r0, asr #5
 80180f4:	f8cd c010 	str.w	ip, [sp, #16]
 80180f8:	f000 fd52 	bl	8018ba0 <labs>
 80180fc:	fb80 230a 	smull	r2, r3, r0, sl
 8018100:	18c2      	adds	r2, r0, r3
 8018102:	49c0      	ldr	r1, [pc, #768]	; (8018404 <strftime+0x7d4>)
 8018104:	f8dd c010 	ldr.w	ip, [sp, #16]
 8018108:	17c3      	asrs	r3, r0, #31
 801810a:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 801810e:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8018112:	fb81 1208 	smull	r1, r2, r1, r8
 8018116:	eba0 0083 	sub.w	r0, r0, r3, lsl #2
 801811a:	4490      	add	r8, r2
 801811c:	9000      	str	r0, [sp, #0]
 801811e:	ebc9 0105 	rsb	r1, r9, r5
 8018122:	ebcc 23e8 	rsb	r3, ip, r8, asr #11
 8018126:	4658      	mov	r0, fp
 8018128:	4ab7      	ldr	r2, [pc, #732]	; (8018408 <strftime+0x7d8>)
 801812a:	f001 fb69 	bl	8019800 <sniprintf>
 801812e:	2800      	cmp	r0, #0
 8018130:	f6bf ae6a 	bge.w	8017e08 <strftime+0x1d8>
 8018134:	e638      	b.n	8017da8 <strftime+0x178>
 8018136:	693b      	ldr	r3, [r7, #16]
 8018138:	4ab4      	ldr	r2, [pc, #720]	; (801840c <strftime+0x7dc>)
 801813a:	3301      	adds	r3, #1
 801813c:	e76b      	b.n	8018016 <strftime+0x3e6>
 801813e:	1e6b      	subs	r3, r5, #1
 8018140:	4599      	cmp	r9, r3
 8018142:	f4bf ae31 	bcs.w	8017da8 <strftime+0x178>
 8018146:	230a      	movs	r3, #10
 8018148:	f806 3009 	strb.w	r3, [r6, r9]
 801814c:	f109 0901 	add.w	r9, r9, #1
 8018150:	e65d      	b.n	8017e0e <strftime+0x1de>
 8018152:	f8dd b014 	ldr.w	fp, [sp, #20]
 8018156:	f8db 80e4 	ldr.w	r8, [fp, #228]	; 0xe4
 801815a:	4640      	mov	r0, r8
 801815c:	f000 fad8 	bl	8018710 <strlen>
 8018160:	e741      	b.n	8017fe6 <strftime+0x3b6>
 8018162:	1e6b      	subs	r3, r5, #1
 8018164:	4599      	cmp	r9, r3
 8018166:	f4bf ae1f 	bcs.w	8017da8 <strftime+0x178>
 801816a:	2309      	movs	r3, #9
 801816c:	f806 3009 	strb.w	r3, [r6, r9]
 8018170:	f109 0901 	add.w	r9, r9, #1
 8018174:	e64b      	b.n	8017e0e <strftime+0x1de>
 8018176:	1e6b      	subs	r3, r5, #1
 8018178:	4599      	cmp	r9, r3
 801817a:	f4bf ae15 	bcs.w	8017da8 <strftime+0x178>
 801817e:	69bb      	ldr	r3, [r7, #24]
 8018180:	b953      	cbnz	r3, 8018198 <strftime+0x568>
 8018182:	2337      	movs	r3, #55	; 0x37
 8018184:	f806 3009 	strb.w	r3, [r6, r9]
 8018188:	f109 0901 	add.w	r9, r9, #1
 801818c:	e63f      	b.n	8017e0e <strftime+0x1de>
 801818e:	1e6b      	subs	r3, r5, #1
 8018190:	4599      	cmp	r9, r3
 8018192:	f4bf ae09 	bcs.w	8017da8 <strftime+0x178>
 8018196:	69bb      	ldr	r3, [r7, #24]
 8018198:	3330      	adds	r3, #48	; 0x30
 801819a:	f806 3009 	strb.w	r3, [r6, r9]
 801819e:	f109 0901 	add.w	r9, r9, #1
 80181a2:	e634      	b.n	8017e0e <strftime+0x1de>
 80181a4:	f8dd b014 	ldr.w	fp, [sp, #20]
 80181a8:	f8db 809c 	ldr.w	r8, [fp, #156]	; 0x9c
 80181ac:	4640      	mov	r0, r8
 80181ae:	f000 faaf 	bl	8018710 <strlen>
 80181b2:	e718      	b.n	8017fe6 <strftime+0x3b6>
 80181b4:	68bb      	ldr	r3, [r7, #8]
 80181b6:	f8dd b014 	ldr.w	fp, [sp, #20]
 80181ba:	2b0b      	cmp	r3, #11
 80181bc:	bfcc      	ite	gt
 80181be:	23a4      	movgt	r3, #164	; 0xa4
 80181c0:	23a0      	movle	r3, #160	; 0xa0
 80181c2:	445b      	add	r3, fp
 80181c4:	f8d3 8004 	ldr.w	r8, [r3, #4]
 80181c8:	4640      	mov	r0, r8
 80181ca:	f000 faa1 	bl	8018710 <strlen>
 80181ce:	2800      	cmp	r0, #0
 80181d0:	f43f ae1d 	beq.w	8017e0e <strftime+0x1de>
 80181d4:	f105 3aff 	add.w	sl, r5, #4294967295
 80181d8:	45d1      	cmp	r9, sl
 80181da:	f4bf ade5 	bcs.w	8017da8 <strftime+0x178>
 80181de:	464a      	mov	r2, r9
 80181e0:	f04f 0c00 	mov.w	ip, #0
 80181e4:	4481      	add	r9, r0
 80181e6:	18b3      	adds	r3, r6, r2
 80181e8:	4661      	mov	r1, ip
 80181ea:	e00b      	b.n	8018204 <strftime+0x5d4>
 80181ec:	f818 000c 	ldrb.w	r0, [r8, ip]
 80181f0:	5458      	strb	r0, [r3, r1]
 80181f2:	454a      	cmp	r2, r9
 80181f4:	f101 0101 	add.w	r1, r1, #1
 80181f8:	468c      	mov	ip, r1
 80181fa:	f43f ae38 	beq.w	8017e6e <strftime+0x23e>
 80181fe:	4552      	cmp	r2, sl
 8018200:	f4bf add2 	bcs.w	8017da8 <strftime+0x178>
 8018204:	7820      	ldrb	r0, [r4, #0]
 8018206:	2850      	cmp	r0, #80	; 0x50
 8018208:	f102 0201 	add.w	r2, r2, #1
 801820c:	d1ee      	bne.n	80181ec <strftime+0x5bc>
 801820e:	f8df b224 	ldr.w	fp, [pc, #548]	; 8018434 <strftime+0x804>
 8018212:	f818 c00c 	ldrb.w	ip, [r8, ip]
 8018216:	f8db 0000 	ldr.w	r0, [fp]
 801821a:	eb00 0b0c 	add.w	fp, r0, ip
 801821e:	4660      	mov	r0, ip
 8018220:	f89b b001 	ldrb.w	fp, [fp, #1]
 8018224:	f00b 0b03 	and.w	fp, fp, #3
 8018228:	f1bb 0f01 	cmp.w	fp, #1
 801822c:	bf08      	it	eq
 801822e:	f10c 0020 	addeq.w	r0, ip, #32
 8018232:	b2c0      	uxtb	r0, r0
 8018234:	e7dc      	b.n	80181f0 <strftime+0x5c0>
 8018236:	687a      	ldr	r2, [r7, #4]
 8018238:	68bb      	ldr	r3, [r7, #8]
 801823a:	9200      	str	r2, [sp, #0]
 801823c:	eb06 0009 	add.w	r0, r6, r9
 8018240:	ebc9 0105 	rsb	r1, r9, r5
 8018244:	4a72      	ldr	r2, [pc, #456]	; (8018410 <strftime+0x7e0>)
 8018246:	f001 fadb 	bl	8019800 <sniprintf>
 801824a:	2800      	cmp	r0, #0
 801824c:	f6bf addc 	bge.w	8017e08 <strftime+0x1d8>
 8018250:	e5aa      	b.n	8017da8 <strftime+0x178>
 8018252:	eb06 0009 	add.w	r0, r6, r9
 8018256:	ebc9 0105 	rsb	r1, r9, r5
 801825a:	4a6c      	ldr	r2, [pc, #432]	; (801840c <strftime+0x7dc>)
 801825c:	683b      	ldr	r3, [r7, #0]
 801825e:	f001 facf 	bl	8019800 <sniprintf>
 8018262:	2800      	cmp	r0, #0
 8018264:	f6bf add0 	bge.w	8017e08 <strftime+0x1d8>
 8018268:	e59e      	b.n	8017da8 <strftime+0x178>
 801826a:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 801826e:	eb06 0009 	add.w	r0, r6, r9
 8018272:	9200      	str	r2, [sp, #0]
 8018274:	9101      	str	r1, [sp, #4]
 8018276:	4a67      	ldr	r2, [pc, #412]	; (8018414 <strftime+0x7e4>)
 8018278:	ebc9 0105 	rsb	r1, r9, r5
 801827c:	f001 fac0 	bl	8019800 <sniprintf>
 8018280:	2800      	cmp	r0, #0
 8018282:	f6bf adc1 	bge.w	8017e08 <strftime+0x1d8>
 8018286:	e58f      	b.n	8017da8 <strftime+0x178>
 8018288:	69f9      	ldr	r1, [r7, #28]
 801828a:	69bb      	ldr	r3, [r7, #24]
 801828c:	4862      	ldr	r0, [pc, #392]	; (8018418 <strftime+0x7e8>)
 801828e:	4a5f      	ldr	r2, [pc, #380]	; (801840c <strftime+0x7dc>)
 8018290:	3107      	adds	r1, #7
 8018292:	1ac9      	subs	r1, r1, r3
 8018294:	fb80 0301 	smull	r0, r3, r0, r1
 8018298:	440b      	add	r3, r1
 801829a:	17c9      	asrs	r1, r1, #31
 801829c:	ebc1 03a3 	rsb	r3, r1, r3, asr #2
 80182a0:	e6b9      	b.n	8018016 <strftime+0x3e6>
 80182a2:	4638      	mov	r0, r7
 80182a4:	f7ff fc4c 	bl	8017b40 <iso_year_adjust>
 80182a8:	69bb      	ldr	r3, [r7, #24]
 80182aa:	2b00      	cmp	r3, #0
 80182ac:	f000 811f 	beq.w	80184ee <strftime+0x8be>
 80182b0:	3b01      	subs	r3, #1
 80182b2:	2800      	cmp	r0, #0
 80182b4:	69fa      	ldr	r2, [r7, #28]
 80182b6:	f340 8157 	ble.w	8018568 <strftime+0x938>
 80182ba:	2301      	movs	r3, #1
 80182bc:	e59b      	b.n	8017df6 <strftime+0x1c6>
 80182be:	69bb      	ldr	r3, [r7, #24]
 80182c0:	2b00      	cmp	r3, #0
 80182c2:	f000 8116 	beq.w	80184f2 <strftime+0x8c2>
 80182c6:	1e59      	subs	r1, r3, #1
 80182c8:	69f8      	ldr	r0, [r7, #28]
 80182ca:	f8df b14c 	ldr.w	fp, [pc, #332]	; 8018418 <strftime+0x7e8>
 80182ce:	4a4f      	ldr	r2, [pc, #316]	; (801840c <strftime+0x7dc>)
 80182d0:	3007      	adds	r0, #7
 80182d2:	1a41      	subs	r1, r0, r1
 80182d4:	fb8b b301 	smull	fp, r3, fp, r1
 80182d8:	440b      	add	r3, r1
 80182da:	17c9      	asrs	r1, r1, #31
 80182dc:	ebc1 03a3 	rsb	r3, r1, r3, asr #2
 80182e0:	e699      	b.n	8018016 <strftime+0x3e6>
 80182e2:	f8dd b014 	ldr.w	fp, [sp, #20]
 80182e6:	f8db 8098 	ldr.w	r8, [fp, #152]	; 0x98
 80182ea:	4640      	mov	r0, r8
 80182ec:	f000 fa10 	bl	8018710 <strlen>
 80182f0:	e679      	b.n	8017fe6 <strftime+0x3b6>
 80182f2:	4a4a      	ldr	r2, [pc, #296]	; (801841c <strftime+0x7ec>)
 80182f4:	f8d7 b014 	ldr.w	fp, [r7, #20]
 80182f8:	4593      	cmp	fp, r2
 80182fa:	bfac      	ite	ge
 80182fc:	2200      	movge	r2, #0
 80182fe:	2201      	movlt	r2, #1
 8018300:	4638      	mov	r0, r7
 8018302:	9203      	str	r2, [sp, #12]
 8018304:	f7ff fc1c 	bl	8017b40 <iso_year_adjust>
 8018308:	f1bb 0f00 	cmp.w	fp, #0
 801830c:	4603      	mov	r3, r0
 801830e:	9a03      	ldr	r2, [sp, #12]
 8018310:	f2c0 816a 	blt.w	80185e8 <strftime+0x9b8>
 8018314:	4842      	ldr	r0, [pc, #264]	; (8018420 <strftime+0x7f0>)
 8018316:	ea4f 71eb 	mov.w	r1, fp, asr #31
 801831a:	fb80 0c0b 	smull	r0, ip, r0, fp
 801831e:	ebc1 1c6c 	rsb	ip, r1, ip, asr #5
 8018322:	f10c 0c13 	add.w	ip, ip, #19
 8018326:	483e      	ldr	r0, [pc, #248]	; (8018420 <strftime+0x7f0>)
 8018328:	fb80 0e0b 	smull	r0, lr, r0, fp
 801832c:	ebc1 1e6e 	rsb	lr, r1, lr, asr #5
 8018330:	2164      	movs	r1, #100	; 0x64
 8018332:	fb01 be1e 	mls	lr, r1, lr, fp
 8018336:	2b00      	cmp	r3, #0
 8018338:	f2c0 8107 	blt.w	801854a <strftime+0x91a>
 801833c:	d003      	beq.n	8018346 <strftime+0x716>
 801833e:	b112      	cbz	r2, 8018346 <strftime+0x716>
 8018340:	f04f 33ff 	mov.w	r3, #4294967295
 8018344:	2201      	movs	r2, #1
 8018346:	4473      	add	r3, lr
 8018348:	1c59      	adds	r1, r3, #1
 801834a:	f000 80f3 	beq.w	8018534 <strftime+0x904>
 801834e:	2b64      	cmp	r3, #100	; 0x64
 8018350:	bf04      	itt	eq
 8018352:	f10c 0c01 	addeq.w	ip, ip, #1
 8018356:	2300      	moveq	r3, #0
 8018358:	2164      	movs	r1, #100	; 0x64
 801835a:	fb01 330c 	mla	r3, r1, ip, r3
 801835e:	2a00      	cmp	r2, #0
 8018360:	f000 808d 	beq.w	801847e <strftime+0x84e>
 8018364:	222d      	movs	r2, #45	; 0x2d
 8018366:	f88d 2018 	strb.w	r2, [sp, #24]
 801836a:	e5ae      	b.n	8017eca <strftime+0x29a>
 801836c:	4827      	ldr	r0, [pc, #156]	; (801840c <strftime+0x7dc>)
 801836e:	4a2d      	ldr	r2, [pc, #180]	; (8018424 <strftime+0x7f4>)
 8018370:	68bb      	ldr	r3, [r7, #8]
 8018372:	296b      	cmp	r1, #107	; 0x6b
 8018374:	bf18      	it	ne
 8018376:	4602      	movne	r2, r0
 8018378:	e64d      	b.n	8018016 <strftime+0x3e6>
 801837a:	68ba      	ldr	r2, [r7, #8]
 801837c:	2a00      	cmp	r2, #0
 801837e:	f000 80ba 	beq.w	80184f6 <strftime+0x8c6>
 8018382:	2a0c      	cmp	r2, #12
 8018384:	f000 80ff 	beq.w	8018586 <strftime+0x956>
 8018388:	4b27      	ldr	r3, [pc, #156]	; (8018428 <strftime+0x7f8>)
 801838a:	fb83 3002 	smull	r3, r0, r3, r2
 801838e:	17d3      	asrs	r3, r2, #31
 8018390:	ebc3 0360 	rsb	r3, r3, r0, asr #1
 8018394:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8018398:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
 801839c:	4821      	ldr	r0, [pc, #132]	; (8018424 <strftime+0x7f4>)
 801839e:	4a1b      	ldr	r2, [pc, #108]	; (801840c <strftime+0x7dc>)
 80183a0:	2949      	cmp	r1, #73	; 0x49
 80183a2:	bf18      	it	ne
 80183a4:	4602      	movne	r2, r0
 80183a6:	e636      	b.n	8018016 <strftime+0x3e6>
 80183a8:	eb06 0009 	add.w	r0, r6, r9
 80183ac:	ebc9 0105 	rsb	r1, r9, r5
 80183b0:	4a16      	ldr	r2, [pc, #88]	; (801840c <strftime+0x7dc>)
 80183b2:	687b      	ldr	r3, [r7, #4]
 80183b4:	f001 fa24 	bl	8019800 <sniprintf>
 80183b8:	2800      	cmp	r0, #0
 80183ba:	f6bf ad25 	bge.w	8017e08 <strftime+0x1d8>
 80183be:	e4f3      	b.n	8017da8 <strftime+0x178>
 80183c0:	697a      	ldr	r2, [r7, #20]
 80183c2:	693b      	ldr	r3, [r7, #16]
 80183c4:	f8d7 a00c 	ldr.w	sl, [r7, #12]
 80183c8:	2a00      	cmp	r2, #0
 80183ca:	f103 0301 	add.w	r3, r3, #1
 80183ce:	eb06 0809 	add.w	r8, r6, r9
 80183d2:	ebc9 0105 	rsb	r1, r9, r5
 80183d6:	f2c0 80d8 	blt.w	801858a <strftime+0x95a>
 80183da:	f8df b044 	ldr.w	fp, [pc, #68]	; 8018420 <strftime+0x7f0>
 80183de:	17d0      	asrs	r0, r2, #31
 80183e0:	fb8b be02 	smull	fp, lr, fp, r2
 80183e4:	ebc0 1e6e 	rsb	lr, r0, lr, asr #5
 80183e8:	2064      	movs	r0, #100	; 0x64
 80183ea:	fb00 2e1e 	mls	lr, r0, lr, r2
 80183ee:	e88d 4400 	stmia.w	sp, {sl, lr}
 80183f2:	4640      	mov	r0, r8
 80183f4:	4a0d      	ldr	r2, [pc, #52]	; (801842c <strftime+0x7fc>)
 80183f6:	f001 fa03 	bl	8019800 <sniprintf>
 80183fa:	2800      	cmp	r0, #0
 80183fc:	f6bf ad04 	bge.w	8017e08 <strftime+0x1d8>
 8018400:	e4d2      	b.n	8017da8 <strftime+0x178>
 8018402:	bf00      	nop
 8018404:	91a2b3c5 	.word	0x91a2b3c5
 8018408:	0801c228 	.word	0x0801c228
 801840c:	0801c1d8 	.word	0x0801c1d8
 8018410:	0801c20c 	.word	0x0801c20c
 8018414:	0801c218 	.word	0x0801c218
 8018418:	92492493 	.word	0x92492493
 801841c:	fffff894 	.word	0xfffff894
 8018420:	51eb851f 	.word	0x51eb851f
 8018424:	0801c1e0 	.word	0x0801c1e0
 8018428:	2aaaaaab 	.word	0x2aaaaaab
 801842c:	0801c1e4 	.word	0x0801c1e4
 8018430:	88888889 	.word	0x88888889
 8018434:	20000918 	.word	0x20000918
 8018438:	6978      	ldr	r0, [r7, #20]
 801843a:	4ba8      	ldr	r3, [pc, #672]	; (80186dc <strftime+0xaac>)
 801843c:	4298      	cmp	r0, r3
 801843e:	bfac      	ite	ge
 8018440:	f04f 0b00 	movge.w	fp, #0
 8018444:	f04f 0b01 	movlt.w	fp, #1
 8018448:	2800      	cmp	r0, #0
 801844a:	f2c0 80f7 	blt.w	801863c <strftime+0xa0c>
 801844e:	4aa4      	ldr	r2, [pc, #656]	; (80186e0 <strftime+0xab0>)
 8018450:	fb82 2100 	smull	r2, r1, r2, r0
 8018454:	17c0      	asrs	r0, r0, #31
 8018456:	ebc0 1161 	rsb	r1, r0, r1, asr #5
 801845a:	3113      	adds	r1, #19
 801845c:	f1b8 0f00 	cmp.w	r8, #0
 8018460:	d04b      	beq.n	80184fa <strftime+0x8ca>
 8018462:	2963      	cmp	r1, #99	; 0x63
 8018464:	dd63      	ble.n	801852e <strftime+0x8fe>
 8018466:	489f      	ldr	r0, [pc, #636]	; (80186e4 <strftime+0xab4>)
 8018468:	4b9f      	ldr	r3, [pc, #636]	; (80186e8 <strftime+0xab8>)
 801846a:	4aa0      	ldr	r2, [pc, #640]	; (80186ec <strftime+0xabc>)
 801846c:	f1b8 0f2b 	cmp.w	r8, #43	; 0x2b
 8018470:	bf18      	it	ne
 8018472:	4618      	movne	r0, r3
 8018474:	e043      	b.n	80184fe <strftime+0x8ce>
 8018476:	4648      	mov	r0, r9
 8018478:	b00f      	add	sp, #60	; 0x3c
 801847a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801847e:	f1b8 0f2b 	cmp.w	r8, #43	; 0x2b
 8018482:	d05b      	beq.n	801853c <strftime+0x90c>
 8018484:	f10d 0b18 	add.w	fp, sp, #24
 8018488:	4658      	mov	r0, fp
 801848a:	2225      	movs	r2, #37	; 0x25
 801848c:	7002      	strb	r2, [r0, #0]
 801848e:	f1b8 0f00 	cmp.w	r8, #0
 8018492:	d118      	bne.n	80184c6 <strftime+0x896>
 8018494:	3001      	adds	r0, #1
 8018496:	4996      	ldr	r1, [pc, #600]	; (80186f0 <strftime+0xac0>)
 8018498:	9302      	str	r3, [sp, #8]
 801849a:	f7ff faf1 	bl	8017a80 <strcpy>
 801849e:	9b02      	ldr	r3, [sp, #8]
 80184a0:	9300      	str	r3, [sp, #0]
 80184a2:	465a      	mov	r2, fp
 80184a4:	4653      	mov	r3, sl
 80184a6:	eb06 0009 	add.w	r0, r6, r9
 80184aa:	ebc9 0105 	rsb	r1, r9, r5
 80184ae:	f001 f9a7 	bl	8019800 <sniprintf>
 80184b2:	2800      	cmp	r0, #0
 80184b4:	f6bf aca8 	bge.w	8017e08 <strftime+0x1d8>
 80184b8:	e476      	b.n	8017da8 <strftime+0x178>
 80184ba:	f10d 0b38 	add.w	fp, sp, #56	; 0x38
 80184be:	2225      	movs	r2, #37	; 0x25
 80184c0:	f80b 2d20 	strb.w	r2, [fp, #-32]!
 80184c4:	4658      	mov	r0, fp
 80184c6:	2230      	movs	r2, #48	; 0x30
 80184c8:	7042      	strb	r2, [r0, #1]
 80184ca:	3002      	adds	r0, #2
 80184cc:	e7e3      	b.n	8018496 <strftime+0x866>
 80184ce:	232b      	movs	r3, #43	; 0x2b
 80184d0:	f88d 3019 	strb.w	r3, [sp, #25]
 80184d4:	2304      	movs	r3, #4
 80184d6:	f10d 081a 	add.w	r8, sp, #26
 80184da:	4640      	mov	r0, r8
 80184dc:	211e      	movs	r1, #30
 80184de:	4a85      	ldr	r2, [pc, #532]	; (80186f4 <strftime+0xac4>)
 80184e0:	f001 f98e 	bl	8019800 <sniprintf>
 80184e4:	2800      	cmp	r0, #0
 80184e6:	f77f ac50 	ble.w	8017d8a <strftime+0x15a>
 80184ea:	4440      	add	r0, r8
 80184ec:	e44e      	b.n	8017d8c <strftime+0x15c>
 80184ee:	2306      	movs	r3, #6
 80184f0:	e6df      	b.n	80182b2 <strftime+0x682>
 80184f2:	2106      	movs	r1, #6
 80184f4:	e6e8      	b.n	80182c8 <strftime+0x698>
 80184f6:	230c      	movs	r3, #12
 80184f8:	e750      	b.n	801839c <strftime+0x76c>
 80184fa:	487b      	ldr	r0, [pc, #492]	; (80186e8 <strftime+0xab8>)
 80184fc:	4a7e      	ldr	r2, [pc, #504]	; (80186f8 <strftime+0xac8>)
 80184fe:	f1ba 0f01 	cmp.w	sl, #1
 8018502:	bf98      	it	ls
 8018504:	f04f 0a02 	movls.w	sl, #2
 8018508:	4b7c      	ldr	r3, [pc, #496]	; (80186fc <strftime+0xacc>)
 801850a:	9101      	str	r1, [sp, #4]
 801850c:	ebcb 010a 	rsb	r1, fp, sl
 8018510:	f1bb 0f00 	cmp.w	fp, #0
 8018514:	bf08      	it	eq
 8018516:	4603      	moveq	r3, r0
 8018518:	9100      	str	r1, [sp, #0]
 801851a:	eb06 0009 	add.w	r0, r6, r9
 801851e:	ebc9 0105 	rsb	r1, r9, r5
 8018522:	f001 f96d 	bl	8019800 <sniprintf>
 8018526:	2800      	cmp	r0, #0
 8018528:	f6bf ac6e 	bge.w	8017e08 <strftime+0x1d8>
 801852c:	e43c      	b.n	8017da8 <strftime+0x178>
 801852e:	486e      	ldr	r0, [pc, #440]	; (80186e8 <strftime+0xab8>)
 8018530:	4a6e      	ldr	r2, [pc, #440]	; (80186ec <strftime+0xabc>)
 8018532:	e7e4      	b.n	80184fe <strftime+0x8ce>
 8018534:	f10c 3cff 	add.w	ip, ip, #4294967295
 8018538:	2363      	movs	r3, #99	; 0x63
 801853a:	e70d      	b.n	8018358 <strftime+0x728>
 801853c:	f242 720f 	movw	r2, #9999	; 0x270f
 8018540:	4293      	cmp	r3, r2
 8018542:	d9ba      	bls.n	80184ba <strftime+0x88a>
 8018544:	f88d 8018 	strb.w	r8, [sp, #24]
 8018548:	e4bf      	b.n	8017eca <strftime+0x29a>
 801854a:	486d      	ldr	r0, [pc, #436]	; (8018700 <strftime+0xad0>)
 801854c:	6979      	ldr	r1, [r7, #20]
 801854e:	4281      	cmp	r1, r0
 8018550:	f6bf aef9 	bge.w	8018346 <strftime+0x716>
 8018554:	2301      	movs	r3, #1
 8018556:	461a      	mov	r2, r3
 8018558:	e6f5      	b.n	8018346 <strftime+0x716>
 801855a:	4969      	ldr	r1, [pc, #420]	; (8018700 <strftime+0xad0>)
 801855c:	697a      	ldr	r2, [r7, #20]
 801855e:	428a      	cmp	r2, r1
 8018560:	bfb8      	it	lt
 8018562:	f04f 0801 	movlt.w	r8, #1
 8018566:	e57c      	b.n	8018062 <strftime+0x432>
 8018568:	d173      	bne.n	8018652 <strftime+0xa22>
 801856a:	320a      	adds	r2, #10
 801856c:	4965      	ldr	r1, [pc, #404]	; (8018704 <strftime+0xad4>)
 801856e:	1ad3      	subs	r3, r2, r3
 8018570:	fb81 1203 	smull	r1, r2, r1, r3
 8018574:	441a      	add	r2, r3
 8018576:	17db      	asrs	r3, r3, #31
 8018578:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 801857c:	e43b      	b.n	8017df6 <strftime+0x1c6>
 801857e:	f000 faf7 	bl	8018b70 <__tz_unlock>
 8018582:	2000      	movs	r0, #0
 8018584:	e411      	b.n	8017daa <strftime+0x17a>
 8018586:	4613      	mov	r3, r2
 8018588:	e708      	b.n	801839c <strftime+0x76c>
 801858a:	f202 706c 	addw	r0, r2, #1900	; 0x76c
 801858e:	9104      	str	r1, [sp, #16]
 8018590:	9302      	str	r3, [sp, #8]
 8018592:	f000 faf5 	bl	8018b80 <abs>
 8018596:	4a52      	ldr	r2, [pc, #328]	; (80186e0 <strftime+0xab0>)
 8018598:	9b02      	ldr	r3, [sp, #8]
 801859a:	9904      	ldr	r1, [sp, #16]
 801859c:	fb82 2e00 	smull	r2, lr, r2, r0
 80185a0:	17c2      	asrs	r2, r0, #31
 80185a2:	ebc2 1e6e 	rsb	lr, r2, lr, asr #5
 80185a6:	2264      	movs	r2, #100	; 0x64
 80185a8:	fb02 0e1e 	mls	lr, r2, lr, r0
 80185ac:	e71f      	b.n	80183ee <strftime+0x7be>
 80185ae:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 80185b2:	f000 fae5 	bl	8018b80 <abs>
 80185b6:	4b4a      	ldr	r3, [pc, #296]	; (80186e0 <strftime+0xab0>)
 80185b8:	fb83 3200 	smull	r3, r2, r3, r0
 80185bc:	17c3      	asrs	r3, r0, #31
 80185be:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 80185c2:	2264      	movs	r2, #100	; 0x64
 80185c4:	fb02 0313 	mls	r3, r2, r3, r0
 80185c8:	e415      	b.n	8017df6 <strftime+0x1c6>
 80185ca:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 80185ce:	f000 fad7 	bl	8018b80 <abs>
 80185d2:	f8df b10c 	ldr.w	fp, [pc, #268]	; 80186e0 <strftime+0xab0>
 80185d6:	17c3      	asrs	r3, r0, #31
 80185d8:	fb8b b200 	smull	fp, r2, fp, r0
 80185dc:	ebc3 1362 	rsb	r3, r3, r2, asr #5
 80185e0:	2264      	movs	r2, #100	; 0x64
 80185e2:	fb02 0313 	mls	r3, r2, r3, r0
 80185e6:	e531      	b.n	801804c <strftime+0x41c>
 80185e8:	f20b 706c 	addw	r0, fp, #1900	; 0x76c
 80185ec:	9203      	str	r2, [sp, #12]
 80185ee:	9302      	str	r3, [sp, #8]
 80185f0:	f000 fac6 	bl	8018b80 <abs>
 80185f4:	f8d7 b014 	ldr.w	fp, [r7, #20]
 80185f8:	4939      	ldr	r1, [pc, #228]	; (80186e0 <strftime+0xab0>)
 80185fa:	9a03      	ldr	r2, [sp, #12]
 80185fc:	9b02      	ldr	r3, [sp, #8]
 80185fe:	fb81 1c00 	smull	r1, ip, r1, r0
 8018602:	f1bb 0f00 	cmp.w	fp, #0
 8018606:	ea4f 70e0 	mov.w	r0, r0, asr #31
 801860a:	ebc0 1c6c 	rsb	ip, r0, ip, asr #5
 801860e:	da5b      	bge.n	80186c8 <strftime+0xa98>
 8018610:	f20b 706c 	addw	r0, fp, #1900	; 0x76c
 8018614:	9203      	str	r2, [sp, #12]
 8018616:	9302      	str	r3, [sp, #8]
 8018618:	f8cd c010 	str.w	ip, [sp, #16]
 801861c:	f000 fab0 	bl	8018b80 <abs>
 8018620:	492f      	ldr	r1, [pc, #188]	; (80186e0 <strftime+0xab0>)
 8018622:	f8dd c010 	ldr.w	ip, [sp, #16]
 8018626:	9b02      	ldr	r3, [sp, #8]
 8018628:	9a03      	ldr	r2, [sp, #12]
 801862a:	fb81 1e00 	smull	r1, lr, r1, r0
 801862e:	17c1      	asrs	r1, r0, #31
 8018630:	ebc1 1e6e 	rsb	lr, r1, lr, asr #5
 8018634:	2164      	movs	r1, #100	; 0x64
 8018636:	fb01 0e1e 	mls	lr, r1, lr, r0
 801863a:	e67c      	b.n	8018336 <strftime+0x706>
 801863c:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 8018640:	f000 fa9e 	bl	8018b80 <abs>
 8018644:	4b26      	ldr	r3, [pc, #152]	; (80186e0 <strftime+0xab0>)
 8018646:	fb83 3100 	smull	r3, r1, r3, r0
 801864a:	17c0      	asrs	r0, r0, #31
 801864c:	ebc0 1161 	rsb	r1, r0, r1, asr #5
 8018650:	e704      	b.n	801845c <strftime+0x82c>
 8018652:	6978      	ldr	r0, [r7, #20]
 8018654:	2800      	cmp	r0, #0
 8018656:	ebc2 0303 	rsb	r3, r2, r3
 801865a:	db22      	blt.n	80186a2 <strftime+0xa72>
 801865c:	f1a0 0165 	sub.w	r1, r0, #101	; 0x65
 8018660:	078a      	lsls	r2, r1, #30
 8018662:	d106      	bne.n	8018672 <strftime+0xa42>
 8018664:	f04f 0e64 	mov.w	lr, #100	; 0x64
 8018668:	fb91 f2fe 	sdiv	r2, r1, lr
 801866c:	fb0e 1112 	mls	r1, lr, r2, r1
 8018670:	bb91      	cbnz	r1, 80186d8 <strftime+0xaa8>
 8018672:	f06f 0164 	mvn.w	r1, #100	; 0x64
 8018676:	4a1a      	ldr	r2, [pc, #104]	; (80186e0 <strftime+0xab0>)
 8018678:	4401      	add	r1, r0
 801867a:	fb82 2001 	smull	r2, r0, r2, r1
 801867e:	17ca      	asrs	r2, r1, #31
 8018680:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 8018684:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8018688:	fb00 1112 	mls	r1, r0, r2, r1
 801868c:	f1d1 0101 	rsbs	r1, r1, #1
 8018690:	bf38      	it	cc
 8018692:	2100      	movcc	r1, #0
 8018694:	1a5b      	subs	r3, r3, r1
 8018696:	2b04      	cmp	r3, #4
 8018698:	bfcc      	ite	gt
 801869a:	2334      	movgt	r3, #52	; 0x34
 801869c:	2335      	movle	r3, #53	; 0x35
 801869e:	f7ff bbaa 	b.w	8017df6 <strftime+0x1c6>
 80186a2:	f200 716b 	addw	r1, r0, #1899	; 0x76b
 80186a6:	078a      	lsls	r2, r1, #30
 80186a8:	d106      	bne.n	80186b8 <strftime+0xa88>
 80186aa:	f04f 0e64 	mov.w	lr, #100	; 0x64
 80186ae:	fb91 f2fe 	sdiv	r2, r1, lr
 80186b2:	fb0e 1112 	mls	r1, lr, r2, r1
 80186b6:	b979      	cbnz	r1, 80186d8 <strftime+0xaa8>
 80186b8:	f240 716b 	movw	r1, #1899	; 0x76b
 80186bc:	e7db      	b.n	8018676 <strftime+0xa46>
 80186be:	f1ba 0306 	subs.w	r3, sl, #6
 80186c2:	f43f ab60 	beq.w	8017d86 <strftime+0x156>
 80186c6:	e706      	b.n	80184d6 <strftime+0x8a6>
 80186c8:	ea4f 71eb 	mov.w	r1, fp, asr #31
 80186cc:	e62b      	b.n	8018326 <strftime+0x6f6>
 80186ce:	f10d 0019 	add.w	r0, sp, #25
 80186d2:	f10d 0b18 	add.w	fp, sp, #24
 80186d6:	e6d8      	b.n	801848a <strftime+0x85a>
 80186d8:	2101      	movs	r1, #1
 80186da:	e7db      	b.n	8018694 <strftime+0xa64>
 80186dc:	fffff894 	.word	0xfffff894
 80186e0:	51eb851f 	.word	0x51eb851f
 80186e4:	0801c1d0 	.word	0x0801c1d0
 80186e8:	0801c620 	.word	0x0801c620
 80186ec:	0801c1c8 	.word	0x0801c1c8
 80186f0:	0801c200 	.word	0x0801c200
 80186f4:	0801c1f4 	.word	0x0801c1f4
 80186f8:	0801c1c0 	.word	0x0801c1c0
 80186fc:	0801c1d4 	.word	0x0801c1d4
 8018700:	fffff895 	.word	0xfffff895
 8018704:	92492493 	.word	0x92492493
	...

08018710 <strlen>:
 8018710:	f020 0103 	bic.w	r1, r0, #3
 8018714:	f010 0003 	ands.w	r0, r0, #3
 8018718:	f1c0 0000 	rsb	r0, r0, #0
 801871c:	f851 3b04 	ldr.w	r3, [r1], #4
 8018720:	f100 0c04 	add.w	ip, r0, #4
 8018724:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8018728:	f06f 0200 	mvn.w	r2, #0
 801872c:	bf1c      	itt	ne
 801872e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8018732:	4313      	orrne	r3, r2
 8018734:	f04f 0c01 	mov.w	ip, #1
 8018738:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 801873c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8018740:	eba3 020c 	sub.w	r2, r3, ip
 8018744:	ea22 0203 	bic.w	r2, r2, r3
 8018748:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 801874c:	bf04      	itt	eq
 801874e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8018752:	3004      	addeq	r0, #4
 8018754:	d0f4      	beq.n	8018740 <strlen+0x30>
 8018756:	f013 0fff 	tst.w	r3, #255	; 0xff
 801875a:	bf1f      	itttt	ne
 801875c:	3001      	addne	r0, #1
 801875e:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 8018762:	3001      	addne	r0, #1
 8018764:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 8018768:	bf18      	it	ne
 801876a:	3001      	addne	r0, #1
 801876c:	4770      	bx	lr
 801876e:	bf00      	nop

08018770 <strpbrk>:
 8018770:	b4f0      	push	{r4, r5, r6, r7}
 8018772:	7804      	ldrb	r4, [r0, #0]
 8018774:	b30c      	cbz	r4, 80187ba <strpbrk+0x4a>
 8018776:	780e      	ldrb	r6, [r1, #0]
 8018778:	4607      	mov	r7, r0
 801877a:	b1c6      	cbz	r6, 80187ae <strpbrk+0x3e>
 801877c:	42a6      	cmp	r6, r4
 801877e:	d010      	beq.n	80187a2 <strpbrk+0x32>
 8018780:	1c4b      	adds	r3, r1, #1
 8018782:	e001      	b.n	8018788 <strpbrk+0x18>
 8018784:	4294      	cmp	r4, r2
 8018786:	d00b      	beq.n	80187a0 <strpbrk+0x30>
 8018788:	461d      	mov	r5, r3
 801878a:	f813 2b01 	ldrb.w	r2, [r3], #1
 801878e:	2a00      	cmp	r2, #0
 8018790:	d1f8      	bne.n	8018784 <strpbrk+0x14>
 8018792:	7844      	ldrb	r4, [r0, #1]
 8018794:	3001      	adds	r0, #1
 8018796:	2c00      	cmp	r4, #0
 8018798:	d1ee      	bne.n	8018778 <strpbrk+0x8>
 801879a:	782e      	ldrb	r6, [r5, #0]
 801879c:	4607      	mov	r7, r0
 801879e:	e000      	b.n	80187a2 <strpbrk+0x32>
 80187a0:	4626      	mov	r6, r4
 80187a2:	2e00      	cmp	r6, #0
 80187a4:	bf14      	ite	ne
 80187a6:	4638      	movne	r0, r7
 80187a8:	2000      	moveq	r0, #0
 80187aa:	bcf0      	pop	{r4, r5, r6, r7}
 80187ac:	4770      	bx	lr
 80187ae:	7844      	ldrb	r4, [r0, #1]
 80187b0:	460d      	mov	r5, r1
 80187b2:	3001      	adds	r0, #1
 80187b4:	2c00      	cmp	r4, #0
 80187b6:	d1df      	bne.n	8018778 <strpbrk+0x8>
 80187b8:	e7ef      	b.n	801879a <strpbrk+0x2a>
 80187ba:	4620      	mov	r0, r4
 80187bc:	bcf0      	pop	{r4, r5, r6, r7}
 80187be:	4770      	bx	lr

080187c0 <strspn>:
 80187c0:	b4f0      	push	{r4, r5, r6, r7}
 80187c2:	7804      	ldrb	r4, [r0, #0]
 80187c4:	b1cc      	cbz	r4, 80187fa <strspn+0x3a>
 80187c6:	780e      	ldrb	r6, [r1, #0]
 80187c8:	4607      	mov	r7, r0
 80187ca:	b19e      	cbz	r6, 80187f4 <strspn+0x34>
 80187cc:	4605      	mov	r5, r0
 80187ce:	42b4      	cmp	r4, r6
 80187d0:	d00a      	beq.n	80187e8 <strspn+0x28>
 80187d2:	460a      	mov	r2, r1
 80187d4:	e001      	b.n	80187da <strspn+0x1a>
 80187d6:	429c      	cmp	r4, r3
 80187d8:	d006      	beq.n	80187e8 <strspn+0x28>
 80187da:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80187de:	2b00      	cmp	r3, #0
 80187e0:	d1f9      	bne.n	80187d6 <strspn+0x16>
 80187e2:	1a28      	subs	r0, r5, r0
 80187e4:	bcf0      	pop	{r4, r5, r6, r7}
 80187e6:	4770      	bx	lr
 80187e8:	786c      	ldrb	r4, [r5, #1]
 80187ea:	1c7d      	adds	r5, r7, #1
 80187ec:	2c00      	cmp	r4, #0
 80187ee:	d0f8      	beq.n	80187e2 <strspn+0x22>
 80187f0:	462f      	mov	r7, r5
 80187f2:	e7ec      	b.n	80187ce <strspn+0xe>
 80187f4:	4630      	mov	r0, r6
 80187f6:	bcf0      	pop	{r4, r5, r6, r7}
 80187f8:	4770      	bx	lr
 80187fa:	4620      	mov	r0, r4
 80187fc:	e7f2      	b.n	80187e4 <strspn+0x24>
 80187fe:	bf00      	nop

08018800 <strtok>:
 8018800:	4b02      	ldr	r3, [pc, #8]	; (801880c <strtok+0xc>)
 8018802:	681a      	ldr	r2, [r3, #0]
 8018804:	2301      	movs	r3, #1
 8018806:	325c      	adds	r2, #92	; 0x5c
 8018808:	f000 b802 	b.w	8018810 <__strtok_r>
 801880c:	20000d88 	.word	0x20000d88

08018810 <__strtok_r>:
 8018810:	b4f0      	push	{r4, r5, r6, r7}
 8018812:	b320      	cbz	r0, 801885e <__strtok_r+0x4e>
 8018814:	4607      	mov	r7, r0
 8018816:	460d      	mov	r5, r1
 8018818:	f817 6b01 	ldrb.w	r6, [r7], #1
 801881c:	e001      	b.n	8018822 <__strtok_r+0x12>
 801881e:	42a6      	cmp	r6, r4
 8018820:	d016      	beq.n	8018850 <__strtok_r+0x40>
 8018822:	f815 4b01 	ldrb.w	r4, [r5], #1
 8018826:	2c00      	cmp	r4, #0
 8018828:	d1f9      	bne.n	801881e <__strtok_r+0xe>
 801882a:	b1ee      	cbz	r6, 8018868 <__strtok_r+0x58>
 801882c:	463e      	mov	r6, r7
 801882e:	460c      	mov	r4, r1
 8018830:	f816 5b01 	ldrb.w	r5, [r6], #1
 8018834:	e000      	b.n	8018838 <__strtok_r+0x28>
 8018836:	b173      	cbz	r3, 8018856 <__strtok_r+0x46>
 8018838:	f814 3b01 	ldrb.w	r3, [r4], #1
 801883c:	42ab      	cmp	r3, r5
 801883e:	d1fa      	bne.n	8018836 <__strtok_r+0x26>
 8018840:	b15d      	cbz	r5, 801885a <__strtok_r+0x4a>
 8018842:	2300      	movs	r3, #0
 8018844:	703b      	strb	r3, [r7, #0]
 8018846:	6016      	str	r6, [r2, #0]
 8018848:	4606      	mov	r6, r0
 801884a:	4630      	mov	r0, r6
 801884c:	bcf0      	pop	{r4, r5, r6, r7}
 801884e:	4770      	bx	lr
 8018850:	b163      	cbz	r3, 801886c <__strtok_r+0x5c>
 8018852:	4638      	mov	r0, r7
 8018854:	e7de      	b.n	8018814 <__strtok_r+0x4>
 8018856:	4637      	mov	r7, r6
 8018858:	e7e8      	b.n	801882c <__strtok_r+0x1c>
 801885a:	462e      	mov	r6, r5
 801885c:	e7f3      	b.n	8018846 <__strtok_r+0x36>
 801885e:	6810      	ldr	r0, [r2, #0]
 8018860:	2800      	cmp	r0, #0
 8018862:	d1d7      	bne.n	8018814 <__strtok_r+0x4>
 8018864:	4606      	mov	r6, r0
 8018866:	e7f0      	b.n	801884a <__strtok_r+0x3a>
 8018868:	6016      	str	r6, [r2, #0]
 801886a:	e7ee      	b.n	801884a <__strtok_r+0x3a>
 801886c:	6017      	str	r7, [r2, #0]
 801886e:	4606      	mov	r6, r0
 8018870:	7003      	strb	r3, [r0, #0]
 8018872:	e7ea      	b.n	801884a <__strtok_r+0x3a>
	...

08018880 <strtok_r>:
 8018880:	2301      	movs	r3, #1
 8018882:	f7ff bfc5 	b.w	8018810 <__strtok_r>
 8018886:	bf00      	nop
	...

08018890 <_strtol_r>:
 8018890:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8018894:	4c42      	ldr	r4, [pc, #264]	; (80189a0 <_strtol_r+0x110>)
 8018896:	b082      	sub	sp, #8
 8018898:	f8d4 c000 	ldr.w	ip, [r4]
 801889c:	9001      	str	r0, [sp, #4]
 801889e:	460e      	mov	r6, r1
 80188a0:	e000      	b.n	80188a4 <_strtol_r+0x14>
 80188a2:	4626      	mov	r6, r4
 80188a4:	4634      	mov	r4, r6
 80188a6:	f814 5b01 	ldrb.w	r5, [r4], #1
 80188aa:	eb0c 0005 	add.w	r0, ip, r5
 80188ae:	7840      	ldrb	r0, [r0, #1]
 80188b0:	f000 0008 	and.w	r0, r0, #8
 80188b4:	f000 0aff 	and.w	sl, r0, #255	; 0xff
 80188b8:	2800      	cmp	r0, #0
 80188ba:	d1f2      	bne.n	80188a2 <_strtol_r+0x12>
 80188bc:	2d2d      	cmp	r5, #45	; 0x2d
 80188be:	d05b      	beq.n	8018978 <_strtol_r+0xe8>
 80188c0:	2d2b      	cmp	r5, #43	; 0x2b
 80188c2:	bf04      	itt	eq
 80188c4:	7875      	ldrbeq	r5, [r6, #1]
 80188c6:	1cb4      	addeq	r4, r6, #2
 80188c8:	f033 0010 	bics.w	r0, r3, #16
 80188cc:	d03c      	beq.n	8018948 <_strtol_r+0xb8>
 80188ce:	4699      	mov	r9, r3
 80188d0:	f1ba 0f00 	cmp.w	sl, #0
 80188d4:	bf0c      	ite	eq
 80188d6:	f06f 4b00 	mvneq.w	fp, #2147483648	; 0x80000000
 80188da:	f04f 4b00 	movne.w	fp, #2147483648	; 0x80000000
 80188de:	fbbb f8f9 	udiv	r8, fp, r9
 80188e2:	2700      	movs	r7, #0
 80188e4:	fb09 bb18 	mls	fp, r9, r8, fp
 80188e8:	4638      	mov	r0, r7
 80188ea:	e00c      	b.n	8018906 <_strtol_r+0x76>
 80188ec:	3d30      	subs	r5, #48	; 0x30
 80188ee:	42ab      	cmp	r3, r5
 80188f0:	dd19      	ble.n	8018926 <_strtol_r+0x96>
 80188f2:	1c7e      	adds	r6, r7, #1
 80188f4:	d005      	beq.n	8018902 <_strtol_r+0x72>
 80188f6:	4540      	cmp	r0, r8
 80188f8:	d823      	bhi.n	8018942 <_strtol_r+0xb2>
 80188fa:	d020      	beq.n	801893e <_strtol_r+0xae>
 80188fc:	fb09 5000 	mla	r0, r9, r0, r5
 8018900:	2701      	movs	r7, #1
 8018902:	f814 5b01 	ldrb.w	r5, [r4], #1
 8018906:	eb0c 0605 	add.w	r6, ip, r5
 801890a:	7876      	ldrb	r6, [r6, #1]
 801890c:	f016 0f04 	tst.w	r6, #4
 8018910:	d1ec      	bne.n	80188ec <_strtol_r+0x5c>
 8018912:	f016 0603 	ands.w	r6, r6, #3
 8018916:	d006      	beq.n	8018926 <_strtol_r+0x96>
 8018918:	2e01      	cmp	r6, #1
 801891a:	bf14      	ite	ne
 801891c:	2657      	movne	r6, #87	; 0x57
 801891e:	2637      	moveq	r6, #55	; 0x37
 8018920:	1bad      	subs	r5, r5, r6
 8018922:	42ab      	cmp	r3, r5
 8018924:	dce5      	bgt.n	80188f2 <_strtol_r+0x62>
 8018926:	1c7b      	adds	r3, r7, #1
 8018928:	d015      	beq.n	8018956 <_strtol_r+0xc6>
 801892a:	f1ba 0f00 	cmp.w	sl, #0
 801892e:	d121      	bne.n	8018974 <_strtol_r+0xe4>
 8018930:	b10a      	cbz	r2, 8018936 <_strtol_r+0xa6>
 8018932:	b9ef      	cbnz	r7, 8018970 <_strtol_r+0xe0>
 8018934:	6011      	str	r1, [r2, #0]
 8018936:	b002      	add	sp, #8
 8018938:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801893c:	4770      	bx	lr
 801893e:	455d      	cmp	r5, fp
 8018940:	dddc      	ble.n	80188fc <_strtol_r+0x6c>
 8018942:	f04f 37ff 	mov.w	r7, #4294967295
 8018946:	e7dc      	b.n	8018902 <_strtol_r+0x72>
 8018948:	2d30      	cmp	r5, #48	; 0x30
 801894a:	d01a      	beq.n	8018982 <_strtol_r+0xf2>
 801894c:	2b00      	cmp	r3, #0
 801894e:	d1be      	bne.n	80188ce <_strtol_r+0x3e>
 8018950:	230a      	movs	r3, #10
 8018952:	4699      	mov	r9, r3
 8018954:	e7bc      	b.n	80188d0 <_strtol_r+0x40>
 8018956:	9901      	ldr	r1, [sp, #4]
 8018958:	f1ba 0f00 	cmp.w	sl, #0
 801895c:	f04f 0322 	mov.w	r3, #34	; 0x22
 8018960:	bf0c      	ite	eq
 8018962:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8018966:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 801896a:	600b      	str	r3, [r1, #0]
 801896c:	2a00      	cmp	r2, #0
 801896e:	d0e2      	beq.n	8018936 <_strtol_r+0xa6>
 8018970:	1e61      	subs	r1, r4, #1
 8018972:	e7df      	b.n	8018934 <_strtol_r+0xa4>
 8018974:	4240      	negs	r0, r0
 8018976:	e7db      	b.n	8018930 <_strtol_r+0xa0>
 8018978:	1cb4      	adds	r4, r6, #2
 801897a:	7875      	ldrb	r5, [r6, #1]
 801897c:	f04f 0a01 	mov.w	sl, #1
 8018980:	e7a2      	b.n	80188c8 <_strtol_r+0x38>
 8018982:	7820      	ldrb	r0, [r4, #0]
 8018984:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8018988:	2858      	cmp	r0, #88	; 0x58
 801898a:	d003      	beq.n	8018994 <_strtol_r+0x104>
 801898c:	2b00      	cmp	r3, #0
 801898e:	d19e      	bne.n	80188ce <_strtol_r+0x3e>
 8018990:	2308      	movs	r3, #8
 8018992:	e79c      	b.n	80188ce <_strtol_r+0x3e>
 8018994:	2310      	movs	r3, #16
 8018996:	7865      	ldrb	r5, [r4, #1]
 8018998:	4699      	mov	r9, r3
 801899a:	3402      	adds	r4, #2
 801899c:	e798      	b.n	80188d0 <_strtol_r+0x40>
 801899e:	bf00      	nop
 80189a0:	20000918 	.word	0x20000918
	...

080189b0 <strtol>:
 80189b0:	b430      	push	{r4, r5}
 80189b2:	4c04      	ldr	r4, [pc, #16]	; (80189c4 <strtol+0x14>)
 80189b4:	460d      	mov	r5, r1
 80189b6:	4613      	mov	r3, r2
 80189b8:	4601      	mov	r1, r0
 80189ba:	462a      	mov	r2, r5
 80189bc:	6820      	ldr	r0, [r4, #0]
 80189be:	bc30      	pop	{r4, r5}
 80189c0:	f7ff bf66 	b.w	8018890 <_strtol_r>
 80189c4:	20000d88 	.word	0x20000d88
	...

080189d0 <_strtoul_r>:
 80189d0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80189d4:	4c44      	ldr	r4, [pc, #272]	; (8018ae8 <_strtoul_r+0x118>)
 80189d6:	b082      	sub	sp, #8
 80189d8:	f8d4 c000 	ldr.w	ip, [r4]
 80189dc:	9001      	str	r0, [sp, #4]
 80189de:	460e      	mov	r6, r1
 80189e0:	e000      	b.n	80189e4 <_strtoul_r+0x14>
 80189e2:	4626      	mov	r6, r4
 80189e4:	4634      	mov	r4, r6
 80189e6:	f814 5b01 	ldrb.w	r5, [r4], #1
 80189ea:	eb0c 0005 	add.w	r0, ip, r5
 80189ee:	7840      	ldrb	r0, [r0, #1]
 80189f0:	f000 0008 	and.w	r0, r0, #8
 80189f4:	f000 07ff 	and.w	r7, r0, #255	; 0xff
 80189f8:	2800      	cmp	r0, #0
 80189fa:	d1f2      	bne.n	80189e2 <_strtoul_r+0x12>
 80189fc:	2d2d      	cmp	r5, #45	; 0x2d
 80189fe:	d057      	beq.n	8018ab0 <_strtoul_r+0xe0>
 8018a00:	2d2b      	cmp	r5, #43	; 0x2b
 8018a02:	bf08      	it	eq
 8018a04:	7875      	ldrbeq	r5, [r6, #1]
 8018a06:	46ba      	mov	sl, r7
 8018a08:	bf08      	it	eq
 8018a0a:	1cb4      	addeq	r4, r6, #2
 8018a0c:	f033 0010 	bics.w	r0, r3, #16
 8018a10:	d039      	beq.n	8018a86 <_strtoul_r+0xb6>
 8018a12:	f04f 38ff 	mov.w	r8, #4294967295
 8018a16:	fbb8 f8f3 	udiv	r8, r8, r3
 8018a1a:	fb03 fb08 	mul.w	fp, r3, r8
 8018a1e:	ea6f 0b0b 	mvn.w	fp, fp
 8018a22:	4699      	mov	r9, r3
 8018a24:	2700      	movs	r7, #0
 8018a26:	4638      	mov	r0, r7
 8018a28:	e00c      	b.n	8018a44 <_strtoul_r+0x74>
 8018a2a:	3d30      	subs	r5, #48	; 0x30
 8018a2c:	42ab      	cmp	r3, r5
 8018a2e:	dd19      	ble.n	8018a64 <_strtoul_r+0x94>
 8018a30:	2f00      	cmp	r7, #0
 8018a32:	db25      	blt.n	8018a80 <_strtoul_r+0xb0>
 8018a34:	4540      	cmp	r0, r8
 8018a36:	d823      	bhi.n	8018a80 <_strtoul_r+0xb0>
 8018a38:	d020      	beq.n	8018a7c <_strtoul_r+0xac>
 8018a3a:	fb09 5000 	mla	r0, r9, r0, r5
 8018a3e:	2701      	movs	r7, #1
 8018a40:	f814 5b01 	ldrb.w	r5, [r4], #1
 8018a44:	eb0c 0605 	add.w	r6, ip, r5
 8018a48:	7876      	ldrb	r6, [r6, #1]
 8018a4a:	f016 0f04 	tst.w	r6, #4
 8018a4e:	d1ec      	bne.n	8018a2a <_strtoul_r+0x5a>
 8018a50:	f016 0603 	ands.w	r6, r6, #3
 8018a54:	d006      	beq.n	8018a64 <_strtoul_r+0x94>
 8018a56:	2e01      	cmp	r6, #1
 8018a58:	bf14      	ite	ne
 8018a5a:	2657      	movne	r6, #87	; 0x57
 8018a5c:	2637      	moveq	r6, #55	; 0x37
 8018a5e:	1bad      	subs	r5, r5, r6
 8018a60:	42ab      	cmp	r3, r5
 8018a62:	dce5      	bgt.n	8018a30 <_strtoul_r+0x60>
 8018a64:	2f00      	cmp	r7, #0
 8018a66:	db1d      	blt.n	8018aa4 <_strtoul_r+0xd4>
 8018a68:	f1ba 0f00 	cmp.w	sl, #0
 8018a6c:	d118      	bne.n	8018aa0 <_strtoul_r+0xd0>
 8018a6e:	b10a      	cbz	r2, 8018a74 <_strtoul_r+0xa4>
 8018a70:	b9a7      	cbnz	r7, 8018a9c <_strtoul_r+0xcc>
 8018a72:	6011      	str	r1, [r2, #0]
 8018a74:	b002      	add	sp, #8
 8018a76:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8018a7a:	4770      	bx	lr
 8018a7c:	455d      	cmp	r5, fp
 8018a7e:	dddc      	ble.n	8018a3a <_strtoul_r+0x6a>
 8018a80:	f04f 37ff 	mov.w	r7, #4294967295
 8018a84:	e7dc      	b.n	8018a40 <_strtoul_r+0x70>
 8018a86:	2d30      	cmp	r5, #48	; 0x30
 8018a88:	d017      	beq.n	8018aba <_strtoul_r+0xea>
 8018a8a:	2b00      	cmp	r3, #0
 8018a8c:	d1c1      	bne.n	8018a12 <_strtoul_r+0x42>
 8018a8e:	230a      	movs	r3, #10
 8018a90:	4699      	mov	r9, r3
 8018a92:	f04f 0b05 	mov.w	fp, #5
 8018a96:	f8df 8054 	ldr.w	r8, [pc, #84]	; 8018aec <_strtoul_r+0x11c>
 8018a9a:	e7c3      	b.n	8018a24 <_strtoul_r+0x54>
 8018a9c:	1e61      	subs	r1, r4, #1
 8018a9e:	e7e8      	b.n	8018a72 <_strtoul_r+0xa2>
 8018aa0:	4240      	negs	r0, r0
 8018aa2:	e7e4      	b.n	8018a6e <_strtoul_r+0x9e>
 8018aa4:	9801      	ldr	r0, [sp, #4]
 8018aa6:	2322      	movs	r3, #34	; 0x22
 8018aa8:	6003      	str	r3, [r0, #0]
 8018aaa:	f04f 30ff 	mov.w	r0, #4294967295
 8018aae:	e7de      	b.n	8018a6e <_strtoul_r+0x9e>
 8018ab0:	1cb4      	adds	r4, r6, #2
 8018ab2:	7875      	ldrb	r5, [r6, #1]
 8018ab4:	f04f 0a01 	mov.w	sl, #1
 8018ab8:	e7a8      	b.n	8018a0c <_strtoul_r+0x3c>
 8018aba:	7820      	ldrb	r0, [r4, #0]
 8018abc:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8018ac0:	2858      	cmp	r0, #88	; 0x58
 8018ac2:	d008      	beq.n	8018ad6 <_strtoul_r+0x106>
 8018ac4:	2b00      	cmp	r3, #0
 8018ac6:	d1a4      	bne.n	8018a12 <_strtoul_r+0x42>
 8018ac8:	2308      	movs	r3, #8
 8018aca:	4699      	mov	r9, r3
 8018acc:	f04f 0b07 	mov.w	fp, #7
 8018ad0:	f06f 4860 	mvn.w	r8, #3758096384	; 0xe0000000
 8018ad4:	e7a6      	b.n	8018a24 <_strtoul_r+0x54>
 8018ad6:	2310      	movs	r3, #16
 8018ad8:	7865      	ldrb	r5, [r4, #1]
 8018ada:	4699      	mov	r9, r3
 8018adc:	f04f 0b0f 	mov.w	fp, #15
 8018ae0:	3402      	adds	r4, #2
 8018ae2:	f06f 4870 	mvn.w	r8, #4026531840	; 0xf0000000
 8018ae6:	e79d      	b.n	8018a24 <_strtoul_r+0x54>
 8018ae8:	20000918 	.word	0x20000918
 8018aec:	19999999 	.word	0x19999999

08018af0 <strtoul>:
 8018af0:	b430      	push	{r4, r5}
 8018af2:	4c04      	ldr	r4, [pc, #16]	; (8018b04 <strtoul+0x14>)
 8018af4:	460d      	mov	r5, r1
 8018af6:	4613      	mov	r3, r2
 8018af8:	4601      	mov	r1, r0
 8018afa:	462a      	mov	r2, r5
 8018afc:	6820      	ldr	r0, [r4, #0]
 8018afe:	bc30      	pop	{r4, r5}
 8018b00:	f7ff bf66 	b.w	80189d0 <_strtoul_r>
 8018b04:	20000d88 	.word	0x20000d88
	...

08018b10 <__get_current_time_locale>:
 8018b10:	4b04      	ldr	r3, [pc, #16]	; (8018b24 <__get_current_time_locale+0x14>)
 8018b12:	4a05      	ldr	r2, [pc, #20]	; (8018b28 <__get_current_time_locale+0x18>)
 8018b14:	6818      	ldr	r0, [r3, #0]
 8018b16:	4b05      	ldr	r3, [pc, #20]	; (8018b2c <__get_current_time_locale+0x1c>)
 8018b18:	2800      	cmp	r0, #0
 8018b1a:	bf0c      	ite	eq
 8018b1c:	4610      	moveq	r0, r2
 8018b1e:	4618      	movne	r0, r3
 8018b20:	4770      	bx	lr
 8018b22:	bf00      	nop
 8018b24:	20003858 	.word	0x20003858
 8018b28:	0801c240 	.word	0x0801c240
 8018b2c:	20003860 	.word	0x20003860

08018b30 <__time_load_locale>:
 8018b30:	b500      	push	{lr}
 8018b32:	b085      	sub	sp, #20
 8018b34:	4b06      	ldr	r3, [pc, #24]	; (8018b50 <__time_load_locale+0x20>)
 8018b36:	4a07      	ldr	r2, [pc, #28]	; (8018b54 <__time_load_locale+0x24>)
 8018b38:	9302      	str	r3, [sp, #8]
 8018b3a:	233f      	movs	r3, #63	; 0x3f
 8018b3c:	9300      	str	r3, [sp, #0]
 8018b3e:	9301      	str	r3, [sp, #4]
 8018b40:	6812      	ldr	r2, [r2, #0]
 8018b42:	4905      	ldr	r1, [pc, #20]	; (8018b58 <__time_load_locale+0x28>)
 8018b44:	4b05      	ldr	r3, [pc, #20]	; (8018b5c <__time_load_locale+0x2c>)
 8018b46:	f000 f833 	bl	8018bb0 <__part_load_locale>
 8018b4a:	b005      	add	sp, #20
 8018b4c:	f85d fb04 	ldr.w	pc, [sp], #4
 8018b50:	20003860 	.word	0x20003860
 8018b54:	2000385c 	.word	0x2000385c
 8018b58:	20003858 	.word	0x20003858
 8018b5c:	0801c340 	.word	0x0801c340

08018b60 <__tz_lock>:
 8018b60:	4770      	bx	lr
 8018b62:	bf00      	nop
	...

08018b70 <__tz_unlock>:
 8018b70:	4770      	bx	lr
 8018b72:	bf00      	nop
	...

08018b80 <abs>:
 8018b80:	2800      	cmp	r0, #0
 8018b82:	bfb8      	it	lt
 8018b84:	4240      	neglt	r0, r0
 8018b86:	4770      	bx	lr
	...

08018b90 <__gettzinfo>:
 8018b90:	4800      	ldr	r0, [pc, #0]	; (8018b94 <__gettzinfo+0x4>)
 8018b92:	4770      	bx	lr
 8018b94:	2000091c 	.word	0x2000091c
	...

08018ba0 <labs>:
 8018ba0:	2800      	cmp	r0, #0
 8018ba2:	bfb8      	it	lt
 8018ba4:	4240      	neglt	r0, r0
 8018ba6:	4770      	bx	lr
	...

08018bb0 <__part_load_locale>:
 8018bb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018bb4:	460f      	mov	r7, r1
 8018bb6:	f2ad 4d4c 	subw	sp, sp, #1100	; 0x44c
 8018bba:	2100      	movs	r1, #0
 8018bbc:	f8d7 a000 	ldr.w	sl, [r7]
 8018bc0:	f8dd 6478 	ldr.w	r6, [sp, #1144]	; 0x478
 8018bc4:	6039      	str	r1, [r7, #0]
 8018bc6:	4615      	mov	r5, r2
 8018bc8:	461c      	mov	r4, r3
 8018bca:	4681      	mov	r9, r0
 8018bcc:	2800      	cmp	r0, #0
 8018bce:	f000 80a2 	beq.w	8018d16 <__part_load_locale+0x166>
 8018bd2:	4967      	ldr	r1, [pc, #412]	; (8018d70 <__part_load_locale+0x1c0>)
 8018bd4:	f7fe fda4 	bl	8017720 <strcmp>
 8018bd8:	b930      	cbnz	r0, 8018be8 <__part_load_locale+0x38>
 8018bda:	f04f 0800 	mov.w	r8, #0
 8018bde:	4640      	mov	r0, r8
 8018be0:	f20d 4d4c 	addw	sp, sp, #1100	; 0x44c
 8018be4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018be8:	4648      	mov	r0, r9
 8018bea:	4962      	ldr	r1, [pc, #392]	; (8018d74 <__part_load_locale+0x1c4>)
 8018bec:	f7fe fd98 	bl	8017720 <strcmp>
 8018bf0:	2800      	cmp	r0, #0
 8018bf2:	d0f2      	beq.n	8018bda <__part_load_locale+0x2a>
 8018bf4:	b13d      	cbz	r5, 8018c06 <__part_load_locale+0x56>
 8018bf6:	4648      	mov	r0, r9
 8018bf8:	4629      	mov	r1, r5
 8018bfa:	f7fe fd91 	bl	8017720 <strcmp>
 8018bfe:	4680      	mov	r8, r0
 8018c00:	2800      	cmp	r0, #0
 8018c02:	f000 809e 	beq.w	8018d42 <__part_load_locale+0x192>
 8018c06:	4648      	mov	r0, r9
 8018c08:	f7ff fd82 	bl	8018710 <strlen>
 8018c0c:	4b5a      	ldr	r3, [pc, #360]	; (8018d78 <__part_load_locale+0x1c8>)
 8018c0e:	6819      	ldr	r1, [r3, #0]
 8018c10:	f100 0801 	add.w	r8, r0, #1
 8018c14:	2900      	cmp	r1, #0
 8018c16:	d07e      	beq.n	8018d16 <__part_load_locale+0x166>
 8018c18:	a812      	add	r0, sp, #72	; 0x48
 8018c1a:	f7fe ff31 	bl	8017a80 <strcpy>
 8018c1e:	4957      	ldr	r1, [pc, #348]	; (8018d7c <__part_load_locale+0x1cc>)
 8018c20:	a812      	add	r0, sp, #72	; 0x48
 8018c22:	f7fe ff05 	bl	8017a30 <strcat>
 8018c26:	4649      	mov	r1, r9
 8018c28:	a812      	add	r0, sp, #72	; 0x48
 8018c2a:	f7fe ff01 	bl	8017a30 <strcat>
 8018c2e:	4953      	ldr	r1, [pc, #332]	; (8018d7c <__part_load_locale+0x1cc>)
 8018c30:	a812      	add	r0, sp, #72	; 0x48
 8018c32:	f7fe fefd 	bl	8017a30 <strcat>
 8018c36:	4621      	mov	r1, r4
 8018c38:	a812      	add	r0, sp, #72	; 0x48
 8018c3a:	f7fe fef9 	bl	8017a30 <strcat>
 8018c3e:	a812      	add	r0, sp, #72	; 0x48
 8018c40:	2100      	movs	r1, #0
 8018c42:	f001 fcc5 	bl	801a5d0 <open>
 8018c46:	1e03      	subs	r3, r0, #0
 8018c48:	9301      	str	r3, [sp, #4]
 8018c4a:	db64      	blt.n	8018d16 <__part_load_locale+0x166>
 8018c4c:	a903      	add	r1, sp, #12
 8018c4e:	f001 fcb7 	bl	801a5c0 <fstat>
 8018c52:	2800      	cmp	r0, #0
 8018c54:	d15c      	bne.n	8018d10 <__part_load_locale+0x160>
 8018c56:	9907      	ldr	r1, [sp, #28]
 8018c58:	2900      	cmp	r1, #0
 8018c5a:	dd59      	ble.n	8018d10 <__part_load_locale+0x160>
 8018c5c:	4441      	add	r1, r8
 8018c5e:	2d00      	cmp	r5, #0
 8018c60:	d068      	beq.n	8018d34 <__part_load_locale+0x184>
 8018c62:	4b47      	ldr	r3, [pc, #284]	; (8018d80 <__part_load_locale+0x1d0>)
 8018c64:	429d      	cmp	r5, r3
 8018c66:	d065      	beq.n	8018d34 <__part_load_locale+0x184>
 8018c68:	4628      	mov	r0, r5
 8018c6a:	f000 fba9 	bl	80193c0 <realloc>
 8018c6e:	4604      	mov	r4, r0
 8018c70:	2800      	cmp	r0, #0
 8018c72:	d079      	beq.n	8018d68 <__part_load_locale+0x1b8>
 8018c74:	4649      	mov	r1, r9
 8018c76:	4620      	mov	r0, r4
 8018c78:	f7fe ff02 	bl	8017a80 <strcpy>
 8018c7c:	9b07      	ldr	r3, [sp, #28]
 8018c7e:	9801      	ldr	r0, [sp, #4]
 8018c80:	eb04 0508 	add.w	r5, r4, r8
 8018c84:	461a      	mov	r2, r3
 8018c86:	4629      	mov	r1, r5
 8018c88:	eb05 0903 	add.w	r9, r5, r3
 8018c8c:	f001 fcb8 	bl	801a600 <read>
 8018c90:	9b07      	ldr	r3, [sp, #28]
 8018c92:	4298      	cmp	r0, r3
 8018c94:	d139      	bne.n	8018d0a <__part_load_locale+0x15a>
 8018c96:	9801      	ldr	r0, [sp, #4]
 8018c98:	f001 fc8a 	bl	801a5b0 <close>
 8018c9c:	4680      	mov	r8, r0
 8018c9e:	bba0      	cbnz	r0, 8018d0a <__part_load_locale+0x15a>
 8018ca0:	f819 3c01 	ldrb.w	r3, [r9, #-1]
 8018ca4:	2b0a      	cmp	r3, #10
 8018ca6:	d130      	bne.n	8018d0a <__part_load_locale+0x15a>
 8018ca8:	454d      	cmp	r5, r9
 8018caa:	4683      	mov	fp, r0
 8018cac:	d20b      	bcs.n	8018cc6 <__part_load_locale+0x116>
 8018cae:	4682      	mov	sl, r0
 8018cb0:	4628      	mov	r0, r5
 8018cb2:	210a      	movs	r1, #10
 8018cb4:	f000 fddc 	bl	8019870 <strchr>
 8018cb8:	1c45      	adds	r5, r0, #1
 8018cba:	45a9      	cmp	r9, r5
 8018cbc:	f10b 0b01 	add.w	fp, fp, #1
 8018cc0:	f880 a000 	strb.w	sl, [r0]
 8018cc4:	d8f4      	bhi.n	8018cb0 <__part_load_locale+0x100>
 8018cc6:	f8dd 2470 	ldr.w	r2, [sp, #1136]	; 0x470
 8018cca:	4593      	cmp	fp, r2
 8018ccc:	db28      	blt.n	8018d20 <__part_load_locale+0x170>
 8018cce:	4b2d      	ldr	r3, [pc, #180]	; (8018d84 <__part_load_locale+0x1d4>)
 8018cd0:	4691      	mov	r9, r2
 8018cd2:	601a      	str	r2, [r3, #0]
 8018cd4:	f1b9 0f00 	cmp.w	r9, #0
 8018cd8:	bfc8      	it	gt
 8018cda:	2500      	movgt	r5, #0
 8018cdc:	dd09      	ble.n	8018cf2 <__part_load_locale+0x142>
 8018cde:	4620      	mov	r0, r4
 8018ce0:	f7ff fd16 	bl	8018710 <strlen>
 8018ce4:	3501      	adds	r5, #1
 8018ce6:	3001      	adds	r0, #1
 8018ce8:	4404      	add	r4, r0
 8018cea:	454d      	cmp	r5, r9
 8018cec:	f846 4b04 	str.w	r4, [r6], #4
 8018cf0:	d1f5      	bne.n	8018cde <__part_load_locale+0x12e>
 8018cf2:	2301      	movs	r3, #1
 8018cf4:	4640      	mov	r0, r8
 8018cf6:	603b      	str	r3, [r7, #0]
 8018cf8:	f20d 4d4c 	addw	sp, sp, #1100	; 0x44c
 8018cfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018d00:	4a20      	ldr	r2, [pc, #128]	; (8018d84 <__part_load_locale+0x1d4>)
 8018d02:	f04f 0a00 	mov.w	sl, #0
 8018d06:	f8c2 b000 	str.w	fp, [r2]
 8018d0a:	4620      	mov	r0, r4
 8018d0c:	f000 f8a0 	bl	8018e50 <free>
 8018d10:	9801      	ldr	r0, [sp, #4]
 8018d12:	f001 fc4d 	bl	801a5b0 <close>
 8018d16:	f8c7 a000 	str.w	sl, [r7]
 8018d1a:	f04f 38ff 	mov.w	r8, #4294967295
 8018d1e:	e75e      	b.n	8018bde <__part_load_locale+0x2e>
 8018d20:	f8dd 3474 	ldr.w	r3, [sp, #1140]	; 0x474
 8018d24:	459b      	cmp	fp, r3
 8018d26:	dbeb      	blt.n	8018d00 <__part_load_locale+0x150>
 8018d28:	4b16      	ldr	r3, [pc, #88]	; (8018d84 <__part_load_locale+0x1d4>)
 8018d2a:	f8dd 9474 	ldr.w	r9, [sp, #1140]	; 0x474
 8018d2e:	f8c3 9000 	str.w	r9, [r3]
 8018d32:	e7cf      	b.n	8018cd4 <__part_load_locale+0x124>
 8018d34:	4608      	mov	r0, r1
 8018d36:	f000 f883 	bl	8018e40 <malloc>
 8018d3a:	4604      	mov	r4, r0
 8018d3c:	2800      	cmp	r0, #0
 8018d3e:	d199      	bne.n	8018c74 <__part_load_locale+0xc4>
 8018d40:	e7e6      	b.n	8018d10 <__part_load_locale+0x160>
 8018d42:	4b10      	ldr	r3, [pc, #64]	; (8018d84 <__part_load_locale+0x1d4>)
 8018d44:	f8d3 9000 	ldr.w	r9, [r3]
 8018d48:	f1b9 0f00 	cmp.w	r9, #0
 8018d4c:	bfc8      	it	gt
 8018d4e:	4604      	movgt	r4, r0
 8018d50:	ddcf      	ble.n	8018cf2 <__part_load_locale+0x142>
 8018d52:	4628      	mov	r0, r5
 8018d54:	f7ff fcdc 	bl	8018710 <strlen>
 8018d58:	3401      	adds	r4, #1
 8018d5a:	3001      	adds	r0, #1
 8018d5c:	4405      	add	r5, r0
 8018d5e:	454c      	cmp	r4, r9
 8018d60:	f846 5b04 	str.w	r5, [r6], #4
 8018d64:	d1f5      	bne.n	8018d52 <__part_load_locale+0x1a2>
 8018d66:	e7c4      	b.n	8018cf2 <__part_load_locale+0x142>
 8018d68:	4628      	mov	r0, r5
 8018d6a:	f000 f871 	bl	8018e50 <free>
 8018d6e:	e7cf      	b.n	8018d10 <__part_load_locale+0x160>
 8018d70:	0801c5c0 	.word	0x0801c5c0
 8018d74:	0801c5e0 	.word	0x0801c5e0
 8018d78:	20003968 	.word	0x20003968
 8018d7c:	0801c5e8 	.word	0x0801c5e8
 8018d80:	20000d8c 	.word	0x20000d8c
 8018d84:	20003964 	.word	0x20003964
	...

08018d90 <_setlocale_r>:
 8018d90:	b510      	push	{r4, lr}
 8018d92:	4614      	mov	r4, r2
 8018d94:	b122      	cbz	r2, 8018da0 <_setlocale_r+0x10>
 8018d96:	4610      	mov	r0, r2
 8018d98:	490a      	ldr	r1, [pc, #40]	; (8018dc4 <_setlocale_r+0x34>)
 8018d9a:	f7fe fcc1 	bl	8017720 <strcmp>
 8018d9e:	b908      	cbnz	r0, 8018da4 <_setlocale_r+0x14>
 8018da0:	4809      	ldr	r0, [pc, #36]	; (8018dc8 <_setlocale_r+0x38>)
 8018da2:	bd10      	pop	{r4, pc}
 8018da4:	4620      	mov	r0, r4
 8018da6:	4908      	ldr	r1, [pc, #32]	; (8018dc8 <_setlocale_r+0x38>)
 8018da8:	f7fe fcba 	bl	8017720 <strcmp>
 8018dac:	2800      	cmp	r0, #0
 8018dae:	d0f7      	beq.n	8018da0 <_setlocale_r+0x10>
 8018db0:	4620      	mov	r0, r4
 8018db2:	4906      	ldr	r1, [pc, #24]	; (8018dcc <_setlocale_r+0x3c>)
 8018db4:	f7fe fcb4 	bl	8017720 <strcmp>
 8018db8:	4b03      	ldr	r3, [pc, #12]	; (8018dc8 <_setlocale_r+0x38>)
 8018dba:	2800      	cmp	r0, #0
 8018dbc:	bf0c      	ite	eq
 8018dbe:	4618      	moveq	r0, r3
 8018dc0:	2000      	movne	r0, #0
 8018dc2:	bd10      	pop	{r4, pc}
 8018dc4:	0801c5e0 	.word	0x0801c5e0
 8018dc8:	0801c5c0 	.word	0x0801c5c0
 8018dcc:	0801c620 	.word	0x0801c620

08018dd0 <__locale_charset>:
 8018dd0:	4800      	ldr	r0, [pc, #0]	; (8018dd4 <__locale_charset+0x4>)
 8018dd2:	4770      	bx	lr
 8018dd4:	20000de8 	.word	0x20000de8
	...

08018de0 <__locale_mb_cur_max>:
 8018de0:	4b01      	ldr	r3, [pc, #4]	; (8018de8 <__locale_mb_cur_max+0x8>)
 8018de2:	6818      	ldr	r0, [r3, #0]
 8018de4:	4770      	bx	lr
 8018de6:	bf00      	nop
 8018de8:	20000e08 	.word	0x20000e08
 8018dec:	00000000 	.word	0x00000000

08018df0 <__locale_msgcharset>:
 8018df0:	4800      	ldr	r0, [pc, #0]	; (8018df4 <__locale_msgcharset+0x4>)
 8018df2:	4770      	bx	lr
 8018df4:	20000d90 	.word	0x20000d90
	...

08018e00 <__locale_cjk_lang>:
 8018e00:	2000      	movs	r0, #0
 8018e02:	4770      	bx	lr
	...

08018e10 <_localeconv_r>:
 8018e10:	4800      	ldr	r0, [pc, #0]	; (8018e14 <_localeconv_r+0x4>)
 8018e12:	4770      	bx	lr
 8018e14:	20000db0 	.word	0x20000db0
	...

08018e20 <setlocale>:
 8018e20:	4b02      	ldr	r3, [pc, #8]	; (8018e2c <setlocale+0xc>)
 8018e22:	460a      	mov	r2, r1
 8018e24:	4601      	mov	r1, r0
 8018e26:	6818      	ldr	r0, [r3, #0]
 8018e28:	f7ff bfb2 	b.w	8018d90 <_setlocale_r>
 8018e2c:	20000d88 	.word	0x20000d88

08018e30 <localeconv>:
 8018e30:	4800      	ldr	r0, [pc, #0]	; (8018e34 <localeconv+0x4>)
 8018e32:	4770      	bx	lr
 8018e34:	20000db0 	.word	0x20000db0
	...

08018e40 <malloc>:
 8018e40:	4b02      	ldr	r3, [pc, #8]	; (8018e4c <malloc+0xc>)
 8018e42:	4601      	mov	r1, r0
 8018e44:	6818      	ldr	r0, [r3, #0]
 8018e46:	f000 b80b 	b.w	8018e60 <_malloc_r>
 8018e4a:	bf00      	nop
 8018e4c:	20000d88 	.word	0x20000d88

08018e50 <free>:
 8018e50:	4b02      	ldr	r3, [pc, #8]	; (8018e5c <free+0xc>)
 8018e52:	4601      	mov	r1, r0
 8018e54:	6818      	ldr	r0, [r3, #0]
 8018e56:	f001 bc33 	b.w	801a6c0 <_free_r>
 8018e5a:	bf00      	nop
 8018e5c:	20000d88 	.word	0x20000d88

08018e60 <_malloc_r>:
 8018e60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018e64:	f101 050b 	add.w	r5, r1, #11
 8018e68:	2d16      	cmp	r5, #22
 8018e6a:	b083      	sub	sp, #12
 8018e6c:	4606      	mov	r6, r0
 8018e6e:	d927      	bls.n	8018ec0 <_malloc_r+0x60>
 8018e70:	f035 0507 	bics.w	r5, r5, #7
 8018e74:	d427      	bmi.n	8018ec6 <_malloc_r+0x66>
 8018e76:	42a9      	cmp	r1, r5
 8018e78:	d825      	bhi.n	8018ec6 <_malloc_r+0x66>
 8018e7a:	4630      	mov	r0, r6
 8018e7c:	f000 fa90 	bl	80193a0 <__malloc_lock>
 8018e80:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 8018e84:	d226      	bcs.n	8018ed4 <_malloc_r+0x74>
 8018e86:	4fc1      	ldr	r7, [pc, #772]	; (801918c <_malloc_r+0x32c>)
 8018e88:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
 8018e8c:	eb07 03cc 	add.w	r3, r7, ip, lsl #3
 8018e90:	68dc      	ldr	r4, [r3, #12]
 8018e92:	429c      	cmp	r4, r3
 8018e94:	f000 81d2 	beq.w	801923c <_malloc_r+0x3dc>
 8018e98:	6863      	ldr	r3, [r4, #4]
 8018e9a:	68e2      	ldr	r2, [r4, #12]
 8018e9c:	68a1      	ldr	r1, [r4, #8]
 8018e9e:	f023 0303 	bic.w	r3, r3, #3
 8018ea2:	4423      	add	r3, r4
 8018ea4:	4630      	mov	r0, r6
 8018ea6:	685d      	ldr	r5, [r3, #4]
 8018ea8:	60ca      	str	r2, [r1, #12]
 8018eaa:	f045 0501 	orr.w	r5, r5, #1
 8018eae:	6091      	str	r1, [r2, #8]
 8018eb0:	605d      	str	r5, [r3, #4]
 8018eb2:	f000 fa7d 	bl	80193b0 <__malloc_unlock>
 8018eb6:	3408      	adds	r4, #8
 8018eb8:	4620      	mov	r0, r4
 8018eba:	b003      	add	sp, #12
 8018ebc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018ec0:	2510      	movs	r5, #16
 8018ec2:	42a9      	cmp	r1, r5
 8018ec4:	d9d9      	bls.n	8018e7a <_malloc_r+0x1a>
 8018ec6:	2400      	movs	r4, #0
 8018ec8:	230c      	movs	r3, #12
 8018eca:	4620      	mov	r0, r4
 8018ecc:	6033      	str	r3, [r6, #0]
 8018ece:	b003      	add	sp, #12
 8018ed0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018ed4:	ea5f 2c55 	movs.w	ip, r5, lsr #9
 8018ed8:	f000 808a 	beq.w	8018ff0 <_malloc_r+0x190>
 8018edc:	f1bc 0f04 	cmp.w	ip, #4
 8018ee0:	f200 8160 	bhi.w	80191a4 <_malloc_r+0x344>
 8018ee4:	ea4f 1c95 	mov.w	ip, r5, lsr #6
 8018ee8:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
 8018eec:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8018ef0:	4fa6      	ldr	r7, [pc, #664]	; (801918c <_malloc_r+0x32c>)
 8018ef2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8018ef6:	68cc      	ldr	r4, [r1, #12]
 8018ef8:	42a1      	cmp	r1, r4
 8018efa:	d105      	bne.n	8018f08 <_malloc_r+0xa8>
 8018efc:	e00c      	b.n	8018f18 <_malloc_r+0xb8>
 8018efe:	2b00      	cmp	r3, #0
 8018f00:	da7a      	bge.n	8018ff8 <_malloc_r+0x198>
 8018f02:	68e4      	ldr	r4, [r4, #12]
 8018f04:	42a1      	cmp	r1, r4
 8018f06:	d007      	beq.n	8018f18 <_malloc_r+0xb8>
 8018f08:	6862      	ldr	r2, [r4, #4]
 8018f0a:	f022 0203 	bic.w	r2, r2, #3
 8018f0e:	1b53      	subs	r3, r2, r5
 8018f10:	2b0f      	cmp	r3, #15
 8018f12:	ddf4      	ble.n	8018efe <_malloc_r+0x9e>
 8018f14:	f10c 3cff 	add.w	ip, ip, #4294967295
 8018f18:	f10c 0c01 	add.w	ip, ip, #1
 8018f1c:	4b9b      	ldr	r3, [pc, #620]	; (801918c <_malloc_r+0x32c>)
 8018f1e:	693c      	ldr	r4, [r7, #16]
 8018f20:	f103 0e08 	add.w	lr, r3, #8
 8018f24:	4574      	cmp	r4, lr
 8018f26:	f000 817e 	beq.w	8019226 <_malloc_r+0x3c6>
 8018f2a:	6861      	ldr	r1, [r4, #4]
 8018f2c:	f021 0103 	bic.w	r1, r1, #3
 8018f30:	1b4a      	subs	r2, r1, r5
 8018f32:	2a0f      	cmp	r2, #15
 8018f34:	f300 8164 	bgt.w	8019200 <_malloc_r+0x3a0>
 8018f38:	2a00      	cmp	r2, #0
 8018f3a:	f8c3 e014 	str.w	lr, [r3, #20]
 8018f3e:	f8c3 e010 	str.w	lr, [r3, #16]
 8018f42:	da6a      	bge.n	801901a <_malloc_r+0x1ba>
 8018f44:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8018f48:	f080 813a 	bcs.w	80191c0 <_malloc_r+0x360>
 8018f4c:	08c9      	lsrs	r1, r1, #3
 8018f4e:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
 8018f52:	ea4f 08a1 	mov.w	r8, r1, asr #2
 8018f56:	685a      	ldr	r2, [r3, #4]
 8018f58:	6881      	ldr	r1, [r0, #8]
 8018f5a:	60a1      	str	r1, [r4, #8]
 8018f5c:	f04f 0901 	mov.w	r9, #1
 8018f60:	fa09 f808 	lsl.w	r8, r9, r8
 8018f64:	ea48 0202 	orr.w	r2, r8, r2
 8018f68:	60e0      	str	r0, [r4, #12]
 8018f6a:	605a      	str	r2, [r3, #4]
 8018f6c:	6084      	str	r4, [r0, #8]
 8018f6e:	60cc      	str	r4, [r1, #12]
 8018f70:	ea4f 03ac 	mov.w	r3, ip, asr #2
 8018f74:	2001      	movs	r0, #1
 8018f76:	4098      	lsls	r0, r3
 8018f78:	4290      	cmp	r0, r2
 8018f7a:	d85b      	bhi.n	8019034 <_malloc_r+0x1d4>
 8018f7c:	4202      	tst	r2, r0
 8018f7e:	d106      	bne.n	8018f8e <_malloc_r+0x12e>
 8018f80:	f02c 0c03 	bic.w	ip, ip, #3
 8018f84:	0040      	lsls	r0, r0, #1
 8018f86:	4202      	tst	r2, r0
 8018f88:	f10c 0c04 	add.w	ip, ip, #4
 8018f8c:	d0fa      	beq.n	8018f84 <_malloc_r+0x124>
 8018f8e:	eb07 08cc 	add.w	r8, r7, ip, lsl #3
 8018f92:	4644      	mov	r4, r8
 8018f94:	46e1      	mov	r9, ip
 8018f96:	68e3      	ldr	r3, [r4, #12]
 8018f98:	429c      	cmp	r4, r3
 8018f9a:	d107      	bne.n	8018fac <_malloc_r+0x14c>
 8018f9c:	e145      	b.n	801922a <_malloc_r+0x3ca>
 8018f9e:	2a00      	cmp	r2, #0
 8018fa0:	f280 8156 	bge.w	8019250 <_malloc_r+0x3f0>
 8018fa4:	68db      	ldr	r3, [r3, #12]
 8018fa6:	429c      	cmp	r4, r3
 8018fa8:	f000 813f 	beq.w	801922a <_malloc_r+0x3ca>
 8018fac:	6859      	ldr	r1, [r3, #4]
 8018fae:	f021 0103 	bic.w	r1, r1, #3
 8018fb2:	1b4a      	subs	r2, r1, r5
 8018fb4:	2a0f      	cmp	r2, #15
 8018fb6:	ddf2      	ble.n	8018f9e <_malloc_r+0x13e>
 8018fb8:	461c      	mov	r4, r3
 8018fba:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 8018fbe:	f854 8f08 	ldr.w	r8, [r4, #8]!
 8018fc2:	1959      	adds	r1, r3, r5
 8018fc4:	f045 0901 	orr.w	r9, r5, #1
 8018fc8:	f042 0501 	orr.w	r5, r2, #1
 8018fcc:	f8c3 9004 	str.w	r9, [r3, #4]
 8018fd0:	4630      	mov	r0, r6
 8018fd2:	f8c8 c00c 	str.w	ip, [r8, #12]
 8018fd6:	f8cc 8008 	str.w	r8, [ip, #8]
 8018fda:	6179      	str	r1, [r7, #20]
 8018fdc:	6139      	str	r1, [r7, #16]
 8018fde:	f8c1 e00c 	str.w	lr, [r1, #12]
 8018fe2:	f8c1 e008 	str.w	lr, [r1, #8]
 8018fe6:	604d      	str	r5, [r1, #4]
 8018fe8:	508a      	str	r2, [r1, r2]
 8018fea:	f000 f9e1 	bl	80193b0 <__malloc_unlock>
 8018fee:	e763      	b.n	8018eb8 <_malloc_r+0x58>
 8018ff0:	217e      	movs	r1, #126	; 0x7e
 8018ff2:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
 8018ff6:	e77b      	b.n	8018ef0 <_malloc_r+0x90>
 8018ff8:	4422      	add	r2, r4
 8018ffa:	68e3      	ldr	r3, [r4, #12]
 8018ffc:	6850      	ldr	r0, [r2, #4]
 8018ffe:	68a1      	ldr	r1, [r4, #8]
 8019000:	f040 0501 	orr.w	r5, r0, #1
 8019004:	60cb      	str	r3, [r1, #12]
 8019006:	4630      	mov	r0, r6
 8019008:	6099      	str	r1, [r3, #8]
 801900a:	6055      	str	r5, [r2, #4]
 801900c:	f000 f9d0 	bl	80193b0 <__malloc_unlock>
 8019010:	3408      	adds	r4, #8
 8019012:	4620      	mov	r0, r4
 8019014:	b003      	add	sp, #12
 8019016:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801901a:	4421      	add	r1, r4
 801901c:	4630      	mov	r0, r6
 801901e:	684b      	ldr	r3, [r1, #4]
 8019020:	f043 0301 	orr.w	r3, r3, #1
 8019024:	604b      	str	r3, [r1, #4]
 8019026:	f000 f9c3 	bl	80193b0 <__malloc_unlock>
 801902a:	3408      	adds	r4, #8
 801902c:	4620      	mov	r0, r4
 801902e:	b003      	add	sp, #12
 8019030:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019034:	68bc      	ldr	r4, [r7, #8]
 8019036:	6863      	ldr	r3, [r4, #4]
 8019038:	f023 0903 	bic.w	r9, r3, #3
 801903c:	45a9      	cmp	r9, r5
 801903e:	d304      	bcc.n	801904a <_malloc_r+0x1ea>
 8019040:	ebc5 0309 	rsb	r3, r5, r9
 8019044:	2b0f      	cmp	r3, #15
 8019046:	f300 8091 	bgt.w	801916c <_malloc_r+0x30c>
 801904a:	4b51      	ldr	r3, [pc, #324]	; (8019190 <_malloc_r+0x330>)
 801904c:	4a51      	ldr	r2, [pc, #324]	; (8019194 <_malloc_r+0x334>)
 801904e:	6819      	ldr	r1, [r3, #0]
 8019050:	6813      	ldr	r3, [r2, #0]
 8019052:	3301      	adds	r3, #1
 8019054:	eb05 0a01 	add.w	sl, r5, r1
 8019058:	eb04 0b09 	add.w	fp, r4, r9
 801905c:	f000 8161 	beq.w	8019322 <_malloc_r+0x4c2>
 8019060:	f50a 5a80 	add.w	sl, sl, #4096	; 0x1000
 8019064:	f10a 0a0f 	add.w	sl, sl, #15
 8019068:	f42a 6a7f 	bic.w	sl, sl, #4080	; 0xff0
 801906c:	f02a 0a0f 	bic.w	sl, sl, #15
 8019070:	4630      	mov	r0, r6
 8019072:	4651      	mov	r1, sl
 8019074:	9201      	str	r2, [sp, #4]
 8019076:	f7f8 fe5b 	bl	8011d30 <_sbrk_r>
 801907a:	f1b0 3fff 	cmp.w	r0, #4294967295
 801907e:	4680      	mov	r8, r0
 8019080:	9a01      	ldr	r2, [sp, #4]
 8019082:	f000 8100 	beq.w	8019286 <_malloc_r+0x426>
 8019086:	4583      	cmp	fp, r0
 8019088:	f200 80fa 	bhi.w	8019280 <_malloc_r+0x420>
 801908c:	f8df c110 	ldr.w	ip, [pc, #272]	; 80191a0 <_malloc_r+0x340>
 8019090:	f8dc 3000 	ldr.w	r3, [ip]
 8019094:	45c3      	cmp	fp, r8
 8019096:	4453      	add	r3, sl
 8019098:	f8cc 3000 	str.w	r3, [ip]
 801909c:	f000 814a 	beq.w	8019334 <_malloc_r+0x4d4>
 80190a0:	6812      	ldr	r2, [r2, #0]
 80190a2:	493c      	ldr	r1, [pc, #240]	; (8019194 <_malloc_r+0x334>)
 80190a4:	3201      	adds	r2, #1
 80190a6:	bf1b      	ittet	ne
 80190a8:	ebcb 0b08 	rsbne	fp, fp, r8
 80190ac:	445b      	addne	r3, fp
 80190ae:	f8c1 8000 	streq.w	r8, [r1]
 80190b2:	f8cc 3000 	strne.w	r3, [ip]
 80190b6:	f018 0307 	ands.w	r3, r8, #7
 80190ba:	f000 8113 	beq.w	80192e4 <_malloc_r+0x484>
 80190be:	f1c3 0208 	rsb	r2, r3, #8
 80190c2:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 80190c6:	4490      	add	r8, r2
 80190c8:	3308      	adds	r3, #8
 80190ca:	44c2      	add	sl, r8
 80190cc:	f3ca 0a0b 	ubfx	sl, sl, #0, #12
 80190d0:	ebca 0a03 	rsb	sl, sl, r3
 80190d4:	4651      	mov	r1, sl
 80190d6:	4630      	mov	r0, r6
 80190d8:	f8cd c004 	str.w	ip, [sp, #4]
 80190dc:	f7f8 fe28 	bl	8011d30 <_sbrk_r>
 80190e0:	1c43      	adds	r3, r0, #1
 80190e2:	f8dd c004 	ldr.w	ip, [sp, #4]
 80190e6:	f000 8135 	beq.w	8019354 <_malloc_r+0x4f4>
 80190ea:	ebc8 0200 	rsb	r2, r8, r0
 80190ee:	4452      	add	r2, sl
 80190f0:	f042 0201 	orr.w	r2, r2, #1
 80190f4:	f8dc 3000 	ldr.w	r3, [ip]
 80190f8:	f8c7 8008 	str.w	r8, [r7, #8]
 80190fc:	4453      	add	r3, sl
 80190fe:	42bc      	cmp	r4, r7
 8019100:	f8c8 2004 	str.w	r2, [r8, #4]
 8019104:	f8cc 3000 	str.w	r3, [ip]
 8019108:	f8df a094 	ldr.w	sl, [pc, #148]	; 80191a0 <_malloc_r+0x340>
 801910c:	d015      	beq.n	801913a <_malloc_r+0x2da>
 801910e:	f1b9 0f0f 	cmp.w	r9, #15
 8019112:	f240 80ea 	bls.w	80192ea <_malloc_r+0x48a>
 8019116:	6861      	ldr	r1, [r4, #4]
 8019118:	f1a9 020c 	sub.w	r2, r9, #12
 801911c:	f022 0207 	bic.w	r2, r2, #7
 8019120:	f001 0e01 	and.w	lr, r1, #1
 8019124:	18a1      	adds	r1, r4, r2
 8019126:	2005      	movs	r0, #5
 8019128:	ea42 0e0e 	orr.w	lr, r2, lr
 801912c:	2a0f      	cmp	r2, #15
 801912e:	f8c4 e004 	str.w	lr, [r4, #4]
 8019132:	6048      	str	r0, [r1, #4]
 8019134:	6088      	str	r0, [r1, #8]
 8019136:	f200 8111 	bhi.w	801935c <_malloc_r+0x4fc>
 801913a:	4a17      	ldr	r2, [pc, #92]	; (8019198 <_malloc_r+0x338>)
 801913c:	68bc      	ldr	r4, [r7, #8]
 801913e:	6811      	ldr	r1, [r2, #0]
 8019140:	428b      	cmp	r3, r1
 8019142:	bf88      	it	hi
 8019144:	6013      	strhi	r3, [r2, #0]
 8019146:	4a15      	ldr	r2, [pc, #84]	; (801919c <_malloc_r+0x33c>)
 8019148:	6811      	ldr	r1, [r2, #0]
 801914a:	428b      	cmp	r3, r1
 801914c:	bf88      	it	hi
 801914e:	6013      	strhi	r3, [r2, #0]
 8019150:	6862      	ldr	r2, [r4, #4]
 8019152:	f022 0203 	bic.w	r2, r2, #3
 8019156:	4295      	cmp	r5, r2
 8019158:	ebc5 0302 	rsb	r3, r5, r2
 801915c:	d801      	bhi.n	8019162 <_malloc_r+0x302>
 801915e:	2b0f      	cmp	r3, #15
 8019160:	dc04      	bgt.n	801916c <_malloc_r+0x30c>
 8019162:	4630      	mov	r0, r6
 8019164:	f000 f924 	bl	80193b0 <__malloc_unlock>
 8019168:	2400      	movs	r4, #0
 801916a:	e6a5      	b.n	8018eb8 <_malloc_r+0x58>
 801916c:	1962      	adds	r2, r4, r5
 801916e:	f043 0301 	orr.w	r3, r3, #1
 8019172:	f045 0501 	orr.w	r5, r5, #1
 8019176:	6065      	str	r5, [r4, #4]
 8019178:	4630      	mov	r0, r6
 801917a:	60ba      	str	r2, [r7, #8]
 801917c:	6053      	str	r3, [r2, #4]
 801917e:	f000 f917 	bl	80193b0 <__malloc_unlock>
 8019182:	3408      	adds	r4, #8
 8019184:	4620      	mov	r0, r4
 8019186:	b003      	add	sp, #12
 8019188:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801918c:	20000e0c 	.word	0x20000e0c
 8019190:	2000397c 	.word	0x2000397c
 8019194:	20001218 	.word	0x20001218
 8019198:	20003978 	.word	0x20003978
 801919c:	20003974 	.word	0x20003974
 80191a0:	20003980 	.word	0x20003980
 80191a4:	f1bc 0f14 	cmp.w	ip, #20
 80191a8:	d961      	bls.n	801926e <_malloc_r+0x40e>
 80191aa:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 80191ae:	f200 808f 	bhi.w	80192d0 <_malloc_r+0x470>
 80191b2:	ea4f 3c15 	mov.w	ip, r5, lsr #12
 80191b6:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
 80191ba:	ea4f 014c 	mov.w	r1, ip, lsl #1
 80191be:	e697      	b.n	8018ef0 <_malloc_r+0x90>
 80191c0:	0a4b      	lsrs	r3, r1, #9
 80191c2:	2b04      	cmp	r3, #4
 80191c4:	d958      	bls.n	8019278 <_malloc_r+0x418>
 80191c6:	2b14      	cmp	r3, #20
 80191c8:	f200 80ae 	bhi.w	8019328 <_malloc_r+0x4c8>
 80191cc:	f103 025b 	add.w	r2, r3, #91	; 0x5b
 80191d0:	0050      	lsls	r0, r2, #1
 80191d2:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 80191d6:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 8019394 <_malloc_r+0x534>
 80191da:	6883      	ldr	r3, [r0, #8]
 80191dc:	4283      	cmp	r3, r0
 80191de:	f000 808a 	beq.w	80192f6 <_malloc_r+0x496>
 80191e2:	685a      	ldr	r2, [r3, #4]
 80191e4:	f022 0203 	bic.w	r2, r2, #3
 80191e8:	4291      	cmp	r1, r2
 80191ea:	d202      	bcs.n	80191f2 <_malloc_r+0x392>
 80191ec:	689b      	ldr	r3, [r3, #8]
 80191ee:	4298      	cmp	r0, r3
 80191f0:	d1f7      	bne.n	80191e2 <_malloc_r+0x382>
 80191f2:	68d9      	ldr	r1, [r3, #12]
 80191f4:	687a      	ldr	r2, [r7, #4]
 80191f6:	60e1      	str	r1, [r4, #12]
 80191f8:	60a3      	str	r3, [r4, #8]
 80191fa:	608c      	str	r4, [r1, #8]
 80191fc:	60dc      	str	r4, [r3, #12]
 80191fe:	e6b7      	b.n	8018f70 <_malloc_r+0x110>
 8019200:	1961      	adds	r1, r4, r5
 8019202:	f042 0701 	orr.w	r7, r2, #1
 8019206:	f045 0501 	orr.w	r5, r5, #1
 801920a:	6065      	str	r5, [r4, #4]
 801920c:	4630      	mov	r0, r6
 801920e:	6159      	str	r1, [r3, #20]
 8019210:	6119      	str	r1, [r3, #16]
 8019212:	f8c1 e00c 	str.w	lr, [r1, #12]
 8019216:	f8c1 e008 	str.w	lr, [r1, #8]
 801921a:	604f      	str	r7, [r1, #4]
 801921c:	508a      	str	r2, [r1, r2]
 801921e:	3408      	adds	r4, #8
 8019220:	f000 f8c6 	bl	80193b0 <__malloc_unlock>
 8019224:	e648      	b.n	8018eb8 <_malloc_r+0x58>
 8019226:	685a      	ldr	r2, [r3, #4]
 8019228:	e6a2      	b.n	8018f70 <_malloc_r+0x110>
 801922a:	f109 0901 	add.w	r9, r9, #1
 801922e:	f019 0f03 	tst.w	r9, #3
 8019232:	f104 0408 	add.w	r4, r4, #8
 8019236:	f47f aeae 	bne.w	8018f96 <_malloc_r+0x136>
 801923a:	e02d      	b.n	8019298 <_malloc_r+0x438>
 801923c:	f104 0308 	add.w	r3, r4, #8
 8019240:	6964      	ldr	r4, [r4, #20]
 8019242:	42a3      	cmp	r3, r4
 8019244:	bf08      	it	eq
 8019246:	f10c 0c02 	addeq.w	ip, ip, #2
 801924a:	f43f ae67 	beq.w	8018f1c <_malloc_r+0xbc>
 801924e:	e623      	b.n	8018e98 <_malloc_r+0x38>
 8019250:	4419      	add	r1, r3
 8019252:	461c      	mov	r4, r3
 8019254:	6848      	ldr	r0, [r1, #4]
 8019256:	68db      	ldr	r3, [r3, #12]
 8019258:	f854 2f08 	ldr.w	r2, [r4, #8]!
 801925c:	f040 0501 	orr.w	r5, r0, #1
 8019260:	604d      	str	r5, [r1, #4]
 8019262:	4630      	mov	r0, r6
 8019264:	60d3      	str	r3, [r2, #12]
 8019266:	609a      	str	r2, [r3, #8]
 8019268:	f000 f8a2 	bl	80193b0 <__malloc_unlock>
 801926c:	e624      	b.n	8018eb8 <_malloc_r+0x58>
 801926e:	f10c 0c5b 	add.w	ip, ip, #91	; 0x5b
 8019272:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8019276:	e63b      	b.n	8018ef0 <_malloc_r+0x90>
 8019278:	098a      	lsrs	r2, r1, #6
 801927a:	3238      	adds	r2, #56	; 0x38
 801927c:	0050      	lsls	r0, r2, #1
 801927e:	e7a8      	b.n	80191d2 <_malloc_r+0x372>
 8019280:	42bc      	cmp	r4, r7
 8019282:	f43f af03 	beq.w	801908c <_malloc_r+0x22c>
 8019286:	68bc      	ldr	r4, [r7, #8]
 8019288:	6862      	ldr	r2, [r4, #4]
 801928a:	f022 0203 	bic.w	r2, r2, #3
 801928e:	e762      	b.n	8019156 <_malloc_r+0x2f6>
 8019290:	f8d8 8000 	ldr.w	r8, [r8]
 8019294:	4598      	cmp	r8, r3
 8019296:	d17b      	bne.n	8019390 <_malloc_r+0x530>
 8019298:	f01c 0f03 	tst.w	ip, #3
 801929c:	f1a8 0308 	sub.w	r3, r8, #8
 80192a0:	f10c 3cff 	add.w	ip, ip, #4294967295
 80192a4:	d1f4      	bne.n	8019290 <_malloc_r+0x430>
 80192a6:	687b      	ldr	r3, [r7, #4]
 80192a8:	ea23 0300 	bic.w	r3, r3, r0
 80192ac:	607b      	str	r3, [r7, #4]
 80192ae:	0040      	lsls	r0, r0, #1
 80192b0:	4298      	cmp	r0, r3
 80192b2:	f63f aebf 	bhi.w	8019034 <_malloc_r+0x1d4>
 80192b6:	2800      	cmp	r0, #0
 80192b8:	f43f aebc 	beq.w	8019034 <_malloc_r+0x1d4>
 80192bc:	4203      	tst	r3, r0
 80192be:	46cc      	mov	ip, r9
 80192c0:	f47f ae65 	bne.w	8018f8e <_malloc_r+0x12e>
 80192c4:	0040      	lsls	r0, r0, #1
 80192c6:	4203      	tst	r3, r0
 80192c8:	f10c 0c04 	add.w	ip, ip, #4
 80192cc:	d0fa      	beq.n	80192c4 <_malloc_r+0x464>
 80192ce:	e65e      	b.n	8018f8e <_malloc_r+0x12e>
 80192d0:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 80192d4:	d81a      	bhi.n	801930c <_malloc_r+0x4ac>
 80192d6:	ea4f 3cd5 	mov.w	ip, r5, lsr #15
 80192da:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
 80192de:	ea4f 014c 	mov.w	r1, ip, lsl #1
 80192e2:	e605      	b.n	8018ef0 <_malloc_r+0x90>
 80192e4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80192e8:	e6ef      	b.n	80190ca <_malloc_r+0x26a>
 80192ea:	2301      	movs	r3, #1
 80192ec:	f8c8 3004 	str.w	r3, [r8, #4]
 80192f0:	4644      	mov	r4, r8
 80192f2:	2200      	movs	r2, #0
 80192f4:	e72f      	b.n	8019156 <_malloc_r+0x2f6>
 80192f6:	1091      	asrs	r1, r2, #2
 80192f8:	2001      	movs	r0, #1
 80192fa:	f8d8 2004 	ldr.w	r2, [r8, #4]
 80192fe:	fa00 f101 	lsl.w	r1, r0, r1
 8019302:	430a      	orrs	r2, r1
 8019304:	f8c8 2004 	str.w	r2, [r8, #4]
 8019308:	4619      	mov	r1, r3
 801930a:	e774      	b.n	80191f6 <_malloc_r+0x396>
 801930c:	f240 5354 	movw	r3, #1364	; 0x554
 8019310:	459c      	cmp	ip, r3
 8019312:	d81b      	bhi.n	801934c <_malloc_r+0x4ec>
 8019314:	ea4f 4c95 	mov.w	ip, r5, lsr #18
 8019318:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
 801931c:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8019320:	e5e6      	b.n	8018ef0 <_malloc_r+0x90>
 8019322:	f10a 0a10 	add.w	sl, sl, #16
 8019326:	e6a3      	b.n	8019070 <_malloc_r+0x210>
 8019328:	2b54      	cmp	r3, #84	; 0x54
 801932a:	d81f      	bhi.n	801936c <_malloc_r+0x50c>
 801932c:	0b0a      	lsrs	r2, r1, #12
 801932e:	326e      	adds	r2, #110	; 0x6e
 8019330:	0050      	lsls	r0, r2, #1
 8019332:	e74e      	b.n	80191d2 <_malloc_r+0x372>
 8019334:	f3cb 010b 	ubfx	r1, fp, #0, #12
 8019338:	2900      	cmp	r1, #0
 801933a:	f47f aeb1 	bne.w	80190a0 <_malloc_r+0x240>
 801933e:	eb0a 0109 	add.w	r1, sl, r9
 8019342:	68ba      	ldr	r2, [r7, #8]
 8019344:	f041 0101 	orr.w	r1, r1, #1
 8019348:	6051      	str	r1, [r2, #4]
 801934a:	e6f6      	b.n	801913a <_malloc_r+0x2da>
 801934c:	21fc      	movs	r1, #252	; 0xfc
 801934e:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
 8019352:	e5cd      	b.n	8018ef0 <_malloc_r+0x90>
 8019354:	2201      	movs	r2, #1
 8019356:	f04f 0a00 	mov.w	sl, #0
 801935a:	e6cb      	b.n	80190f4 <_malloc_r+0x294>
 801935c:	f104 0108 	add.w	r1, r4, #8
 8019360:	4630      	mov	r0, r6
 8019362:	f001 f9ad 	bl	801a6c0 <_free_r>
 8019366:	f8da 3000 	ldr.w	r3, [sl]
 801936a:	e6e6      	b.n	801913a <_malloc_r+0x2da>
 801936c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8019370:	d803      	bhi.n	801937a <_malloc_r+0x51a>
 8019372:	0bca      	lsrs	r2, r1, #15
 8019374:	3277      	adds	r2, #119	; 0x77
 8019376:	0050      	lsls	r0, r2, #1
 8019378:	e72b      	b.n	80191d2 <_malloc_r+0x372>
 801937a:	f240 5254 	movw	r2, #1364	; 0x554
 801937e:	4293      	cmp	r3, r2
 8019380:	d803      	bhi.n	801938a <_malloc_r+0x52a>
 8019382:	0c8a      	lsrs	r2, r1, #18
 8019384:	327c      	adds	r2, #124	; 0x7c
 8019386:	0050      	lsls	r0, r2, #1
 8019388:	e723      	b.n	80191d2 <_malloc_r+0x372>
 801938a:	20fc      	movs	r0, #252	; 0xfc
 801938c:	227e      	movs	r2, #126	; 0x7e
 801938e:	e720      	b.n	80191d2 <_malloc_r+0x372>
 8019390:	687b      	ldr	r3, [r7, #4]
 8019392:	e78c      	b.n	80192ae <_malloc_r+0x44e>
 8019394:	20000e0c 	.word	0x20000e0c
	...

080193a0 <__malloc_lock>:
 80193a0:	4770      	bx	lr
 80193a2:	bf00      	nop
	...

080193b0 <__malloc_unlock>:
 80193b0:	4770      	bx	lr
 80193b2:	bf00      	nop
	...

080193c0 <realloc>:
 80193c0:	4b02      	ldr	r3, [pc, #8]	; (80193cc <realloc+0xc>)
 80193c2:	460a      	mov	r2, r1
 80193c4:	4601      	mov	r1, r0
 80193c6:	6818      	ldr	r0, [r3, #0]
 80193c8:	f000 b802 	b.w	80193d0 <_realloc_r>
 80193cc:	20000d88 	.word	0x20000d88

080193d0 <_realloc_r>:
 80193d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80193d4:	460c      	mov	r4, r1
 80193d6:	b083      	sub	sp, #12
 80193d8:	4690      	mov	r8, r2
 80193da:	4681      	mov	r9, r0
 80193dc:	2900      	cmp	r1, #0
 80193de:	f000 80e2 	beq.w	80195a6 <_realloc_r+0x1d6>
 80193e2:	f7ff ffdd 	bl	80193a0 <__malloc_lock>
 80193e6:	f108 060b 	add.w	r6, r8, #11
 80193ea:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80193ee:	2e16      	cmp	r6, #22
 80193f0:	f023 0503 	bic.w	r5, r3, #3
 80193f4:	f1a4 0708 	sub.w	r7, r4, #8
 80193f8:	d84b      	bhi.n	8019492 <_realloc_r+0xc2>
 80193fa:	2110      	movs	r1, #16
 80193fc:	460e      	mov	r6, r1
 80193fe:	45b0      	cmp	r8, r6
 8019400:	d84c      	bhi.n	801949c <_realloc_r+0xcc>
 8019402:	428d      	cmp	r5, r1
 8019404:	da78      	bge.n	80194f8 <_realloc_r+0x128>
 8019406:	f8df b390 	ldr.w	fp, [pc, #912]	; 8019798 <_realloc_r+0x3c8>
 801940a:	f8db e008 	ldr.w	lr, [fp, #8]
 801940e:	1978      	adds	r0, r7, r5
 8019410:	4586      	cmp	lr, r0
 8019412:	f000 80ce 	beq.w	80195b2 <_realloc_r+0x1e2>
 8019416:	6842      	ldr	r2, [r0, #4]
 8019418:	f022 0c01 	bic.w	ip, r2, #1
 801941c:	4484      	add	ip, r0
 801941e:	f8dc c004 	ldr.w	ip, [ip, #4]
 8019422:	f01c 0f01 	tst.w	ip, #1
 8019426:	d07a      	beq.n	801951e <_realloc_r+0x14e>
 8019428:	2200      	movs	r2, #0
 801942a:	4610      	mov	r0, r2
 801942c:	07db      	lsls	r3, r3, #31
 801942e:	f100 8092 	bmi.w	8019556 <_realloc_r+0x186>
 8019432:	f854 3c08 	ldr.w	r3, [r4, #-8]
 8019436:	ebc3 0a07 	rsb	sl, r3, r7
 801943a:	f8da 3004 	ldr.w	r3, [sl, #4]
 801943e:	f023 0303 	bic.w	r3, r3, #3
 8019442:	442b      	add	r3, r5
 8019444:	b388      	cbz	r0, 80194aa <_realloc_r+0xda>
 8019446:	4570      	cmp	r0, lr
 8019448:	f000 80ed 	beq.w	8019626 <_realloc_r+0x256>
 801944c:	eb02 0e03 	add.w	lr, r2, r3
 8019450:	458e      	cmp	lr, r1
 8019452:	db2a      	blt.n	80194aa <_realloc_r+0xda>
 8019454:	68c3      	ldr	r3, [r0, #12]
 8019456:	6882      	ldr	r2, [r0, #8]
 8019458:	4657      	mov	r7, sl
 801945a:	60d3      	str	r3, [r2, #12]
 801945c:	609a      	str	r2, [r3, #8]
 801945e:	f857 1f08 	ldr.w	r1, [r7, #8]!
 8019462:	f8da 300c 	ldr.w	r3, [sl, #12]
 8019466:	60cb      	str	r3, [r1, #12]
 8019468:	1f2a      	subs	r2, r5, #4
 801946a:	2a24      	cmp	r2, #36	; 0x24
 801946c:	6099      	str	r1, [r3, #8]
 801946e:	f200 8126 	bhi.w	80196be <_realloc_r+0x2ee>
 8019472:	2a13      	cmp	r2, #19
 8019474:	f240 80b3 	bls.w	80195de <_realloc_r+0x20e>
 8019478:	6823      	ldr	r3, [r4, #0]
 801947a:	f8ca 3008 	str.w	r3, [sl, #8]
 801947e:	6863      	ldr	r3, [r4, #4]
 8019480:	f8ca 300c 	str.w	r3, [sl, #12]
 8019484:	2a1b      	cmp	r2, #27
 8019486:	f200 8130 	bhi.w	80196ea <_realloc_r+0x31a>
 801948a:	3408      	adds	r4, #8
 801948c:	f10a 0310 	add.w	r3, sl, #16
 8019490:	e0a6      	b.n	80195e0 <_realloc_r+0x210>
 8019492:	f026 0607 	bic.w	r6, r6, #7
 8019496:	2e00      	cmp	r6, #0
 8019498:	4631      	mov	r1, r6
 801949a:	dab0      	bge.n	80193fe <_realloc_r+0x2e>
 801949c:	230c      	movs	r3, #12
 801949e:	2000      	movs	r0, #0
 80194a0:	f8c9 3000 	str.w	r3, [r9]
 80194a4:	b003      	add	sp, #12
 80194a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80194aa:	428b      	cmp	r3, r1
 80194ac:	db53      	blt.n	8019556 <_realloc_r+0x186>
 80194ae:	4657      	mov	r7, sl
 80194b0:	f8da 100c 	ldr.w	r1, [sl, #12]
 80194b4:	f857 0f08 	ldr.w	r0, [r7, #8]!
 80194b8:	1f2a      	subs	r2, r5, #4
 80194ba:	2a24      	cmp	r2, #36	; 0x24
 80194bc:	60c1      	str	r1, [r0, #12]
 80194be:	6088      	str	r0, [r1, #8]
 80194c0:	f200 8109 	bhi.w	80196d6 <_realloc_r+0x306>
 80194c4:	2a13      	cmp	r2, #19
 80194c6:	f240 8104 	bls.w	80196d2 <_realloc_r+0x302>
 80194ca:	6821      	ldr	r1, [r4, #0]
 80194cc:	f8ca 1008 	str.w	r1, [sl, #8]
 80194d0:	6861      	ldr	r1, [r4, #4]
 80194d2:	f8ca 100c 	str.w	r1, [sl, #12]
 80194d6:	2a1b      	cmp	r2, #27
 80194d8:	f200 811c 	bhi.w	8019714 <_realloc_r+0x344>
 80194dc:	3408      	adds	r4, #8
 80194de:	f10a 0210 	add.w	r2, sl, #16
 80194e2:	6821      	ldr	r1, [r4, #0]
 80194e4:	6011      	str	r1, [r2, #0]
 80194e6:	6861      	ldr	r1, [r4, #4]
 80194e8:	6051      	str	r1, [r2, #4]
 80194ea:	68a1      	ldr	r1, [r4, #8]
 80194ec:	6091      	str	r1, [r2, #8]
 80194ee:	461d      	mov	r5, r3
 80194f0:	f8da 3004 	ldr.w	r3, [sl, #4]
 80194f4:	463c      	mov	r4, r7
 80194f6:	4657      	mov	r7, sl
 80194f8:	1baa      	subs	r2, r5, r6
 80194fa:	2a0f      	cmp	r2, #15
 80194fc:	f003 0301 	and.w	r3, r3, #1
 8019500:	d819      	bhi.n	8019536 <_realloc_r+0x166>
 8019502:	432b      	orrs	r3, r5
 8019504:	443d      	add	r5, r7
 8019506:	607b      	str	r3, [r7, #4]
 8019508:	686b      	ldr	r3, [r5, #4]
 801950a:	f043 0301 	orr.w	r3, r3, #1
 801950e:	606b      	str	r3, [r5, #4]
 8019510:	4648      	mov	r0, r9
 8019512:	f7ff ff4d 	bl	80193b0 <__malloc_unlock>
 8019516:	4620      	mov	r0, r4
 8019518:	b003      	add	sp, #12
 801951a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801951e:	f022 0203 	bic.w	r2, r2, #3
 8019522:	eb02 0c05 	add.w	ip, r2, r5
 8019526:	458c      	cmp	ip, r1
 8019528:	db80      	blt.n	801942c <_realloc_r+0x5c>
 801952a:	68c2      	ldr	r2, [r0, #12]
 801952c:	6881      	ldr	r1, [r0, #8]
 801952e:	4665      	mov	r5, ip
 8019530:	60ca      	str	r2, [r1, #12]
 8019532:	6091      	str	r1, [r2, #8]
 8019534:	e7e0      	b.n	80194f8 <_realloc_r+0x128>
 8019536:	19b9      	adds	r1, r7, r6
 8019538:	f042 0001 	orr.w	r0, r2, #1
 801953c:	431e      	orrs	r6, r3
 801953e:	440a      	add	r2, r1
 8019540:	607e      	str	r6, [r7, #4]
 8019542:	6048      	str	r0, [r1, #4]
 8019544:	6853      	ldr	r3, [r2, #4]
 8019546:	f043 0301 	orr.w	r3, r3, #1
 801954a:	3108      	adds	r1, #8
 801954c:	6053      	str	r3, [r2, #4]
 801954e:	4648      	mov	r0, r9
 8019550:	f001 f8b6 	bl	801a6c0 <_free_r>
 8019554:	e7dc      	b.n	8019510 <_realloc_r+0x140>
 8019556:	4641      	mov	r1, r8
 8019558:	4648      	mov	r0, r9
 801955a:	f7ff fc81 	bl	8018e60 <_malloc_r>
 801955e:	4680      	mov	r8, r0
 8019560:	b1d0      	cbz	r0, 8019598 <_realloc_r+0x1c8>
 8019562:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8019566:	f023 0201 	bic.w	r2, r3, #1
 801956a:	443a      	add	r2, r7
 801956c:	f1a0 0108 	sub.w	r1, r0, #8
 8019570:	4291      	cmp	r1, r2
 8019572:	f000 809e 	beq.w	80196b2 <_realloc_r+0x2e2>
 8019576:	1f2a      	subs	r2, r5, #4
 8019578:	2a24      	cmp	r2, #36	; 0x24
 801957a:	d850      	bhi.n	801961e <_realloc_r+0x24e>
 801957c:	2a13      	cmp	r2, #19
 801957e:	d823      	bhi.n	80195c8 <_realloc_r+0x1f8>
 8019580:	4603      	mov	r3, r0
 8019582:	4622      	mov	r2, r4
 8019584:	6811      	ldr	r1, [r2, #0]
 8019586:	6019      	str	r1, [r3, #0]
 8019588:	6851      	ldr	r1, [r2, #4]
 801958a:	6059      	str	r1, [r3, #4]
 801958c:	6892      	ldr	r2, [r2, #8]
 801958e:	609a      	str	r2, [r3, #8]
 8019590:	4621      	mov	r1, r4
 8019592:	4648      	mov	r0, r9
 8019594:	f001 f894 	bl	801a6c0 <_free_r>
 8019598:	4648      	mov	r0, r9
 801959a:	f7ff ff09 	bl	80193b0 <__malloc_unlock>
 801959e:	4640      	mov	r0, r8
 80195a0:	b003      	add	sp, #12
 80195a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80195a6:	4611      	mov	r1, r2
 80195a8:	b003      	add	sp, #12
 80195aa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80195ae:	f7ff bc57 	b.w	8018e60 <_malloc_r>
 80195b2:	f8de 2004 	ldr.w	r2, [lr, #4]
 80195b6:	f022 0203 	bic.w	r2, r2, #3
 80195ba:	1950      	adds	r0, r2, r5
 80195bc:	f106 0c10 	add.w	ip, r6, #16
 80195c0:	4560      	cmp	r0, ip
 80195c2:	da19      	bge.n	80195f8 <_realloc_r+0x228>
 80195c4:	4670      	mov	r0, lr
 80195c6:	e731      	b.n	801942c <_realloc_r+0x5c>
 80195c8:	6823      	ldr	r3, [r4, #0]
 80195ca:	6003      	str	r3, [r0, #0]
 80195cc:	6863      	ldr	r3, [r4, #4]
 80195ce:	6043      	str	r3, [r0, #4]
 80195d0:	2a1b      	cmp	r2, #27
 80195d2:	d863      	bhi.n	801969c <_realloc_r+0x2cc>
 80195d4:	f100 0308 	add.w	r3, r0, #8
 80195d8:	f104 0208 	add.w	r2, r4, #8
 80195dc:	e7d2      	b.n	8019584 <_realloc_r+0x1b4>
 80195de:	463b      	mov	r3, r7
 80195e0:	6822      	ldr	r2, [r4, #0]
 80195e2:	601a      	str	r2, [r3, #0]
 80195e4:	6862      	ldr	r2, [r4, #4]
 80195e6:	605a      	str	r2, [r3, #4]
 80195e8:	68a2      	ldr	r2, [r4, #8]
 80195ea:	609a      	str	r2, [r3, #8]
 80195ec:	463c      	mov	r4, r7
 80195ee:	4675      	mov	r5, lr
 80195f0:	f8da 3004 	ldr.w	r3, [sl, #4]
 80195f4:	4657      	mov	r7, sl
 80195f6:	e77f      	b.n	80194f8 <_realloc_r+0x128>
 80195f8:	4437      	add	r7, r6
 80195fa:	1b83      	subs	r3, r0, r6
 80195fc:	f043 0301 	orr.w	r3, r3, #1
 8019600:	f8cb 7008 	str.w	r7, [fp, #8]
 8019604:	607b      	str	r3, [r7, #4]
 8019606:	f854 3c04 	ldr.w	r3, [r4, #-4]
 801960a:	f003 0301 	and.w	r3, r3, #1
 801960e:	431e      	orrs	r6, r3
 8019610:	4648      	mov	r0, r9
 8019612:	f844 6c04 	str.w	r6, [r4, #-4]
 8019616:	f7ff fecb 	bl	80193b0 <__malloc_unlock>
 801961a:	4620      	mov	r0, r4
 801961c:	e77c      	b.n	8019518 <_realloc_r+0x148>
 801961e:	4621      	mov	r1, r4
 8019620:	f001 f966 	bl	801a8f0 <memmove>
 8019624:	e7b4      	b.n	8019590 <_realloc_r+0x1c0>
 8019626:	eb02 0c03 	add.w	ip, r2, r3
 801962a:	f106 0210 	add.w	r2, r6, #16
 801962e:	4594      	cmp	ip, r2
 8019630:	f6ff af3b 	blt.w	80194aa <_realloc_r+0xda>
 8019634:	4657      	mov	r7, sl
 8019636:	f8da 300c 	ldr.w	r3, [sl, #12]
 801963a:	f857 1f08 	ldr.w	r1, [r7, #8]!
 801963e:	1f2a      	subs	r2, r5, #4
 8019640:	2a24      	cmp	r2, #36	; 0x24
 8019642:	60cb      	str	r3, [r1, #12]
 8019644:	6099      	str	r1, [r3, #8]
 8019646:	f200 8087 	bhi.w	8019758 <_realloc_r+0x388>
 801964a:	2a13      	cmp	r2, #19
 801964c:	d978      	bls.n	8019740 <_realloc_r+0x370>
 801964e:	6823      	ldr	r3, [r4, #0]
 8019650:	f8ca 3008 	str.w	r3, [sl, #8]
 8019654:	6863      	ldr	r3, [r4, #4]
 8019656:	f8ca 300c 	str.w	r3, [sl, #12]
 801965a:	2a1b      	cmp	r2, #27
 801965c:	f200 8085 	bhi.w	801976a <_realloc_r+0x39a>
 8019660:	3408      	adds	r4, #8
 8019662:	f10a 0310 	add.w	r3, sl, #16
 8019666:	6822      	ldr	r2, [r4, #0]
 8019668:	601a      	str	r2, [r3, #0]
 801966a:	6862      	ldr	r2, [r4, #4]
 801966c:	605a      	str	r2, [r3, #4]
 801966e:	68a2      	ldr	r2, [r4, #8]
 8019670:	609a      	str	r2, [r3, #8]
 8019672:	eb0a 0306 	add.w	r3, sl, r6
 8019676:	ebc6 020c 	rsb	r2, r6, ip
 801967a:	f042 0201 	orr.w	r2, r2, #1
 801967e:	f8cb 3008 	str.w	r3, [fp, #8]
 8019682:	605a      	str	r2, [r3, #4]
 8019684:	f8da 3004 	ldr.w	r3, [sl, #4]
 8019688:	f003 0301 	and.w	r3, r3, #1
 801968c:	431e      	orrs	r6, r3
 801968e:	4648      	mov	r0, r9
 8019690:	f8ca 6004 	str.w	r6, [sl, #4]
 8019694:	f7ff fe8c 	bl	80193b0 <__malloc_unlock>
 8019698:	4638      	mov	r0, r7
 801969a:	e73d      	b.n	8019518 <_realloc_r+0x148>
 801969c:	68a3      	ldr	r3, [r4, #8]
 801969e:	6083      	str	r3, [r0, #8]
 80196a0:	68e3      	ldr	r3, [r4, #12]
 80196a2:	60c3      	str	r3, [r0, #12]
 80196a4:	2a24      	cmp	r2, #36	; 0x24
 80196a6:	d02c      	beq.n	8019702 <_realloc_r+0x332>
 80196a8:	f100 0310 	add.w	r3, r0, #16
 80196ac:	f104 0210 	add.w	r2, r4, #16
 80196b0:	e768      	b.n	8019584 <_realloc_r+0x1b4>
 80196b2:	f850 2c04 	ldr.w	r2, [r0, #-4]
 80196b6:	f022 0203 	bic.w	r2, r2, #3
 80196ba:	4415      	add	r5, r2
 80196bc:	e71c      	b.n	80194f8 <_realloc_r+0x128>
 80196be:	4621      	mov	r1, r4
 80196c0:	4638      	mov	r0, r7
 80196c2:	4675      	mov	r5, lr
 80196c4:	463c      	mov	r4, r7
 80196c6:	f001 f913 	bl	801a8f0 <memmove>
 80196ca:	4657      	mov	r7, sl
 80196cc:	f8da 3004 	ldr.w	r3, [sl, #4]
 80196d0:	e712      	b.n	80194f8 <_realloc_r+0x128>
 80196d2:	463a      	mov	r2, r7
 80196d4:	e705      	b.n	80194e2 <_realloc_r+0x112>
 80196d6:	4621      	mov	r1, r4
 80196d8:	4638      	mov	r0, r7
 80196da:	461d      	mov	r5, r3
 80196dc:	463c      	mov	r4, r7
 80196de:	f001 f907 	bl	801a8f0 <memmove>
 80196e2:	4657      	mov	r7, sl
 80196e4:	f8da 3004 	ldr.w	r3, [sl, #4]
 80196e8:	e706      	b.n	80194f8 <_realloc_r+0x128>
 80196ea:	68a3      	ldr	r3, [r4, #8]
 80196ec:	f8ca 3010 	str.w	r3, [sl, #16]
 80196f0:	68e3      	ldr	r3, [r4, #12]
 80196f2:	f8ca 3014 	str.w	r3, [sl, #20]
 80196f6:	2a24      	cmp	r2, #36	; 0x24
 80196f8:	d018      	beq.n	801972c <_realloc_r+0x35c>
 80196fa:	3410      	adds	r4, #16
 80196fc:	f10a 0318 	add.w	r3, sl, #24
 8019700:	e76e      	b.n	80195e0 <_realloc_r+0x210>
 8019702:	6923      	ldr	r3, [r4, #16]
 8019704:	6103      	str	r3, [r0, #16]
 8019706:	6963      	ldr	r3, [r4, #20]
 8019708:	6143      	str	r3, [r0, #20]
 801970a:	f104 0218 	add.w	r2, r4, #24
 801970e:	f100 0318 	add.w	r3, r0, #24
 8019712:	e737      	b.n	8019584 <_realloc_r+0x1b4>
 8019714:	68a1      	ldr	r1, [r4, #8]
 8019716:	f8ca 1010 	str.w	r1, [sl, #16]
 801971a:	68e1      	ldr	r1, [r4, #12]
 801971c:	f8ca 1014 	str.w	r1, [sl, #20]
 8019720:	2a24      	cmp	r2, #36	; 0x24
 8019722:	d00f      	beq.n	8019744 <_realloc_r+0x374>
 8019724:	3410      	adds	r4, #16
 8019726:	f10a 0218 	add.w	r2, sl, #24
 801972a:	e6da      	b.n	80194e2 <_realloc_r+0x112>
 801972c:	6923      	ldr	r3, [r4, #16]
 801972e:	f8ca 3018 	str.w	r3, [sl, #24]
 8019732:	6963      	ldr	r3, [r4, #20]
 8019734:	f8ca 301c 	str.w	r3, [sl, #28]
 8019738:	3418      	adds	r4, #24
 801973a:	f10a 0320 	add.w	r3, sl, #32
 801973e:	e74f      	b.n	80195e0 <_realloc_r+0x210>
 8019740:	463b      	mov	r3, r7
 8019742:	e790      	b.n	8019666 <_realloc_r+0x296>
 8019744:	6922      	ldr	r2, [r4, #16]
 8019746:	f8ca 2018 	str.w	r2, [sl, #24]
 801974a:	6962      	ldr	r2, [r4, #20]
 801974c:	f8ca 201c 	str.w	r2, [sl, #28]
 8019750:	3418      	adds	r4, #24
 8019752:	f10a 0220 	add.w	r2, sl, #32
 8019756:	e6c4      	b.n	80194e2 <_realloc_r+0x112>
 8019758:	4621      	mov	r1, r4
 801975a:	4638      	mov	r0, r7
 801975c:	f8cd c004 	str.w	ip, [sp, #4]
 8019760:	f001 f8c6 	bl	801a8f0 <memmove>
 8019764:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019768:	e783      	b.n	8019672 <_realloc_r+0x2a2>
 801976a:	68a3      	ldr	r3, [r4, #8]
 801976c:	f8ca 3010 	str.w	r3, [sl, #16]
 8019770:	68e3      	ldr	r3, [r4, #12]
 8019772:	f8ca 3014 	str.w	r3, [sl, #20]
 8019776:	2a24      	cmp	r2, #36	; 0x24
 8019778:	d003      	beq.n	8019782 <_realloc_r+0x3b2>
 801977a:	3410      	adds	r4, #16
 801977c:	f10a 0318 	add.w	r3, sl, #24
 8019780:	e771      	b.n	8019666 <_realloc_r+0x296>
 8019782:	6923      	ldr	r3, [r4, #16]
 8019784:	f8ca 3018 	str.w	r3, [sl, #24]
 8019788:	6963      	ldr	r3, [r4, #20]
 801978a:	f8ca 301c 	str.w	r3, [sl, #28]
 801978e:	3418      	adds	r4, #24
 8019790:	f10a 0320 	add.w	r3, sl, #32
 8019794:	e767      	b.n	8019666 <_realloc_r+0x296>
 8019796:	bf00      	nop
 8019798:	20000e0c 	.word	0x20000e0c
 801979c:	00000000 	.word	0x00000000

080197a0 <_sniprintf_r>:
 80197a0:	b408      	push	{r3}
 80197a2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80197a4:	1e14      	subs	r4, r2, #0
 80197a6:	b09c      	sub	sp, #112	; 0x70
 80197a8:	4607      	mov	r7, r0
 80197aa:	db23      	blt.n	80197f4 <_sniprintf_r+0x54>
 80197ac:	f44f 7302 	mov.w	r3, #520	; 0x208
 80197b0:	ad22      	add	r5, sp, #136	; 0x88
 80197b2:	bf14      	ite	ne
 80197b4:	f104 36ff 	addne.w	r6, r4, #4294967295
 80197b8:	4626      	moveq	r6, r4
 80197ba:	9a21      	ldr	r2, [sp, #132]	; 0x84
 80197bc:	9102      	str	r1, [sp, #8]
 80197be:	9106      	str	r1, [sp, #24]
 80197c0:	f8ad 3014 	strh.w	r3, [sp, #20]
 80197c4:	f64f 7eff 	movw	lr, #65535	; 0xffff
 80197c8:	462b      	mov	r3, r5
 80197ca:	a902      	add	r1, sp, #8
 80197cc:	9604      	str	r6, [sp, #16]
 80197ce:	9607      	str	r6, [sp, #28]
 80197d0:	9501      	str	r5, [sp, #4]
 80197d2:	f8ad e016 	strh.w	lr, [sp, #22]
 80197d6:	f000 f94b 	bl	8019a70 <_svfiprintf_r>
 80197da:	1c43      	adds	r3, r0, #1
 80197dc:	bfbc      	itt	lt
 80197de:	228b      	movlt	r2, #139	; 0x8b
 80197e0:	603a      	strlt	r2, [r7, #0]
 80197e2:	b114      	cbz	r4, 80197ea <_sniprintf_r+0x4a>
 80197e4:	9a02      	ldr	r2, [sp, #8]
 80197e6:	2100      	movs	r1, #0
 80197e8:	7011      	strb	r1, [r2, #0]
 80197ea:	b01c      	add	sp, #112	; 0x70
 80197ec:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80197f0:	b001      	add	sp, #4
 80197f2:	4770      	bx	lr
 80197f4:	238b      	movs	r3, #139	; 0x8b
 80197f6:	6003      	str	r3, [r0, #0]
 80197f8:	f04f 30ff 	mov.w	r0, #4294967295
 80197fc:	e7f5      	b.n	80197ea <_sniprintf_r+0x4a>
 80197fe:	bf00      	nop

08019800 <sniprintf>:
 8019800:	b40c      	push	{r2, r3}
 8019802:	b5f0      	push	{r4, r5, r6, r7, lr}
 8019804:	4b17      	ldr	r3, [pc, #92]	; (8019864 <sniprintf+0x64>)
 8019806:	1e0c      	subs	r4, r1, #0
 8019808:	b09d      	sub	sp, #116	; 0x74
 801980a:	681f      	ldr	r7, [r3, #0]
 801980c:	db24      	blt.n	8019858 <sniprintf+0x58>
 801980e:	f44f 7302 	mov.w	r3, #520	; 0x208
 8019812:	ad23      	add	r5, sp, #140	; 0x8c
 8019814:	bf14      	ite	ne
 8019816:	f104 36ff 	addne.w	r6, r4, #4294967295
 801981a:	4626      	moveq	r6, r4
 801981c:	9002      	str	r0, [sp, #8]
 801981e:	9006      	str	r0, [sp, #24]
 8019820:	f8ad 3014 	strh.w	r3, [sp, #20]
 8019824:	f64f 7eff 	movw	lr, #65535	; 0xffff
 8019828:	462b      	mov	r3, r5
 801982a:	4638      	mov	r0, r7
 801982c:	a902      	add	r1, sp, #8
 801982e:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8019830:	9604      	str	r6, [sp, #16]
 8019832:	9607      	str	r6, [sp, #28]
 8019834:	9501      	str	r5, [sp, #4]
 8019836:	f8ad e016 	strh.w	lr, [sp, #22]
 801983a:	f000 f919 	bl	8019a70 <_svfiprintf_r>
 801983e:	1c43      	adds	r3, r0, #1
 8019840:	bfbc      	itt	lt
 8019842:	238b      	movlt	r3, #139	; 0x8b
 8019844:	603b      	strlt	r3, [r7, #0]
 8019846:	b114      	cbz	r4, 801984e <sniprintf+0x4e>
 8019848:	9b02      	ldr	r3, [sp, #8]
 801984a:	2200      	movs	r2, #0
 801984c:	701a      	strb	r2, [r3, #0]
 801984e:	b01d      	add	sp, #116	; 0x74
 8019850:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8019854:	b002      	add	sp, #8
 8019856:	4770      	bx	lr
 8019858:	238b      	movs	r3, #139	; 0x8b
 801985a:	603b      	str	r3, [r7, #0]
 801985c:	f04f 30ff 	mov.w	r0, #4294967295
 8019860:	e7f5      	b.n	801984e <sniprintf+0x4e>
 8019862:	bf00      	nop
 8019864:	20000d88 	.word	0x20000d88
	...

08019870 <strchr>:
 8019870:	b2c9      	uxtb	r1, r1
 8019872:	b4f0      	push	{r4, r5, r6, r7}
 8019874:	2900      	cmp	r1, #0
 8019876:	d047      	beq.n	8019908 <strchr+0x98>
 8019878:	0785      	lsls	r5, r0, #30
 801987a:	d00f      	beq.n	801989c <strchr+0x2c>
 801987c:	7802      	ldrb	r2, [r0, #0]
 801987e:	2a00      	cmp	r2, #0
 8019880:	d03f      	beq.n	8019902 <strchr+0x92>
 8019882:	4291      	cmp	r1, r2
 8019884:	d03e      	beq.n	8019904 <strchr+0x94>
 8019886:	1c43      	adds	r3, r0, #1
 8019888:	e005      	b.n	8019896 <strchr+0x26>
 801988a:	f813 2b01 	ldrb.w	r2, [r3], #1
 801988e:	2a00      	cmp	r2, #0
 8019890:	d037      	beq.n	8019902 <strchr+0x92>
 8019892:	4291      	cmp	r1, r2
 8019894:	d036      	beq.n	8019904 <strchr+0x94>
 8019896:	079a      	lsls	r2, r3, #30
 8019898:	4618      	mov	r0, r3
 801989a:	d1f6      	bne.n	801988a <strchr+0x1a>
 801989c:	6803      	ldr	r3, [r0, #0]
 801989e:	ea41 2701 	orr.w	r7, r1, r1, lsl #8
 80198a2:	ea47 4707 	orr.w	r7, r7, r7, lsl #16
 80198a6:	ea83 0207 	eor.w	r2, r3, r7
 80198aa:	f1a2 3501 	sub.w	r5, r2, #16843009	; 0x1010101
 80198ae:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 80198b2:	ea25 0202 	bic.w	r2, r5, r2
 80198b6:	ea24 0303 	bic.w	r3, r4, r3
 80198ba:	4313      	orrs	r3, r2
 80198bc:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80198c0:	d111      	bne.n	80198e6 <strchr+0x76>
 80198c2:	1d02      	adds	r2, r0, #4
 80198c4:	4610      	mov	r0, r2
 80198c6:	f852 3b04 	ldr.w	r3, [r2], #4
 80198ca:	ea83 0407 	eor.w	r4, r3, r7
 80198ce:	f1a4 3601 	sub.w	r6, r4, #16843009	; 0x1010101
 80198d2:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 80198d6:	ea26 0404 	bic.w	r4, r6, r4
 80198da:	ea25 0303 	bic.w	r3, r5, r3
 80198de:	4323      	orrs	r3, r4
 80198e0:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80198e4:	d0ee      	beq.n	80198c4 <strchr+0x54>
 80198e6:	7803      	ldrb	r3, [r0, #0]
 80198e8:	2b00      	cmp	r3, #0
 80198ea:	d039      	beq.n	8019960 <strchr+0xf0>
 80198ec:	4299      	cmp	r1, r3
 80198ee:	d009      	beq.n	8019904 <strchr+0x94>
 80198f0:	1c43      	adds	r3, r0, #1
 80198f2:	e001      	b.n	80198f8 <strchr+0x88>
 80198f4:	4291      	cmp	r1, r2
 80198f6:	d005      	beq.n	8019904 <strchr+0x94>
 80198f8:	4618      	mov	r0, r3
 80198fa:	f813 2b01 	ldrb.w	r2, [r3], #1
 80198fe:	2a00      	cmp	r2, #0
 8019900:	d1f8      	bne.n	80198f4 <strchr+0x84>
 8019902:	4610      	mov	r0, r2
 8019904:	bcf0      	pop	{r4, r5, r6, r7}
 8019906:	4770      	bx	lr
 8019908:	0784      	lsls	r4, r0, #30
 801990a:	d00b      	beq.n	8019924 <strchr+0xb4>
 801990c:	7803      	ldrb	r3, [r0, #0]
 801990e:	2b00      	cmp	r3, #0
 8019910:	d0f8      	beq.n	8019904 <strchr+0x94>
 8019912:	1c43      	adds	r3, r0, #1
 8019914:	e003      	b.n	801991e <strchr+0xae>
 8019916:	7802      	ldrb	r2, [r0, #0]
 8019918:	3301      	adds	r3, #1
 801991a:	2a00      	cmp	r2, #0
 801991c:	d0f2      	beq.n	8019904 <strchr+0x94>
 801991e:	0799      	lsls	r1, r3, #30
 8019920:	4618      	mov	r0, r3
 8019922:	d1f8      	bne.n	8019916 <strchr+0xa6>
 8019924:	6803      	ldr	r3, [r0, #0]
 8019926:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 801992a:	ea22 0303 	bic.w	r3, r2, r3
 801992e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8019932:	d10a      	bne.n	801994a <strchr+0xda>
 8019934:	1d03      	adds	r3, r0, #4
 8019936:	4618      	mov	r0, r3
 8019938:	f853 2b04 	ldr.w	r2, [r3], #4
 801993c:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
 8019940:	ea21 0202 	bic.w	r2, r1, r2
 8019944:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8019948:	d0f5      	beq.n	8019936 <strchr+0xc6>
 801994a:	7803      	ldrb	r3, [r0, #0]
 801994c:	2b00      	cmp	r3, #0
 801994e:	d0d9      	beq.n	8019904 <strchr+0x94>
 8019950:	1c43      	adds	r3, r0, #1
 8019952:	4618      	mov	r0, r3
 8019954:	3301      	adds	r3, #1
 8019956:	7802      	ldrb	r2, [r0, #0]
 8019958:	2a00      	cmp	r2, #0
 801995a:	d1fa      	bne.n	8019952 <strchr+0xe2>
 801995c:	bcf0      	pop	{r4, r5, r6, r7}
 801995e:	4770      	bx	lr
 8019960:	4618      	mov	r0, r3
 8019962:	e7cf      	b.n	8019904 <strchr+0x94>
	...

08019970 <__ssprint_r>:
 8019970:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019974:	6894      	ldr	r4, [r2, #8]
 8019976:	6816      	ldr	r6, [r2, #0]
 8019978:	b083      	sub	sp, #12
 801997a:	4692      	mov	sl, r2
 801997c:	4680      	mov	r8, r0
 801997e:	460d      	mov	r5, r1
 8019980:	2c00      	cmp	r4, #0
 8019982:	d06f      	beq.n	8019a64 <__ssprint_r+0xf4>
 8019984:	f04f 0b00 	mov.w	fp, #0
 8019988:	6808      	ldr	r0, [r1, #0]
 801998a:	688b      	ldr	r3, [r1, #8]
 801998c:	465c      	mov	r4, fp
 801998e:	2c00      	cmp	r4, #0
 8019990:	d043      	beq.n	8019a1a <__ssprint_r+0xaa>
 8019992:	429c      	cmp	r4, r3
 8019994:	461f      	mov	r7, r3
 8019996:	d345      	bcc.n	8019a24 <__ssprint_r+0xb4>
 8019998:	89ab      	ldrh	r3, [r5, #12]
 801999a:	f413 6f90 	tst.w	r3, #1152	; 0x480
 801999e:	d044      	beq.n	8019a2a <__ssprint_r+0xba>
 80199a0:	696f      	ldr	r7, [r5, #20]
 80199a2:	6929      	ldr	r1, [r5, #16]
 80199a4:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 80199a8:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 80199ac:	ebc1 0900 	rsb	r9, r1, r0
 80199b0:	1c62      	adds	r2, r4, #1
 80199b2:	107f      	asrs	r7, r7, #1
 80199b4:	444a      	add	r2, r9
 80199b6:	4297      	cmp	r7, r2
 80199b8:	bf34      	ite	cc
 80199ba:	4617      	movcc	r7, r2
 80199bc:	463a      	movcs	r2, r7
 80199be:	055b      	lsls	r3, r3, #21
 80199c0:	d535      	bpl.n	8019a2e <__ssprint_r+0xbe>
 80199c2:	4611      	mov	r1, r2
 80199c4:	4640      	mov	r0, r8
 80199c6:	f7ff fa4b 	bl	8018e60 <_malloc_r>
 80199ca:	2800      	cmp	r0, #0
 80199cc:	d039      	beq.n	8019a42 <__ssprint_r+0xd2>
 80199ce:	6929      	ldr	r1, [r5, #16]
 80199d0:	9001      	str	r0, [sp, #4]
 80199d2:	464a      	mov	r2, r9
 80199d4:	f7fd fe04 	bl	80175e0 <memcpy>
 80199d8:	89aa      	ldrh	r2, [r5, #12]
 80199da:	9b01      	ldr	r3, [sp, #4]
 80199dc:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 80199e0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80199e4:	81aa      	strh	r2, [r5, #12]
 80199e6:	ebc9 0207 	rsb	r2, r9, r7
 80199ea:	eb03 0009 	add.w	r0, r3, r9
 80199ee:	616f      	str	r7, [r5, #20]
 80199f0:	612b      	str	r3, [r5, #16]
 80199f2:	6028      	str	r0, [r5, #0]
 80199f4:	60aa      	str	r2, [r5, #8]
 80199f6:	4627      	mov	r7, r4
 80199f8:	46a1      	mov	r9, r4
 80199fa:	464a      	mov	r2, r9
 80199fc:	4659      	mov	r1, fp
 80199fe:	f000 ff77 	bl	801a8f0 <memmove>
 8019a02:	f8da 2008 	ldr.w	r2, [sl, #8]
 8019a06:	68ab      	ldr	r3, [r5, #8]
 8019a08:	6828      	ldr	r0, [r5, #0]
 8019a0a:	1bdb      	subs	r3, r3, r7
 8019a0c:	4448      	add	r0, r9
 8019a0e:	1b14      	subs	r4, r2, r4
 8019a10:	60ab      	str	r3, [r5, #8]
 8019a12:	6028      	str	r0, [r5, #0]
 8019a14:	f8ca 4008 	str.w	r4, [sl, #8]
 8019a18:	b324      	cbz	r4, 8019a64 <__ssprint_r+0xf4>
 8019a1a:	f8d6 b000 	ldr.w	fp, [r6]
 8019a1e:	6874      	ldr	r4, [r6, #4]
 8019a20:	3608      	adds	r6, #8
 8019a22:	e7b4      	b.n	801998e <__ssprint_r+0x1e>
 8019a24:	4627      	mov	r7, r4
 8019a26:	46a1      	mov	r9, r4
 8019a28:	e7e7      	b.n	80199fa <__ssprint_r+0x8a>
 8019a2a:	46b9      	mov	r9, r7
 8019a2c:	e7e5      	b.n	80199fa <__ssprint_r+0x8a>
 8019a2e:	4640      	mov	r0, r8
 8019a30:	f7ff fcce 	bl	80193d0 <_realloc_r>
 8019a34:	4603      	mov	r3, r0
 8019a36:	2800      	cmp	r0, #0
 8019a38:	d1d5      	bne.n	80199e6 <__ssprint_r+0x76>
 8019a3a:	4640      	mov	r0, r8
 8019a3c:	6929      	ldr	r1, [r5, #16]
 8019a3e:	f000 fe3f 	bl	801a6c0 <_free_r>
 8019a42:	89aa      	ldrh	r2, [r5, #12]
 8019a44:	230c      	movs	r3, #12
 8019a46:	f8c8 3000 	str.w	r3, [r8]
 8019a4a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8019a4e:	2300      	movs	r3, #0
 8019a50:	f04f 30ff 	mov.w	r0, #4294967295
 8019a54:	81aa      	strh	r2, [r5, #12]
 8019a56:	f8ca 3008 	str.w	r3, [sl, #8]
 8019a5a:	f8ca 3004 	str.w	r3, [sl, #4]
 8019a5e:	b003      	add	sp, #12
 8019a60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019a64:	4620      	mov	r0, r4
 8019a66:	f8ca 4004 	str.w	r4, [sl, #4]
 8019a6a:	b003      	add	sp, #12
 8019a6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08019a70 <_svfiprintf_r>:
 8019a70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019a74:	4690      	mov	r8, r2
 8019a76:	898a      	ldrh	r2, [r1, #12]
 8019a78:	b0b1      	sub	sp, #196	; 0xc4
 8019a7a:	468a      	mov	sl, r1
 8019a7c:	0611      	lsls	r1, r2, #24
 8019a7e:	9309      	str	r3, [sp, #36]	; 0x24
 8019a80:	9002      	str	r0, [sp, #8]
 8019a82:	d504      	bpl.n	8019a8e <_svfiprintf_r+0x1e>
 8019a84:	f8da 3010 	ldr.w	r3, [sl, #16]
 8019a88:	2b00      	cmp	r3, #0
 8019a8a:	f000 854c 	beq.w	801a526 <_svfiprintf_r+0xab6>
 8019a8e:	2300      	movs	r3, #0
 8019a90:	af20      	add	r7, sp, #128	; 0x80
 8019a92:	930b      	str	r3, [sp, #44]	; 0x2c
 8019a94:	9315      	str	r3, [sp, #84]	; 0x54
 8019a96:	9314      	str	r3, [sp, #80]	; 0x50
 8019a98:	9308      	str	r3, [sp, #32]
 8019a9a:	9713      	str	r7, [sp, #76]	; 0x4c
 8019a9c:	463e      	mov	r6, r7
 8019a9e:	f898 3000 	ldrb.w	r3, [r8]
 8019aa2:	2b00      	cmp	r3, #0
 8019aa4:	f000 839e 	beq.w	801a1e4 <_svfiprintf_r+0x774>
 8019aa8:	2b25      	cmp	r3, #37	; 0x25
 8019aaa:	f000 839b 	beq.w	801a1e4 <_svfiprintf_r+0x774>
 8019aae:	f108 0201 	add.w	r2, r8, #1
 8019ab2:	e001      	b.n	8019ab8 <_svfiprintf_r+0x48>
 8019ab4:	2b25      	cmp	r3, #37	; 0x25
 8019ab6:	d004      	beq.n	8019ac2 <_svfiprintf_r+0x52>
 8019ab8:	4614      	mov	r4, r2
 8019aba:	3201      	adds	r2, #1
 8019abc:	7823      	ldrb	r3, [r4, #0]
 8019abe:	2b00      	cmp	r3, #0
 8019ac0:	d1f8      	bne.n	8019ab4 <_svfiprintf_r+0x44>
 8019ac2:	ebc8 0504 	rsb	r5, r8, r4
 8019ac6:	b17d      	cbz	r5, 8019ae8 <_svfiprintf_r+0x78>
 8019ac8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8019aca:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8019acc:	f8c6 8000 	str.w	r8, [r6]
 8019ad0:	3301      	adds	r3, #1
 8019ad2:	442a      	add	r2, r5
 8019ad4:	2b07      	cmp	r3, #7
 8019ad6:	6075      	str	r5, [r6, #4]
 8019ad8:	9215      	str	r2, [sp, #84]	; 0x54
 8019ada:	9314      	str	r3, [sp, #80]	; 0x50
 8019adc:	f300 842d 	bgt.w	801a33a <_svfiprintf_r+0x8ca>
 8019ae0:	3608      	adds	r6, #8
 8019ae2:	9808      	ldr	r0, [sp, #32]
 8019ae4:	4428      	add	r0, r5
 8019ae6:	9008      	str	r0, [sp, #32]
 8019ae8:	7823      	ldrb	r3, [r4, #0]
 8019aea:	2b00      	cmp	r3, #0
 8019aec:	f000 83c7 	beq.w	801a27e <_svfiprintf_r+0x80e>
 8019af0:	2100      	movs	r1, #0
 8019af2:	f04f 0200 	mov.w	r2, #0
 8019af6:	f104 0801 	add.w	r8, r4, #1
 8019afa:	7863      	ldrb	r3, [r4, #1]
 8019afc:	f88d 2047 	strb.w	r2, [sp, #71]	; 0x47
 8019b00:	f04f 34ff 	mov.w	r4, #4294967295
 8019b04:	9105      	str	r1, [sp, #20]
 8019b06:	9101      	str	r1, [sp, #4]
 8019b08:	9403      	str	r4, [sp, #12]
 8019b0a:	4608      	mov	r0, r1
 8019b0c:	f108 0801 	add.w	r8, r8, #1
 8019b10:	f1a3 0220 	sub.w	r2, r3, #32
 8019b14:	2a58      	cmp	r2, #88	; 0x58
 8019b16:	f200 829a 	bhi.w	801a04e <_svfiprintf_r+0x5de>
 8019b1a:	e8df f012 	tbh	[pc, r2, lsl #1]
 8019b1e:	0102      	.short	0x0102
 8019b20:	02980298 	.word	0x02980298
 8019b24:	029800ce 	.word	0x029800ce
 8019b28:	02980298 	.word	0x02980298
 8019b2c:	02980298 	.word	0x02980298
 8019b30:	00590298 	.word	0x00590298
 8019b34:	029800d5 	.word	0x029800d5
 8019b38:	02390064 	.word	0x02390064
 8019b3c:	022c0298 	.word	0x022c0298
 8019b40:	021e021e 	.word	0x021e021e
 8019b44:	021e021e 	.word	0x021e021e
 8019b48:	021e021e 	.word	0x021e021e
 8019b4c:	021e021e 	.word	0x021e021e
 8019b50:	0298021e 	.word	0x0298021e
 8019b54:	02980298 	.word	0x02980298
 8019b58:	02980298 	.word	0x02980298
 8019b5c:	02980298 	.word	0x02980298
 8019b60:	02980298 	.word	0x02980298
 8019b64:	02000298 	.word	0x02000298
 8019b68:	02980298 	.word	0x02980298
 8019b6c:	02980298 	.word	0x02980298
 8019b70:	02980298 	.word	0x02980298
 8019b74:	02980298 	.word	0x02980298
 8019b78:	02980298 	.word	0x02980298
 8019b7c:	02980276 	.word	0x02980276
 8019b80:	02980298 	.word	0x02980298
 8019b84:	02980298 	.word	0x02980298
 8019b88:	02980256 	.word	0x02980256
 8019b8c:	01710298 	.word	0x01710298
 8019b90:	02980298 	.word	0x02980298
 8019b94:	02980298 	.word	0x02980298
 8019b98:	02980298 	.word	0x02980298
 8019b9c:	02980298 	.word	0x02980298
 8019ba0:	02980298 	.word	0x02980298
 8019ba4:	01b30109 	.word	0x01b30109
 8019ba8:	02980298 	.word	0x02980298
 8019bac:	01aa0298 	.word	0x01aa0298
 8019bb0:	029801b3 	.word	0x029801b3
 8019bb4:	019f0298 	.word	0x019f0298
 8019bb8:	018c0298 	.word	0x018c0298
 8019bbc:	00b800a6 	.word	0x00b800a6
 8019bc0:	029801f7 	.word	0x029801f7
 8019bc4:	029801d1 	.word	0x029801d1
 8019bc8:	0298006b 	.word	0x0298006b
 8019bcc:	00d90298 	.word	0x00d90298
 8019bd0:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8019bd4:	f8dc 0000 	ldr.w	r0, [ip]
 8019bd8:	2800      	cmp	r0, #0
 8019bda:	f10c 0304 	add.w	r3, ip, #4
 8019bde:	f280 841a 	bge.w	801a416 <_svfiprintf_r+0x9a6>
 8019be2:	4240      	negs	r0, r0
 8019be4:	9309      	str	r3, [sp, #36]	; 0x24
 8019be6:	9c01      	ldr	r4, [sp, #4]
 8019be8:	f044 0404 	orr.w	r4, r4, #4
 8019bec:	9401      	str	r4, [sp, #4]
 8019bee:	f898 3000 	ldrb.w	r3, [r8]
 8019bf2:	e78b      	b.n	8019b0c <_svfiprintf_r+0x9c>
 8019bf4:	9c01      	ldr	r4, [sp, #4]
 8019bf6:	9005      	str	r0, [sp, #20]
 8019bf8:	06a0      	lsls	r0, r4, #26
 8019bfa:	f140 81f1 	bpl.w	8019fe0 <_svfiprintf_r+0x570>
 8019bfe:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8019c00:	1deb      	adds	r3, r5, #7
 8019c02:	f023 0307 	bic.w	r3, r3, #7
 8019c06:	f103 0c08 	add.w	ip, r3, #8
 8019c0a:	e9d3 4500 	ldrd	r4, r5, [r3]
 8019c0e:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8019c12:	2301      	movs	r3, #1
 8019c14:	f04f 0100 	mov.w	r1, #0
 8019c18:	9a03      	ldr	r2, [sp, #12]
 8019c1a:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8019c1e:	2000      	movs	r0, #0
 8019c20:	9206      	str	r2, [sp, #24]
 8019c22:	9007      	str	r0, [sp, #28]
 8019c24:	9903      	ldr	r1, [sp, #12]
 8019c26:	2900      	cmp	r1, #0
 8019c28:	db05      	blt.n	8019c36 <_svfiprintf_r+0x1c6>
 8019c2a:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019c2e:	f02c 0c80 	bic.w	ip, ip, #128	; 0x80
 8019c32:	f8cd c004 	str.w	ip, [sp, #4]
 8019c36:	ea54 0005 	orrs.w	r0, r4, r5
 8019c3a:	f040 82d5 	bne.w	801a1e8 <_svfiprintf_r+0x778>
 8019c3e:	9903      	ldr	r1, [sp, #12]
 8019c40:	2900      	cmp	r1, #0
 8019c42:	f040 82d1 	bne.w	801a1e8 <_svfiprintf_r+0x778>
 8019c46:	b91b      	cbnz	r3, 8019c50 <_svfiprintf_r+0x1e0>
 8019c48:	9c01      	ldr	r4, [sp, #4]
 8019c4a:	07e2      	lsls	r2, r4, #31
 8019c4c:	f100 830e 	bmi.w	801a26c <_svfiprintf_r+0x7fc>
 8019c50:	46b9      	mov	r9, r7
 8019c52:	9c03      	ldr	r4, [sp, #12]
 8019c54:	9d06      	ldr	r5, [sp, #24]
 8019c56:	42a5      	cmp	r5, r4
 8019c58:	bfb8      	it	lt
 8019c5a:	4625      	movlt	r5, r4
 8019c5c:	9c07      	ldr	r4, [sp, #28]
 8019c5e:	9504      	str	r5, [sp, #16]
 8019c60:	2c00      	cmp	r4, #0
 8019c62:	d07b      	beq.n	8019d5c <_svfiprintf_r+0x2ec>
 8019c64:	3501      	adds	r5, #1
 8019c66:	9504      	str	r5, [sp, #16]
 8019c68:	e078      	b.n	8019d5c <_svfiprintf_r+0x2ec>
 8019c6a:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019c6e:	9005      	str	r0, [sp, #20]
 8019c70:	f01c 0320 	ands.w	r3, ip, #32
 8019c74:	f000 81d4 	beq.w	801a020 <_svfiprintf_r+0x5b0>
 8019c78:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8019c7a:	1de3      	adds	r3, r4, #7
 8019c7c:	f023 0307 	bic.w	r3, r3, #7
 8019c80:	f103 0508 	add.w	r5, r3, #8
 8019c84:	9509      	str	r5, [sp, #36]	; 0x24
 8019c86:	e9d3 4500 	ldrd	r4, r5, [r3]
 8019c8a:	2300      	movs	r3, #0
 8019c8c:	e7c2      	b.n	8019c14 <_svfiprintf_r+0x1a4>
 8019c8e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8019c90:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019c94:	9005      	str	r0, [sp, #20]
 8019c96:	2330      	movs	r3, #48	; 0x30
 8019c98:	1d15      	adds	r5, r2, #4
 8019c9a:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 8019c9e:	f04c 0c02 	orr.w	ip, ip, #2
 8019ca2:	2378      	movs	r3, #120	; 0x78
 8019ca4:	48b7      	ldr	r0, [pc, #732]	; (8019f84 <_svfiprintf_r+0x514>)
 8019ca6:	9509      	str	r5, [sp, #36]	; 0x24
 8019ca8:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
 8019cac:	6814      	ldr	r4, [r2, #0]
 8019cae:	f8cd c004 	str.w	ip, [sp, #4]
 8019cb2:	2500      	movs	r5, #0
 8019cb4:	900b      	str	r0, [sp, #44]	; 0x2c
 8019cb6:	2302      	movs	r3, #2
 8019cb8:	e7ac      	b.n	8019c14 <_svfiprintf_r+0x1a4>
 8019cba:	9d01      	ldr	r5, [sp, #4]
 8019cbc:	f045 0501 	orr.w	r5, r5, #1
 8019cc0:	9501      	str	r5, [sp, #4]
 8019cc2:	f898 3000 	ldrb.w	r3, [r8]
 8019cc6:	e721      	b.n	8019b0c <_svfiprintf_r+0x9c>
 8019cc8:	f898 3000 	ldrb.w	r3, [r8]
 8019ccc:	212b      	movs	r1, #43	; 0x2b
 8019cce:	e71d      	b.n	8019b0c <_svfiprintf_r+0x9c>
 8019cd0:	9d01      	ldr	r5, [sp, #4]
 8019cd2:	4cac      	ldr	r4, [pc, #688]	; (8019f84 <_svfiprintf_r+0x514>)
 8019cd4:	9005      	str	r0, [sp, #20]
 8019cd6:	06aa      	lsls	r2, r5, #26
 8019cd8:	940b      	str	r4, [sp, #44]	; 0x2c
 8019cda:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8019cde:	f140 8098 	bpl.w	8019e12 <_svfiprintf_r+0x3a2>
 8019ce2:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8019ce6:	f10c 0207 	add.w	r2, ip, #7
 8019cea:	f022 0207 	bic.w	r2, r2, #7
 8019cee:	f102 0408 	add.w	r4, r2, #8
 8019cf2:	9409      	str	r4, [sp, #36]	; 0x24
 8019cf4:	e9d2 4500 	ldrd	r4, r5, [r2]
 8019cf8:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019cfc:	f01c 0f01 	tst.w	ip, #1
 8019d00:	f000 81ba 	beq.w	801a078 <_svfiprintf_r+0x608>
 8019d04:	ea54 0005 	orrs.w	r0, r4, r5
 8019d08:	f000 81b6 	beq.w	801a078 <_svfiprintf_r+0x608>
 8019d0c:	2230      	movs	r2, #48	; 0x30
 8019d0e:	f04c 0c02 	orr.w	ip, ip, #2
 8019d12:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
 8019d16:	f8cd c004 	str.w	ip, [sp, #4]
 8019d1a:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
 8019d1e:	2302      	movs	r3, #2
 8019d20:	e778      	b.n	8019c14 <_svfiprintf_r+0x1a4>
 8019d22:	f898 3000 	ldrb.w	r3, [r8]
 8019d26:	2900      	cmp	r1, #0
 8019d28:	f47f aef0 	bne.w	8019b0c <_svfiprintf_r+0x9c>
 8019d2c:	2120      	movs	r1, #32
 8019d2e:	e6ed      	b.n	8019b0c <_svfiprintf_r+0x9c>
 8019d30:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8019d32:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8019d36:	681b      	ldr	r3, [r3, #0]
 8019d38:	9005      	str	r0, [sp, #20]
 8019d3a:	2401      	movs	r4, #1
 8019d3c:	f04f 0500 	mov.w	r5, #0
 8019d40:	f10c 0c04 	add.w	ip, ip, #4
 8019d44:	9404      	str	r4, [sp, #16]
 8019d46:	f88d 5047 	strb.w	r5, [sp, #71]	; 0x47
 8019d4a:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
 8019d4e:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8019d52:	9406      	str	r4, [sp, #24]
 8019d54:	f10d 0958 	add.w	r9, sp, #88	; 0x58
 8019d58:	2400      	movs	r4, #0
 8019d5a:	9403      	str	r4, [sp, #12]
 8019d5c:	9d01      	ldr	r5, [sp, #4]
 8019d5e:	f015 0502 	ands.w	r5, r5, #2
 8019d62:	9507      	str	r5, [sp, #28]
 8019d64:	d005      	beq.n	8019d72 <_svfiprintf_r+0x302>
 8019d66:	f8dd c010 	ldr.w	ip, [sp, #16]
 8019d6a:	f10c 0c02 	add.w	ip, ip, #2
 8019d6e:	f8cd c010 	str.w	ip, [sp, #16]
 8019d72:	9b01      	ldr	r3, [sp, #4]
 8019d74:	f013 0384 	ands.w	r3, r3, #132	; 0x84
 8019d78:	930a      	str	r3, [sp, #40]	; 0x28
 8019d7a:	f040 817f 	bne.w	801a07c <_svfiprintf_r+0x60c>
 8019d7e:	9d05      	ldr	r5, [sp, #20]
 8019d80:	f8dd c010 	ldr.w	ip, [sp, #16]
 8019d84:	ebcc 0405 	rsb	r4, ip, r5
 8019d88:	2c00      	cmp	r4, #0
 8019d8a:	f340 8177 	ble.w	801a07c <_svfiprintf_r+0x60c>
 8019d8e:	2c10      	cmp	r4, #16
 8019d90:	9915      	ldr	r1, [sp, #84]	; 0x54
 8019d92:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8019d94:	f8df b1f4 	ldr.w	fp, [pc, #500]	; 8019f8c <_svfiprintf_r+0x51c>
 8019d98:	dd26      	ble.n	8019de8 <_svfiprintf_r+0x378>
 8019d9a:	465b      	mov	r3, fp
 8019d9c:	2510      	movs	r5, #16
 8019d9e:	46a3      	mov	fp, r4
 8019da0:	461c      	mov	r4, r3
 8019da2:	e006      	b.n	8019db2 <_svfiprintf_r+0x342>
 8019da4:	f1ab 0b10 	sub.w	fp, fp, #16
 8019da8:	f1bb 0f10 	cmp.w	fp, #16
 8019dac:	f106 0608 	add.w	r6, r6, #8
 8019db0:	dd17      	ble.n	8019de2 <_svfiprintf_r+0x372>
 8019db2:	3201      	adds	r2, #1
 8019db4:	3110      	adds	r1, #16
 8019db6:	2a07      	cmp	r2, #7
 8019db8:	9115      	str	r1, [sp, #84]	; 0x54
 8019dba:	9214      	str	r2, [sp, #80]	; 0x50
 8019dbc:	e886 0030 	stmia.w	r6, {r4, r5}
 8019dc0:	ddf0      	ble.n	8019da4 <_svfiprintf_r+0x334>
 8019dc2:	9802      	ldr	r0, [sp, #8]
 8019dc4:	4651      	mov	r1, sl
 8019dc6:	aa13      	add	r2, sp, #76	; 0x4c
 8019dc8:	f7ff fdd2 	bl	8019970 <__ssprint_r>
 8019dcc:	2800      	cmp	r0, #0
 8019dce:	f040 825d 	bne.w	801a28c <_svfiprintf_r+0x81c>
 8019dd2:	f1ab 0b10 	sub.w	fp, fp, #16
 8019dd6:	f1bb 0f10 	cmp.w	fp, #16
 8019dda:	9915      	ldr	r1, [sp, #84]	; 0x54
 8019ddc:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8019dde:	463e      	mov	r6, r7
 8019de0:	dce7      	bgt.n	8019db2 <_svfiprintf_r+0x342>
 8019de2:	4623      	mov	r3, r4
 8019de4:	465c      	mov	r4, fp
 8019de6:	469b      	mov	fp, r3
 8019de8:	3201      	adds	r2, #1
 8019dea:	4421      	add	r1, r4
 8019dec:	2a07      	cmp	r2, #7
 8019dee:	9115      	str	r1, [sp, #84]	; 0x54
 8019df0:	9214      	str	r2, [sp, #80]	; 0x50
 8019df2:	f8c6 b000 	str.w	fp, [r6]
 8019df6:	6074      	str	r4, [r6, #4]
 8019df8:	f300 82ee 	bgt.w	801a3d8 <_svfiprintf_r+0x968>
 8019dfc:	3608      	adds	r6, #8
 8019dfe:	e13f      	b.n	801a080 <_svfiprintf_r+0x610>
 8019e00:	9d01      	ldr	r5, [sp, #4]
 8019e02:	4c61      	ldr	r4, [pc, #388]	; (8019f88 <_svfiprintf_r+0x518>)
 8019e04:	9005      	str	r0, [sp, #20]
 8019e06:	06aa      	lsls	r2, r5, #26
 8019e08:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8019e0c:	940b      	str	r4, [sp, #44]	; 0x2c
 8019e0e:	f53f af68 	bmi.w	8019ce2 <_svfiprintf_r+0x272>
 8019e12:	9d01      	ldr	r5, [sp, #4]
 8019e14:	06ed      	lsls	r5, r5, #27
 8019e16:	f100 8330 	bmi.w	801a47a <_svfiprintf_r+0xa0a>
 8019e1a:	9c01      	ldr	r4, [sp, #4]
 8019e1c:	0664      	lsls	r4, r4, #25
 8019e1e:	f140 8358 	bpl.w	801a4d2 <_svfiprintf_r+0xa62>
 8019e22:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8019e26:	f8bc 4000 	ldrh.w	r4, [ip]
 8019e2a:	f10c 0c04 	add.w	ip, ip, #4
 8019e2e:	2500      	movs	r5, #0
 8019e30:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8019e34:	e760      	b.n	8019cf8 <_svfiprintf_r+0x288>
 8019e36:	9c01      	ldr	r4, [sp, #4]
 8019e38:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8019e3c:	06a4      	lsls	r4, r4, #26
 8019e3e:	f100 8326 	bmi.w	801a48e <_svfiprintf_r+0xa1e>
 8019e42:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019e46:	f01c 0f10 	tst.w	ip, #16
 8019e4a:	f000 8348 	beq.w	801a4de <_svfiprintf_r+0xa6e>
 8019e4e:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8019e50:	9d08      	ldr	r5, [sp, #32]
 8019e52:	6823      	ldr	r3, [r4, #0]
 8019e54:	3404      	adds	r4, #4
 8019e56:	9409      	str	r4, [sp, #36]	; 0x24
 8019e58:	601d      	str	r5, [r3, #0]
 8019e5a:	e620      	b.n	8019a9e <_svfiprintf_r+0x2e>
 8019e5c:	f898 3000 	ldrb.w	r3, [r8]
 8019e60:	2b6c      	cmp	r3, #108	; 0x6c
 8019e62:	4642      	mov	r2, r8
 8019e64:	f000 8320 	beq.w	801a4a8 <_svfiprintf_r+0xa38>
 8019e68:	9d01      	ldr	r5, [sp, #4]
 8019e6a:	f045 0510 	orr.w	r5, r5, #16
 8019e6e:	9501      	str	r5, [sp, #4]
 8019e70:	e64c      	b.n	8019b0c <_svfiprintf_r+0x9c>
 8019e72:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019e76:	f04c 0c40 	orr.w	ip, ip, #64	; 0x40
 8019e7a:	f8cd c004 	str.w	ip, [sp, #4]
 8019e7e:	f898 3000 	ldrb.w	r3, [r8]
 8019e82:	e643      	b.n	8019b0c <_svfiprintf_r+0x9c>
 8019e84:	9d01      	ldr	r5, [sp, #4]
 8019e86:	9005      	str	r0, [sp, #20]
 8019e88:	06aa      	lsls	r2, r5, #26
 8019e8a:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8019e8e:	d550      	bpl.n	8019f32 <_svfiprintf_r+0x4c2>
 8019e90:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8019e94:	f10c 0107 	add.w	r1, ip, #7
 8019e98:	f021 0107 	bic.w	r1, r1, #7
 8019e9c:	e9d1 2300 	ldrd	r2, r3, [r1]
 8019ea0:	3108      	adds	r1, #8
 8019ea2:	9109      	str	r1, [sp, #36]	; 0x24
 8019ea4:	4614      	mov	r4, r2
 8019ea6:	461d      	mov	r5, r3
 8019ea8:	2a00      	cmp	r2, #0
 8019eaa:	f173 0000 	sbcs.w	r0, r3, #0
 8019eae:	f2c0 82d6 	blt.w	801a45e <_svfiprintf_r+0x9ee>
 8019eb2:	f89d 1047 	ldrb.w	r1, [sp, #71]	; 0x47
 8019eb6:	9a03      	ldr	r2, [sp, #12]
 8019eb8:	9107      	str	r1, [sp, #28]
 8019eba:	9206      	str	r2, [sp, #24]
 8019ebc:	2301      	movs	r3, #1
 8019ebe:	e6b1      	b.n	8019c24 <_svfiprintf_r+0x1b4>
 8019ec0:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8019ec2:	9005      	str	r0, [sp, #20]
 8019ec4:	f8d4 9000 	ldr.w	r9, [r4]
 8019ec8:	f04f 0500 	mov.w	r5, #0
 8019ecc:	f88d 5047 	strb.w	r5, [sp, #71]	; 0x47
 8019ed0:	3404      	adds	r4, #4
 8019ed2:	9d03      	ldr	r5, [sp, #12]
 8019ed4:	f1b9 0f00 	cmp.w	r9, #0
 8019ed8:	f000 8319 	beq.w	801a50e <_svfiprintf_r+0xa9e>
 8019edc:	2d00      	cmp	r5, #0
 8019ede:	4648      	mov	r0, r9
 8019ee0:	f2c0 830a 	blt.w	801a4f8 <_svfiprintf_r+0xa88>
 8019ee4:	2100      	movs	r1, #0
 8019ee6:	462a      	mov	r2, r5
 8019ee8:	f000 fcba 	bl	801a860 <memchr>
 8019eec:	2800      	cmp	r0, #0
 8019eee:	f000 8334 	beq.w	801a55a <_svfiprintf_r+0xaea>
 8019ef2:	ebc9 0000 	rsb	r0, r9, r0
 8019ef6:	42a8      	cmp	r0, r5
 8019ef8:	bfb8      	it	lt
 8019efa:	4605      	movlt	r5, r0
 8019efc:	9506      	str	r5, [sp, #24]
 8019efe:	9409      	str	r4, [sp, #36]	; 0x24
 8019f00:	2500      	movs	r5, #0
 8019f02:	f89d 4047 	ldrb.w	r4, [sp, #71]	; 0x47
 8019f06:	9407      	str	r4, [sp, #28]
 8019f08:	9503      	str	r5, [sp, #12]
 8019f0a:	e6a2      	b.n	8019c52 <_svfiprintf_r+0x1e2>
 8019f0c:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019f10:	f04c 0c20 	orr.w	ip, ip, #32
 8019f14:	f8cd c004 	str.w	ip, [sp, #4]
 8019f18:	f898 3000 	ldrb.w	r3, [r8]
 8019f1c:	e5f6      	b.n	8019b0c <_svfiprintf_r+0x9c>
 8019f1e:	9c01      	ldr	r4, [sp, #4]
 8019f20:	9005      	str	r0, [sp, #20]
 8019f22:	f044 0410 	orr.w	r4, r4, #16
 8019f26:	9401      	str	r4, [sp, #4]
 8019f28:	9d01      	ldr	r5, [sp, #4]
 8019f2a:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8019f2e:	06aa      	lsls	r2, r5, #26
 8019f30:	d4ae      	bmi.n	8019e90 <_svfiprintf_r+0x420>
 8019f32:	9c01      	ldr	r4, [sp, #4]
 8019f34:	06e3      	lsls	r3, r4, #27
 8019f36:	f100 8282 	bmi.w	801a43e <_svfiprintf_r+0x9ce>
 8019f3a:	9c01      	ldr	r4, [sp, #4]
 8019f3c:	0665      	lsls	r5, r4, #25
 8019f3e:	f140 827e 	bpl.w	801a43e <_svfiprintf_r+0x9ce>
 8019f42:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8019f46:	f9bc 4000 	ldrsh.w	r4, [ip]
 8019f4a:	f10c 0c04 	add.w	ip, ip, #4
 8019f4e:	17e5      	asrs	r5, r4, #31
 8019f50:	4622      	mov	r2, r4
 8019f52:	462b      	mov	r3, r5
 8019f54:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8019f58:	e7a6      	b.n	8019ea8 <_svfiprintf_r+0x438>
 8019f5a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8019f5e:	2000      	movs	r0, #0
 8019f60:	f818 3b01 	ldrb.w	r3, [r8], #1
 8019f64:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8019f68:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 8019f6c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8019f70:	2a09      	cmp	r2, #9
 8019f72:	d9f5      	bls.n	8019f60 <_svfiprintf_r+0x4f0>
 8019f74:	e5cc      	b.n	8019b10 <_svfiprintf_r+0xa0>
 8019f76:	9d01      	ldr	r5, [sp, #4]
 8019f78:	f045 0580 	orr.w	r5, r5, #128	; 0x80
 8019f7c:	9501      	str	r5, [sp, #4]
 8019f7e:	f898 3000 	ldrb.w	r3, [r8]
 8019f82:	e5c3      	b.n	8019b0c <_svfiprintf_r+0x9c>
 8019f84:	0801c624 	.word	0x0801c624
 8019f88:	0801c610 	.word	0x0801c610
 8019f8c:	0801c640 	.word	0x0801c640
 8019f90:	f898 3000 	ldrb.w	r3, [r8]
 8019f94:	2b2a      	cmp	r3, #42	; 0x2a
 8019f96:	f108 0501 	add.w	r5, r8, #1
 8019f9a:	f000 82ec 	beq.w	801a576 <_svfiprintf_r+0xb06>
 8019f9e:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8019fa2:	2a09      	cmp	r2, #9
 8019fa4:	bf98      	it	ls
 8019fa6:	2400      	movls	r4, #0
 8019fa8:	f200 82e0 	bhi.w	801a56c <_svfiprintf_r+0xafc>
 8019fac:	f815 3b01 	ldrb.w	r3, [r5], #1
 8019fb0:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8019fb4:	eb02 0444 	add.w	r4, r2, r4, lsl #1
 8019fb8:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8019fbc:	2a09      	cmp	r2, #9
 8019fbe:	d9f5      	bls.n	8019fac <_svfiprintf_r+0x53c>
 8019fc0:	ea44 74e4 	orr.w	r4, r4, r4, asr #31
 8019fc4:	9403      	str	r4, [sp, #12]
 8019fc6:	46a8      	mov	r8, r5
 8019fc8:	e5a2      	b.n	8019b10 <_svfiprintf_r+0xa0>
 8019fca:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019fce:	9005      	str	r0, [sp, #20]
 8019fd0:	f04c 0c10 	orr.w	ip, ip, #16
 8019fd4:	f8cd c004 	str.w	ip, [sp, #4]
 8019fd8:	9c01      	ldr	r4, [sp, #4]
 8019fda:	06a0      	lsls	r0, r4, #26
 8019fdc:	f53f ae0f 	bmi.w	8019bfe <_svfiprintf_r+0x18e>
 8019fe0:	9c01      	ldr	r4, [sp, #4]
 8019fe2:	06e1      	lsls	r1, r4, #27
 8019fe4:	f100 8223 	bmi.w	801a42e <_svfiprintf_r+0x9be>
 8019fe8:	f8dd c004 	ldr.w	ip, [sp, #4]
 8019fec:	f01c 0f40 	tst.w	ip, #64	; 0x40
 8019ff0:	f000 821d 	beq.w	801a42e <_svfiprintf_r+0x9be>
 8019ff4:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8019ff8:	f8bc 4000 	ldrh.w	r4, [ip]
 8019ffc:	f10c 0c04 	add.w	ip, ip, #4
 801a000:	2500      	movs	r5, #0
 801a002:	2301      	movs	r3, #1
 801a004:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 801a008:	e604      	b.n	8019c14 <_svfiprintf_r+0x1a4>
 801a00a:	9d01      	ldr	r5, [sp, #4]
 801a00c:	9005      	str	r0, [sp, #20]
 801a00e:	f045 0510 	orr.w	r5, r5, #16
 801a012:	9501      	str	r5, [sp, #4]
 801a014:	f8dd c004 	ldr.w	ip, [sp, #4]
 801a018:	f01c 0320 	ands.w	r3, ip, #32
 801a01c:	f47f ae2c 	bne.w	8019c78 <_svfiprintf_r+0x208>
 801a020:	f8dd c004 	ldr.w	ip, [sp, #4]
 801a024:	f01c 0210 	ands.w	r2, ip, #16
 801a028:	f040 81fa 	bne.w	801a420 <_svfiprintf_r+0x9b0>
 801a02c:	f8dd c004 	ldr.w	ip, [sp, #4]
 801a030:	f01c 0340 	ands.w	r3, ip, #64	; 0x40
 801a034:	f000 81f4 	beq.w	801a420 <_svfiprintf_r+0x9b0>
 801a038:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 801a03c:	f8bc 4000 	ldrh.w	r4, [ip]
 801a040:	f10c 0c04 	add.w	ip, ip, #4
 801a044:	4613      	mov	r3, r2
 801a046:	2500      	movs	r5, #0
 801a048:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 801a04c:	e5e2      	b.n	8019c14 <_svfiprintf_r+0x1a4>
 801a04e:	9005      	str	r0, [sp, #20]
 801a050:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 801a054:	2b00      	cmp	r3, #0
 801a056:	f000 8112 	beq.w	801a27e <_svfiprintf_r+0x80e>
 801a05a:	f04f 0c01 	mov.w	ip, #1
 801a05e:	f04f 0000 	mov.w	r0, #0
 801a062:	f8cd c010 	str.w	ip, [sp, #16]
 801a066:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
 801a06a:	f88d 0047 	strb.w	r0, [sp, #71]	; 0x47
 801a06e:	f8cd c018 	str.w	ip, [sp, #24]
 801a072:	f10d 0958 	add.w	r9, sp, #88	; 0x58
 801a076:	e66f      	b.n	8019d58 <_svfiprintf_r+0x2e8>
 801a078:	2302      	movs	r3, #2
 801a07a:	e5cb      	b.n	8019c14 <_svfiprintf_r+0x1a4>
 801a07c:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a07e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a080:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
 801a084:	b163      	cbz	r3, 801a0a0 <_svfiprintf_r+0x630>
 801a086:	3201      	adds	r2, #1
 801a088:	3101      	adds	r1, #1
 801a08a:	f10d 0047 	add.w	r0, sp, #71	; 0x47
 801a08e:	2301      	movs	r3, #1
 801a090:	2a07      	cmp	r2, #7
 801a092:	9115      	str	r1, [sp, #84]	; 0x54
 801a094:	9214      	str	r2, [sp, #80]	; 0x50
 801a096:	e886 0009 	stmia.w	r6, {r0, r3}
 801a09a:	f300 8185 	bgt.w	801a3a8 <_svfiprintf_r+0x938>
 801a09e:	3608      	adds	r6, #8
 801a0a0:	9b07      	ldr	r3, [sp, #28]
 801a0a2:	b15b      	cbz	r3, 801a0bc <_svfiprintf_r+0x64c>
 801a0a4:	3201      	adds	r2, #1
 801a0a6:	3102      	adds	r1, #2
 801a0a8:	a812      	add	r0, sp, #72	; 0x48
 801a0aa:	2302      	movs	r3, #2
 801a0ac:	2a07      	cmp	r2, #7
 801a0ae:	9115      	str	r1, [sp, #84]	; 0x54
 801a0b0:	9214      	str	r2, [sp, #80]	; 0x50
 801a0b2:	e886 0009 	stmia.w	r6, {r0, r3}
 801a0b6:	f300 8183 	bgt.w	801a3c0 <_svfiprintf_r+0x950>
 801a0ba:	3608      	adds	r6, #8
 801a0bc:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 801a0be:	2c80      	cmp	r4, #128	; 0x80
 801a0c0:	f000 80ef 	beq.w	801a2a2 <_svfiprintf_r+0x832>
 801a0c4:	9d03      	ldr	r5, [sp, #12]
 801a0c6:	9b06      	ldr	r3, [sp, #24]
 801a0c8:	1aec      	subs	r4, r5, r3
 801a0ca:	2c00      	cmp	r4, #0
 801a0cc:	dd30      	ble.n	801a130 <_svfiprintf_r+0x6c0>
 801a0ce:	2c10      	cmp	r4, #16
 801a0d0:	4da4      	ldr	r5, [pc, #656]	; (801a364 <_svfiprintf_r+0x8f4>)
 801a0d2:	dd23      	ble.n	801a11c <_svfiprintf_r+0x6ac>
 801a0d4:	462b      	mov	r3, r5
 801a0d6:	f04f 0b10 	mov.w	fp, #16
 801a0da:	4625      	mov	r5, r4
 801a0dc:	461c      	mov	r4, r3
 801a0de:	e004      	b.n	801a0ea <_svfiprintf_r+0x67a>
 801a0e0:	3d10      	subs	r5, #16
 801a0e2:	2d10      	cmp	r5, #16
 801a0e4:	f106 0608 	add.w	r6, r6, #8
 801a0e8:	dd15      	ble.n	801a116 <_svfiprintf_r+0x6a6>
 801a0ea:	3201      	adds	r2, #1
 801a0ec:	3110      	adds	r1, #16
 801a0ee:	2a07      	cmp	r2, #7
 801a0f0:	9115      	str	r1, [sp, #84]	; 0x54
 801a0f2:	9214      	str	r2, [sp, #80]	; 0x50
 801a0f4:	e886 0810 	stmia.w	r6, {r4, fp}
 801a0f8:	ddf2      	ble.n	801a0e0 <_svfiprintf_r+0x670>
 801a0fa:	9802      	ldr	r0, [sp, #8]
 801a0fc:	4651      	mov	r1, sl
 801a0fe:	aa13      	add	r2, sp, #76	; 0x4c
 801a100:	f7ff fc36 	bl	8019970 <__ssprint_r>
 801a104:	2800      	cmp	r0, #0
 801a106:	f040 80c1 	bne.w	801a28c <_svfiprintf_r+0x81c>
 801a10a:	3d10      	subs	r5, #16
 801a10c:	2d10      	cmp	r5, #16
 801a10e:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a110:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a112:	463e      	mov	r6, r7
 801a114:	dce9      	bgt.n	801a0ea <_svfiprintf_r+0x67a>
 801a116:	4623      	mov	r3, r4
 801a118:	462c      	mov	r4, r5
 801a11a:	461d      	mov	r5, r3
 801a11c:	3201      	adds	r2, #1
 801a11e:	4421      	add	r1, r4
 801a120:	2a07      	cmp	r2, #7
 801a122:	9115      	str	r1, [sp, #84]	; 0x54
 801a124:	9214      	str	r2, [sp, #80]	; 0x50
 801a126:	6035      	str	r5, [r6, #0]
 801a128:	6074      	str	r4, [r6, #4]
 801a12a:	f300 8110 	bgt.w	801a34e <_svfiprintf_r+0x8de>
 801a12e:	3608      	adds	r6, #8
 801a130:	9c06      	ldr	r4, [sp, #24]
 801a132:	f8c6 9000 	str.w	r9, [r6]
 801a136:	3201      	adds	r2, #1
 801a138:	4421      	add	r1, r4
 801a13a:	2a07      	cmp	r2, #7
 801a13c:	9115      	str	r1, [sp, #84]	; 0x54
 801a13e:	9214      	str	r2, [sp, #80]	; 0x50
 801a140:	6074      	str	r4, [r6, #4]
 801a142:	f300 80e7 	bgt.w	801a314 <_svfiprintf_r+0x8a4>
 801a146:	3608      	adds	r6, #8
 801a148:	9d01      	ldr	r5, [sp, #4]
 801a14a:	076b      	lsls	r3, r5, #29
 801a14c:	d536      	bpl.n	801a1bc <_svfiprintf_r+0x74c>
 801a14e:	9d05      	ldr	r5, [sp, #20]
 801a150:	f8dd c010 	ldr.w	ip, [sp, #16]
 801a154:	ebcc 0405 	rsb	r4, ip, r5
 801a158:	2c00      	cmp	r4, #0
 801a15a:	dd2f      	ble.n	801a1bc <_svfiprintf_r+0x74c>
 801a15c:	2c10      	cmp	r4, #16
 801a15e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a160:	f8df b204 	ldr.w	fp, [pc, #516]	; 801a368 <_svfiprintf_r+0x8f8>
 801a164:	dd20      	ble.n	801a1a8 <_svfiprintf_r+0x738>
 801a166:	2510      	movs	r5, #16
 801a168:	460b      	mov	r3, r1
 801a16a:	f8dd 9008 	ldr.w	r9, [sp, #8]
 801a16e:	e004      	b.n	801a17a <_svfiprintf_r+0x70a>
 801a170:	3c10      	subs	r4, #16
 801a172:	2c10      	cmp	r4, #16
 801a174:	f106 0608 	add.w	r6, r6, #8
 801a178:	dd15      	ble.n	801a1a6 <_svfiprintf_r+0x736>
 801a17a:	3201      	adds	r2, #1
 801a17c:	3310      	adds	r3, #16
 801a17e:	2a07      	cmp	r2, #7
 801a180:	9315      	str	r3, [sp, #84]	; 0x54
 801a182:	9214      	str	r2, [sp, #80]	; 0x50
 801a184:	f8c6 b000 	str.w	fp, [r6]
 801a188:	6075      	str	r5, [r6, #4]
 801a18a:	ddf1      	ble.n	801a170 <_svfiprintf_r+0x700>
 801a18c:	4648      	mov	r0, r9
 801a18e:	4651      	mov	r1, sl
 801a190:	aa13      	add	r2, sp, #76	; 0x4c
 801a192:	f7ff fbed 	bl	8019970 <__ssprint_r>
 801a196:	2800      	cmp	r0, #0
 801a198:	d178      	bne.n	801a28c <_svfiprintf_r+0x81c>
 801a19a:	3c10      	subs	r4, #16
 801a19c:	2c10      	cmp	r4, #16
 801a19e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801a1a0:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a1a2:	463e      	mov	r6, r7
 801a1a4:	dce9      	bgt.n	801a17a <_svfiprintf_r+0x70a>
 801a1a6:	4619      	mov	r1, r3
 801a1a8:	3201      	adds	r2, #1
 801a1aa:	4421      	add	r1, r4
 801a1ac:	2a07      	cmp	r2, #7
 801a1ae:	9115      	str	r1, [sp, #84]	; 0x54
 801a1b0:	9214      	str	r2, [sp, #80]	; 0x50
 801a1b2:	f8c6 b000 	str.w	fp, [r6]
 801a1b6:	6074      	str	r4, [r6, #4]
 801a1b8:	f300 8123 	bgt.w	801a402 <_svfiprintf_r+0x992>
 801a1bc:	9c08      	ldr	r4, [sp, #32]
 801a1be:	f8dd c010 	ldr.w	ip, [sp, #16]
 801a1c2:	9d05      	ldr	r5, [sp, #20]
 801a1c4:	45ac      	cmp	ip, r5
 801a1c6:	bfac      	ite	ge
 801a1c8:	4464      	addge	r4, ip
 801a1ca:	1964      	addlt	r4, r4, r5
 801a1cc:	9408      	str	r4, [sp, #32]
 801a1ce:	2900      	cmp	r1, #0
 801a1d0:	f040 80aa 	bne.w	801a328 <_svfiprintf_r+0x8b8>
 801a1d4:	f898 3000 	ldrb.w	r3, [r8]
 801a1d8:	2000      	movs	r0, #0
 801a1da:	9014      	str	r0, [sp, #80]	; 0x50
 801a1dc:	463e      	mov	r6, r7
 801a1de:	2b00      	cmp	r3, #0
 801a1e0:	f47f ac62 	bne.w	8019aa8 <_svfiprintf_r+0x38>
 801a1e4:	4644      	mov	r4, r8
 801a1e6:	e47f      	b.n	8019ae8 <_svfiprintf_r+0x78>
 801a1e8:	2b01      	cmp	r3, #1
 801a1ea:	f000 80bf 	beq.w	801a36c <_svfiprintf_r+0x8fc>
 801a1ee:	2b02      	cmp	r3, #2
 801a1f0:	f10d 037f 	add.w	r3, sp, #127	; 0x7f
 801a1f4:	d11a      	bne.n	801a22c <_svfiprintf_r+0x7bc>
 801a1f6:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 801a1fa:	4619      	mov	r1, r3
 801a1fc:	f004 000f 	and.w	r0, r4, #15
 801a200:	0922      	lsrs	r2, r4, #4
 801a202:	ea42 7205 	orr.w	r2, r2, r5, lsl #28
 801a206:	4689      	mov	r9, r1
 801a208:	092b      	lsrs	r3, r5, #4
 801a20a:	f81c 1000 	ldrb.w	r1, [ip, r0]
 801a20e:	f889 1000 	strb.w	r1, [r9]
 801a212:	ea52 0003 	orrs.w	r0, r2, r3
 801a216:	4614      	mov	r4, r2
 801a218:	461d      	mov	r5, r3
 801a21a:	f109 31ff 	add.w	r1, r9, #4294967295
 801a21e:	d1ed      	bne.n	801a1fc <_svfiprintf_r+0x78c>
 801a220:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 801a224:	ebc9 0307 	rsb	r3, r9, r7
 801a228:	9306      	str	r3, [sp, #24]
 801a22a:	e512      	b.n	8019c52 <_svfiprintf_r+0x1e2>
 801a22c:	08e0      	lsrs	r0, r4, #3
 801a22e:	ea40 7045 	orr.w	r0, r0, r5, lsl #29
 801a232:	f004 0207 	and.w	r2, r4, #7
 801a236:	08e9      	lsrs	r1, r5, #3
 801a238:	3230      	adds	r2, #48	; 0x30
 801a23a:	ea50 0c01 	orrs.w	ip, r0, r1
 801a23e:	4699      	mov	r9, r3
 801a240:	701a      	strb	r2, [r3, #0]
 801a242:	4604      	mov	r4, r0
 801a244:	460d      	mov	r5, r1
 801a246:	f103 33ff 	add.w	r3, r3, #4294967295
 801a24a:	d1ef      	bne.n	801a22c <_svfiprintf_r+0x7bc>
 801a24c:	9c01      	ldr	r4, [sp, #4]
 801a24e:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 801a252:	07e0      	lsls	r0, r4, #31
 801a254:	4649      	mov	r1, r9
 801a256:	d50e      	bpl.n	801a276 <_svfiprintf_r+0x806>
 801a258:	2a30      	cmp	r2, #48	; 0x30
 801a25a:	d0e3      	beq.n	801a224 <_svfiprintf_r+0x7b4>
 801a25c:	4699      	mov	r9, r3
 801a25e:	ebc9 0407 	rsb	r4, r9, r7
 801a262:	2330      	movs	r3, #48	; 0x30
 801a264:	9406      	str	r4, [sp, #24]
 801a266:	f801 3c01 	strb.w	r3, [r1, #-1]
 801a26a:	e4f2      	b.n	8019c52 <_svfiprintf_r+0x1e2>
 801a26c:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
 801a270:	2330      	movs	r3, #48	; 0x30
 801a272:	f809 3d41 	strb.w	r3, [r9, #-65]!
 801a276:	ebc9 0507 	rsb	r5, r9, r7
 801a27a:	9506      	str	r5, [sp, #24]
 801a27c:	e4e9      	b.n	8019c52 <_svfiprintf_r+0x1e2>
 801a27e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801a280:	b123      	cbz	r3, 801a28c <_svfiprintf_r+0x81c>
 801a282:	9802      	ldr	r0, [sp, #8]
 801a284:	4651      	mov	r1, sl
 801a286:	aa13      	add	r2, sp, #76	; 0x4c
 801a288:	f7ff fb72 	bl	8019970 <__ssprint_r>
 801a28c:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 801a290:	9808      	ldr	r0, [sp, #32]
 801a292:	f013 0f40 	tst.w	r3, #64	; 0x40
 801a296:	bf18      	it	ne
 801a298:	f04f 30ff 	movne.w	r0, #4294967295
 801a29c:	b031      	add	sp, #196	; 0xc4
 801a29e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801a2a2:	9d05      	ldr	r5, [sp, #20]
 801a2a4:	f8dd c010 	ldr.w	ip, [sp, #16]
 801a2a8:	ebcc 0405 	rsb	r4, ip, r5
 801a2ac:	2c00      	cmp	r4, #0
 801a2ae:	f77f af09 	ble.w	801a0c4 <_svfiprintf_r+0x654>
 801a2b2:	2c10      	cmp	r4, #16
 801a2b4:	4d2b      	ldr	r5, [pc, #172]	; (801a364 <_svfiprintf_r+0x8f4>)
 801a2b6:	dd22      	ble.n	801a2fe <_svfiprintf_r+0x88e>
 801a2b8:	462b      	mov	r3, r5
 801a2ba:	f04f 0b10 	mov.w	fp, #16
 801a2be:	4625      	mov	r5, r4
 801a2c0:	461c      	mov	r4, r3
 801a2c2:	e004      	b.n	801a2ce <_svfiprintf_r+0x85e>
 801a2c4:	3d10      	subs	r5, #16
 801a2c6:	2d10      	cmp	r5, #16
 801a2c8:	f106 0608 	add.w	r6, r6, #8
 801a2cc:	dd14      	ble.n	801a2f8 <_svfiprintf_r+0x888>
 801a2ce:	3201      	adds	r2, #1
 801a2d0:	3110      	adds	r1, #16
 801a2d2:	2a07      	cmp	r2, #7
 801a2d4:	9115      	str	r1, [sp, #84]	; 0x54
 801a2d6:	9214      	str	r2, [sp, #80]	; 0x50
 801a2d8:	e886 0810 	stmia.w	r6, {r4, fp}
 801a2dc:	ddf2      	ble.n	801a2c4 <_svfiprintf_r+0x854>
 801a2de:	9802      	ldr	r0, [sp, #8]
 801a2e0:	4651      	mov	r1, sl
 801a2e2:	aa13      	add	r2, sp, #76	; 0x4c
 801a2e4:	f7ff fb44 	bl	8019970 <__ssprint_r>
 801a2e8:	2800      	cmp	r0, #0
 801a2ea:	d1cf      	bne.n	801a28c <_svfiprintf_r+0x81c>
 801a2ec:	3d10      	subs	r5, #16
 801a2ee:	2d10      	cmp	r5, #16
 801a2f0:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a2f2:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a2f4:	463e      	mov	r6, r7
 801a2f6:	dcea      	bgt.n	801a2ce <_svfiprintf_r+0x85e>
 801a2f8:	4623      	mov	r3, r4
 801a2fa:	462c      	mov	r4, r5
 801a2fc:	461d      	mov	r5, r3
 801a2fe:	3201      	adds	r2, #1
 801a300:	4421      	add	r1, r4
 801a302:	2a07      	cmp	r2, #7
 801a304:	9115      	str	r1, [sp, #84]	; 0x54
 801a306:	9214      	str	r2, [sp, #80]	; 0x50
 801a308:	6035      	str	r5, [r6, #0]
 801a30a:	6074      	str	r4, [r6, #4]
 801a30c:	f300 80d5 	bgt.w	801a4ba <_svfiprintf_r+0xa4a>
 801a310:	3608      	adds	r6, #8
 801a312:	e6d7      	b.n	801a0c4 <_svfiprintf_r+0x654>
 801a314:	9802      	ldr	r0, [sp, #8]
 801a316:	4651      	mov	r1, sl
 801a318:	aa13      	add	r2, sp, #76	; 0x4c
 801a31a:	f7ff fb29 	bl	8019970 <__ssprint_r>
 801a31e:	2800      	cmp	r0, #0
 801a320:	d1b4      	bne.n	801a28c <_svfiprintf_r+0x81c>
 801a322:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a324:	463e      	mov	r6, r7
 801a326:	e70f      	b.n	801a148 <_svfiprintf_r+0x6d8>
 801a328:	9802      	ldr	r0, [sp, #8]
 801a32a:	4651      	mov	r1, sl
 801a32c:	aa13      	add	r2, sp, #76	; 0x4c
 801a32e:	f7ff fb1f 	bl	8019970 <__ssprint_r>
 801a332:	2800      	cmp	r0, #0
 801a334:	f43f af4e 	beq.w	801a1d4 <_svfiprintf_r+0x764>
 801a338:	e7a8      	b.n	801a28c <_svfiprintf_r+0x81c>
 801a33a:	9802      	ldr	r0, [sp, #8]
 801a33c:	4651      	mov	r1, sl
 801a33e:	aa13      	add	r2, sp, #76	; 0x4c
 801a340:	f7ff fb16 	bl	8019970 <__ssprint_r>
 801a344:	2800      	cmp	r0, #0
 801a346:	d1a1      	bne.n	801a28c <_svfiprintf_r+0x81c>
 801a348:	463e      	mov	r6, r7
 801a34a:	f7ff bbca 	b.w	8019ae2 <_svfiprintf_r+0x72>
 801a34e:	9802      	ldr	r0, [sp, #8]
 801a350:	4651      	mov	r1, sl
 801a352:	aa13      	add	r2, sp, #76	; 0x4c
 801a354:	f7ff fb0c 	bl	8019970 <__ssprint_r>
 801a358:	2800      	cmp	r0, #0
 801a35a:	d197      	bne.n	801a28c <_svfiprintf_r+0x81c>
 801a35c:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a35e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a360:	463e      	mov	r6, r7
 801a362:	e6e5      	b.n	801a130 <_svfiprintf_r+0x6c0>
 801a364:	0801c600 	.word	0x0801c600
 801a368:	0801c640 	.word	0x0801c640
 801a36c:	2d00      	cmp	r5, #0
 801a36e:	bf08      	it	eq
 801a370:	2c0a      	cmpeq	r4, #10
 801a372:	d33d      	bcc.n	801a3f0 <_svfiprintf_r+0x980>
 801a374:	f10d 0b7f 	add.w	fp, sp, #127	; 0x7f
 801a378:	4620      	mov	r0, r4
 801a37a:	4629      	mov	r1, r5
 801a37c:	220a      	movs	r2, #10
 801a37e:	2300      	movs	r3, #0
 801a380:	f7fd fade 	bl	8017940 <__aeabi_uldivmod>
 801a384:	3230      	adds	r2, #48	; 0x30
 801a386:	f88b 2000 	strb.w	r2, [fp]
 801a38a:	4620      	mov	r0, r4
 801a38c:	4629      	mov	r1, r5
 801a38e:	220a      	movs	r2, #10
 801a390:	2300      	movs	r3, #0
 801a392:	f7fd fad5 	bl	8017940 <__aeabi_uldivmod>
 801a396:	4604      	mov	r4, r0
 801a398:	460d      	mov	r5, r1
 801a39a:	ea54 0c05 	orrs.w	ip, r4, r5
 801a39e:	46d9      	mov	r9, fp
 801a3a0:	f10b 3bff 	add.w	fp, fp, #4294967295
 801a3a4:	d1e8      	bne.n	801a378 <_svfiprintf_r+0x908>
 801a3a6:	e73d      	b.n	801a224 <_svfiprintf_r+0x7b4>
 801a3a8:	9802      	ldr	r0, [sp, #8]
 801a3aa:	4651      	mov	r1, sl
 801a3ac:	aa13      	add	r2, sp, #76	; 0x4c
 801a3ae:	f7ff fadf 	bl	8019970 <__ssprint_r>
 801a3b2:	2800      	cmp	r0, #0
 801a3b4:	f47f af6a 	bne.w	801a28c <_svfiprintf_r+0x81c>
 801a3b8:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a3ba:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a3bc:	463e      	mov	r6, r7
 801a3be:	e66f      	b.n	801a0a0 <_svfiprintf_r+0x630>
 801a3c0:	9802      	ldr	r0, [sp, #8]
 801a3c2:	4651      	mov	r1, sl
 801a3c4:	aa13      	add	r2, sp, #76	; 0x4c
 801a3c6:	f7ff fad3 	bl	8019970 <__ssprint_r>
 801a3ca:	2800      	cmp	r0, #0
 801a3cc:	f47f af5e 	bne.w	801a28c <_svfiprintf_r+0x81c>
 801a3d0:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a3d2:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a3d4:	463e      	mov	r6, r7
 801a3d6:	e671      	b.n	801a0bc <_svfiprintf_r+0x64c>
 801a3d8:	9802      	ldr	r0, [sp, #8]
 801a3da:	4651      	mov	r1, sl
 801a3dc:	aa13      	add	r2, sp, #76	; 0x4c
 801a3de:	f7ff fac7 	bl	8019970 <__ssprint_r>
 801a3e2:	2800      	cmp	r0, #0
 801a3e4:	f47f af52 	bne.w	801a28c <_svfiprintf_r+0x81c>
 801a3e8:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a3ea:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a3ec:	463e      	mov	r6, r7
 801a3ee:	e647      	b.n	801a080 <_svfiprintf_r+0x610>
 801a3f0:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
 801a3f4:	3430      	adds	r4, #48	; 0x30
 801a3f6:	f809 4d41 	strb.w	r4, [r9, #-65]!
 801a3fa:	ebc9 0507 	rsb	r5, r9, r7
 801a3fe:	9506      	str	r5, [sp, #24]
 801a400:	e427      	b.n	8019c52 <_svfiprintf_r+0x1e2>
 801a402:	9802      	ldr	r0, [sp, #8]
 801a404:	4651      	mov	r1, sl
 801a406:	aa13      	add	r2, sp, #76	; 0x4c
 801a408:	f7ff fab2 	bl	8019970 <__ssprint_r>
 801a40c:	2800      	cmp	r0, #0
 801a40e:	f47f af3d 	bne.w	801a28c <_svfiprintf_r+0x81c>
 801a412:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a414:	e6d2      	b.n	801a1bc <_svfiprintf_r+0x74c>
 801a416:	9309      	str	r3, [sp, #36]	; 0x24
 801a418:	f898 3000 	ldrb.w	r3, [r8]
 801a41c:	f7ff bb76 	b.w	8019b0c <_svfiprintf_r+0x9c>
 801a420:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801a422:	682c      	ldr	r4, [r5, #0]
 801a424:	3504      	adds	r5, #4
 801a426:	9509      	str	r5, [sp, #36]	; 0x24
 801a428:	2500      	movs	r5, #0
 801a42a:	f7ff bbf3 	b.w	8019c14 <_svfiprintf_r+0x1a4>
 801a42e:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801a430:	682c      	ldr	r4, [r5, #0]
 801a432:	3504      	adds	r5, #4
 801a434:	9509      	str	r5, [sp, #36]	; 0x24
 801a436:	2301      	movs	r3, #1
 801a438:	2500      	movs	r5, #0
 801a43a:	f7ff bbeb 	b.w	8019c14 <_svfiprintf_r+0x1a4>
 801a43e:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801a440:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 801a444:	682c      	ldr	r4, [r5, #0]
 801a446:	17e5      	asrs	r5, r4, #31
 801a448:	4622      	mov	r2, r4
 801a44a:	462b      	mov	r3, r5
 801a44c:	f10c 0c04 	add.w	ip, ip, #4
 801a450:	2a00      	cmp	r2, #0
 801a452:	f173 0000 	sbcs.w	r0, r3, #0
 801a456:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 801a45a:	f6bf ad2a 	bge.w	8019eb2 <_svfiprintf_r+0x442>
 801a45e:	f04f 0b2d 	mov.w	fp, #45	; 0x2d
 801a462:	9b03      	ldr	r3, [sp, #12]
 801a464:	9306      	str	r3, [sp, #24]
 801a466:	4264      	negs	r4, r4
 801a468:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 801a46c:	f88d b047 	strb.w	fp, [sp, #71]	; 0x47
 801a470:	f8cd b01c 	str.w	fp, [sp, #28]
 801a474:	2301      	movs	r3, #1
 801a476:	f7ff bbd5 	b.w	8019c24 <_svfiprintf_r+0x1b4>
 801a47a:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 801a47e:	f8dc 4000 	ldr.w	r4, [ip]
 801a482:	f10c 0c04 	add.w	ip, ip, #4
 801a486:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 801a48a:	2500      	movs	r5, #0
 801a48c:	e434      	b.n	8019cf8 <_svfiprintf_r+0x288>
 801a48e:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801a490:	9c08      	ldr	r4, [sp, #32]
 801a492:	6829      	ldr	r1, [r5, #0]
 801a494:	17e5      	asrs	r5, r4, #31
 801a496:	462b      	mov	r3, r5
 801a498:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801a49a:	4622      	mov	r2, r4
 801a49c:	3504      	adds	r5, #4
 801a49e:	9509      	str	r5, [sp, #36]	; 0x24
 801a4a0:	e9c1 2300 	strd	r2, r3, [r1]
 801a4a4:	f7ff bafb 	b.w	8019a9e <_svfiprintf_r+0x2e>
 801a4a8:	9c01      	ldr	r4, [sp, #4]
 801a4aa:	7853      	ldrb	r3, [r2, #1]
 801a4ac:	f044 0420 	orr.w	r4, r4, #32
 801a4b0:	f108 0801 	add.w	r8, r8, #1
 801a4b4:	9401      	str	r4, [sp, #4]
 801a4b6:	f7ff bb29 	b.w	8019b0c <_svfiprintf_r+0x9c>
 801a4ba:	9802      	ldr	r0, [sp, #8]
 801a4bc:	4651      	mov	r1, sl
 801a4be:	aa13      	add	r2, sp, #76	; 0x4c
 801a4c0:	f7ff fa56 	bl	8019970 <__ssprint_r>
 801a4c4:	2800      	cmp	r0, #0
 801a4c6:	f47f aee1 	bne.w	801a28c <_svfiprintf_r+0x81c>
 801a4ca:	9915      	ldr	r1, [sp, #84]	; 0x54
 801a4cc:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801a4ce:	463e      	mov	r6, r7
 801a4d0:	e5f8      	b.n	801a0c4 <_svfiprintf_r+0x654>
 801a4d2:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801a4d4:	682c      	ldr	r4, [r5, #0]
 801a4d6:	3504      	adds	r5, #4
 801a4d8:	9509      	str	r5, [sp, #36]	; 0x24
 801a4da:	2500      	movs	r5, #0
 801a4dc:	e40c      	b.n	8019cf8 <_svfiprintf_r+0x288>
 801a4de:	f8dd c004 	ldr.w	ip, [sp, #4]
 801a4e2:	f01c 0f40 	tst.w	ip, #64	; 0x40
 801a4e6:	d02c      	beq.n	801a542 <_svfiprintf_r+0xad2>
 801a4e8:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801a4ea:	9d08      	ldr	r5, [sp, #32]
 801a4ec:	6823      	ldr	r3, [r4, #0]
 801a4ee:	3404      	adds	r4, #4
 801a4f0:	9409      	str	r4, [sp, #36]	; 0x24
 801a4f2:	801d      	strh	r5, [r3, #0]
 801a4f4:	f7ff bad3 	b.w	8019a9e <_svfiprintf_r+0x2e>
 801a4f8:	9409      	str	r4, [sp, #36]	; 0x24
 801a4fa:	f7fe f909 	bl	8018710 <strlen>
 801a4fe:	2500      	movs	r5, #0
 801a500:	f89d 4047 	ldrb.w	r4, [sp, #71]	; 0x47
 801a504:	9006      	str	r0, [sp, #24]
 801a506:	9407      	str	r4, [sp, #28]
 801a508:	9503      	str	r5, [sp, #12]
 801a50a:	f7ff bba2 	b.w	8019c52 <_svfiprintf_r+0x1e2>
 801a50e:	2d06      	cmp	r5, #6
 801a510:	bf28      	it	cs
 801a512:	2506      	movcs	r5, #6
 801a514:	ea25 7ce5 	bic.w	ip, r5, r5, asr #31
 801a518:	9506      	str	r5, [sp, #24]
 801a51a:	9409      	str	r4, [sp, #36]	; 0x24
 801a51c:	f8cd c010 	str.w	ip, [sp, #16]
 801a520:	f8df 9084 	ldr.w	r9, [pc, #132]	; 801a5a8 <_svfiprintf_r+0xb38>
 801a524:	e418      	b.n	8019d58 <_svfiprintf_r+0x2e8>
 801a526:	2140      	movs	r1, #64	; 0x40
 801a528:	f7fe fc9a 	bl	8018e60 <_malloc_r>
 801a52c:	f8ca 0000 	str.w	r0, [sl]
 801a530:	f8ca 0010 	str.w	r0, [sl, #16]
 801a534:	2800      	cmp	r0, #0
 801a536:	d031      	beq.n	801a59c <_svfiprintf_r+0xb2c>
 801a538:	2340      	movs	r3, #64	; 0x40
 801a53a:	f8ca 3014 	str.w	r3, [sl, #20]
 801a53e:	f7ff baa6 	b.w	8019a8e <_svfiprintf_r+0x1e>
 801a542:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 801a546:	9c08      	ldr	r4, [sp, #32]
 801a548:	f8dc 3000 	ldr.w	r3, [ip]
 801a54c:	f10c 0c04 	add.w	ip, ip, #4
 801a550:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 801a554:	601c      	str	r4, [r3, #0]
 801a556:	f7ff baa2 	b.w	8019a9e <_svfiprintf_r+0x2e>
 801a55a:	f89d 5047 	ldrb.w	r5, [sp, #71]	; 0x47
 801a55e:	9507      	str	r5, [sp, #28]
 801a560:	9d03      	ldr	r5, [sp, #12]
 801a562:	9506      	str	r5, [sp, #24]
 801a564:	9409      	str	r4, [sp, #36]	; 0x24
 801a566:	9003      	str	r0, [sp, #12]
 801a568:	f7ff bb73 	b.w	8019c52 <_svfiprintf_r+0x1e2>
 801a56c:	46a8      	mov	r8, r5
 801a56e:	2500      	movs	r5, #0
 801a570:	9503      	str	r5, [sp, #12]
 801a572:	f7ff bacd 	b.w	8019b10 <_svfiprintf_r+0xa0>
 801a576:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801a578:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 801a57c:	6824      	ldr	r4, [r4, #0]
 801a57e:	f898 3001 	ldrb.w	r3, [r8, #1]
 801a582:	9403      	str	r4, [sp, #12]
 801a584:	f10c 0204 	add.w	r2, ip, #4
 801a588:	2c00      	cmp	r4, #0
 801a58a:	9209      	str	r2, [sp, #36]	; 0x24
 801a58c:	46a8      	mov	r8, r5
 801a58e:	f6bf aabd 	bge.w	8019b0c <_svfiprintf_r+0x9c>
 801a592:	f04f 34ff 	mov.w	r4, #4294967295
 801a596:	9403      	str	r4, [sp, #12]
 801a598:	f7ff bab8 	b.w	8019b0c <_svfiprintf_r+0x9c>
 801a59c:	9c02      	ldr	r4, [sp, #8]
 801a59e:	230c      	movs	r3, #12
 801a5a0:	6023      	str	r3, [r4, #0]
 801a5a2:	f04f 30ff 	mov.w	r0, #4294967295
 801a5a6:	e679      	b.n	801a29c <_svfiprintf_r+0x82c>
 801a5a8:	0801c638 	.word	0x0801c638
 801a5ac:	00000000 	.word	0x00000000

0801a5b0 <close>:
 801a5b0:	4b02      	ldr	r3, [pc, #8]	; (801a5bc <close+0xc>)
 801a5b2:	4601      	mov	r1, r0
 801a5b4:	6818      	ldr	r0, [r3, #0]
 801a5b6:	f7f7 bbb3 	b.w	8011d20 <_close_r>
 801a5ba:	bf00      	nop
 801a5bc:	20000d88 	.word	0x20000d88

0801a5c0 <fstat>:
 801a5c0:	4b02      	ldr	r3, [pc, #8]	; (801a5cc <fstat+0xc>)
 801a5c2:	460a      	mov	r2, r1
 801a5c4:	4601      	mov	r1, r0
 801a5c6:	6818      	ldr	r0, [r3, #0]
 801a5c8:	f7f7 bbca 	b.w	8011d60 <_fstat_r>
 801a5cc:	20000d88 	.word	0x20000d88

0801a5d0 <open>:
 801a5d0:	b40e      	push	{r1, r2, r3}
 801a5d2:	b510      	push	{r4, lr}
 801a5d4:	b083      	sub	sp, #12
 801a5d6:	a905      	add	r1, sp, #20
 801a5d8:	4c06      	ldr	r4, [pc, #24]	; (801a5f4 <open+0x24>)
 801a5da:	f851 2b04 	ldr.w	r2, [r1], #4
 801a5de:	9101      	str	r1, [sp, #4]
 801a5e0:	9b06      	ldr	r3, [sp, #24]
 801a5e2:	4601      	mov	r1, r0
 801a5e4:	6820      	ldr	r0, [r4, #0]
 801a5e6:	f7f7 fb93 	bl	8011d10 <_open_r>
 801a5ea:	b003      	add	sp, #12
 801a5ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801a5f0:	b003      	add	sp, #12
 801a5f2:	4770      	bx	lr
 801a5f4:	20000d88 	.word	0x20000d88
	...

0801a600 <read>:
 801a600:	b430      	push	{r4, r5}
 801a602:	4c04      	ldr	r4, [pc, #16]	; (801a614 <read+0x14>)
 801a604:	460d      	mov	r5, r1
 801a606:	4613      	mov	r3, r2
 801a608:	4601      	mov	r1, r0
 801a60a:	462a      	mov	r2, r5
 801a60c:	6820      	ldr	r0, [r4, #0]
 801a60e:	bc30      	pop	{r4, r5}
 801a610:	f7f7 bb4e 	b.w	8011cb0 <_read_r>
 801a614:	20000d88 	.word	0x20000d88
	...

0801a620 <_malloc_trim_r>:
 801a620:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a622:	4d23      	ldr	r5, [pc, #140]	; (801a6b0 <_malloc_trim_r+0x90>)
 801a624:	460f      	mov	r7, r1
 801a626:	4604      	mov	r4, r0
 801a628:	f7fe feba 	bl	80193a0 <__malloc_lock>
 801a62c:	68ab      	ldr	r3, [r5, #8]
 801a62e:	685e      	ldr	r6, [r3, #4]
 801a630:	f026 0603 	bic.w	r6, r6, #3
 801a634:	1bf1      	subs	r1, r6, r7
 801a636:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
 801a63a:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 801a63e:	f021 010f 	bic.w	r1, r1, #15
 801a642:	f5a1 5780 	sub.w	r7, r1, #4096	; 0x1000
 801a646:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 801a64a:	db07      	blt.n	801a65c <_malloc_trim_r+0x3c>
 801a64c:	4620      	mov	r0, r4
 801a64e:	2100      	movs	r1, #0
 801a650:	f7f7 fb6e 	bl	8011d30 <_sbrk_r>
 801a654:	68ab      	ldr	r3, [r5, #8]
 801a656:	4433      	add	r3, r6
 801a658:	4298      	cmp	r0, r3
 801a65a:	d004      	beq.n	801a666 <_malloc_trim_r+0x46>
 801a65c:	4620      	mov	r0, r4
 801a65e:	f7fe fea7 	bl	80193b0 <__malloc_unlock>
 801a662:	2000      	movs	r0, #0
 801a664:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801a666:	4620      	mov	r0, r4
 801a668:	4279      	negs	r1, r7
 801a66a:	f7f7 fb61 	bl	8011d30 <_sbrk_r>
 801a66e:	3001      	adds	r0, #1
 801a670:	d00d      	beq.n	801a68e <_malloc_trim_r+0x6e>
 801a672:	4b10      	ldr	r3, [pc, #64]	; (801a6b4 <_malloc_trim_r+0x94>)
 801a674:	68aa      	ldr	r2, [r5, #8]
 801a676:	6819      	ldr	r1, [r3, #0]
 801a678:	1bf6      	subs	r6, r6, r7
 801a67a:	f046 0601 	orr.w	r6, r6, #1
 801a67e:	4620      	mov	r0, r4
 801a680:	1bc9      	subs	r1, r1, r7
 801a682:	6056      	str	r6, [r2, #4]
 801a684:	6019      	str	r1, [r3, #0]
 801a686:	f7fe fe93 	bl	80193b0 <__malloc_unlock>
 801a68a:	2001      	movs	r0, #1
 801a68c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801a68e:	4620      	mov	r0, r4
 801a690:	2100      	movs	r1, #0
 801a692:	f7f7 fb4d 	bl	8011d30 <_sbrk_r>
 801a696:	68ab      	ldr	r3, [r5, #8]
 801a698:	1ac2      	subs	r2, r0, r3
 801a69a:	2a0f      	cmp	r2, #15
 801a69c:	ddde      	ble.n	801a65c <_malloc_trim_r+0x3c>
 801a69e:	4d06      	ldr	r5, [pc, #24]	; (801a6b8 <_malloc_trim_r+0x98>)
 801a6a0:	4904      	ldr	r1, [pc, #16]	; (801a6b4 <_malloc_trim_r+0x94>)
 801a6a2:	682d      	ldr	r5, [r5, #0]
 801a6a4:	f042 0201 	orr.w	r2, r2, #1
 801a6a8:	1b40      	subs	r0, r0, r5
 801a6aa:	605a      	str	r2, [r3, #4]
 801a6ac:	6008      	str	r0, [r1, #0]
 801a6ae:	e7d5      	b.n	801a65c <_malloc_trim_r+0x3c>
 801a6b0:	20000e0c 	.word	0x20000e0c
 801a6b4:	20003980 	.word	0x20003980
 801a6b8:	20001218 	.word	0x20001218
 801a6bc:	00000000 	.word	0x00000000

0801a6c0 <_free_r>:
 801a6c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a6c4:	460d      	mov	r5, r1
 801a6c6:	4606      	mov	r6, r0
 801a6c8:	2900      	cmp	r1, #0
 801a6ca:	d055      	beq.n	801a778 <_free_r+0xb8>
 801a6cc:	f7fe fe68 	bl	80193a0 <__malloc_lock>
 801a6d0:	f855 1c04 	ldr.w	r1, [r5, #-4]
 801a6d4:	f8df c174 	ldr.w	ip, [pc, #372]	; 801a84c <_free_r+0x18c>
 801a6d8:	f021 0301 	bic.w	r3, r1, #1
 801a6dc:	f1a5 0408 	sub.w	r4, r5, #8
 801a6e0:	18e2      	adds	r2, r4, r3
 801a6e2:	f8dc 0008 	ldr.w	r0, [ip, #8]
 801a6e6:	6857      	ldr	r7, [r2, #4]
 801a6e8:	4290      	cmp	r0, r2
 801a6ea:	f027 0703 	bic.w	r7, r7, #3
 801a6ee:	d069      	beq.n	801a7c4 <_free_r+0x104>
 801a6f0:	f011 0101 	ands.w	r1, r1, #1
 801a6f4:	6057      	str	r7, [r2, #4]
 801a6f6:	d032      	beq.n	801a75e <_free_r+0x9e>
 801a6f8:	2100      	movs	r1, #0
 801a6fa:	19d0      	adds	r0, r2, r7
 801a6fc:	6840      	ldr	r0, [r0, #4]
 801a6fe:	07c0      	lsls	r0, r0, #31
 801a700:	d406      	bmi.n	801a710 <_free_r+0x50>
 801a702:	443b      	add	r3, r7
 801a704:	6890      	ldr	r0, [r2, #8]
 801a706:	2900      	cmp	r1, #0
 801a708:	d04e      	beq.n	801a7a8 <_free_r+0xe8>
 801a70a:	68d2      	ldr	r2, [r2, #12]
 801a70c:	60c2      	str	r2, [r0, #12]
 801a70e:	6090      	str	r0, [r2, #8]
 801a710:	f043 0201 	orr.w	r2, r3, #1
 801a714:	6062      	str	r2, [r4, #4]
 801a716:	50e3      	str	r3, [r4, r3]
 801a718:	b9e1      	cbnz	r1, 801a754 <_free_r+0x94>
 801a71a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801a71e:	d32d      	bcc.n	801a77c <_free_r+0xbc>
 801a720:	0a5a      	lsrs	r2, r3, #9
 801a722:	2a04      	cmp	r2, #4
 801a724:	d86a      	bhi.n	801a7fc <_free_r+0x13c>
 801a726:	0998      	lsrs	r0, r3, #6
 801a728:	3038      	adds	r0, #56	; 0x38
 801a72a:	0041      	lsls	r1, r0, #1
 801a72c:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
 801a730:	4946      	ldr	r1, [pc, #280]	; (801a84c <_free_r+0x18c>)
 801a732:	f8dc 2008 	ldr.w	r2, [ip, #8]
 801a736:	4562      	cmp	r2, ip
 801a738:	d066      	beq.n	801a808 <_free_r+0x148>
 801a73a:	6851      	ldr	r1, [r2, #4]
 801a73c:	f021 0103 	bic.w	r1, r1, #3
 801a740:	428b      	cmp	r3, r1
 801a742:	d202      	bcs.n	801a74a <_free_r+0x8a>
 801a744:	6892      	ldr	r2, [r2, #8]
 801a746:	4594      	cmp	ip, r2
 801a748:	d1f7      	bne.n	801a73a <_free_r+0x7a>
 801a74a:	68d3      	ldr	r3, [r2, #12]
 801a74c:	60e3      	str	r3, [r4, #12]
 801a74e:	60a2      	str	r2, [r4, #8]
 801a750:	609c      	str	r4, [r3, #8]
 801a752:	60d4      	str	r4, [r2, #12]
 801a754:	4630      	mov	r0, r6
 801a756:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801a75a:	f7fe be29 	b.w	80193b0 <__malloc_unlock>
 801a75e:	f855 5c08 	ldr.w	r5, [r5, #-8]
 801a762:	1b64      	subs	r4, r4, r5
 801a764:	f10c 0808 	add.w	r8, ip, #8
 801a768:	68a0      	ldr	r0, [r4, #8]
 801a76a:	4540      	cmp	r0, r8
 801a76c:	442b      	add	r3, r5
 801a76e:	d043      	beq.n	801a7f8 <_free_r+0x138>
 801a770:	68e5      	ldr	r5, [r4, #12]
 801a772:	60c5      	str	r5, [r0, #12]
 801a774:	60a8      	str	r0, [r5, #8]
 801a776:	e7c0      	b.n	801a6fa <_free_r+0x3a>
 801a778:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801a77c:	08db      	lsrs	r3, r3, #3
 801a77e:	eb0c 02c3 	add.w	r2, ip, r3, lsl #3
 801a782:	2501      	movs	r5, #1
 801a784:	f8dc 0004 	ldr.w	r0, [ip, #4]
 801a788:	6891      	ldr	r1, [r2, #8]
 801a78a:	60a1      	str	r1, [r4, #8]
 801a78c:	109b      	asrs	r3, r3, #2
 801a78e:	fa05 f303 	lsl.w	r3, r5, r3
 801a792:	4318      	orrs	r0, r3
 801a794:	60e2      	str	r2, [r4, #12]
 801a796:	f8cc 0004 	str.w	r0, [ip, #4]
 801a79a:	6094      	str	r4, [r2, #8]
 801a79c:	4630      	mov	r0, r6
 801a79e:	60cc      	str	r4, [r1, #12]
 801a7a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801a7a4:	f7fe be04 	b.w	80193b0 <__malloc_unlock>
 801a7a8:	4d29      	ldr	r5, [pc, #164]	; (801a850 <_free_r+0x190>)
 801a7aa:	42a8      	cmp	r0, r5
 801a7ac:	d1ad      	bne.n	801a70a <_free_r+0x4a>
 801a7ae:	f043 0201 	orr.w	r2, r3, #1
 801a7b2:	f8cc 4014 	str.w	r4, [ip, #20]
 801a7b6:	f8cc 4010 	str.w	r4, [ip, #16]
 801a7ba:	60e0      	str	r0, [r4, #12]
 801a7bc:	60a0      	str	r0, [r4, #8]
 801a7be:	6062      	str	r2, [r4, #4]
 801a7c0:	50e3      	str	r3, [r4, r3]
 801a7c2:	e7c7      	b.n	801a754 <_free_r+0x94>
 801a7c4:	441f      	add	r7, r3
 801a7c6:	07cb      	lsls	r3, r1, #31
 801a7c8:	d407      	bmi.n	801a7da <_free_r+0x11a>
 801a7ca:	f855 3c08 	ldr.w	r3, [r5, #-8]
 801a7ce:	1ae4      	subs	r4, r4, r3
 801a7d0:	441f      	add	r7, r3
 801a7d2:	68a2      	ldr	r2, [r4, #8]
 801a7d4:	68e3      	ldr	r3, [r4, #12]
 801a7d6:	60d3      	str	r3, [r2, #12]
 801a7d8:	609a      	str	r2, [r3, #8]
 801a7da:	4b1e      	ldr	r3, [pc, #120]	; (801a854 <_free_r+0x194>)
 801a7dc:	681b      	ldr	r3, [r3, #0]
 801a7de:	f047 0201 	orr.w	r2, r7, #1
 801a7e2:	429f      	cmp	r7, r3
 801a7e4:	6062      	str	r2, [r4, #4]
 801a7e6:	f8cc 4008 	str.w	r4, [ip, #8]
 801a7ea:	d3b3      	bcc.n	801a754 <_free_r+0x94>
 801a7ec:	4b1a      	ldr	r3, [pc, #104]	; (801a858 <_free_r+0x198>)
 801a7ee:	4630      	mov	r0, r6
 801a7f0:	6819      	ldr	r1, [r3, #0]
 801a7f2:	f7ff ff15 	bl	801a620 <_malloc_trim_r>
 801a7f6:	e7ad      	b.n	801a754 <_free_r+0x94>
 801a7f8:	2101      	movs	r1, #1
 801a7fa:	e77e      	b.n	801a6fa <_free_r+0x3a>
 801a7fc:	2a14      	cmp	r2, #20
 801a7fe:	d80c      	bhi.n	801a81a <_free_r+0x15a>
 801a800:	f102 005b 	add.w	r0, r2, #91	; 0x5b
 801a804:	0041      	lsls	r1, r0, #1
 801a806:	e791      	b.n	801a72c <_free_r+0x6c>
 801a808:	684b      	ldr	r3, [r1, #4]
 801a80a:	1080      	asrs	r0, r0, #2
 801a80c:	2501      	movs	r5, #1
 801a80e:	fa05 f000 	lsl.w	r0, r5, r0
 801a812:	4303      	orrs	r3, r0
 801a814:	604b      	str	r3, [r1, #4]
 801a816:	4613      	mov	r3, r2
 801a818:	e798      	b.n	801a74c <_free_r+0x8c>
 801a81a:	2a54      	cmp	r2, #84	; 0x54
 801a81c:	d803      	bhi.n	801a826 <_free_r+0x166>
 801a81e:	0b18      	lsrs	r0, r3, #12
 801a820:	306e      	adds	r0, #110	; 0x6e
 801a822:	0041      	lsls	r1, r0, #1
 801a824:	e782      	b.n	801a72c <_free_r+0x6c>
 801a826:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 801a82a:	d803      	bhi.n	801a834 <_free_r+0x174>
 801a82c:	0bd8      	lsrs	r0, r3, #15
 801a82e:	3077      	adds	r0, #119	; 0x77
 801a830:	0041      	lsls	r1, r0, #1
 801a832:	e77b      	b.n	801a72c <_free_r+0x6c>
 801a834:	f240 5154 	movw	r1, #1364	; 0x554
 801a838:	428a      	cmp	r2, r1
 801a83a:	d803      	bhi.n	801a844 <_free_r+0x184>
 801a83c:	0c98      	lsrs	r0, r3, #18
 801a83e:	307c      	adds	r0, #124	; 0x7c
 801a840:	0041      	lsls	r1, r0, #1
 801a842:	e773      	b.n	801a72c <_free_r+0x6c>
 801a844:	21fc      	movs	r1, #252	; 0xfc
 801a846:	207e      	movs	r0, #126	; 0x7e
 801a848:	e770      	b.n	801a72c <_free_r+0x6c>
 801a84a:	bf00      	nop
 801a84c:	20000e0c 	.word	0x20000e0c
 801a850:	20000e14 	.word	0x20000e14
 801a854:	20001214 	.word	0x20001214
 801a858:	2000397c 	.word	0x2000397c
 801a85c:	00000000 	.word	0x00000000

0801a860 <memchr>:
 801a860:	0783      	lsls	r3, r0, #30
 801a862:	b470      	push	{r4, r5, r6}
 801a864:	b2c9      	uxtb	r1, r1
 801a866:	d03f      	beq.n	801a8e8 <memchr+0x88>
 801a868:	1e54      	subs	r4, r2, #1
 801a86a:	b32a      	cbz	r2, 801a8b8 <memchr+0x58>
 801a86c:	7803      	ldrb	r3, [r0, #0]
 801a86e:	428b      	cmp	r3, r1
 801a870:	d023      	beq.n	801a8ba <memchr+0x5a>
 801a872:	1c43      	adds	r3, r0, #1
 801a874:	e004      	b.n	801a880 <memchr+0x20>
 801a876:	b1fc      	cbz	r4, 801a8b8 <memchr+0x58>
 801a878:	7804      	ldrb	r4, [r0, #0]
 801a87a:	428c      	cmp	r4, r1
 801a87c:	d01d      	beq.n	801a8ba <memchr+0x5a>
 801a87e:	4614      	mov	r4, r2
 801a880:	f013 0f03 	tst.w	r3, #3
 801a884:	4618      	mov	r0, r3
 801a886:	f104 32ff 	add.w	r2, r4, #4294967295
 801a88a:	f103 0301 	add.w	r3, r3, #1
 801a88e:	d1f2      	bne.n	801a876 <memchr+0x16>
 801a890:	2c03      	cmp	r4, #3
 801a892:	d814      	bhi.n	801a8be <memchr+0x5e>
 801a894:	1e65      	subs	r5, r4, #1
 801a896:	b34c      	cbz	r4, 801a8ec <memchr+0x8c>
 801a898:	7803      	ldrb	r3, [r0, #0]
 801a89a:	428b      	cmp	r3, r1
 801a89c:	d00d      	beq.n	801a8ba <memchr+0x5a>
 801a89e:	1c42      	adds	r2, r0, #1
 801a8a0:	2300      	movs	r3, #0
 801a8a2:	e002      	b.n	801a8aa <memchr+0x4a>
 801a8a4:	7804      	ldrb	r4, [r0, #0]
 801a8a6:	428c      	cmp	r4, r1
 801a8a8:	d007      	beq.n	801a8ba <memchr+0x5a>
 801a8aa:	42ab      	cmp	r3, r5
 801a8ac:	4610      	mov	r0, r2
 801a8ae:	f103 0301 	add.w	r3, r3, #1
 801a8b2:	f102 0201 	add.w	r2, r2, #1
 801a8b6:	d1f5      	bne.n	801a8a4 <memchr+0x44>
 801a8b8:	2000      	movs	r0, #0
 801a8ba:	bc70      	pop	{r4, r5, r6}
 801a8bc:	4770      	bx	lr
 801a8be:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 801a8c2:	4603      	mov	r3, r0
 801a8c4:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 801a8c8:	4618      	mov	r0, r3
 801a8ca:	3304      	adds	r3, #4
 801a8cc:	6802      	ldr	r2, [r0, #0]
 801a8ce:	4072      	eors	r2, r6
 801a8d0:	f1a2 3501 	sub.w	r5, r2, #16843009	; 0x1010101
 801a8d4:	ea25 0202 	bic.w	r2, r5, r2
 801a8d8:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 801a8dc:	d1da      	bne.n	801a894 <memchr+0x34>
 801a8de:	3c04      	subs	r4, #4
 801a8e0:	2c03      	cmp	r4, #3
 801a8e2:	4618      	mov	r0, r3
 801a8e4:	d8f0      	bhi.n	801a8c8 <memchr+0x68>
 801a8e6:	e7d5      	b.n	801a894 <memchr+0x34>
 801a8e8:	4614      	mov	r4, r2
 801a8ea:	e7d1      	b.n	801a890 <memchr+0x30>
 801a8ec:	4620      	mov	r0, r4
 801a8ee:	e7e4      	b.n	801a8ba <memchr+0x5a>

0801a8f0 <memmove>:
 801a8f0:	4288      	cmp	r0, r1
 801a8f2:	b4f0      	push	{r4, r5, r6, r7}
 801a8f4:	d910      	bls.n	801a918 <memmove+0x28>
 801a8f6:	188c      	adds	r4, r1, r2
 801a8f8:	42a0      	cmp	r0, r4
 801a8fa:	d20d      	bcs.n	801a918 <memmove+0x28>
 801a8fc:	1885      	adds	r5, r0, r2
 801a8fe:	1e53      	subs	r3, r2, #1
 801a900:	b142      	cbz	r2, 801a914 <memmove+0x24>
 801a902:	4621      	mov	r1, r4
 801a904:	462a      	mov	r2, r5
 801a906:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
 801a90a:	f802 4d01 	strb.w	r4, [r2, #-1]!
 801a90e:	3b01      	subs	r3, #1
 801a910:	1c5c      	adds	r4, r3, #1
 801a912:	d1f8      	bne.n	801a906 <memmove+0x16>
 801a914:	bcf0      	pop	{r4, r5, r6, r7}
 801a916:	4770      	bx	lr
 801a918:	2a0f      	cmp	r2, #15
 801a91a:	d93f      	bls.n	801a99c <memmove+0xac>
 801a91c:	ea40 0301 	orr.w	r3, r0, r1
 801a920:	079b      	lsls	r3, r3, #30
 801a922:	d13f      	bne.n	801a9a4 <memmove+0xb4>
 801a924:	f1a2 0710 	sub.w	r7, r2, #16
 801a928:	093f      	lsrs	r7, r7, #4
 801a92a:	eb00 1607 	add.w	r6, r0, r7, lsl #4
 801a92e:	3610      	adds	r6, #16
 801a930:	460c      	mov	r4, r1
 801a932:	4603      	mov	r3, r0
 801a934:	6825      	ldr	r5, [r4, #0]
 801a936:	601d      	str	r5, [r3, #0]
 801a938:	6865      	ldr	r5, [r4, #4]
 801a93a:	605d      	str	r5, [r3, #4]
 801a93c:	68a5      	ldr	r5, [r4, #8]
 801a93e:	609d      	str	r5, [r3, #8]
 801a940:	68e5      	ldr	r5, [r4, #12]
 801a942:	60dd      	str	r5, [r3, #12]
 801a944:	3310      	adds	r3, #16
 801a946:	42b3      	cmp	r3, r6
 801a948:	f104 0410 	add.w	r4, r4, #16
 801a94c:	d1f2      	bne.n	801a934 <memmove+0x44>
 801a94e:	1c7b      	adds	r3, r7, #1
 801a950:	f002 0c0f 	and.w	ip, r2, #15
 801a954:	011b      	lsls	r3, r3, #4
 801a956:	f1bc 0f03 	cmp.w	ip, #3
 801a95a:	4419      	add	r1, r3
 801a95c:	4403      	add	r3, r0
 801a95e:	d923      	bls.n	801a9a8 <memmove+0xb8>
 801a960:	460e      	mov	r6, r1
 801a962:	461d      	mov	r5, r3
 801a964:	4664      	mov	r4, ip
 801a966:	3c04      	subs	r4, #4
 801a968:	f856 7b04 	ldr.w	r7, [r6], #4
 801a96c:	f845 7b04 	str.w	r7, [r5], #4
 801a970:	2c03      	cmp	r4, #3
 801a972:	d8f8      	bhi.n	801a966 <memmove+0x76>
 801a974:	f1ac 0404 	sub.w	r4, ip, #4
 801a978:	f024 0403 	bic.w	r4, r4, #3
 801a97c:	3404      	adds	r4, #4
 801a97e:	f002 0203 	and.w	r2, r2, #3
 801a982:	4423      	add	r3, r4
 801a984:	4421      	add	r1, r4
 801a986:	2a00      	cmp	r2, #0
 801a988:	d0c4      	beq.n	801a914 <memmove+0x24>
 801a98a:	441a      	add	r2, r3
 801a98c:	f811 4b01 	ldrb.w	r4, [r1], #1
 801a990:	f803 4b01 	strb.w	r4, [r3], #1
 801a994:	4293      	cmp	r3, r2
 801a996:	d1f9      	bne.n	801a98c <memmove+0x9c>
 801a998:	bcf0      	pop	{r4, r5, r6, r7}
 801a99a:	4770      	bx	lr
 801a99c:	4603      	mov	r3, r0
 801a99e:	2a00      	cmp	r2, #0
 801a9a0:	d1f3      	bne.n	801a98a <memmove+0x9a>
 801a9a2:	e7b7      	b.n	801a914 <memmove+0x24>
 801a9a4:	4603      	mov	r3, r0
 801a9a6:	e7f0      	b.n	801a98a <memmove+0x9a>
 801a9a8:	4662      	mov	r2, ip
 801a9aa:	2a00      	cmp	r2, #0
 801a9ac:	d1ed      	bne.n	801a98a <memmove+0x9a>
 801a9ae:	e7b1      	b.n	801a914 <memmove+0x24>

0801a9b0 <ram_areas>:
 801a9b0:	d074 0801 6d20 2000 6d20 2000 6d20 2000     t... m.  m.  m. 
 801a9c0:	d074 0801 0000 0000 0000 0000 0000 0000     t...............
 801a9d0:	d074 0801 0000 0000 0000 0000 0000 0000     t...............
 801a9e0:	d074 0801 0000 0000 0000 0000 0000 0000     t...............
 801a9f0:	d074 0801 0000 1000 0000 1000 0000 1000     t...............
 801aa00:	d074 0801 0000 0000 0000 0000 0000 0000     t...............
 801aa10:	d074 0801 0000 0000 0000 0000 0000 0000     t...............
 801aa20:	d074 0801 0000 0000 0000 0000 0000 0000     t...............
 801aa30:	6469 656c 0000 0000 0000 0000 0000 0000     idle............

0801aa40 <ch_debug>:
 801aa40:	616d 6e69 1600 1845 0404 0844 100c 1814     main..E...D.....
 801aa50:	1c00 1e1d 001f 0000 0000 0000 0000 0000     ................

0801aa60 <month_len>:
 801aa60:	1e1f 1e1f 1e1f 1f1f 1f1e 1f1e 0000 0000     ................

0801aa70 <sdc_vmt>:
 801aa70:	bb01 0800 bb11 0800 5b01 0800 5cc1 0800     .........[...\..
 801aa80:	5d21 0800 5d81 0800 5e11 0800 5e51 0800     !]...]...^..Q^..

0801aa90 <vmt>:
 801aa90:	6041 0800 6071 0800 60a1 0800 60d1 0800     A`..q`...`...`..
 801aaa0:	60f1 0800 6121 0800 6141 0800 6171 0800     .`..!a..Aa..qa..

0801aab0 <zero_status>:
 801aab0:	0000 0000                                   ....

0801aab4 <active_status>:
 801aab4:	0000 0000                                   ....

0801aab8 <halted_status>:
 801aab8:	0001 0000 0000 0000                         ........

0801aac0 <_stm32_dma_streams>:
 801aac0:	0000 4002 0008 4002 0001 0000 00a8 4002     ...@...@.......@
 801aad0:	0000 000b 0000 4002 001c 4002 0002 0000     .......@...@....
 801aae0:	00a8 4002 0104 000c 0000 4002 0030 4002     ...@.......@0..@
 801aaf0:	0004 0000 00a8 4002 0208 000d 0000 4002     .......@.......@
 801ab00:	0044 4002 0008 0000 00a8 4002 030c 000e     D..@.......@....
 801ab10:	0000 4002 0058 4002 0010 0000 00a8 4002     ...@X..@.......@
 801ab20:	0410 000f 0000 4002 006c 4002 0020 0000     .......@l..@ ...
 801ab30:	00a8 4002 0514 0010 0000 4002 0080 4002     ...@.......@...@
 801ab40:	0040 0000 00a8 4002 0618 0011 0400 4002     @......@.......@
 801ab50:	0408 4002 0080 0000 04a8 4002 0700 0038     ...@.......@..8.
 801ab60:	0400 4002 041c 4002 0100 0000 04a8 4002     ...@...@.......@
 801ab70:	0804 0039 0400 4002 0430 4002 0200 0000     ..9....@0..@....
 801ab80:	04a8 4002 0908 003a 0400 4002 0444 4002     ...@..:....@D..@
 801ab90:	0400 0000 04a8 4002 0a0c 003b 0400 4002     .......@..;....@
 801aba0:	0458 4002 0800 0000 04a8 4002 0b10 003c     X..@.......@..<.
 801abb0:	0400 4002 046c 4002 1000 0000 04a8 4002     ...@l..@.......@
 801abc0:	0c14 0044 0400 4002 0480 4002 2000 0000     ..D....@...@. ..
 801abd0:	04a8 4002 0d18 0045 0000 0000 0000 0000     ...@..E.........

0801abe0 <ep0config>:
 801abe0:	0000 0000 7011 0800 7171 0800 7271 0800     .....p..qq..qr..
 801abf0:	0040 0040 124c 2000 124c 2000 0001 0000     @.@.L.. L.. ....
 801ac00:	125c 2000                                   \.. 

0801ac04 <fsparams>:
 801ac04:	0080 0000 0140 0000 0003 0000 7375 5f62     ....@.......usb_
 801ac14:	6c6c 5f64 7570 706d 0000 0000               lld_pump....

0801ac20 <sdc_default_cfg>:
 801ac20:	0000 0000 0001 0000 0000 0000 0000 0000     ................

0801ac30 <dummytx>:
 801ac30:	ffff 0000 4d44 2041 6166 6c69 7275 0065     ....DMA failure.

0801ac40 <default_config>:
 801ac40:	9600 0000 0000 0000 4000 0000 0000 0000     .........@......

0801ac50 <pal_default_config>:
 801ac50:	ab73 ebff 0000 0000 fcc0 c3f0 0008 2800     s..............(
 801ac60:	ffff 0000 0000 5550 00b0 0000 0000 0000     ......PU........
 801ac70:	0000 0000 afd4 b9fc 0000 0000 3c3f cf0f     ............?<..
 801ac80:	0002 000a ffff 0000 0000 0600 0000 505b     ..............[P
	...
 801ac98:	f1ec 0eff 0000 0000 cf3c 0fc3 0822 0000     ........<..."...
 801aca8:	fdff 0000 0600 0000 0000 0008 0000 0000     ................
 801acb8:	0000 0000 ffef ffff 0000 0000 ffff ffff     ................
 801acc8:	0000 0000 fffe 0000 0800 0000 0000 0000     ................
	...
 801ace0:	ffff ffff 0000 0000 ffff ffff 0009 5550     ..............PU
 801acf0:	feff 0000 0d00 6ddd aa60 aaaa 0000 0000     .......m`.......
 801ad00:	0000 0000 ffff ffff 0000 0000 ffff ffff     ................
 801ad10:	0000 0000 ffff 0000 0000 0000 0000 0000     ................
	...
 801ad28:	ffff fdff 0000 0000 0000 0000 0000 0000     ................
 801ad38:	ffff 0000 0000 0000 0000 0000 0000 0000     ................
 801ad48:	0000 0000 fffd ffff 0000 0000 0003 0000     ................
 801ad58:	0000 0000 ffff 0000 0000 0000 0000 0000     ................
	...

0801ad70 <wa>:
 801ad70:	3e50 2000 3f98 2000 40e0 2000 4228 2000     P>. .?. .@. (B. 
 801ad80:	4370 2000 0a0d 0000 0000 0000 2a2a 202a     pC. ........*** 
 801ad90:	6843 6269 4f69 2f53 5452 7420 7365 2074     ChibiOS/RT test 
 801ada0:	7573 7469 0065 0000 2a2a 002a 2a2a 202a     suite...***.*** 
 801adb0:	654b 6e72 6c65 203a 2020 2020 2020 0000     Kernel:       ..
 801adc0:	2e33 2e31 0035 0000 2a2a 202a 6f43 706d     3.1.5...*** Comp
 801add0:	6c69 6465 203a 2020 2020 0000 7041 2072     iled:     ..Apr 
 801ade0:	3732 3220 3130 2037 202d 3431 343a 3a34     27 2017 - 14:44:
 801adf0:	3630 0000 2a2a 202a 6f43 706d 6c69 7265     06..*** Compiler
 801ae00:	203a 2020 2020 0000 4347 2043 2e34 2e38     :     ..GCC 4.8.
 801ae10:	2034 3032 3431 3530 3632 2820 6572 656c     4 20140526 (rele
 801ae20:	7361 2965 5b20 5241 2f4d 6d65 6562 6464     ase) [ARM/embedd
 801ae30:	6465 342d 385f 622d 6172 636e 2068 6572     ed-4_8-branch re
 801ae40:	6976 6973 6e6f 3220 3131 3533 5d38 0000     vision 211358]..
 801ae50:	2a2a 202a 7241 6863 7469 6365 7574 6572     *** Architecture
 801ae60:	203a 0000 5241 764d 4537 4d2d 0000 0000     : ..ARMv7E-M....
 801ae70:	2a2a 202a 6f43 6572 5620 7261 6169 746e     *** Core Variant
 801ae80:	203a 0000 6f43 7472 7865 4d2d 0034 0000     : ..Cortex-M4...
 801ae90:	2a2a 202a 6f50 7472 4920 666e 3a6f 2020     *** Port Info:  
 801aea0:	2020 0000 6441 6176 636e 6465 6b20 7265       ..Advanced ker
 801aeb0:	656e 206c 6f6d 6564 0000 0000 2a2a 202a     nel mode....*** 
 801aec0:	6c50 7461 6f66 6d72 203a 2020 2020 0000     Platform:     ..
 801aed0:	5453 334d 4c32 7834 2078 6c55 7274 2061     STM32L4xx Ultra 
 801aee0:	6f4c 2077 6f50 6577 0072 0000 2a2a 202a     Low Power...*** 
 801aef0:	6554 7473 4220 616f 6472 203a 2020 0000     Test Board:   ..
 801af00:	5453 5320 6e65 6f73 7472 6c69 2065 0000     ST Sensortile ..
 801af10:	2d2d 202d 6554 7473 4320 7361 2065 0000     --- Test Case ..
 801af20:	002e 0000 2820 0000 0029 0000 2d2d 202d     .... (..)...--- 
 801af30:	6552 7573 746c 203a 4146 4c49 5255 2045     Result: FAILURE 
 801af40:	2328 0000 5b20 0000 295d 0000 2d2d 202d     (#.. [..])..--- 
 801af50:	6552 7573 746c 203a 5553 4343 5345 0053     Result: SUCCESS.
 801af60:	6946 616e 206c 6572 7573 746c 203a 0000     Final result: ..
 801af70:	4146 4c49 5255 0045 5553 4343 5345 0053     FAILURE.SUCCESS.
 801af80:	0045 0000 0044 0000 0043 0000 0042 0000     E...D...C...B...
 801af90:	0041 0000 4241 4443 0045 0000 6854 6572     A...ABCDE...Thre
 801afa0:	6461 2c73 6520 716e 6575 6975 676e 7420     ads, enqueuing t
 801afb0:	7365 2074 3123 0000                         est #1..

0801afb8 <testthd1>:
 801afb8:	af9c 0801 0000 0000 0000 0000 c3a1 0800     ................
 801afc8:	6854 6572 6461 2c73 6520 716e 6575 6975     Threads, enqueui
 801afd8:	676e 7420 7365 2074 3223 0000               ng test #2..

0801afe4 <testthd2>:
 801afe4:	afc8 0801 0000 0000 0000 0000 c4a1 0800     ................
 801aff4:	6854 6572 6461 2c73 7020 6972 726f 7469     Threads, priorit
 801b004:	2079 6863 6e61 6567 0000 0000               y change....

0801b010 <testthd3>:
 801b010:	aff4 0801 0000 0000 0000 0000 c5b1 0800     ................
 801b020:	6854 6572 6461 2c73 6420 6c65 7961 0073     Threads, delays.

0801b030 <testthd4>:
 801b030:	b020 0801 0000 0000 0000 0000 c7a1 0800      ...............

0801b040 <patternthd>:
 801b040:	afb8 0801 afe4 0801 b010 0801 b030 0801     ............0...
	...
 801b060:	0041 0000 0042 0000 0043 0000 0044 0000     A...B...C...D...
 801b070:	0045 0000 4241 4443 0045 0000 6553 616d     E...ABCDE...Sema
 801b080:	6870 726f 7365 202c 6e65 7571 7565 6e69     phores, enqueuin
 801b090:	0067 0000                                   g...

0801b094 <testsem1>:
 801b094:	b07c 0801 ca11 0800 0000 0000 ca41 0800     |...........A...
 801b0a4:	6553 616d 6870 726f 7365 202c 6974 656d     Semaphores, time
 801b0b4:	756f 0074                                   out.

0801b0b8 <testsem2>:
 801b0b8:	b0a4 0801 cbc1 0800 0000 0000 cc01 0800     ................
 801b0c8:	6553 616d 6870 726f 7365 202c 7461 6d6f     Semaphores, atom
 801b0d8:	6369 7320 6769 616e 2d6c 6177 7469 0000     ic signal-wait..

0801b0e8 <testsem3>:
 801b0e8:	b0c8 0801 cdc1 0800 0000 0000 cdf1 0800     ................
 801b0f8:	6942 616e 7972 5320 6d65 7061 6f68 6572     Binary Semaphore
 801b108:	2c73 6620 6e75 7463 6f69 616e 696c 7974     s, functionality
 801b118:	0000 0000                                   ....

0801b11c <testsem4>:
 801b11c:	b0f8 0801 0000 0000 0000 0000 ced1 0800     ................

0801b12c <patternsem>:
 801b12c:	b094 0801 b0b8 0801 b0e8 0801 b11c 0801     ................
 801b13c:	0000 0000 0045 0000 0044 0000 0043 0000     ....E...D...C...
 801b14c:	0042 0000 0041 0000 4241 4443 0045 0000     B...A...ABCDE...
 801b15c:	754d 6574 6578 2c73 7020 6972 726f 7469     Mutexes, priorit
 801b16c:	2079 6e65 7571 7565 6e69 2067 6574 7473     y enqueuing test
 801b17c:	0000 0000                                   ....

0801b180 <testmtx1>:
 801b180:	b15c 0801 d0f1 0800 0000 0000 d131 0800     \...........1...
 801b190:	754d 6574 6578 2c73 7020 6972 726f 7469     Mutexes, priorit
 801b1a0:	2079 6572 7574 6e72 0000 0000               y return....

0801b1ac <testmtx4>:
 801b1ac:	b190 0801 d251 0800 0000 0000 d2d1 0800     ....Q...........
 801b1bc:	754d 6574 6578 2c73 7320 6174 7574 0073     Mutexes, status.

0801b1cc <testmtx5>:
 801b1cc:	b1bc 0801 d5d1 0800 0000 0000 d5e1 0800     ................
 801b1dc:	6f43 646e 6156 2c72 7320 6769 616e 206c     CondVar, signal 
 801b1ec:	6574 7473 0000 0000                         test....

0801b1f4 <testmtx6>:
 801b1f4:	b1dc 0801 d6f1 0800 0000 0000 d741 0800     ............A...
 801b204:	6f43 646e 6156 2c72 6220 6f72 6461 6163     CondVar, broadca
 801b214:	7473 7420 7365 0074                         st test.

0801b21c <testmtx7>:
 801b21c:	b204 0801 d861 0800 0000 0000 d881 0800     ....a...........
 801b22c:	4241 0043 6f43 646e 6156 2c72 6220 6f6f     ABC.CondVar, boo
 801b23c:	7473 7420 7365 0074                         st test.

0801b244 <testmtx8>:
 801b244:	b230 0801 d981 0800 0000 0000 da31 0800     0...........1...

0801b254 <patternmtx>:
 801b254:	b180 0801 b1ac 0801 b1cc 0801 b1f4 0801     ................
 801b264:	b21c 0801 b244 0801 0000 0000 4241 0043     ....D.......ABC.
 801b274:	654d 7373 6761 7365 202c 6f6c 706f 0000     Messages, loop..

0801b284 <testmsg1>:
 801b284:	b274 0801 0000 0000 0000 0000 db51 0800     t...........Q...

0801b294 <patternmsg>:
 801b294:	b284 0801 0000 0000 0000 0000 4241 4443     ............ABCD
 801b2a4:	0045 0000 614d 6c69 6f62 6578 2c73 7120     E...Mailboxes, q
 801b2b4:	6575 6975 676e 6120 646e 7420 6d69 6f65     ueuing and timeo
 801b2c4:	7475 0073                                   uts.

0801b2c8 <testmbox1>:
 801b2c8:	b2a8 0801 dc91 0800 0000 0000 dcb1 0800     ................

0801b2d8 <patternmbox>:
 801b2d8:	b2c8 0801 0000 0000                         ........

0801b2e0 <evhndl>:
 801b2e0:	e5e1 0800 e601 0800 e621 0800 4241 0043     ........!...ABC.
 801b2f0:	7645 6e65 7374 202c 6572 6967 7473 6172     Events, registra
 801b300:	6974 6e6f 6120 646e 6420 7369 6170 6374     tion and dispatc
 801b310:	0068 0000                                   h...

0801b314 <testevt1>:
 801b314:	b2f0 0801 e5d1 0800 0000 0000 e641 0800     ............A...
 801b324:	0041 0000 7645 6e65 7374 202c 6177 7469     A...Events, wait
 801b334:	6120 646e 6220 6f72 6461 6163 7473 0000      and broadcast..

0801b344 <testevt2>:
 801b344:	b328 0801 e701 0800 0000 0000 e761 0800     (...........a...
 801b354:	7645 6e65 7374 202c 6974 656d 756f 7374     Events, timeouts
 801b364:	0000 0000                                   ....

0801b368 <testevt3>:
 801b368:	b354 0801 ead1 0800 0000 0000 eae1 0800     T...............

0801b378 <patternevt>:
 801b378:	b314 0801 b344 0801 b368 0801 0000 0000     ....D...h.......
	...
 801b390:	6548 7061 202c 6c61 6f6c 6163 6974 6e6f     Heap, allocation
 801b3a0:	6120 646e 6620 6172 6d67 6e65 6174 6974      and fragmentati
 801b3b0:	6e6f 7420 7365 0074                         on test.

0801b3b8 <testheap1>:
 801b3b8:	b390 0801 ebe1 0800 0000 0000 ec01 0800     ................

0801b3c8 <patternheap>:
 801b3c8:	b3b8 0801 0000 0000 654d 6f6d 7972 5020     ........Memory P
 801b3d8:	6f6f 736c 202c 7571 7565 2f65 6564 7571     ools, queue/dequ
 801b3e8:	7565 0065                                   eue.

0801b3ec <testpools1>:
 801b3ec:	b3d0 0801 eef1 0800 0000 0000 ef11 0800     ................

0801b3fc <patternpools>:
 801b3fc:	b3ec 0801 0000 0000 0000 0000 0000 0000     ................
 801b40c:	0000 0000 0041 0000 0042 0000 0043 0000     ....A...B...C...
 801b41c:	4241 0000 7944 616e 696d 2063 5041 7349     AB..Dynamic APIs
 801b42c:	202c 6874 6572 6461 2073 7263 6165 6974     , threads creati
 801b43c:	6e6f 6620 6f72 206d 6568 7061 0000 0000     on from heap....

0801b44c <testdyn1>:
 801b44c:	b420 0801 f071 0800 0000 0000 f091 0800      ...q...........
 801b45c:	0044 0000 0045 0000 4241 4443 0000 0000     D...E...ABCD....
 801b46c:	7944 616e 696d 2063 5041 7349 202c 6874     Dynamic APIs, th
 801b47c:	6572 6461 2073 7263 6165 6974 6e6f 6620     reads creation f
 801b48c:	6f72 206d 656d 6f6d 7972 7020 6f6f 006c     rom memory pool.

0801b49c <testdyn2>:
 801b49c:	b46c 0801 f1e1 0800 0000 0000 f201 0800     l...............
 801b4ac:	7944 616e 696d 2063 5041 7349 202c 6572     Dynamic APIs, re
 801b4bc:	6967 7473 7972 6120 646e 7220 6665 7265     gistry and refer
 801b4cc:	6e65 6563 0073 0000                         ences...

0801b4d4 <testdyn3>:
 801b4d4:	b4ac 0801 f3d1 0800 0000 0000 f3f1 0800     ................

0801b4e4 <patterndyn>:
 801b4e4:	b44c 0801 b49c 0801 b4d4 0801 0000 0000     L...............
	...
 801b500:	4241 4443 0000 0000 7551 7565 7365 202c     ABCD....Queues, 
 801b510:	6e69 7570 2074 7571 7565 7365 0000 0000     input queues....

0801b520 <testqueues1>:
 801b520:	b508 0801 f731 0800 0000 0000 f781 0800     ....1...........
 801b530:	7551 7565 7365 202c 756f 7074 7475 7120     Queues, output q
 801b540:	6575 6575 0073 0000                         ueues...

0801b548 <testqueues2>:
 801b548:	b530 0801 fa91 0800 0000 0000 fae1 0800     0...............

0801b558 <patternqueues>:
 801b558:	b520 0801 b548 0801 0000 0000 0000 0000      ...H...........
	...
 801b570:	7953 7473 6d65 202c 7263 7469 6369 6c61     System, critical
 801b580:	7a20 6e6f 7365 0000                          zones..

0801b588 <testsys1>:
 801b588:	b570 0801 0000 0000 0000 0000 0021 0801     p...........!...
 801b598:	7953 7473 6d65 202c 6e69 6574 7272 7075     System, interrup
 801b5a8:	7374 6820 6e61 6c64 6e69 0067               ts handling.

0801b5b4 <testsys2>:
 801b5b4:	b598 0801 0000 0000 0000 0000 00b1 0801     ................
 801b5c4:	7953 7473 6d65 202c 6e69 6574 7267 7469     System, integrit
 801b5d4:	0079 0000                                   y...

0801b5d8 <testsys3>:
 801b5d8:	b5c4 0801 0000 0000 0000 0000 00d1 0801     ................

0801b5e8 <patternsys>:
 801b5e8:	b588 0801 b5b4 0801 b5d8 0801 0000 0000     ................
	...
 801b600:	2d2d 202d 6353 726f 2065 203a 0000 0000     --- Score : ....
 801b610:	6d20 6773 2f73 2c53 0020 0000 6320 7874      msgs/S, ... ctx
 801b620:	7773 2f63 0053 0000 6542 636e 6d68 7261     swc/S...Benchmar
 801b630:	2c6b 6d20 7365 6173 6567 2073 3123 0000     k, messages #1..

0801b640 <testbmk1>:
 801b640:	b628 0801 0000 0000 0000 0000 0331 0801     (...........1...
 801b650:	6542 636e 6d68 7261 2c6b 6d20 7365 6173     Benchmark, messa
 801b660:	6567 2073 3223 0000                         ges #2..

0801b668 <testbmk2>:
 801b668:	b650 0801 0000 0000 0000 0000 03b1 0801     P...............
 801b678:	6542 636e 6d68 7261 2c6b 6d20 7365 6173     Benchmark, messa
 801b688:	6567 2073 3323 0000                         ges #3..

0801b690 <testbmk3>:
 801b690:	b678 0801 0000 0000 0000 0000 0431 0801     x...........1...
 801b6a0:	6542 636e 6d68 7261 2c6b 6320 6e6f 6574     Benchmark, conte
 801b6b0:	7478 7320 6977 6374 0068 0000               xt switch...

0801b6bc <testbmk4>:
 801b6bc:	b6a0 0801 0000 0000 0000 0000 0571 0801     ............q...
 801b6cc:	7420 7268 6165 7364 532f 0000 6542 636e      threads/S..Benc
 801b6dc:	6d68 7261 2c6b 7420 7268 6165 7364 202c     hmark, threads, 
 801b6ec:	7566 6c6c 6320 6379 656c 0000               full cycle..

0801b6f8 <testbmk5>:
 801b6f8:	b6d8 0801 0000 0000 0000 0000 0641 0801     ............A...
 801b708:	6542 636e 6d68 7261 2c6b 7420 7268 6165     Benchmark, threa
 801b718:	7364 202c 7263 6165 6574 6f20 6c6e 0079     ds, create only.

0801b728 <testbmk6>:
 801b728:	b708 0801 0000 0000 0000 0000 06c1 0801     ................
 801b738:	7220 7365 6863 6465 6c75 7365 532f 202c      reschedules/S, 
 801b748:	0000 0000 6542 636e 6d68 7261 2c6b 6d20     ....Benchmark, m
 801b758:	7361 2073 6572 6373 6568 7564 656c 202c     ass reschedule, 
 801b768:	2035 6874 6572 6461 0073 0000               5 threads...

0801b774 <testbmk7>:
 801b774:	b74c 0801 0771 0801 0000 0000 0781 0801     L...q...........
 801b784:	6542 636e 6d68 7261 2c6b 7220 756f 646e     Benchmark, round
 801b794:	7220 626f 6e69 6320 6e6f 6574 7478 7320      robin context s
 801b7a4:	6977 6374 6968 676e 0000 0000               witching....

0801b7b0 <testbmk8>:
 801b7b0:	b784 0801 0000 0000 0000 0000 0901 0801     ................
 801b7c0:	6220 7479 7365 532f 0000 0000 6542 636e      bytes/S....Benc
 801b7d0:	6d68 7261 2c6b 4920 4f2f 5120 6575 6575     hmark, I/O Queue
 801b7e0:	2073 6874 6f72 6775 7068 7475 0000 0000     s throughput....

0801b7f0 <testbmk9>:
 801b7f0:	b7cc 0801 0000 0000 0000 0000 0a01 0801     ................
 801b800:	7420 6d69 7265 2f73 0053 0000 6542 636e      timers/S...Benc
 801b810:	6d68 7261 2c6b 7620 7269 7574 6c61 7420     hmark, virtual t
 801b820:	6d69 7265 2073 6573 2f74 6572 6573 0074     imers set/reset.

0801b830 <testbmk10>:
 801b830:	b80c 0801 0000 0000 0000 0000 0ac1 0801     ................
 801b840:	7720 6961 2b74 6973 6e67 6c61 532f 0000      wait+signal/S..
 801b850:	6542 636e 6d68 7261 2c6b 7320 6d65 7061     Benchmark, semap
 801b860:	6f68 6572 2073 6177 7469 732f 6769 616e     hores wait/signa
 801b870:	006c 0000                                   l...

0801b874 <testbmk11>:
 801b874:	b850 0801 0b51 0801 0000 0000 0b61 0801     P...Q.......a...
 801b884:	6c20 636f 2b6b 6e75 6f6c 6b63 532f 0000      lock+unlock/S..
 801b894:	6542 636e 6d68 7261 2c6b 6d20 7475 7865     Benchmark, mutex
 801b8a4:	7365 6c20 636f 2f6b 6e75 6f6c 6b63 0000     es lock/unlock..

0801b8b4 <testbmk12>:
 801b8b4:	b894 0801 0bf1 0801 0000 0000 0c01 0801     ................
 801b8c4:	2d2d 202d 7953 7473 6d65 203a 0000 0000     --- System: ....
 801b8d4:	6220 7479 7365 0000 2d2d 202d 6854 6572      bytes..--- Thre
 801b8e4:	6461 203a 0000 0000 2d2d 202d 6954 656d     ad: ....--- Time
 801b8f4:	2072 203a 0000 0000 2d2d 202d 6553 616d     r : ....--- Sema
 801b904:	6870 203a 0000 0000 2d2d 202d 7645 6e65     ph: ....--- Even
 801b914:	5374 203a 0000 0000 2d2d 202d 7645 6e65     tS: ....--- Even
 801b924:	4c74 203a 0000 0000 2d2d 202d 754d 6574     tL: ....--- Mute
 801b934:	2078 203a 0000 0000 2d2d 202d 6f43 646e     x : ....--- Cond
 801b944:	2e56 203a 0000 0000 2d2d 202d 7551 7565     V.: ....--- Queu
 801b954:	2065 203a 0000 0000 2d2d 202d 614d 6c69     e : ....--- Mail
 801b964:	2e42 203a 0000 0000 6542 636e 6d68 7261     B.: ....Benchmar
 801b974:	2c6b 5220 4d41 6620 6f6f 7074 6972 746e     k, RAM footprint
 801b984:	0000 0000                                   ....

0801b988 <testbmk13>:
 801b988:	b96c 0801 0000 0000 0000 0000 0c91 0801     l...............

0801b998 <patternbmk>:
 801b998:	b640 0801 b668 0801 b690 0801 b6bc 0801     @...h...........
 801b9a8:	b6f8 0801 b728 0801 b774 0801 b7b0 0801     ....(...t.......
 801b9b8:	b7f0 0801 b830 0801 b874 0801 b8b4 0801     ....0...t.......
 801b9c8:	b988 0801 0000 0000                         ........

0801b9d0 <vmt>:
 801b9d0:	0f81 0801 0fe1 0801 1041 0801 1091 0801     ........A.......
 801b9e0:	6e28 6c75 296c 0000 0000 0000 0000 0000     (null)..........
 801b9f0:	7355 6761 3a65 2520 0d73 000a 7325 0020     Usage: %s...%s .
 801ba00:	6e69 6f66 0000 0000 654b 6e72 6c65 203a     info....Kernel: 
 801ba10:	2020 2020 2020 7325 0a0d 0000 2e33 2e31           %s....3.1.
 801ba20:	0035 0000 6f43 706d 6c69 7265 203a 2020     5...Compiler:   
 801ba30:	2020 7325 0a0d 0000 4347 2043 2e34 2e38       %s....GCC 4.8.
 801ba40:	2034 3032 3431 3530 3632 2820 6572 656c     4 20140526 (rele
 801ba50:	7361 2965 5b20 5241 2f4d 6d65 6562 6464     ase) [ARM/embedd
 801ba60:	6465 342d 385f 622d 6172 636e 2068 6572     ed-4_8-branch re
 801ba70:	6976 6973 6e6f 3220 3131 3533 5d38 0000     vision 211358]..
 801ba80:	7241 6863 7469 6365 7574 6572 203a 7325     Architecture: %s
 801ba90:	0a0d 0000 5241 764d 4537 4d2d 0000 0000     ....ARMv7E-M....
 801baa0:	6f43 6572 5620 7261 6169 746e 203a 7325     Core Variant: %s
 801bab0:	0a0d 0000 6f43 7472 7865 4d2d 0034 0000     ....Cortex-M4...
 801bac0:	6f50 7472 4920 666e 3a6f 2020 2020 7325     Port Info:    %s
 801bad0:	0a0d 0000 6441 6176 636e 6465 6b20 7265     ....Advanced ker
 801bae0:	656e 206c 6f6d 6564 0000 0000 6c50 7461     nel mode....Plat
 801baf0:	6f66 6d72 203a 2020 2020 7325 0a0d 0000     form:     %s....
 801bb00:	5453 334d 4c32 7834 2078 6c55 7274 2061     STM32L4xx Ultra 
 801bb10:	6f4c 2077 6f50 6577 0072 0000 6f42 7261     Low Power...Boar
 801bb20:	3a64 2020 2020 2020 2020 7325 0a0d 0000     d:        %s....
 801bb30:	5453 5320 6e65 6f73 7472 6c69 2065 0000     ST Sensortile ..
 801bb40:	7542 6c69 2064 6974 656d 203a 2020 7325     Build time:   %s
 801bb50:	7325 7325 0a0d 0000 7041 2072 3732 3220     %s%s....Apr 27 2
 801bb60:	3130 0037 2d20 0020 3431 343a 3a34 3830     017. - .14:44:08
 801bb70:	0000 0000 7973 7473 6d69 0065 6c25 0d75     ....systime.%lu.
 801bb80:	000a 0000                                   ....

0801bb84 <local_commands>:
 801bb84:	ba00 0801 1831 0801 bb74 0801 1901 0801     ....1...t.......
	...
 801bb9c:	6873 6c65 006c 0000 0a0d 6843 6269 4f69     shell.....ChibiO
 801bbac:	2f53 5452 5320 6568 6c6c 0a0d 0000 0000     S/RT Shell......
 801bbbc:	6863 203e 0000 0000 0a0d 6f6c 6f67 7475     ch> ......logout
 801bbcc:	0000 0000 0920 0000 6f74 206f 616d 796e     .... ...too many
 801bbdc:	6120 6772 6d75 6e65 7374 0a0d 0000 0000      arguments......
 801bbec:	7865 7469 0000 0000 6568 706c 0000 0000     exit....help....
 801bbfc:	6f43 6d6d 6e61 7364 203a 6568 706c 6520     Commands: help e
 801bc0c:	6978 2074 0000 0000 0a0d 0000 7325 0000     xit ........%s..
 801bc1c:	3f20 0a0d 0000 0000 445e 0000 0000 0000      ?......^D......
 801bc2c:	0000 0000 6c62 6e69 656b 0072 6f73 6b63     ....blinker.sock
 801bc3c:	7465 0000 0d0a 5453 5241 4954 474e 5420     et....STARTING T
 801bc4c:	5043 0d0a 0000 0000 5441 0000 5441 432b     CP......AT..AT+C
 801bc5c:	4147 5454 003f 0000 5441 432b 5049 4853     GATT?...AT+CIPSH
 801bc6c:	5455 0000 5441 432b 5049 5453 5441 5355     UT..AT+CIPSTATUS
 801bc7c:	0000 0000 5441 432b 5049 554d 3d58 0030     ....AT+CIPMUX=0.
 801bc8c:	5441 432b 5453 3d54 7722 6f68 656c 6173     AT+CSTT="wholesa
 801bc9c:	656c 0022 5441 432b 4949 5243 0000 0000     le".AT+CIICR....
 801bcac:	5441 432b 4649 5253 0000 0000 5441 432b     AT+CIFSR....AT+C
 801bcbc:	5049 5453 5241 3d54 5422 5043 2c22 7322     IPSTART="TCP","s
 801bccc:	6c69 2e6f 7363 692e 646e 6169 616e 652e     ilo.cs.indiana.e
 801bcdc:	7564 2c22 3522 3130 3630 0022 5441 432b     du","50106".AT+C
 801bcec:	5049 4553 444e 003d 6325 0000 002c 0000     IPSEND=.%c..,...
 801bcfc:	000a 0000 0020 0000 6974 656d 7473 6d61     .... ...timestam
 801bd0c:	0070 0000 570d 7261 696e 676e 203a 6341     p....Warning: Ac
 801bd1c:	6563 656c 6f72 656d 6574 2072 6552 632d     celerometer Re-c
 801bd2c:	6c61 6269 6172 6574 0d64 500a 6572 6976     alibrated..Previ
 801bd3c:	756f 2073 6164 6174 6d20 7961 6e20 746f     ous data may not
 801bd4c:	6220 2065 6361 7563 6172 6574 0d2e 000a      be accurate....
 801bd5c:	6863 6365 746b 7268 7365 6f68 646c 0000     checkthreshold..
 801bd6c:	7325 0d0a 0000 0000 5441 3144 3637 3435     %s......ATD17654
 801bd7c:	3430 3931 3337 003b 6553 746e 6320 6c61     041973;.Sent cal
 801bd8c:	2e6c 0d0a 0000 0000 6142 2064 7261 7367     l.......Bad args
 801bd9c:	0a2e 000d 250a 0a64 000d 0000 6e49 6f63     .....%d.....Inco
 801bdac:	7272 6365 2074 7261 7367 0a2e 000d 0000     rrect args......
 801bdbc:	5545 5241 2054 6954 656d 2064 756f 0a74     EUART Timed out.
 801bdcc:	000d 0000 5545 5241 2054 7245 6f72 0a72     ....EUART Error.
 801bddc:	000d 0000 670a 746f 6320 6168 3a72 2520     .....got char: %
 801bdec:	2063 6b61 2061 7830 7825 0d0a 0000 0000     c aka 0x%x......
 801bdfc:	670a 746f 6320 6168 3a72 2520 2063 6b61     .got char: %c ak
 801be0c:	2061 7830 7825 202c 6f63 706d 7261 2065     a 0x%x, compare 
 801be1c:	6f74 2520 0a63 000d 736c 336d 3330 5720     to %c...lsm303 W
 801be2c:	6f68 4120 206d 2049 6164 6174 3d20 3020     ho Am I data = 0
 801be3c:	2578 3230 0a78 000d 520d 7761 203a 6425     x%02x....Raw: %d
 801be4c:	202c 6425 202c 6425 0a0d 0000 430d 6c61     , %d, %d.....Cal
 801be5c:	6269 6172 6574 3a64 2520 2c64 2520 2c64     ibrated: %d, %d,
 801be6c:	2520 0d64 000a 0000 250d 3230 2f64 3025      %d......%02d/%0
 801be7c:	6432 252f 3430 2064 3025 6432 253a 3230     2d/%04d %02d:%02
 801be8c:	2064 202d 2520 0d64 000a 0000 250d 2064     d -  %d......%d 
 801be9c:	6572 6f63 6472 2c73 6120 7070 6f72 2e78     records, approx.
 801beac:	2520 2064 6573 6f63 646e 2073 666f 7220      %d seconds of r
 801bebc:	6365 726f 6964 676e 0a0d 0000 440d 7665     ecording.....Dev
 801becc:	6369 2065 6873 756f 646c 6220 2065 6568     ice should be he
 801bedc:	646c 6920 206e 2061 6966 6578 2064 6f70     ld in a fixed po
 801beec:	6973 6974 6e6f 6920 206e 7469 2073 6e69     sition in its in
 801befc:	6574 646e 6465 6f20 6972 6e65 6174 6974     tended orientati
 801bf0c:	6e6f 7720 7469 2068 6f6e 7620 6269 6172     on with no vibra
 801bf1c:	6974 6e6f 0a0d 0000 430d 6c61 6269 6172     tion.....Calibra
 801bf2c:	6974 676e 2e2e 0d2e 000a 0000 430d 6c61     ting.........Cal
 801bf3c:	6269 6172 6574 2064 6977 6874 5820 203a     ibrated with X: 
 801bf4c:	6425 202c 3a59 2520 2c64 5a20 253a 0d64     %d, Y: %d, Z:%d.
 801bf5c:	000a 0000 530d 7465 5420 5043 6620 616c     .....Set TCP fla
 801bf6c:	0d67 000a 490d 636e 726f 6572 7463 6120     g....Incorrect a
 801bf7c:	6772 6d75 6e65 7374 202e 7845 6d61 6c70     rguments. Exampl
 801bf8c:	2065 6e69 7570 3a74 0a0d 0000 730d 7465     e input:.....set
 801bf9c:	745f 6d69 2065 4444 4d2f 2f4d 5959 5959     _time DD/MM/YYYY
 801bfac:	4820 3a48 4d4d 2820 696d 696c 6174 7972      HH:MM (military
 801bfbc:	7420 6d69 2965 0a0d 0000 0000 796d 6365      time)......myec
 801bfcc:	6f68 0000 6361 6563 5f6c 7270 6e69 0074     ho..accel_print.
 801bfdc:	6361 6563 5f6c 6177 0069 0000 6361 6563     accel_wai...acce
 801bfec:	5f6c 6163 696c 7262 7461 0065 6964 7073     l_calibrate.disp
 801bffc:	616c 5f79 6f63 6e75 7374 0000 0064 0000     lay_counts..d...
 801c00c:	6573 5f74 6974 656d 0000 0000 7570 5f74     set_time....put_
 801c01c:	6863 7261 0000 0000 6567 5f74 6863 7261     char....get_char
 801c02c:	0000 0000 6574 7473 635f 6168 0072 0000     ....test_char...
 801c03c:	6163 6c6c 6d5f 6761 6967 0065 6f6d 6564     call_maggie.mode
 801c04c:	5f6d 6d63 0064 0000 7473 7261 5f74 6374     m_cmd...start_tc
 801c05c:	0070 0000                                   p...

0801c060 <commands>:
 801c060:	bfc8 0801 2331 0801 bfd0 0801 25a1 0801     ....1#.......%..
 801c070:	bfdc 0801 2571 0801 bfe8 0801 2731 0801     ....q%......1'..
 801c080:	bff8 0801 2631 0801 c008 0801 2631 0801     ....1&......1&..
 801c090:	c00c 0801 27b1 0801 c018 0801 2401 0801     .....'.......$..
 801c0a0:	c024 0801 2451 0801 c030 0801 24c1 0801     $...Q$..0....$..
 801c0b0:	c03c 0801 2371 0801 c048 0801 23b1 0801     <...q#..H....#..
 801c0c0:	c054 0801 2781 0801 0000 0000 0000 0000     T....'..........

0801c0d0 <shell_cfg1>:
 801c0d0:	3db8 2000 c060 0801 0d0a 7055 6120 646e     .=. `.....Up and
 801c0e0:	5220 6e75 696e 676e 0d0a 0000 480d 6e69      Running.....Hin
 801c0f0:	3a74 7220 6e75 7320 7465 745f 6d69 2065     t: run set_time 
 801c100:	4444 4d2f 2f4d 5959 5959 4820 3a48 4d4d     DD/MM/YYYY HH:MM
 801c110:	2820 696d 696c 6174 7972 7420 6d69 2965      (military time)
 801c120:	7420 206f 6e69 7469 6169 696c 657a 7420      to initialize t
 801c130:	6d69 2e65 0a0d 0000 410d 6363 6c65 7265     ime......Acceler
 801c140:	6d6f 7465 7265 4320 6c61 6269 6172 6574     ometer Calibrate
 801c150:	0d64 000a 0000 0000 0000 0000 0000 0000     d...............

0801c160 <LSM303AGR_ACC_Sensitivity_List>:
 801c160:	03d4 0000 0000 0000 079e 0000 0000 0000     ................
 801c170:	0f3c 0000 0000 0000 2dc8 0000 0000 0000     <........-......
 801c180:	0f3c 0000 0000 0000 1e8c 0000 0000 0000     <...............
 801c190:	3d0e 0000 0000 0000 b734 0000 0000 0000     .=......4.......
 801c1a0:	3d0e 0000 0000 0000 7a1c 0000 0000 0000     .=.......z......
 801c1b0:	f438 0000 0000 0000 dcbc 0002 0000 0000     8...............
 801c1c0:	7325 2e25 642a 0000 7325 3025 2a2e 0064     %s%.*d..%s%0.*d.
 801c1d0:	002b 0000 002d 0000 2e25 6432 0000 0000     +...-...%.2d....
 801c1e0:	3225 0064 2e25 6432 252f 322e 2f64 2e25     %2d.%.2d/%.2d/%.
 801c1f0:	6432 0000 6c25 0075 2d59 6d25 252d 0064     2d..%lu.Y-%m-%d.
 801c200:	2a2e 0075 2e25 6433 0000 0000 2e25 6432     .*u.%.3d....%.2d
 801c210:	253a 322e 0064 0000 2e25 6432 253a 322e     :%.2d...%.2d:%.2
 801c220:	3a64 2e25 6432 0000 2b25 3330 646c 2e25     d:%.2d..%+03ld%.
 801c230:	6c32 0064 0000 0000 0000 0000 0000 0000     2ld.............

0801c240 <_C_time_locale>:
 801c240:	c348 0801 c34c 0801 c350 0801 c354 0801     H...L...P...T...
 801c250:	c358 0801 c35c 0801 c360 0801 c364 0801     X...\...`...d...
 801c260:	c368 0801 c36c 0801 c370 0801 c374 0801     h...l...p...t...
 801c270:	c378 0801 c380 0801 c38c 0801 c394 0801     x...............
 801c280:	c358 0801 c39c 0801 c3a4 0801 c3ac 0801     X...............
 801c290:	c3b4 0801 c3c0 0801 c3c8 0801 c3d4 0801     ................
 801c2a0:	c3e0 0801 c3e4 0801 c3e8 0801 c3ec 0801     ................
 801c2b0:	c3f0 0801 c3f4 0801 c3f8 0801 c3fc 0801     ................
 801c2c0:	c404 0801 c40c 0801 c414 0801 c420 0801     ............ ...
 801c2d0:	c42c 0801 c434 0801 c440 0801 c44c 0801     ,...4...@...L...
 801c2e0:	c458 0801 c470 0801 c474 0801 c478 0801     X...p...t...x...
 801c2f0:	c378 0801 c380 0801 c38c 0801 c394 0801     x...............
 801c300:	c358 0801 c39c 0801 c3a4 0801 c3ac 0801     X...............
 801c310:	c3b4 0801 c3c0 0801 c3c8 0801 c3d4 0801     ................
 801c320:	c490 0801 c494 0801 c620 0801 c620 0801     ........ ... ...
 801c330:	c620 0801 c620 0801 c620 0801 0000 0000      ... ... .......
 801c340:	434c 545f 4d49 0045 614a 006e 6546 0062     LC_TIME.Jan.Feb.
 801c350:	614d 0072 7041 0072 614d 0079 754a 006e     Mar.Apr.May.Jun.
 801c360:	754a 006c 7541 0067 6553 0070 634f 0074     Jul.Aug.Sep.Oct.
 801c370:	6f4e 0076 6544 0063 614a 756e 7261 0079     Nov.Dec.January.
 801c380:	6546 7262 6175 7972 0000 0000 614d 6372     February....Marc
 801c390:	0068 0000 7041 6972 006c 0000 754a 656e     h...April...June
 801c3a0:	0000 0000 754a 796c 0000 0000 7541 7567     ....July....Augu
 801c3b0:	7473 0000 6553 7470 6d65 6562 0072 0000     st..September...
 801c3c0:	634f 6f74 6562 0072 6f4e 6576 626d 7265     October.November
 801c3d0:	0000 0000 6544 6563 626d 7265 0000 0000     ....December....
 801c3e0:	7553 006e 6f4d 006e 7554 0065 6557 0064     Sun.Mon.Tue.Wed.
 801c3f0:	6854 0075 7246 0069 6153 0074 7553 646e     Thu.Fri.Sat.Sund
 801c400:	7961 0000 6f4d 646e 7961 0000 7554 7365     ay..Monday..Tues
 801c410:	6164 0079 6557 6e64 7365 6164 0079 0000     day.Wednesday...
 801c420:	6854 7275 6473 7961 0000 0000 7246 6469     Thursday....Frid
 801c430:	7961 0000 6153 7574 6472 7961 0000 0000     ay..Saturday....
 801c440:	4825 253a 3a4d 5325 0000 0000 6d25 252f     %H:%M:%S....%m/%
 801c450:	2f64 7925 0000 0000 6125 2520 2062 6525     d/%y....%a %b %e
 801c460:	2520 3a48 4d25 253a 2053 5925 0000 0000      %H:%M:%S %Y....
 801c470:	4d41 0000 4d50 0000 6125 2520 2062 6525     AM..PM..%a %b %e
 801c480:	2520 3a48 4d25 253a 2053 5a25 2520 0059      %H:%M:%S %Z %Y.
 801c490:	646d 0000 4925 253a 3a4d 5325 2520 0070     md..%I:%M:%S %p.
 801c4a0:	4d47 0054 0000 0000 0000 0000 0000 0000     GMT.............

0801c4b0 <_ctype_>:
 801c4b0:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
 801c4c0:	2020 2020 2020 2020 2020 2020 2020 2020                     
 801c4d0:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
 801c4e0:	0410 0404 0404 0404 0404 1004 1010 1010     ................
 801c4f0:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
 801c500:	0101 0101 0101 0101 0101 0101 1010 1010     ................
 801c510:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
 801c520:	0202 0202 0202 0202 0202 0202 1010 1010     ................
 801c530:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
 801c5c0:	0043 0000 0000 0000 0000 0000 0000 0000     C...............

0801c5d0 <_global_impure_ptr>:
 801c5d0:	0960 2000 0000 0000 0000 0000 0000 0000     `.. ............
 801c5e0:	4f50 4953 0058 0000 002f 0000 0000 0000     POSIX.../.......
 801c5f0:	002e 0000 0000 0000 0000 0000 0000 0000     ................

0801c600 <zeroes.6707>:
 801c600:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
 801c610:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
 801c620:	0000 0000 3130 3332 3534 3736 3938 6261     ....0123456789ab
 801c630:	6463 6665 0000 0000 6e28 6c75 296c 0000     cdef....(null)..

0801c640 <blanks.6706>:
 801c640:	2020 2020 2020 2020 2020 2020 2020 2020                     
